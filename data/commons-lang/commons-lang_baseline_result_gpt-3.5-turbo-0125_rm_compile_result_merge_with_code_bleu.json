[
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic randomLong(startInclusive long, endExclusive long) : long extracted from public nextLong(startInclusive long, endExclusive long) : long in class org.apache.commons.lang3.RandomUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 190,
                "endLine": 210,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 205,
                "endLine": 216,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 403,
                "endLine": 420,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomUtils#nextLong",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomUtils#nextLong\n methodBody: public static long nextLong(final long startInclusive, final long endExclusive) {\nValidate.isTrue(endExclusive >= startInclusive,\"Start value must be smaller or equal to end value.\");\nValidate.isTrue(startInclusive >= 0,\"Both range values must be non-negative.\");\nif(startInclusive == endExclusive){return startInclusive;\n}return startInclusive + nextLong(endExclusive - startInclusive);\n}",
        "classSignatureBefore": "public class RandomUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomUtils#nextLong"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.Random;\n\n/**\n * Utility library that supplements the standard {@link Random} class.\n *\n * <p>Please note that the Apache Commons project provides a component\n * dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be\n * a better choice for applications with more stringent requirements\n * (performance and/or correctness).</p>\n *\n * @deprecated Use Apache Commons RNG's optimized <a href=\"https://commons.apache.org/proper/commons-rng/commons-rng-client-api/apidocs/org/apache/commons/rng/UniformRandomProvider.html\">UniformRandomProvider</a>\n * @since 3.3\n */\n@Deprecated\npublic class RandomUtils {\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return RandomStringUtils.random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard\n     * programming. Instead, the class should be used as\n     * {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        // empty\n    }\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Supplements the standard {@link Random} class.\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Please note that the Apache Commons project provides a component dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be a better choice for\n * applications with more stringent requirements (performance and/or correctness).\n * </p>\n *\n * @see RandomStringUtils\n * @since 3.3\n */\npublic class RandomUtils {\n\n    private static RandomUtils INSECURE = new RandomUtils(ThreadLocalRandom::current);\n\n    private static final Supplier<Random> SECURE_SUPPLIER = () -> RandomUtils.SECURE_RANDOM.get();\n\n    private static RandomUtils SECURE = new RandomUtils(SECURE_SUPPLIER);\n\n    private static final ThreadLocal<SecureRandom> SECURE_RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (final NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * </p>\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    static RandomUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return secure().randomBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        return secure().randomBytes(count);\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return secure().randomDouble();\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        return secure().randomDouble(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return secure().randomFloat();\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        return secure().randomFloat(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return secure().randomInt();\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        return secure().randomInt(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return secure().randomLong();\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n     *\n     * @param n Bound on the random number to be returned. Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n     */\n    private static long nextLong(final long n) {\n        return secure().randomLong(n);\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        return secure().randomLong(startInclusive, endExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomUtils secure() {\n        return SECURE;\n    }\n\n    static SecureRandom secureRandom() {\n        return SECURE_RANDOM.get();\n    }\n\n    private final Supplier<Random> random;\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard programming. Instead, the class should be\n     * used as {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomUtils(final Supplier<Random> random) {\n        this.random = random;\n    }\n\n    Random random() {\n        return random.get();\n    }\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.16.0\n     */\n    public boolean randomBoolean() {\n        return random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     * @since 3.16.0\n     */\n    public byte[] randomBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.16.0\n     */\n    public double randomDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random double\n     * @since 3.16.0\n     */\n    public double randomDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.16.0\n     */\n    public float randomFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random float\n     */\n    public float randomFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.16.0\n     */\n    public int randomInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random integer\n     * @since 3.16.0\n     */\n    public int randomInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.16.0\n     */\n    public long randomLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n     *\n     * @param n Bound on the random number to be returned. Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n     */\n    private long randomLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = random().nextLong() >>> 1;\n            val = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     * @since 3.16.0\n     */\n    public long randomLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     * @since 3.16.0\n     */\n    public long randomLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomUtils#nextLong\n methodBody: public static long nextLong(final long startInclusive, final long endExclusive) {\nValidate.isTrue(endExclusive >= startInclusive,\"Start value must be smaller or equal to end value.\");\nValidate.isTrue(startInclusive >= 0,\"Both range values must be non-negative.\");\nif(startInclusive == endExclusive){return startInclusive;\n}return startInclusive + nextLong(endExclusive - startInclusive);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        return secure().randomLong(startInclusive, endExclusive);\n    }\n/**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     * @since 3.16.0\n     */\n    public long randomLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }",
        "diffSourceCode": "-  190:     /**\n-  191:      * Generates a random long within the specified range.\n-  192:      *\n-  193:      * @param startInclusive\n-  194:      *            the smallest value that can be returned, must be non-negative\n-  195:      * @param endExclusive\n-  196:      *            the upper bound (not included)\n-  197:      * @throws IllegalArgumentException\n-  198:      *             if {@code startInclusive > endExclusive} or if\n-  199:      *             {@code startInclusive} is negative\n-  200:      * @return the random long\n-  201:      */\n-  202:     public static long nextLong(final long startInclusive, final long endExclusive) {\n-  203:         Validate.isTrue(endExclusive >= startInclusive,\n-  204:                 \"Start value must be smaller or equal to end value.\");\n-  205:         Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n-  206:         if (startInclusive == endExclusive) {\n-  207:             return startInclusive;\n-  208:         }\n-  209:         return startInclusive + nextLong(endExclusive - startInclusive);\n-  210:     }\n-  211: \n-  212:     /**\n-  213:      * {@link RandomUtils} instances should NOT be constructed in standard\n-  214:      * programming. Instead, the class should be used as\n-  215:      * {@code RandomUtils.nextBytes(5);}.\n-  216:      * <p>\n+  190:      */\n+  191:     public static long nextLong() {\n+  192:         return secure().randomLong();\n+  193:     }\n+  194: \n+  195:     /**\n+  196:      * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n+  197:      *\n+  198:      * @param n Bound on the random number to be returned. Must be positive.\n+  199:      * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n+  200:      */\n+  201:     private static long nextLong(final long n) {\n+  202:         return secure().randomLong(n);\n+  203:     }\n+  204: \n+  205:     /**\n+  206:      * Generates a random long within the specified range.\n+  207:      *\n+  208:      * @param startInclusive the smallest value that can be returned, must be non-negative\n+  209:      * @param endExclusive   the upper bound (not included)\n+  210:      * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n+  211:      *                                  negative\n+  212:      * @return the random long\n+  213:      */\n+  214:     public static long nextLong(final long startInclusive, final long endExclusive) {\n+  215:         return secure().randomLong(startInclusive, endExclusive);\n+  216:     }\n+  403:     /**\n+  404:      * Generates a random long within the specified range.\n+  405:      *\n+  406:      * @param startInclusive the smallest value that can be returned, must be non-negative\n+  407:      * @param endExclusive   the upper bound (not included)\n+  408:      * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n+  409:      *                                  negative\n+  410:      * @return the random long\n+  411:      * @since 3.16.0\n+  412:      */\n+  413:     public long randomLong(final long startInclusive, final long endExclusive) {\n+  414:         Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n+  415:         Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n+  416:         if (startInclusive == endExclusive) {\n+  417:             return startInclusive;\n+  418:         }\n+  419:         return startInclusive + nextLong(endExclusive - startInclusive);\n+  420:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_190_210_403_420_205_216",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 35
            },
            "BRANCH": {
                "missed": 0,
                "covered": 6
            },
            "LINE": {
                "missed": 0,
                "covered": 5
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n/**\n * Generates a random long within the specified range.\n *\n * @param startInclusive\n *            the smallest value that can be returned, must be non-negative\n * @param endExclusive\n *            the upper bound (not included)\n * @throws IllegalArgumentException\n *             if {@code startInclusive > endExclusive} or if\n *             {@code startInclusive} is negative\n * @return the random long\n */\npublic static long nextLong(final long startInclusive, final long endExclusive) {\n    Validate.isTrue(endExclusive >= startInclusive,\n            \"Start value must be smaller or equal to end value.\");\n    Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n    if (startInclusive == endExclusive) {\n        return startInclusive;\n    }\n    return startInclusive + generateRandomLongInRange(endExclusive - startInclusive);\n}\n\n/**\n * Generates a random long within the specified range.\n *\n * @param range\n *            the range of values to generate the random long\n * @return the random long within the specified range\n */\nprivate static long generateRandomLongInRange(final long range) {\n    // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n    long bits;\n    long val;\n    do {\n        bits = RandomStringUtils.random().nextLong() >>> 1;\n        val  = bits % range;\n    } while (bits - val + range - 1 < 0);\n    return val;\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.Random;\n\n/**\n * Utility library that supplements the standard {@link Random} class.\n *\n * <p>Please note that the Apache Commons project provides a component\n * dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be\n * a better choice for applications with more stringent requirements\n * (performance and/or correctness).</p>\n *\n * @deprecated Use Apache Commons RNG's optimized <a href=\"https://commons.apache.org/proper/commons-rng/commons-rng-client-api/apidocs/org/apache/commons/rng/UniformRandomProvider.html\">UniformRandomProvider</a>\n * @since 3.3\n */\n@Deprecated\npublic class RandomUtils {\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return RandomStringUtils.random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard\n     * programming. Instead, the class should be used as\n     * {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        // empty\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic secure() : RandomUtils extracted from private nextLong(n long) : long in class org.apache.commons.lang3.RandomUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 171,
                "endLine": 188,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 195,
                "endLine": 203,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 218,
                "endLine": 231,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomUtils#nextLong",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}\nmethodSignature: org.apache.commons.lang3.RandomUtils#nextLong\n methodBody: public static long nextLong(final long startInclusive, final long endExclusive) {\nValidate.isTrue(endExclusive >= startInclusive,\"Start value must be smaller or equal to end value.\");\nValidate.isTrue(startInclusive >= 0,\"Both range values must be non-negative.\");\nif(startInclusive == endExclusive){return startInclusive;\n}return startInclusive + nextLong(endExclusive - startInclusive);\n}",
        "classSignatureBefore": "public class RandomUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomUtils#nextLong"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.Random;\n\n/**\n * Utility library that supplements the standard {@link Random} class.\n *\n * <p>Please note that the Apache Commons project provides a component\n * dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be\n * a better choice for applications with more stringent requirements\n * (performance and/or correctness).</p>\n *\n * @deprecated Use Apache Commons RNG's optimized <a href=\"https://commons.apache.org/proper/commons-rng/commons-rng-client-api/apidocs/org/apache/commons/rng/UniformRandomProvider.html\">UniformRandomProvider</a>\n * @since 3.3\n */\n@Deprecated\npublic class RandomUtils {\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return RandomStringUtils.random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard\n     * programming. Instead, the class should be used as\n     * {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        // empty\n    }\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Supplements the standard {@link Random} class.\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Please note that the Apache Commons project provides a component dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be a better choice for\n * applications with more stringent requirements (performance and/or correctness).\n * </p>\n *\n * @see RandomStringUtils\n * @since 3.3\n */\npublic class RandomUtils {\n\n    private static RandomUtils INSECURE = new RandomUtils(ThreadLocalRandom::current);\n\n    private static final Supplier<Random> SECURE_SUPPLIER = () -> RandomUtils.SECURE_RANDOM.get();\n\n    private static RandomUtils SECURE = new RandomUtils(SECURE_SUPPLIER);\n\n    private static final ThreadLocal<SecureRandom> SECURE_RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (final NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * </p>\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    static RandomUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return secure().randomBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        return secure().randomBytes(count);\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return secure().randomDouble();\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        return secure().randomDouble(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return secure().randomFloat();\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        return secure().randomFloat(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return secure().randomInt();\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        return secure().randomInt(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return secure().randomLong();\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n     *\n     * @param n Bound on the random number to be returned. Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n     */\n    private static long nextLong(final long n) {\n        return secure().randomLong(n);\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        return secure().randomLong(startInclusive, endExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomUtils secure() {\n        return SECURE;\n    }\n\n    static SecureRandom secureRandom() {\n        return SECURE_RANDOM.get();\n    }\n\n    private final Supplier<Random> random;\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard programming. Instead, the class should be\n     * used as {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomUtils(final Supplier<Random> random) {\n        this.random = random;\n    }\n\n    Random random() {\n        return random.get();\n    }\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.16.0\n     */\n    public boolean randomBoolean() {\n        return random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     * @since 3.16.0\n     */\n    public byte[] randomBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.16.0\n     */\n    public double randomDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random double\n     * @since 3.16.0\n     */\n    public double randomDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.16.0\n     */\n    public float randomFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random float\n     */\n    public float randomFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.16.0\n     */\n    public int randomInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random integer\n     * @since 3.16.0\n     */\n    public int randomInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.16.0\n     */\n    public long randomLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n     *\n     * @param n Bound on the random number to be returned. Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n     */\n    private long randomLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = random().nextLong() >>> 1;\n            val = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     * @since 3.16.0\n     */\n    public long randomLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomUtils secure() {\n        return SECURE;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}",
            "methodSignature: org.apache.commons.lang3.RandomUtils#nextLong\n methodBody: public static long nextLong(final long startInclusive, final long endExclusive) {\nValidate.isTrue(endExclusive >= startInclusive,\"Start value must be smaller or equal to end value.\");\nValidate.isTrue(startInclusive >= 0,\"Both range values must be non-negative.\");\nif(startInclusive == endExclusive){return startInclusive;\n}return startInclusive + nextLong(endExclusive - startInclusive);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n     *\n     * @param n Bound on the random number to be returned. Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n     */\n    private static long nextLong(final long n) {\n        return secure().randomLong(n);\n    }\n/**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomUtils secure() {\n        return SECURE;\n    }",
        "diffSourceCode": "   171:     /**\n-  172:      * Generates a {@code long} value between 0 (inclusive) and the specified\n-  173:      * value (exclusive).\n-  174:      *\n-  175:      * @param n Bound on the random number to be returned.  Must be positive.\n-  176:      * @return a random {@code long} value between 0 (inclusive) and {@code n}\n-  177:      * (exclusive).\n-  178:      */\n-  179:     private static long nextLong(final long n) {\n-  180:         // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n-  181:         long bits;\n-  182:         long val;\n-  183:         do {\n-  184:             bits = RandomStringUtils.random().nextLong() >>> 1;\n-  185:             val  = bits % n;\n-  186:         } while (bits - val + n - 1 < 0);\n-  187:         return val;\n-  188:     }\n-  195:      * @param endExclusive\n-  196:      *            the upper bound (not included)\n-  197:      * @throws IllegalArgumentException\n-  198:      *             if {@code startInclusive > endExclusive} or if\n-  199:      *             {@code startInclusive} is negative\n-  200:      * @return the random long\n-  201:      */\n-  202:     public static long nextLong(final long startInclusive, final long endExclusive) {\n-  203:         Validate.isTrue(endExclusive >= startInclusive,\n-  218:      * instance to operate.\n-  219:      * </p>\n-  220:      *\n-  221:      * @deprecated TODO Make private in 4.0.\n-  222:      */\n-  223:     @Deprecated\n-  224:     public RandomUtils() {\n-  225:         // empty\n-  226:     }\n-  227: }\n+  172:      * Generates a random integer within the specified range.\n+  173:      *\n+  174:      * @param startInclusive the smallest value that can be returned, must be non-negative\n+  175:      * @param endExclusive   the upper bound (not included)\n+  176:      * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n+  177:      *                                  negative\n+  178:      * @return the random integer\n+  179:      */\n+  180:     public static int nextInt(final int startInclusive, final int endExclusive) {\n+  181:         return secure().randomInt(startInclusive, endExclusive);\n+  182:     }\n+  183: \n+  184:     /**\n+  185:      * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n+  186:      *\n+  187:      * @return the random long\n+  188:      * @see #nextLong(long, long)\n+  195:     /**\n+  196:      * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n+  197:      *\n+  198:      * @param n Bound on the random number to be returned. Must be positive.\n+  199:      * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n+  200:      */\n+  201:     private static long nextLong(final long n) {\n+  202:         return secure().randomLong(n);\n+  203:     }\n+  218:     /**\n+  219:      * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n+  220:      * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n+  221:      * <p>\n+  222:      * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n+  223:      * </p>\n+  224:      *\n+  225:      * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n+  226:      * @see SecureRandom#getInstanceStrong()\n+  227:      * @since 3.16.0\n+  228:      */\n+  229:     public static RandomUtils secure() {\n+  230:         return SECURE;\n+  231:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_171_188_218_231_195_203",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 35
            },
            "BRANCH": {
                "missed": 0,
                "covered": 6
            },
            "LINE": {
                "missed": 0,
                "covered": 5
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": true,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Generates a {@code long} value between 0 (inclusive) and the specified\n * value (exclusive).\n *\n * @param n Bound on the random number to be returned.  Must be positive.\n * @return a random {@code long} value between 0 (inclusive) and {@code n}\n * (exclusive).\n */\nprivate static long nextLong(final long n) {\n    return generateRandomLong(n);\n}\n\n/**\n * Generates a random long within the specified range.\n *\n * @param startInclusive\n *            the smallest value that can be returned, must be non-negative\n * @param endExclusive\n *            the upper bound (not included)\n * @throws IllegalArgumentException\n *             if {@code startInclusive > endExclusive} or if\n *             {@code startInclusive} is negative\n * @return the random long\n */\npublic static long nextLong(final long startInclusive, final long endExclusive) {\n    Validate.isTrue(endExclusive >= startInclusive,\n            \"Start value must be smaller or equal to end value.\");\n    Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n    if (startInclusive == endExclusive) {\n        return startInclusive;\n    }\n    return startInclusive + generateRandomLong(endExclusive - startInclusive);\n}\n\n/**\n * Generates a random long value between 0 (inclusive) and the specified value (exclusive).\n *\n * @param n Bound on the random number to be returned.  Must be positive.\n * @return a random long value between 0 (inclusive) and {@code n} (exclusive).\n */\nprivate static long generateRandomLong(final long n) {\n    long bits;\n    long val;\n    do {\n        bits = RandomStringUtils.random().nextLong() >>> 1;\n        val = bits % n;\n    } while (bits - val + n - 1 < 0);\n    return val;\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.Random;\n\n/**\n * Utility library that supplements the standard {@link Random} class.\n *\n * <p>Please note that the Apache Commons project provides a component\n * dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be\n * a better choice for applications with more stringent requirements\n * (performance and/or correctness).</p>\n *\n * @deprecated Use Apache Commons RNG's optimized <a href=\"https://commons.apache.org/proper/commons-rng/commons-rng-client-api/apidocs/org/apache/commons/rng/UniformRandomProvider.html\">UniformRandomProvider</a>\n * @since 3.3\n */\n@Deprecated\npublic class RandomUtils {\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return RandomStringUtils.random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard\n     * programming. Instead, the class should be used as\n     * {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        // empty\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic randomLong() : long extracted from public nextLong() : long in class org.apache.commons.lang3.RandomUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 160,
                "endLine": 169,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 184,
                "endLine": 193,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 375,
                "endLine": 384,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomUtils#nextLong",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomUtils#nextLong\n methodBody: public static long nextLong(final long startInclusive, final long endExclusive) {\nValidate.isTrue(endExclusive >= startInclusive,\"Start value must be smaller or equal to end value.\");\nValidate.isTrue(startInclusive >= 0,\"Both range values must be non-negative.\");\nif(startInclusive == endExclusive){return startInclusive;\n}return startInclusive + nextLong(endExclusive - startInclusive);\n}",
        "classSignatureBefore": "public class RandomUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomUtils#nextLong"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.Random;\n\n/**\n * Utility library that supplements the standard {@link Random} class.\n *\n * <p>Please note that the Apache Commons project provides a component\n * dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be\n * a better choice for applications with more stringent requirements\n * (performance and/or correctness).</p>\n *\n * @deprecated Use Apache Commons RNG's optimized <a href=\"https://commons.apache.org/proper/commons-rng/commons-rng-client-api/apidocs/org/apache/commons/rng/UniformRandomProvider.html\">UniformRandomProvider</a>\n * @since 3.3\n */\n@Deprecated\npublic class RandomUtils {\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return RandomStringUtils.random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard\n     * programming. Instead, the class should be used as\n     * {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        // empty\n    }\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Supplements the standard {@link Random} class.\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Please note that the Apache Commons project provides a component dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be a better choice for\n * applications with more stringent requirements (performance and/or correctness).\n * </p>\n *\n * @see RandomStringUtils\n * @since 3.3\n */\npublic class RandomUtils {\n\n    private static RandomUtils INSECURE = new RandomUtils(ThreadLocalRandom::current);\n\n    private static final Supplier<Random> SECURE_SUPPLIER = () -> RandomUtils.SECURE_RANDOM.get();\n\n    private static RandomUtils SECURE = new RandomUtils(SECURE_SUPPLIER);\n\n    private static final ThreadLocal<SecureRandom> SECURE_RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (final NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * </p>\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    static RandomUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return secure().randomBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        return secure().randomBytes(count);\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return secure().randomDouble();\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        return secure().randomDouble(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return secure().randomFloat();\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        return secure().randomFloat(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return secure().randomInt();\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        return secure().randomInt(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return secure().randomLong();\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n     *\n     * @param n Bound on the random number to be returned. Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n     */\n    private static long nextLong(final long n) {\n        return secure().randomLong(n);\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        return secure().randomLong(startInclusive, endExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomUtils secure() {\n        return SECURE;\n    }\n\n    static SecureRandom secureRandom() {\n        return SECURE_RANDOM.get();\n    }\n\n    private final Supplier<Random> random;\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard programming. Instead, the class should be\n     * used as {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomUtils(final Supplier<Random> random) {\n        this.random = random;\n    }\n\n    Random random() {\n        return random.get();\n    }\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.16.0\n     */\n    public boolean randomBoolean() {\n        return random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     * @since 3.16.0\n     */\n    public byte[] randomBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.16.0\n     */\n    public double randomDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random double\n     * @since 3.16.0\n     */\n    public double randomDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.16.0\n     */\n    public float randomFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random float\n     */\n    public float randomFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.16.0\n     */\n    public int randomInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random integer\n     * @since 3.16.0\n     */\n    public int randomInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.16.0\n     */\n    public long randomLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n     *\n     * @param n Bound on the random number to be returned. Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n     */\n    private long randomLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = random().nextLong() >>> 1;\n            val = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     * @since 3.16.0\n     */\n    public long randomLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.16.0\n     */\n    public long randomLong() {\n        return nextLong(Long.MAX_VALUE);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomUtils#nextLong\n methodBody: public static long nextLong(final long startInclusive, final long endExclusive) {\nValidate.isTrue(endExclusive >= startInclusive,\"Start value must be smaller or equal to end value.\");\nValidate.isTrue(startInclusive >= 0,\"Both range values must be non-negative.\");\nif(startInclusive == endExclusive){return startInclusive;\n}return startInclusive + nextLong(endExclusive - startInclusive);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return secure().randomLong();\n    }\n/**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.16.0\n     */\n    public long randomLong() {\n        return nextLong(Long.MAX_VALUE);\n    }",
        "diffSourceCode": "   160:     /**\n-  161:      * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n+  161:      * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n   162:      *\n-  163:      * @return the random long\n-  164:      * @see #nextLong(long, long)\n+  163:      * @return the random integer\n+  164:      * @see #nextInt(int, int)\n   165:      * @since 3.5\n   166:      */\n-  167:     public static long nextLong() {\n-  168:         return nextLong(Long.MAX_VALUE);\n+  167:     public static int nextInt() {\n+  168:         return secure().randomInt();\n   169:     }\n-  184:             bits = RandomStringUtils.random().nextLong() >>> 1;\n-  185:             val  = bits % n;\n-  186:         } while (bits - val + n - 1 < 0);\n-  187:         return val;\n-  188:     }\n-  189: \n-  190:     /**\n-  191:      * Generates a random long within the specified range.\n-  192:      *\n-  193:      * @param startInclusive\n+  184:     /**\n+  185:      * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n+  186:      *\n+  187:      * @return the random long\n+  188:      * @see #nextLong(long, long)\n+  189:      * @since 3.5\n+  190:      */\n+  191:     public static long nextLong() {\n+  192:         return secure().randomLong();\n+  193:     }\n+  375:     /**\n+  376:      * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n+  377:      *\n+  378:      * @return the random long\n+  379:      * @see #nextLong(long, long)\n+  380:      * @since 3.16.0\n+  381:      */\n+  382:     public long randomLong() {\n+  383:         return nextLong(Long.MAX_VALUE);\n+  384:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_160_169_375_384_184_193",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 35
            },
            "BRANCH": {
                "missed": 0,
                "covered": 6
            },
            "LINE": {
                "missed": 0,
                "covered": 5
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n *\n * @return the random long\n * @see #nextLong(long, long)\n * @since 3.5\n */\npublic static long nextLong() {\n    return nextLong(Long.MAX_VALUE);\n}\n\n/**\n * Generates a {@code long} value between 0 (inclusive) and the specified\n * value (exclusive).\n *\n * @param n Bound on the random number to be returned.  Must be positive.\n * @return a random {@code long} value between 0 (inclusive) and {@code n}\n * (exclusive).\n */\nprivate static long nextLong(final long n) {\n    // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n    long bits;\n    long val;\n    do {\n        bits = RandomStringUtils.random().nextLong() >>> 1;\n        val  = bits % n;\n    } while (bits - val + n - 1 < 0);\n    return val;\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.Random;\n\n/**\n * Utility library that supplements the standard {@link Random} class.\n *\n * <p>Please note that the Apache Commons project provides a component\n * dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be\n * a better choice for applications with more stringent requirements\n * (performance and/or correctness).</p>\n *\n * @deprecated Use Apache Commons RNG's optimized <a href=\"https://commons.apache.org/proper/commons-rng/commons-rng-client-api/apidocs/org/apache/commons/rng/UniformRandomProvider.html\">UniformRandomProvider</a>\n * @since 3.3\n */\n@Deprecated\npublic class RandomUtils {\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return RandomStringUtils.random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard\n     * programming. Instead, the class should be used as\n     * {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        // empty\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic randomInt() : int extracted from public nextInt() : int in class org.apache.commons.lang3.RandomUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 127,
                "endLine": 136,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 160,
                "endLine": 169,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 345,
                "endLine": 354,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomUtils#nextInt",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomUtils#nextInt\n methodBody: public static int nextInt(final int startInclusive, final int endExclusive) {\nValidate.isTrue(endExclusive >= startInclusive,\"Start value must be smaller or equal to end value.\");\nValidate.isTrue(startInclusive >= 0,\"Both range values must be non-negative.\");\nif(startInclusive == endExclusive){return startInclusive;\n}return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n}",
        "classSignatureBefore": "public class RandomUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomUtils#nextInt"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.Random;\n\n/**\n * Utility library that supplements the standard {@link Random} class.\n *\n * <p>Please note that the Apache Commons project provides a component\n * dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be\n * a better choice for applications with more stringent requirements\n * (performance and/or correctness).</p>\n *\n * @deprecated Use Apache Commons RNG's optimized <a href=\"https://commons.apache.org/proper/commons-rng/commons-rng-client-api/apidocs/org/apache/commons/rng/UniformRandomProvider.html\">UniformRandomProvider</a>\n * @since 3.3\n */\n@Deprecated\npublic class RandomUtils {\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return RandomStringUtils.random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard\n     * programming. Instead, the class should be used as\n     * {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        // empty\n    }\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Supplements the standard {@link Random} class.\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Please note that the Apache Commons project provides a component dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be a better choice for\n * applications with more stringent requirements (performance and/or correctness).\n * </p>\n *\n * @see RandomStringUtils\n * @since 3.3\n */\npublic class RandomUtils {\n\n    private static RandomUtils INSECURE = new RandomUtils(ThreadLocalRandom::current);\n\n    private static final Supplier<Random> SECURE_SUPPLIER = () -> RandomUtils.SECURE_RANDOM.get();\n\n    private static RandomUtils SECURE = new RandomUtils(SECURE_SUPPLIER);\n\n    private static final ThreadLocal<SecureRandom> SECURE_RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (final NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * </p>\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    static RandomUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return secure().randomBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        return secure().randomBytes(count);\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return secure().randomDouble();\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        return secure().randomDouble(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return secure().randomFloat();\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        return secure().randomFloat(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return secure().randomInt();\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        return secure().randomInt(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return secure().randomLong();\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n     *\n     * @param n Bound on the random number to be returned. Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n     */\n    private static long nextLong(final long n) {\n        return secure().randomLong(n);\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        return secure().randomLong(startInclusive, endExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomUtils secure() {\n        return SECURE;\n    }\n\n    static SecureRandom secureRandom() {\n        return SECURE_RANDOM.get();\n    }\n\n    private final Supplier<Random> random;\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard programming. Instead, the class should be\n     * used as {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomUtils(final Supplier<Random> random) {\n        this.random = random;\n    }\n\n    Random random() {\n        return random.get();\n    }\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.16.0\n     */\n    public boolean randomBoolean() {\n        return random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     * @since 3.16.0\n     */\n    public byte[] randomBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.16.0\n     */\n    public double randomDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random double\n     * @since 3.16.0\n     */\n    public double randomDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.16.0\n     */\n    public float randomFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random float\n     */\n    public float randomFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.16.0\n     */\n    public int randomInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random integer\n     * @since 3.16.0\n     */\n    public int randomInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.16.0\n     */\n    public long randomLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n     *\n     * @param n Bound on the random number to be returned. Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n     */\n    private long randomLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = random().nextLong() >>> 1;\n            val = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     * @since 3.16.0\n     */\n    public long randomLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.16.0\n     */\n    public int randomInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomUtils#nextInt\n methodBody: public static int nextInt(final int startInclusive, final int endExclusive) {\nValidate.isTrue(endExclusive >= startInclusive,\"Start value must be smaller or equal to end value.\");\nValidate.isTrue(startInclusive >= 0,\"Both range values must be non-negative.\");\nif(startInclusive == endExclusive){return startInclusive;\n}return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return secure().randomInt();\n    }\n/**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.16.0\n     */\n    public int randomInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }",
        "diffSourceCode": "-  127:     /**\n-  128:      * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n-  129:      *\n-  130:      * @return the random integer\n-  131:      * @see #nextInt(int, int)\n-  132:      * @since 3.5\n-  133:      */\n-  134:     public static int nextInt() {\n-  135:         return nextInt(0, Integer.MAX_VALUE);\n-  136:     }\n+  127:      * @param endExclusive   the upper bound (not included)\n+  128:      * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n+  129:      *                                  negative\n+  130:      * @return the random double\n+  131:      */\n+  132:     public static double nextDouble(final double startInclusive, final double endExclusive) {\n+  133:         return secure().randomDouble(startInclusive, endExclusive);\n+  134:     }\n+  135: \n+  136:     /**\n   160:     /**\n-  161:      * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n+  161:      * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n   162:      *\n-  163:      * @return the random long\n-  164:      * @see #nextLong(long, long)\n+  163:      * @return the random integer\n+  164:      * @see #nextInt(int, int)\n   165:      * @since 3.5\n   166:      */\n-  167:     public static long nextLong() {\n-  168:         return nextLong(Long.MAX_VALUE);\n+  167:     public static int nextInt() {\n+  168:         return secure().randomInt();\n   169:     }\n+  345:     /**\n+  346:      * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n+  347:      *\n+  348:      * @return the random integer\n+  349:      * @see #nextInt(int, int)\n+  350:      * @since 3.16.0\n+  351:      */\n+  352:     public int randomInt() {\n+  353:         return nextInt(0, Integer.MAX_VALUE);\n+  354:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_127_136_345_354_160_169",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 32
            },
            "BRANCH": {
                "missed": 0,
                "covered": 6
            },
            "LINE": {
                "missed": 0,
                "covered": 5
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Generates a random int between the specified range.\n *\n * @param startInclusive the smallest value that can be returned, must be non-negative\n * @param endExclusive the upper bound (not included)\n * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if\n * {@code startInclusive} is negative\n * @return the random integer\n */\npublic static int nextInt(final int startInclusive, final int endExclusive) {\n    Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n    Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n    if (startInclusive == endExclusive) {\n        return startInclusive;\n    }\n    return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.Random;\n\n/**\n * Utility library that supplements the standard {@link Random} class.\n *\n * <p>Please note that the Apache Commons project provides a component\n * dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be\n * a better choice for applications with more stringent requirements\n * (performance and/or correctness).</p>\n *\n * @deprecated Use Apache Commons RNG's optimized <a href=\"https://commons.apache.org/proper/commons-rng/commons-rng-client-api/apidocs/org/apache/commons/rng/UniformRandomProvider.html\">UniformRandomProvider</a>\n * @since 3.3\n */\n@Deprecated\npublic class RandomUtils {\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return RandomStringUtils.random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard\n     * programming. Instead, the class should be used as\n     * {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        // empty\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic randomFloat() : float extracted from public nextFloat() : float in class org.apache.commons.lang3.RandomUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 94,
                "endLine": 103,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 136,
                "endLine": 145,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 316,
                "endLine": 325,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomUtils#nextFloat",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomUtils#nextFloat\n methodBody: public static float nextFloat(final float startInclusive, final float endExclusive) {\nValidate.isTrue(endExclusive >= startInclusive,\"Start value must be smaller or equal to end value.\");\nValidate.isTrue(startInclusive >= 0,\"Both range values must be non-negative.\");\nif(startInclusive == endExclusive){return startInclusive;\n}return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n}",
        "classSignatureBefore": "public class RandomUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomUtils#nextFloat"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.Random;\n\n/**\n * Utility library that supplements the standard {@link Random} class.\n *\n * <p>Please note that the Apache Commons project provides a component\n * dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be\n * a better choice for applications with more stringent requirements\n * (performance and/or correctness).</p>\n *\n * @deprecated Use Apache Commons RNG's optimized <a href=\"https://commons.apache.org/proper/commons-rng/commons-rng-client-api/apidocs/org/apache/commons/rng/UniformRandomProvider.html\">UniformRandomProvider</a>\n * @since 3.3\n */\n@Deprecated\npublic class RandomUtils {\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return RandomStringUtils.random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard\n     * programming. Instead, the class should be used as\n     * {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        // empty\n    }\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Supplements the standard {@link Random} class.\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Please note that the Apache Commons project provides a component dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be a better choice for\n * applications with more stringent requirements (performance and/or correctness).\n * </p>\n *\n * @see RandomStringUtils\n * @since 3.3\n */\npublic class RandomUtils {\n\n    private static RandomUtils INSECURE = new RandomUtils(ThreadLocalRandom::current);\n\n    private static final Supplier<Random> SECURE_SUPPLIER = () -> RandomUtils.SECURE_RANDOM.get();\n\n    private static RandomUtils SECURE = new RandomUtils(SECURE_SUPPLIER);\n\n    private static final ThreadLocal<SecureRandom> SECURE_RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (final NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * </p>\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    static RandomUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return secure().randomBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        return secure().randomBytes(count);\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return secure().randomDouble();\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        return secure().randomDouble(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return secure().randomFloat();\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        return secure().randomFloat(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return secure().randomInt();\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        return secure().randomInt(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return secure().randomLong();\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n     *\n     * @param n Bound on the random number to be returned. Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n     */\n    private static long nextLong(final long n) {\n        return secure().randomLong(n);\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        return secure().randomLong(startInclusive, endExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomUtils secure() {\n        return SECURE;\n    }\n\n    static SecureRandom secureRandom() {\n        return SECURE_RANDOM.get();\n    }\n\n    private final Supplier<Random> random;\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard programming. Instead, the class should be\n     * used as {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomUtils(final Supplier<Random> random) {\n        this.random = random;\n    }\n\n    Random random() {\n        return random.get();\n    }\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.16.0\n     */\n    public boolean randomBoolean() {\n        return random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     * @since 3.16.0\n     */\n    public byte[] randomBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.16.0\n     */\n    public double randomDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random double\n     * @since 3.16.0\n     */\n    public double randomDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.16.0\n     */\n    public float randomFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random float\n     */\n    public float randomFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.16.0\n     */\n    public int randomInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random integer\n     * @since 3.16.0\n     */\n    public int randomInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.16.0\n     */\n    public long randomLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n     *\n     * @param n Bound on the random number to be returned. Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n     */\n    private long randomLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = random().nextLong() >>> 1;\n            val = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     * @since 3.16.0\n     */\n    public long randomLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.16.0\n     */\n    public float randomFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomUtils#nextFloat\n methodBody: public static float nextFloat(final float startInclusive, final float endExclusive) {\nValidate.isTrue(endExclusive >= startInclusive,\"Start value must be smaller or equal to end value.\");\nValidate.isTrue(startInclusive >= 0,\"Both range values must be non-negative.\");\nif(startInclusive == endExclusive){return startInclusive;\n}return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return secure().randomFloat();\n    }\n/**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.16.0\n     */\n    public float randomFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }",
        "diffSourceCode": "-   94:     /**\n-   95:      * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n-   96:      *\n-   97:      * @return the random float\n-   98:      * @see #nextFloat(float, float)\n-   99:      * @since 3.5\n-  100:      */\n-  101:     public static float nextFloat() {\n-  102:         return nextFloat(0, Float.MAX_VALUE);\n-  103:     }\n-  136:     }\n-  137: \n-  138:     /**\n-  139:      * Generates a random integer within the specified range.\n-  140:      *\n-  141:      * @param startInclusive\n-  142:      *            the smallest value that can be returned, must be non-negative\n-  143:      * @param endExclusive\n-  144:      *            the upper bound (not included)\n-  145:      * @throws IllegalArgumentException\n+   94:      * @return the random boolean\n+   95:      * @since 3.5\n+   96:      */\n+   97:     public static boolean nextBoolean() {\n+   98:         return secure().randomBoolean();\n+   99:     }\n+  100: \n+  101:     /**\n+  102:      * Generates an array of random bytes.\n+  103:      *\n+  136:     /**\n+  137:      * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n+  138:      *\n+  139:      * @return the random float\n+  140:      * @see #nextFloat(float, float)\n+  141:      * @since 3.5\n+  142:      */\n+  143:     public static float nextFloat() {\n+  144:         return secure().randomFloat();\n+  145:     }\n+  316:     /**\n+  317:      * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n+  318:      *\n+  319:      * @return the random float\n+  320:      * @see #nextFloat(float, float)\n+  321:      * @since 3.16.0\n+  322:      */\n+  323:     public float randomFloat() {\n+  324:         return nextFloat(0, Float.MAX_VALUE);\n+  325:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_94_103_316_325_136_145",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 37
            },
            "BRANCH": {
                "missed": 0,
                "covered": 6
            },
            "LINE": {
                "missed": 0,
                "covered": 5
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Generates a random float within the specified range.\n *\n * @param startInclusive\n *            the smallest value that can be returned, must be non-negative\n * @param endExclusive\n *            the upper bound (not included)\n * @throws IllegalArgumentException\n *             if {@code startInclusive > endExclusive} or if\n *             {@code startInclusive} is negative\n * @return the random float\n */\npublic static float nextFloat(final float startInclusive, final float endExclusive) {\n    Validate.isTrue(endExclusive >= startInclusive,\n            \"Start value must be smaller or equal to end value.\");\n    Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n    if (startInclusive == endExclusive) {\n        return startInclusive;\n    }\n    return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.Random;\n\n/**\n * Utility library that supplements the standard {@link Random} class.\n *\n * <p>Please note that the Apache Commons project provides a component\n * dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be\n * a better choice for applications with more stringent requirements\n * (performance and/or correctness).</p>\n *\n * @deprecated Use Apache Commons RNG's optimized <a href=\"https://commons.apache.org/proper/commons-rng/commons-rng-client-api/apidocs/org/apache/commons/rng/UniformRandomProvider.html\">UniformRandomProvider</a>\n * @since 3.3\n */\n@Deprecated\npublic class RandomUtils {\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return RandomStringUtils.random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard\n     * programming. Instead, the class should be used as\n     * {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        // empty\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic randomDouble() : double extracted from public nextDouble() : double in class org.apache.commons.lang3.RandomUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 61,
                "endLine": 70,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 112,
                "endLine": 121,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 286,
                "endLine": 295,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomUtils#nextDouble",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomUtils#nextDouble\n methodBody: public static double nextDouble(final double startInclusive, final double endExclusive) {\nValidate.isTrue(endExclusive >= startInclusive,\"Start value must be smaller or equal to end value.\");\nValidate.isTrue(startInclusive >= 0,\"Both range values must be non-negative.\");\nif(startInclusive == endExclusive){return startInclusive;\n}return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n}",
        "classSignatureBefore": "public class RandomUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomUtils#nextDouble"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.Random;\n\n/**\n * Utility library that supplements the standard {@link Random} class.\n *\n * <p>Please note that the Apache Commons project provides a component\n * dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be\n * a better choice for applications with more stringent requirements\n * (performance and/or correctness).</p>\n *\n * @deprecated Use Apache Commons RNG's optimized <a href=\"https://commons.apache.org/proper/commons-rng/commons-rng-client-api/apidocs/org/apache/commons/rng/UniformRandomProvider.html\">UniformRandomProvider</a>\n * @since 3.3\n */\n@Deprecated\npublic class RandomUtils {\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return RandomStringUtils.random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard\n     * programming. Instead, the class should be used as\n     * {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        // empty\n    }\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Supplements the standard {@link Random} class.\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Please note that the Apache Commons project provides a component dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be a better choice for\n * applications with more stringent requirements (performance and/or correctness).\n * </p>\n *\n * @see RandomStringUtils\n * @since 3.3\n */\npublic class RandomUtils {\n\n    private static RandomUtils INSECURE = new RandomUtils(ThreadLocalRandom::current);\n\n    private static final Supplier<Random> SECURE_SUPPLIER = () -> RandomUtils.SECURE_RANDOM.get();\n\n    private static RandomUtils SECURE = new RandomUtils(SECURE_SUPPLIER);\n\n    private static final ThreadLocal<SecureRandom> SECURE_RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (final NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * </p>\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    static RandomUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return secure().randomBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        return secure().randomBytes(count);\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return secure().randomDouble();\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        return secure().randomDouble(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return secure().randomFloat();\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        return secure().randomFloat(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return secure().randomInt();\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        return secure().randomInt(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return secure().randomLong();\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n     *\n     * @param n Bound on the random number to be returned. Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n     */\n    private static long nextLong(final long n) {\n        return secure().randomLong(n);\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        return secure().randomLong(startInclusive, endExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomUtils secure() {\n        return SECURE;\n    }\n\n    static SecureRandom secureRandom() {\n        return SECURE_RANDOM.get();\n    }\n\n    private final Supplier<Random> random;\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard programming. Instead, the class should be\n     * used as {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomUtils(final Supplier<Random> random) {\n        this.random = random;\n    }\n\n    Random random() {\n        return random.get();\n    }\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.16.0\n     */\n    public boolean randomBoolean() {\n        return random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     * @since 3.16.0\n     */\n    public byte[] randomBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.16.0\n     */\n    public double randomDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random double\n     * @since 3.16.0\n     */\n    public double randomDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.16.0\n     */\n    public float randomFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random float\n     */\n    public float randomFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.16.0\n     */\n    public int randomInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random integer\n     * @since 3.16.0\n     */\n    public int randomInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.16.0\n     */\n    public long randomLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n     *\n     * @param n Bound on the random number to be returned. Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n     */\n    private long randomLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = random().nextLong() >>> 1;\n            val = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     * @since 3.16.0\n     */\n    public long randomLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.16.0\n     */\n    public double randomDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomUtils#nextDouble\n methodBody: public static double nextDouble(final double startInclusive, final double endExclusive) {\nValidate.isTrue(endExclusive >= startInclusive,\"Start value must be smaller or equal to end value.\");\nValidate.isTrue(startInclusive >= 0,\"Both range values must be non-negative.\");\nif(startInclusive == endExclusive){return startInclusive;\n}return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return secure().randomDouble();\n    }\n/**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.16.0\n     */\n    public double randomDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }",
        "diffSourceCode": "-   61:     /**\n-   62:      * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n-   63:      *\n-   64:      * @return the random double\n-   65:      * @see #nextDouble(double, double)\n-   66:      * @since 3.5\n-   67:      */\n-   68:     public static double nextDouble() {\n-   69:         return nextDouble(0, Double.MAX_VALUE);\n-   70:     }\n-  112:      * @throws IllegalArgumentException\n-  113:      *             if {@code startInclusive > endExclusive} or if\n-  114:      *             {@code startInclusive} is negative\n-  115:      * @return the random float\n-  116:      */\n-  117:     public static float nextFloat(final float startInclusive, final float endExclusive) {\n-  118:         Validate.isTrue(endExclusive >= startInclusive,\n-  119:                 \"Start value must be smaller or equal to end value.\");\n-  120:         Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n-  121:         if (startInclusive == endExclusive) {\n+   61:     private static final Supplier<Random> SECURE_SUPPLIER = () -> RandomUtils.SECURE_RANDOM.get();\n+   62: \n+   63:     private static RandomUtils SECURE = new RandomUtils(SECURE_SUPPLIER);\n+   64: \n+   65:     private static final ThreadLocal<SecureRandom> SECURE_RANDOM = ThreadLocal.withInitial(() -> {\n+   66:         try {\n+   67:             return SecureRandom.getInstanceStrong();\n+   68:         } catch (final NoSuchAlgorithmException e) {\n+   69:             throw new UncheckedException(e);\n+   70:         }\n+  112:     /**\n+  113:      * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n+  114:      *\n+  115:      * @return the random double\n+  116:      * @see #nextDouble(double, double)\n+  117:      * @since 3.5\n+  118:      */\n+  119:     public static double nextDouble() {\n+  120:         return secure().randomDouble();\n+  121:     }\n+  286:     /**\n+  287:      * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n+  288:      *\n+  289:      * @return the random double\n+  290:      * @see #nextDouble(double, double)\n+  291:      * @since 3.16.0\n+  292:      */\n+  293:     public double randomDouble() {\n+  294:         return nextDouble(0, Double.MAX_VALUE);\n+  295:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_61_70_286_295_112_121",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 37
            },
            "BRANCH": {
                "missed": 0,
                "covered": 6
            },
            "LINE": {
                "missed": 0,
                "covered": 5
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Generates a random double within the specified range.\n *\n * @param startInclusive\n *            the smallest value that can be returned, must be non-negative\n * @param endExclusive\n *            the upper bound (not included)\n * @throws IllegalArgumentException\n *             if {@code startInclusive > endExclusive} or if\n *             {@code startInclusive} is negative\n * @return the random double\n */\npublic static double nextDouble(final double startInclusive, final double endExclusive) {\n    Validate.isTrue(endExclusive >= startInclusive,\n            \"Start value must be smaller or equal to end value.\");\n    Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n    if (startInclusive == endExclusive) {\n        return startInclusive;\n    }\n    return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.Random;\n\n/**\n * Utility library that supplements the standard {@link Random} class.\n *\n * <p>Please note that the Apache Commons project provides a component\n * dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be\n * a better choice for applications with more stringent requirements\n * (performance and/or correctness).</p>\n *\n * @deprecated Use Apache Commons RNG's optimized <a href=\"https://commons.apache.org/proper/commons-rng/commons-rng-client-api/apidocs/org/apache/commons/rng/UniformRandomProvider.html\">UniformRandomProvider</a>\n * @since 3.3\n */\n@Deprecated\npublic class RandomUtils {\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return RandomStringUtils.random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard\n     * programming. Instead, the class should be used as\n     * {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        // empty\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic secure() : RandomUtils extracted from public nextBytes(count int) : byte[] in class org.apache.commons.lang3.RandomUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 46,
                "endLine": 59,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 101,
                "endLine": 110,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
                "startLine": 218,
                "endLine": 231,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomUtils#nextBytes",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}\nmethodSignature: org.apache.commons.lang3.RandomUtils#nextBytes\n methodBody: public static byte[] nextBytes(final int count) {\nValidate.isTrue(count >= 0,\"Count cannot be negative.\");\nfinal byte[] result=new byte[count];\nRandomStringUtils.random().nextBytes(result);\nreturn result;\n}",
        "classSignatureBefore": "public class RandomUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomUtils#nextBytes"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.Random;\n\n/**\n * Utility library that supplements the standard {@link Random} class.\n *\n * <p>Please note that the Apache Commons project provides a component\n * dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be\n * a better choice for applications with more stringent requirements\n * (performance and/or correctness).</p>\n *\n * @deprecated Use Apache Commons RNG's optimized <a href=\"https://commons.apache.org/proper/commons-rng/commons-rng-client-api/apidocs/org/apache/commons/rng/UniformRandomProvider.html\">UniformRandomProvider</a>\n * @since 3.3\n */\n@Deprecated\npublic class RandomUtils {\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return RandomStringUtils.random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard\n     * programming. Instead, the class should be used as\n     * {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        // empty\n    }\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Supplements the standard {@link Random} class.\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Please note that the Apache Commons project provides a component dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be a better choice for\n * applications with more stringent requirements (performance and/or correctness).\n * </p>\n *\n * @see RandomStringUtils\n * @since 3.3\n */\npublic class RandomUtils {\n\n    private static RandomUtils INSECURE = new RandomUtils(ThreadLocalRandom::current);\n\n    private static final Supplier<Random> SECURE_SUPPLIER = () -> RandomUtils.SECURE_RANDOM.get();\n\n    private static RandomUtils SECURE = new RandomUtils(SECURE_SUPPLIER);\n\n    private static final ThreadLocal<SecureRandom> SECURE_RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (final NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * </p>\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    static RandomUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return secure().randomBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        return secure().randomBytes(count);\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return secure().randomDouble();\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        return secure().randomDouble(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return secure().randomFloat();\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        return secure().randomFloat(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return secure().randomInt();\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        return secure().randomInt(startInclusive, endExclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return secure().randomLong();\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n     *\n     * @param n Bound on the random number to be returned. Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n     */\n    private static long nextLong(final long n) {\n        return secure().randomLong(n);\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        return secure().randomLong(startInclusive, endExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomUtils secure() {\n        return SECURE;\n    }\n\n    static SecureRandom secureRandom() {\n        return SECURE_RANDOM.get();\n    }\n\n    private final Supplier<Random> random;\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard programming. Instead, the class should be\n     * used as {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomUtils(final Supplier<Random> random) {\n        this.random = random;\n    }\n\n    Random random() {\n        return random.get();\n    }\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.16.0\n     */\n    public boolean randomBoolean() {\n        return random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     * @since 3.16.0\n     */\n    public byte[] randomBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.16.0\n     */\n    public double randomDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random double\n     * @since 3.16.0\n     */\n    public double randomDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.16.0\n     */\n    public float randomFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random float\n     */\n    public float randomFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.16.0\n     */\n    public int randomInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random integer\n     * @since 3.16.0\n     */\n    public int randomInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.16.0\n     */\n    public long randomLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified value (exclusive).\n     *\n     * @param n Bound on the random number to be returned. Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n} (exclusive).\n     */\n    private long randomLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = random().nextLong() >>> 1;\n            val = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive the smallest value that can be returned, must be non-negative\n     * @param endExclusive   the upper bound (not included)\n     * @throws IllegalArgumentException if {@code startInclusive > endExclusive} or if {@code startInclusive} is\n     *                                  negative\n     * @return the random long\n     * @since 3.16.0\n     */\n    public long randomLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive, \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomUtils secure() {\n        return SECURE;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}",
            "methodSignature: org.apache.commons.lang3.RandomUtils#nextBytes\n methodBody: public static byte[] nextBytes(final int count) {\nValidate.isTrue(count >= 0,\"Count cannot be negative.\");\nfinal byte[] result=new byte[count];\nRandomStringUtils.random().nextBytes(result);\nreturn result;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Generates an array of random bytes.\n     *\n     * @param count the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        return secure().randomBytes(count);\n    }\n/**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomUtils secure() {\n        return SECURE;\n    }",
        "diffSourceCode": "-   46:     /**\n-   47:      * Generates an array of random bytes.\n-   48:      *\n-   49:      * @param count\n-   50:      *            the size of the returned array\n-   51:      * @return the random byte array\n-   52:      * @throws IllegalArgumentException if {@code count} is negative\n-   53:      */\n-   54:     public static byte[] nextBytes(final int count) {\n-   55:         Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n-   56:         final byte[] result = new byte[count];\n-   57:         RandomStringUtils.random().nextBytes(result);\n-   58:         return result;\n-   59:     }\n-  101:     public static float nextFloat() {\n-  102:         return nextFloat(0, Float.MAX_VALUE);\n-  103:     }\n-  104: \n-  105:     /**\n-  106:      * Generates a random float within the specified range.\n-  107:      *\n-  108:      * @param startInclusive\n-  109:      *            the smallest value that can be returned, must be non-negative\n-  110:      * @param endExclusive\n-  218:      * instance to operate.\n-  219:      * </p>\n-  220:      *\n-  221:      * @deprecated TODO Make private in 4.0.\n-  222:      */\n-  223:     @Deprecated\n-  224:     public RandomUtils() {\n-  225:         // empty\n-  226:     }\n-  227: }\n+   46:  * cryptographically secure.\n+   47:  * </p>\n+   48:  * <p>\n+   49:  * Please note that the Apache Commons project provides a component dedicated to pseudo-random number generation, namely\n+   50:  * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be a better choice for\n+   51:  * applications with more stringent requirements (performance and/or correctness).\n+   52:  * </p>\n+   53:  *\n+   54:  * @see RandomStringUtils\n+   55:  * @since 3.3\n+   56:  */\n+   57: public class RandomUtils {\n+   58: \n+   59:     private static RandomUtils INSECURE = new RandomUtils(ThreadLocalRandom::current);\n+  101:     /**\n+  102:      * Generates an array of random bytes.\n+  103:      *\n+  104:      * @param count the size of the returned array\n+  105:      * @return the random byte array\n+  106:      * @throws IllegalArgumentException if {@code count} is negative\n+  107:      */\n+  108:     public static byte[] nextBytes(final int count) {\n+  109:         return secure().randomBytes(count);\n+  110:     }\n+  218:     /**\n+  219:      * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n+  220:      * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n+  221:      * <p>\n+  222:      * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n+  223:      * </p>\n+  224:      *\n+  225:      * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n+  226:      * @see SecureRandom#getInstanceStrong()\n+  227:      * @since 3.16.0\n+  228:      */\n+  229:     public static RandomUtils secure() {\n+  230:         return SECURE;\n+  231:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_46_59_218_231_101_110",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 17
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": true,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n/**\n * Generates an array of random bytes.\n *\n * @param count\n *            the size of the returned array\n * @return the random byte array\n * @throws IllegalArgumentException if {@code count} is negative\n */\npublic static byte[] nextBytes(final int count) {\n    Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n    final byte[] result = new byte[count];\n    generateRandomBytes(result);\n    return result;\n}\n\n/**\n * Generates random bytes and fills the provided byte array.\n *\n * @param bytes\n *            the byte array to be filled with random bytes\n */\nprivate static void generateRandomBytes(byte[] bytes) {\n    RandomStringUtils.random().nextBytes(bytes);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.Random;\n\n/**\n * Utility library that supplements the standard {@link Random} class.\n *\n * <p>Please note that the Apache Commons project provides a component\n * dedicated to pseudo-random number generation, namely\n * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>, that may be\n * a better choice for applications with more stringent requirements\n * (performance and/or correctness).</p>\n *\n * @deprecated Use Apache Commons RNG's optimized <a href=\"https://commons.apache.org/proper/commons-rng/commons-rng-client-api/apidocs/org/apache/commons/rng/UniformRandomProvider.html\">UniformRandomProvider</a>\n * @since 3.3\n */\n@Deprecated\npublic class RandomUtils {\n\n    /**\n     * Generates a random boolean value.\n     *\n     * @return the random boolean\n     * @since 3.5\n     */\n    public static boolean nextBoolean() {\n        return RandomStringUtils.random().nextBoolean();\n    }\n\n    /**\n     * Generates an array of random bytes.\n     *\n     * @param count\n     *            the size of the returned array\n     * @return the random byte array\n     * @throws IllegalArgumentException if {@code count} is negative\n     */\n    public static byte[] nextBytes(final int count) {\n        Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n        final byte[] result = new byte[count];\n        RandomStringUtils.random().nextBytes(result);\n        return result;\n    }\n\n    /**\n     * Generates a random double between 0 (inclusive) and Double.MAX_VALUE (exclusive).\n     *\n     * @return the random double\n     * @see #nextDouble(double, double)\n     * @since 3.5\n     */\n    public static double nextDouble() {\n        return nextDouble(0, Double.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random double within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random double\n     */\n    public static double nextDouble(final double startInclusive, final double endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextDouble();\n    }\n\n    /**\n     * Generates a random float between 0 (inclusive) and Float.MAX_VALUE (exclusive).\n     *\n     * @return the random float\n     * @see #nextFloat(float, float)\n     * @since 3.5\n     */\n    public static float nextFloat() {\n        return nextFloat(0, Float.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random float within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random float\n     */\n    public static float nextFloat(final float startInclusive, final float endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + (endExclusive - startInclusive) * RandomStringUtils.random().nextFloat();\n    }\n\n    /**\n     * Generates a random int between 0 (inclusive) and Integer.MAX_VALUE (exclusive).\n     *\n     * @return the random integer\n     * @see #nextInt(int, int)\n     * @since 3.5\n     */\n    public static int nextInt() {\n        return nextInt(0, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Generates a random integer within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random integer\n     */\n    public static int nextInt(final int startInclusive, final int endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + RandomStringUtils.random().nextInt(endExclusive - startInclusive);\n    }\n\n    /**\n     * Generates a random long between 0 (inclusive) and Long.MAX_VALUE (exclusive).\n     *\n     * @return the random long\n     * @see #nextLong(long, long)\n     * @since 3.5\n     */\n    public static long nextLong() {\n        return nextLong(Long.MAX_VALUE);\n    }\n\n    /**\n     * Generates a {@code long} value between 0 (inclusive) and the specified\n     * value (exclusive).\n     *\n     * @param n Bound on the random number to be returned.  Must be positive.\n     * @return a random {@code long} value between 0 (inclusive) and {@code n}\n     * (exclusive).\n     */\n    private static long nextLong(final long n) {\n        // Extracted from o.a.c.rng.core.BaseProvider.nextLong(long)\n        long bits;\n        long val;\n        do {\n            bits = RandomStringUtils.random().nextLong() >>> 1;\n            val  = bits % n;\n        } while (bits - val + n - 1 < 0);\n        return val;\n    }\n\n    /**\n     * Generates a random long within the specified range.\n     *\n     * @param startInclusive\n     *            the smallest value that can be returned, must be non-negative\n     * @param endExclusive\n     *            the upper bound (not included)\n     * @throws IllegalArgumentException\n     *             if {@code startInclusive > endExclusive} or if\n     *             {@code startInclusive} is negative\n     * @return the random long\n     */\n    public static long nextLong(final long startInclusive, final long endExclusive) {\n        Validate.isTrue(endExclusive >= startInclusive,\n                \"Start value must be smaller or equal to end value.\");\n        Validate.isTrue(startInclusive >= 0, \"Both range values must be non-negative.\");\n        if (startInclusive == endExclusive) {\n            return startInclusive;\n        }\n        return startInclusive + nextLong(endExclusive - startInclusive);\n    }\n\n    /**\n     * {@link RandomUtils} instances should NOT be constructed in standard\n     * programming. Instead, the class should be used as\n     * {@code RandomUtils.nextBytes(5);}.\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean\n     * instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomUtils() {\n        // empty\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": "/**\n * Generates an array of random bytes.\n *\n * @param count\n *            the size of the returned array\n * @return the random byte array\n * @throws IllegalArgumentException if {@code count} is negative\n */\npublic static byte[] nextBytes(final int count) {\n    Validate.isTrue(count >= 0, \"Count cannot be negative.\");\n    final byte[] result = new byte[count];\n    generateRandomBytes(result);\n    return result;\n}\n\n/**\n * Generates random bytes and fills the provided byte array.\n *\n * @param bytes\n *            the byte array to be filled with random bytes\n */\nprivate static void generateRandomBytes(byte[] bytes) {\n    RandomStringUtils.random().nextBytes(bytes);\n}",
        "codebleu": 0.5966378524058875,
        "ngram_match_score": 0.4005646466408405,
        "syntax_match_score": 0.5714285714285714,
        "weighted_ngram_match_score": 0.41455819155413787,
        "dataflow_match_score": 1.0
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic nextPrint(count int) : String extracted from public randomPrint(count int) : String in class org.apache.commons.lang3.RandomStringUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 515,
                "endLine": 529,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 528,
                "endLine": 543,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 875,
                "endLine": 891,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomStringUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomStringUtils#randomPrint",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}",
        "classSignatureBefore": "public class RandomStringUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils#randomPrint"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomStringUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\n * \"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\">\n * RandomStringGenerator</a> instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>\n * dedicated to pseudo-random number generation, that may be a better choice for applications with more stringent\n * requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the\n * values 56192 (db80) and 56319 (dbff) as we don't know how to handle them. High and low surrogates are correctly dealt\n * with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) then it is followed by a low\n * surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @see RandomUtils\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final Supplier<RandomUtils> SECURE_SUPPLIER = RandomUtils::secure;\n\n    private static RandomStringUtils INSECURE = new RandomStringUtils(RandomUtils::insecure);\n\n    private static RandomStringUtils SECURE = new RandomStringUtils(SECURE_SUPPLIER);\n\n    private static final char[] ALPHANUMERICAL_CHARS = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n            'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\n            'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1',\n            '2', '3', '4', '5', '6', '7', '8', '9' };\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return secure().next(count);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return secure().next(count, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers) {\n        return secure().next(count, start, end, letters, numbers);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers, final char... chars) {\n        return secure().next(count, start, end, letters, numbers, chars);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using supplied source of randomness.\n     *\n     * <p>\n     * If start and end are both {@code 0}, start and end are set to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both {@code false}, in which case, start and end are set\n     * to {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>\n     * If set is not {@code null}, characters between start and end are chosen.\n     * </p>\n     *\n     * <p>\n     * This method accepts a user-supplied {@link Random} instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call, the same random sequence of strings can be\n     * generated repeatedly and predictably.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at (inclusive)\n     * @param end     the position in set of chars to end before (exclusive)\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from, must not be empty. If {@code null}, then it will use the\n     *                set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n            final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \"\n                            + \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint) || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return secure().nextAlphabetic(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphabetic(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return secure().nextAlphanumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphanumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return secure().nextAscii(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAscii(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return secure().nextGraph(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextGraph(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return secure().nextNumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextNumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return secure().nextPrint(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextPrint(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils secure() {\n        return SECURE;\n    }\n\n    private final Supplier<RandomUtils> random;\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in standard programming. Instead, the class should\n     * be used as {@code RandomStringUtils.random(5);}.\n     *\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomStringUtils(final Supplier<RandomUtils> random) {\n        this.random = random;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers,\n            final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     * @since 3.16.0\n     */\n    public String next(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public String nextGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     * @since 3.16.0\n     */\n    public String nextPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.16.0\n     */\n    public String nextPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Gets the Random.\n     *\n     * @return the Random.\n     */\n    private Random random() {\n        return randomUtils().random();\n    }\n\n    /**\n     * Gets the RandomUtils.\n     *\n     * @return the RandomUtils.\n     */\n    private RandomUtils randomUtils() {\n        return random.get();\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomStringUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     * @since 3.16.0\n     */\n    public String nextPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return secure().nextPrint(count);\n    }\n/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     * @since 3.16.0\n     */\n    public String nextPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }",
        "diffSourceCode": "-  515:     /**\n-  516:      * Creates a random string whose length is the number of characters specified.\n-  517:      *\n-  518:      * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n-  519:      * regular expression character class. This class includes all visible ASCII characters and spaces\n-  520:      * (i.e. anything except control characters).</p>\n-  521:      *\n-  522:      * @param count  the length of random string to create\n-  523:      * @return the random string\n-  524:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n-  525:      * @since 3.5\n-  526:      */\n-  527:     public static String randomPrint(final int count) {\n-  528:         return random(count, 32, 126, false, false);\n-  529:     }\n-  530: \n-  531:     /**\n-  532:      * Creates a random string whose length is between the inclusive minimum and\n-  533:      * the exclusive maximum.\n-  534:      *\n-  535:      * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n-  536:      *\n-  537:      * @param minLengthInclusive the inclusive minimum length of the string to generate\n-  538:      * @param maxLengthExclusive the exclusive maximum length of the string to generate\n-  539:      * @return the random string\n-  540:      * @since 3.5\n-  541:      */\n-  542:     public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n-  543:         return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n+  515:      * <p>\n+  516:      * Characters will be chosen from the set of \\p{Digit} characters.\n+  517:      * </p>\n+  518:      *\n+  519:      * @param minLengthInclusive the inclusive minimum length of the string to generate\n+  520:      * @param maxLengthExclusive the exclusive maximum length of the string to generate\n+  521:      * @return the random string\n+  522:      * @since 3.5\n+  523:      */\n+  524:     public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n+  525:         return secure().nextNumeric(minLengthInclusive, maxLengthExclusive);\n+  526:     }\n+  527: \n+  528:     /**\n+  529:      * Creates a random string whose length is the number of characters specified.\n+  530:      *\n+  531:      * <p>\n+  532:      * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n+  533:      * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n+  534:      * </p>\n+  535:      *\n+  536:      * @param count the length of random string to create\n+  537:      * @return the random string\n+  538:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  539:      * @since 3.5\n+  540:      */\n+  541:     public static String randomPrint(final int count) {\n+  542:         return secure().nextPrint(count);\n+  543:     }\n+  875:     /**\n+  876:      * Creates a random string whose length is the number of characters specified.\n+  877:      *\n+  878:      * <p>\n+  879:      * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n+  880:      * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n+  881:      * </p>\n+  882:      *\n+  883:      * @param count the length of random string to create\n+  884:      * @return the random string\n+  885:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  886:      * @since 3.5\n+  887:      * @since 3.16.0\n+  888:      */\n+  889:     public String nextPrint(final int count) {\n+  890:         return random(count, 32, 126, false, false);\n+  891:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_515_529_875_891_528_543",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Generates a random string based on the specified parameters.\n *\n * @param count the length of the random string to create\n * @param start the position in the set of characters to start at\n * @param end the position in the set of characters to end before\n * @param letters if true, generated string may include alphabetic characters\n * @param numbers if true, generated string may include numeric characters\n * @param chars the set of characters to choose randoms from, may be null\n * @param random a source of randomness\n * @return the random string\n * @throws IllegalArgumentException if count is less than 0 or the provided chars array is empty\n */\npublic static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n    if (chars == null) {\n        return random(count, 0, 0, false, false, null, random());\n    }\n    return random(count, 0, chars.length, false, false, chars, random());\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic nextNumeric(count int) : String extracted from public randomNumeric(count int) : String in class org.apache.commons.lang3.RandomStringUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 485,
                "endLine": 498,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 497,
                "endLine": 510,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 844,
                "endLine": 857,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomStringUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomStringUtils#randomNumeric",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}",
        "classSignatureBefore": "public class RandomStringUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils#randomNumeric"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomStringUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\n * \"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\">\n * RandomStringGenerator</a> instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>\n * dedicated to pseudo-random number generation, that may be a better choice for applications with more stringent\n * requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the\n * values 56192 (db80) and 56319 (dbff) as we don't know how to handle them. High and low surrogates are correctly dealt\n * with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) then it is followed by a low\n * surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @see RandomUtils\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final Supplier<RandomUtils> SECURE_SUPPLIER = RandomUtils::secure;\n\n    private static RandomStringUtils INSECURE = new RandomStringUtils(RandomUtils::insecure);\n\n    private static RandomStringUtils SECURE = new RandomStringUtils(SECURE_SUPPLIER);\n\n    private static final char[] ALPHANUMERICAL_CHARS = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n            'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\n            'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1',\n            '2', '3', '4', '5', '6', '7', '8', '9' };\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return secure().next(count);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return secure().next(count, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers) {\n        return secure().next(count, start, end, letters, numbers);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers, final char... chars) {\n        return secure().next(count, start, end, letters, numbers, chars);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using supplied source of randomness.\n     *\n     * <p>\n     * If start and end are both {@code 0}, start and end are set to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both {@code false}, in which case, start and end are set\n     * to {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>\n     * If set is not {@code null}, characters between start and end are chosen.\n     * </p>\n     *\n     * <p>\n     * This method accepts a user-supplied {@link Random} instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call, the same random sequence of strings can be\n     * generated repeatedly and predictably.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at (inclusive)\n     * @param end     the position in set of chars to end before (exclusive)\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from, must not be empty. If {@code null}, then it will use the\n     *                set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n            final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \"\n                            + \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint) || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return secure().nextAlphabetic(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphabetic(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return secure().nextAlphanumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphanumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return secure().nextAscii(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAscii(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return secure().nextGraph(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextGraph(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return secure().nextNumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextNumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return secure().nextPrint(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextPrint(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils secure() {\n        return SECURE;\n    }\n\n    private final Supplier<RandomUtils> random;\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in standard programming. Instead, the class should\n     * be used as {@code RandomStringUtils.random(5);}.\n     *\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomStringUtils(final Supplier<RandomUtils> random) {\n        this.random = random;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers,\n            final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     * @since 3.16.0\n     */\n    public String next(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public String nextGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     * @since 3.16.0\n     */\n    public String nextPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.16.0\n     */\n    public String nextPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Gets the Random.\n     *\n     * @return the Random.\n     */\n    private Random random() {\n        return randomUtils().random();\n    }\n\n    /**\n     * Gets the RandomUtils.\n     *\n     * @return the RandomUtils.\n     */\n    private RandomUtils randomUtils() {\n        return random.get();\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomStringUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextNumeric(final int count) {\n        return random(count, false, true);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return secure().nextNumeric(count);\n    }\n/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextNumeric(final int count) {\n        return random(count, false, true);\n    }",
        "diffSourceCode": "-  485:     /**\n-  486:      * Creates a random string whose length is the number of characters\n-  487:      * specified.\n-  488:      *\n-  489:      * <p>Characters will be chosen from the set of numeric\n-  490:      * characters.</p>\n-  491:      *\n-  492:      * @param count  the length of random string to create\n-  493:      * @return the random string\n-  494:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n-  495:      */\n-  496:     public static String randomNumeric(final int count) {\n-  497:         return random(count, false, true);\n-  498:     }\n-  499: \n-  500:     /**\n-  501:      * Creates a random string whose length is between the inclusive minimum and\n-  502:      * the exclusive maximum.\n+  485:      * Characters will be chosen from the set of \\p{Graph} characters.\n+  486:      * </p>\n+  487:      *\n+  488:      * @param minLengthInclusive the inclusive minimum length of the string to generate\n+  489:      * @param maxLengthExclusive the exclusive maximum length of the string to generate\n+  490:      * @return the random string\n+  491:      * @since 3.5\n+  492:      */\n+  493:     public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n+  494:         return secure().nextGraph(minLengthInclusive, maxLengthExclusive);\n+  495:     }\n+  496: \n+  497:     /**\n+  498:      * Creates a random string whose length is the number of characters specified.\n+  499:      *\n+  500:      * <p>\n+  501:      * Characters will be chosen from the set of numeric characters.\n+  502:      * </p>\n   503:      *\n-  504:      * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n-  505:      *\n-  506:      * @param minLengthInclusive the inclusive minimum length of the string to generate\n-  507:      * @param maxLengthExclusive the exclusive maximum length of the string to generate\n-  508:      * @return the random string\n-  509:      * @since 3.5\n-  510:      */\n+  504:      * @param count the length of random string to create\n+  505:      * @return the random string\n+  506:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  507:      */\n+  508:     public static String randomNumeric(final int count) {\n+  509:         return secure().nextNumeric(count);\n+  510:     }\n+  844:     /**\n+  845:      * Creates a random string whose length is the number of characters specified.\n+  846:      *\n+  847:      * <p>\n+  848:      * Characters will be chosen from the set of numeric characters.\n+  849:      * </p>\n+  850:      *\n+  851:      * @param count the length of random string to create\n+  852:      * @return the random string\n+  853:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  854:      */\n+  855:     public String nextNumeric(final int count) {\n+  856:         return random(count, false, true);\n+  857:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_485_498_844_857_497_510",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Generates a random string of specified length using the given parameters.\n *\n * @param count    the length of the random string to create\n * @param start    the position in the set of characters to start at\n * @param end      the position in the set of characters to end before\n * @param letters  if true, generated string may include alphabetic characters\n * @param numbers  if true, generated string may include numeric characters\n * @param chars    the character array containing the set of characters to use, may be null\n * @param random   a source of randomness\n * @return the random string\n * @throws IllegalArgumentException if count is less than 0 or the provided chars array is empty\n */\npublic static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n    if (chars == null) {\n        return random(count, 0, 0, false, false, null, random());\n    }\n    return random(count, 0, chars.length, false, false, chars, random());\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic nextGraph(count int) : String extracted from public randomGraph(count int) : String in class org.apache.commons.lang3.RandomStringUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 454,
                "endLine": 468,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 464,
                "endLine": 479,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 811,
                "endLine": 826,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomStringUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomStringUtils#randomGraph",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}",
        "classSignatureBefore": "public class RandomStringUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils#randomGraph"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomStringUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\n * \"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\">\n * RandomStringGenerator</a> instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>\n * dedicated to pseudo-random number generation, that may be a better choice for applications with more stringent\n * requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the\n * values 56192 (db80) and 56319 (dbff) as we don't know how to handle them. High and low surrogates are correctly dealt\n * with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) then it is followed by a low\n * surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @see RandomUtils\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final Supplier<RandomUtils> SECURE_SUPPLIER = RandomUtils::secure;\n\n    private static RandomStringUtils INSECURE = new RandomStringUtils(RandomUtils::insecure);\n\n    private static RandomStringUtils SECURE = new RandomStringUtils(SECURE_SUPPLIER);\n\n    private static final char[] ALPHANUMERICAL_CHARS = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n            'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\n            'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1',\n            '2', '3', '4', '5', '6', '7', '8', '9' };\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return secure().next(count);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return secure().next(count, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers) {\n        return secure().next(count, start, end, letters, numbers);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers, final char... chars) {\n        return secure().next(count, start, end, letters, numbers, chars);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using supplied source of randomness.\n     *\n     * <p>\n     * If start and end are both {@code 0}, start and end are set to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both {@code false}, in which case, start and end are set\n     * to {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>\n     * If set is not {@code null}, characters between start and end are chosen.\n     * </p>\n     *\n     * <p>\n     * This method accepts a user-supplied {@link Random} instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call, the same random sequence of strings can be\n     * generated repeatedly and predictably.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at (inclusive)\n     * @param end     the position in set of chars to end before (exclusive)\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from, must not be empty. If {@code null}, then it will use the\n     *                set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n            final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \"\n                            + \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint) || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return secure().nextAlphabetic(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphabetic(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return secure().nextAlphanumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphanumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return secure().nextAscii(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAscii(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return secure().nextGraph(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextGraph(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return secure().nextNumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextNumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return secure().nextPrint(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextPrint(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils secure() {\n        return SECURE;\n    }\n\n    private final Supplier<RandomUtils> random;\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in standard programming. Instead, the class should\n     * be used as {@code RandomStringUtils.random(5);}.\n     *\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomStringUtils(final Supplier<RandomUtils> random) {\n        this.random = random;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers,\n            final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     * @since 3.16.0\n     */\n    public String next(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public String nextGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     * @since 3.16.0\n     */\n    public String nextPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.16.0\n     */\n    public String nextPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Gets the Random.\n     *\n     * @return the Random.\n     */\n    private Random random() {\n        return randomUtils().random();\n    }\n\n    /**\n     * Gets the RandomUtils.\n     *\n     * @return the RandomUtils.\n     */\n    private RandomUtils randomUtils() {\n        return random.get();\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomStringUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public String nextGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return secure().nextGraph(count);\n    }\n/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public String nextGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }",
        "diffSourceCode": "-  454:     /**\n-  455:      * Creates a random string whose length is the number of characters specified.\n-  456:      *\n-  457:      * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n-  458:      * regular expression character class. This class contains all visible ASCII characters\n-  459:      * (i.e. anything except spaces and control characters).</p>\n-  460:      *\n-  461:      * @param count  the length of random string to create\n-  462:      * @return the random string\n-  463:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n-  464:      * @since 3.5\n-  465:      */\n-  466:     public static String randomGraph(final int count) {\n-  467:         return random(count, 33, 126, false, false);\n-  468:     }\n-  469: \n-  470:     /**\n-  471:      * Creates a random string whose length is between the inclusive minimum and\n-  472:      * the exclusive maximum.\n-  473:      *\n-  474:      * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n-  475:      *\n-  476:      * @param minLengthInclusive the inclusive minimum length of the string to generate\n-  477:      * @param maxLengthExclusive the exclusive maximum length of the string to generate\n-  478:      * @return the random string\n-  479:      * @since 3.5\n+  454:      *\n+  455:      * @param minLengthInclusive the inclusive minimum length of the string to generate\n+  456:      * @param maxLengthExclusive the exclusive maximum length of the string to generate\n+  457:      * @return the random string\n+  458:      * @since 3.5\n+  459:      */\n+  460:     public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n+  461:         return secure().nextAscii(minLengthInclusive, maxLengthExclusive);\n+  462:     }\n+  463: \n+  464:     /**\n+  465:      * Creates a random string whose length is the number of characters specified.\n+  466:      *\n+  467:      * <p>\n+  468:      * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n+  469:      * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n+  470:      * </p>\n+  471:      *\n+  472:      * @param count the length of random string to create\n+  473:      * @return the random string\n+  474:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  475:      * @since 3.5\n+  476:      */\n+  477:     public static String randomGraph(final int count) {\n+  478:         return secure().nextGraph(count);\n+  479:     }\n+  811:     /**\n+  812:      * Creates a random string whose length is the number of characters specified.\n+  813:      *\n+  814:      * <p>\n+  815:      * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n+  816:      * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n+  817:      * </p>\n+  818:      *\n+  819:      * @param count the length of random string to create\n+  820:      * @return the random string\n+  821:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  822:      * @since 3.5\n+  823:      */\n+  824:     public String nextGraph(final int count) {\n+  825:         return random(count, 33, 126, false, false);\n+  826:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_454_468_811_826_464_479",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Generates a random string of specified length using the given parameters.\n *\n * @param count the length of the random string to create\n * @param start the starting position in the character set\n * @param end the ending position in the character set\n * @param letters flag indicating if alphabetic characters should be included\n * @param numbers flag indicating if numeric characters should be included\n * @param chars the character array containing the set of characters to use\n * @param random the source of randomness\n * @return the random string\n * @throws IllegalArgumentException if count is less than 0 or the provided chars array is empty\n */\npublic static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n    // Method implementation remains the same\n    return random(count, start, end, letters, numbers, chars, random());\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic nextAscii(count int) : String extracted from public randomAscii(count int) : String in class org.apache.commons.lang3.RandomStringUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 423,
                "endLine": 436,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 431,
                "endLine": 445,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 778,
                "endLine": 792,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomStringUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomStringUtils#randomAscii",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}",
        "classSignatureBefore": "public class RandomStringUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils#randomAscii"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomStringUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\n * \"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\">\n * RandomStringGenerator</a> instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>\n * dedicated to pseudo-random number generation, that may be a better choice for applications with more stringent\n * requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the\n * values 56192 (db80) and 56319 (dbff) as we don't know how to handle them. High and low surrogates are correctly dealt\n * with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) then it is followed by a low\n * surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @see RandomUtils\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final Supplier<RandomUtils> SECURE_SUPPLIER = RandomUtils::secure;\n\n    private static RandomStringUtils INSECURE = new RandomStringUtils(RandomUtils::insecure);\n\n    private static RandomStringUtils SECURE = new RandomStringUtils(SECURE_SUPPLIER);\n\n    private static final char[] ALPHANUMERICAL_CHARS = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n            'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\n            'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1',\n            '2', '3', '4', '5', '6', '7', '8', '9' };\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return secure().next(count);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return secure().next(count, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers) {\n        return secure().next(count, start, end, letters, numbers);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers, final char... chars) {\n        return secure().next(count, start, end, letters, numbers, chars);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using supplied source of randomness.\n     *\n     * <p>\n     * If start and end are both {@code 0}, start and end are set to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both {@code false}, in which case, start and end are set\n     * to {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>\n     * If set is not {@code null}, characters between start and end are chosen.\n     * </p>\n     *\n     * <p>\n     * This method accepts a user-supplied {@link Random} instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call, the same random sequence of strings can be\n     * generated repeatedly and predictably.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at (inclusive)\n     * @param end     the position in set of chars to end before (exclusive)\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from, must not be empty. If {@code null}, then it will use the\n     *                set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n            final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \"\n                            + \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint) || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return secure().nextAlphabetic(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphabetic(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return secure().nextAlphanumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphanumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return secure().nextAscii(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAscii(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return secure().nextGraph(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextGraph(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return secure().nextNumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextNumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return secure().nextPrint(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextPrint(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils secure() {\n        return SECURE;\n    }\n\n    private final Supplier<RandomUtils> random;\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in standard programming. Instead, the class should\n     * be used as {@code RandomStringUtils.random(5);}.\n     *\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomStringUtils(final Supplier<RandomUtils> random) {\n        this.random = random;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers,\n            final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     * @since 3.16.0\n     */\n    public String next(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public String nextGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     * @since 3.16.0\n     */\n    public String nextPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.16.0\n     */\n    public String nextPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Gets the Random.\n     *\n     * @return the Random.\n     */\n    private Random random() {\n        return randomUtils().random();\n    }\n\n    /**\n     * Gets the RandomUtils.\n     *\n     * @return the RandomUtils.\n     */\n    private RandomUtils randomUtils() {\n        return random.get();\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomStringUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return secure().nextAscii(count);\n    }\n/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }",
        "diffSourceCode": "-  423:     /**\n-  424:      * Creates a random string whose length is the number of characters\n-  425:      * specified.\n-  426:      *\n-  427:      * <p>Characters will be chosen from the set of characters whose\n-  428:      * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n-  429:      *\n-  430:      * @param count  the length of random string to create\n-  431:      * @return the random string\n-  432:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n-  433:      */\n-  434:     public static String randomAscii(final int count) {\n-  435:         return random(count, 32, 127, false, false);\n-  436:     }\n-  437: \n-  438:     /**\n-  439:      * Creates a random string whose length is between the inclusive minimum and\n-  440:      * the exclusive maximum.\n-  441:      *\n-  442:      * <p>Characters will be chosen from the set of characters whose\n-  443:      * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n-  444:      *\n-  445:      * @param minLengthInclusive the inclusive minimum length of the string to generate\n+  423:      * @param maxLengthExclusive the exclusive maximum length of the string to generate\n+  424:      * @return the random string\n+  425:      * @since 3.5\n+  426:      */\n+  427:     public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n+  428:         return secure().nextAlphanumeric(minLengthInclusive, maxLengthExclusive);\n+  429:     }\n+  430: \n+  431:     /**\n+  432:      * Creates a random string whose length is the number of characters specified.\n+  433:      *\n+  434:      * <p>\n+  435:      * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n+  436:      * (inclusive).\n+  437:      * </p>\n+  438:      *\n+  439:      * @param count the length of random string to create\n+  440:      * @return the random string\n+  441:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  442:      */\n+  443:     public static String randomAscii(final int count) {\n+  444:         return secure().nextAscii(count);\n+  445:     }\n+  778:     /**\n+  779:      * Creates a random string whose length is the number of characters specified.\n+  780:      *\n+  781:      * <p>\n+  782:      * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n+  783:      * (inclusive).\n+  784:      * </p>\n+  785:      *\n+  786:      * @param count the length of random string to create\n+  787:      * @return the random string\n+  788:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  789:      */\n+  790:     public String nextAscii(final int count) {\n+  791:         return random(count, 32, 127, false, false);\n+  792:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_423_436_778_792_431_445",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Generates a random string of specified length using the given parameters.\n *\n * @param count    the length of the random string to create\n * @param start    the starting position in the character set\n * @param end      the ending position in the character set\n * @param letters  if true, include alphabetic characters\n * @param numbers  if true, include numeric characters\n * @param chars    the character array containing the set of characters to use\n * @param random   the source of randomness\n * @return the random string\n * @throws IllegalArgumentException if count is less than 0 or the provided chars array is empty\n */\npublic static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n    if (chars == null) {\n        return random(count, 0, 0, false, false, null, random());\n    }\n    return random(count, 0, chars.length, false, false, chars, random());\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic nextAlphanumeric(count int) : String extracted from public randomAlphanumeric(count int) : String in class org.apache.commons.lang3.RandomStringUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 392,
                "endLine": 405,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 400,
                "endLine": 413,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 747,
                "endLine": 760,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomStringUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomStringUtils#randomAlphanumeric",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}",
        "classSignatureBefore": "public class RandomStringUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils#randomAlphanumeric"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomStringUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\n * \"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\">\n * RandomStringGenerator</a> instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>\n * dedicated to pseudo-random number generation, that may be a better choice for applications with more stringent\n * requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the\n * values 56192 (db80) and 56319 (dbff) as we don't know how to handle them. High and low surrogates are correctly dealt\n * with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) then it is followed by a low\n * surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @see RandomUtils\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final Supplier<RandomUtils> SECURE_SUPPLIER = RandomUtils::secure;\n\n    private static RandomStringUtils INSECURE = new RandomStringUtils(RandomUtils::insecure);\n\n    private static RandomStringUtils SECURE = new RandomStringUtils(SECURE_SUPPLIER);\n\n    private static final char[] ALPHANUMERICAL_CHARS = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n            'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\n            'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1',\n            '2', '3', '4', '5', '6', '7', '8', '9' };\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return secure().next(count);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return secure().next(count, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers) {\n        return secure().next(count, start, end, letters, numbers);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers, final char... chars) {\n        return secure().next(count, start, end, letters, numbers, chars);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using supplied source of randomness.\n     *\n     * <p>\n     * If start and end are both {@code 0}, start and end are set to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both {@code false}, in which case, start and end are set\n     * to {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>\n     * If set is not {@code null}, characters between start and end are chosen.\n     * </p>\n     *\n     * <p>\n     * This method accepts a user-supplied {@link Random} instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call, the same random sequence of strings can be\n     * generated repeatedly and predictably.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at (inclusive)\n     * @param end     the position in set of chars to end before (exclusive)\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from, must not be empty. If {@code null}, then it will use the\n     *                set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n            final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \"\n                            + \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint) || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return secure().nextAlphabetic(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphabetic(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return secure().nextAlphanumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphanumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return secure().nextAscii(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAscii(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return secure().nextGraph(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextGraph(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return secure().nextNumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextNumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return secure().nextPrint(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextPrint(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils secure() {\n        return SECURE;\n    }\n\n    private final Supplier<RandomUtils> random;\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in standard programming. Instead, the class should\n     * be used as {@code RandomStringUtils.random(5);}.\n     *\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomStringUtils(final Supplier<RandomUtils> random) {\n        this.random = random;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers,\n            final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     * @since 3.16.0\n     */\n    public String next(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public String nextGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     * @since 3.16.0\n     */\n    public String nextPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.16.0\n     */\n    public String nextPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Gets the Random.\n     *\n     * @return the Random.\n     */\n    private Random random() {\n        return randomUtils().random();\n    }\n\n    /**\n     * Gets the RandomUtils.\n     *\n     * @return the RandomUtils.\n     */\n    private RandomUtils randomUtils() {\n        return random.get();\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomStringUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphanumeric(final int count) {\n        return random(count, true, true);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return secure().nextAlphanumeric(count);\n    }\n/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphanumeric(final int count) {\n        return random(count, true, true);\n    }",
        "diffSourceCode": "-  392:     /**\n-  393:      * Creates a random string whose length is the number of characters\n-  394:      * specified.\n-  395:      *\n-  396:      * <p>Characters will be chosen from the set of Latin alphabetic\n-  397:      * characters (a-z, A-Z) and the digits 0-9.</p>\n-  398:      *\n-  399:      * @param count  the length of random string to create\n-  400:      * @return the random string\n-  401:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n-  402:      */\n-  403:     public static String randomAlphanumeric(final int count) {\n-  404:         return random(count, true, true);\n-  405:     }\n-  406: \n-  407:     /**\n-  408:      * Creates a random string whose length is between the inclusive minimum and\n-  409:      * the exclusive maximum.\n-  410:      *\n-  411:      * <p>Characters will be chosen from the set of Latin alphabetic\n-  412:      * characters (a-z, A-Z) and the digits 0-9.</p>\n-  413:      *\n+  392:      * @param maxLengthExclusive the exclusive maximum length of the string to generate\n+  393:      * @return the random string\n+  394:      * @since 3.5\n+  395:      */\n+  396:     public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n+  397:         return secure().nextAlphabetic(minLengthInclusive, maxLengthExclusive);\n+  398:     }\n+  399: \n+  400:     /**\n+  401:      * Creates a random string whose length is the number of characters specified.\n+  402:      *\n+  403:      * <p>\n+  404:      * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n+  405:      * </p>\n+  406:      *\n+  407:      * @param count the length of random string to create\n+  408:      * @return the random string\n+  409:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  410:      */\n+  411:     public static String randomAlphanumeric(final int count) {\n+  412:         return secure().nextAlphanumeric(count);\n+  413:     }\n+  747:     /**\n+  748:      * Creates a random string whose length is the number of characters specified.\n+  749:      *\n+  750:      * <p>\n+  751:      * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n+  752:      * </p>\n+  753:      *\n+  754:      * @param count the length of random string to create\n+  755:      * @return the random string\n+  756:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  757:      */\n+  758:     public String nextAlphanumeric(final int count) {\n+  759:         return random(count, true, true);\n+  760:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_392_405_747_760_400_413",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Generates a random string of specified length using the given parameters.\n *\n * @param count    the length of the random string to create\n * @param start    the position in the set of characters to start at\n * @param end      the position in the set of characters to end before\n * @param letters  if true, generated string may include alphabetic characters\n * @param numbers  if true, generated string may include numeric characters\n * @param chars    the character array containing the set of characters to use, may be null\n * @param random   a source of randomness\n * @return the random string\n * @throws IllegalArgumentException if count is less than 0 or the provided chars array is empty\n */\npublic static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n    if (chars == null) {\n        return random(count, 0, 0, false, false, null, random());\n    }\n    return random(count, 0, chars.length, false, false, chars, random());\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic nextAlphabetic(count int) : String extracted from public randomAlphabetic(count int) : String in class org.apache.commons.lang3.RandomStringUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 362,
                "endLine": 375,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 369,
                "endLine": 382,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 716,
                "endLine": 729,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomStringUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomStringUtils#randomAlphabetic",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}",
        "classSignatureBefore": "public class RandomStringUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils#randomAlphabetic"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomStringUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\n * \"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\">\n * RandomStringGenerator</a> instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>\n * dedicated to pseudo-random number generation, that may be a better choice for applications with more stringent\n * requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the\n * values 56192 (db80) and 56319 (dbff) as we don't know how to handle them. High and low surrogates are correctly dealt\n * with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) then it is followed by a low\n * surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @see RandomUtils\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final Supplier<RandomUtils> SECURE_SUPPLIER = RandomUtils::secure;\n\n    private static RandomStringUtils INSECURE = new RandomStringUtils(RandomUtils::insecure);\n\n    private static RandomStringUtils SECURE = new RandomStringUtils(SECURE_SUPPLIER);\n\n    private static final char[] ALPHANUMERICAL_CHARS = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n            'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\n            'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1',\n            '2', '3', '4', '5', '6', '7', '8', '9' };\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return secure().next(count);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return secure().next(count, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers) {\n        return secure().next(count, start, end, letters, numbers);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers, final char... chars) {\n        return secure().next(count, start, end, letters, numbers, chars);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using supplied source of randomness.\n     *\n     * <p>\n     * If start and end are both {@code 0}, start and end are set to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both {@code false}, in which case, start and end are set\n     * to {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>\n     * If set is not {@code null}, characters between start and end are chosen.\n     * </p>\n     *\n     * <p>\n     * This method accepts a user-supplied {@link Random} instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call, the same random sequence of strings can be\n     * generated repeatedly and predictably.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at (inclusive)\n     * @param end     the position in set of chars to end before (exclusive)\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from, must not be empty. If {@code null}, then it will use the\n     *                set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n            final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \"\n                            + \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint) || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return secure().nextAlphabetic(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphabetic(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return secure().nextAlphanumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphanumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return secure().nextAscii(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAscii(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return secure().nextGraph(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextGraph(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return secure().nextNumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextNumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return secure().nextPrint(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextPrint(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils secure() {\n        return SECURE;\n    }\n\n    private final Supplier<RandomUtils> random;\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in standard programming. Instead, the class should\n     * be used as {@code RandomStringUtils.random(5);}.\n     *\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomStringUtils(final Supplier<RandomUtils> random) {\n        this.random = random;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers,\n            final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     * @since 3.16.0\n     */\n    public String next(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public String nextGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     * @since 3.16.0\n     */\n    public String nextPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.16.0\n     */\n    public String nextPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Gets the Random.\n     *\n     * @return the Random.\n     */\n    private Random random() {\n        return randomUtils().random();\n    }\n\n    /**\n     * Gets the RandomUtils.\n     *\n     * @return the RandomUtils.\n     */\n    private RandomUtils randomUtils() {\n        return random.get();\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomStringUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphabetic(final int count) {\n        return random(count, true, false);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return secure().nextAlphabetic(count);\n    }\n/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphabetic(final int count) {\n        return random(count, true, false);\n    }",
        "diffSourceCode": "-  362:     /**\n-  363:      * Creates a random string whose length is the number of characters\n-  364:      * specified.\n-  365:      *\n-  366:      * <p>Characters will be chosen from the set of Latin alphabetic\n-  367:      * characters (a-z, A-Z).</p>\n-  368:      *\n-  369:      * @param count  the length of random string to create\n-  370:      * @return the random string\n-  371:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n-  372:      */\n-  373:     public static String randomAlphabetic(final int count) {\n-  374:         return random(count, true, false);\n-  375:     }\n-  376: \n-  377:     /**\n-  378:      * Creates a random string whose length is between the inclusive minimum and\n-  379:      * the exclusive maximum.\n-  380:      *\n-  381:      * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n-  382:      *\n+  362:      * @return the random string\n+  363:      * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n+  364:      */\n+  365:     public static String random(final int count, final String chars) {\n+  366:         return secure().next(count, chars);\n+  367:     }\n+  368: \n+  369:     /**\n+  370:      * Creates a random string whose length is the number of characters specified.\n+  371:      *\n+  372:      * <p>\n+  373:      * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n+  374:      * </p>\n+  375:      *\n+  376:      * @param count the length of random string to create\n+  377:      * @return the random string\n+  378:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  379:      */\n+  380:     public static String randomAlphabetic(final int count) {\n+  381:         return secure().nextAlphabetic(count);\n+  382:     }\n+  716:     /**\n+  717:      * Creates a random string whose length is the number of characters specified.\n+  718:      *\n+  719:      * <p>\n+  720:      * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n+  721:      * </p>\n+  722:      *\n+  723:      * @param count the length of random string to create\n+  724:      * @return the random string\n+  725:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  726:      */\n+  727:     public String nextAlphabetic(final int count) {\n+  728:         return random(count, true, false);\n+  729:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_362_375_716_729_369_382",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Generates a random string of specified length using the given parameters.\n *\n * @param count    the length of the random string to create\n * @param start    the starting position in the set of characters\n * @param end      the ending position in the set of characters\n * @param letters  if true, include alphabetic characters\n * @param numbers  if true, include numeric characters\n * @param chars    the character array containing the set of characters to use\n * @param random   the source of randomness\n * @return the random string\n * @throws IllegalArgumentException if count is less than 0 or the provided chars array is empty\n */\npublic static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n    return random(count, start, end, letters, numbers, chars, random());\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic next(count int, chars String) : String extracted from public random(count int, chars String) : String in class org.apache.commons.lang3.RandomStringUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 341,
                "endLine": 360,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 352,
                "endLine": 367,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 695,
                "endLine": 714,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomStringUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomStringUtils#random",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}",
        "classSignatureBefore": "public class RandomStringUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils#random"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomStringUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\n * \"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\">\n * RandomStringGenerator</a> instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>\n * dedicated to pseudo-random number generation, that may be a better choice for applications with more stringent\n * requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the\n * values 56192 (db80) and 56319 (dbff) as we don't know how to handle them. High and low surrogates are correctly dealt\n * with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) then it is followed by a low\n * surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @see RandomUtils\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final Supplier<RandomUtils> SECURE_SUPPLIER = RandomUtils::secure;\n\n    private static RandomStringUtils INSECURE = new RandomStringUtils(RandomUtils::insecure);\n\n    private static RandomStringUtils SECURE = new RandomStringUtils(SECURE_SUPPLIER);\n\n    private static final char[] ALPHANUMERICAL_CHARS = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n            'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\n            'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1',\n            '2', '3', '4', '5', '6', '7', '8', '9' };\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return secure().next(count);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return secure().next(count, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers) {\n        return secure().next(count, start, end, letters, numbers);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers, final char... chars) {\n        return secure().next(count, start, end, letters, numbers, chars);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using supplied source of randomness.\n     *\n     * <p>\n     * If start and end are both {@code 0}, start and end are set to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both {@code false}, in which case, start and end are set\n     * to {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>\n     * If set is not {@code null}, characters between start and end are chosen.\n     * </p>\n     *\n     * <p>\n     * This method accepts a user-supplied {@link Random} instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call, the same random sequence of strings can be\n     * generated repeatedly and predictably.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at (inclusive)\n     * @param end     the position in set of chars to end before (exclusive)\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from, must not be empty. If {@code null}, then it will use the\n     *                set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n            final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \"\n                            + \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint) || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return secure().nextAlphabetic(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphabetic(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return secure().nextAlphanumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphanumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return secure().nextAscii(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAscii(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return secure().nextGraph(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextGraph(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return secure().nextNumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextNumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return secure().nextPrint(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextPrint(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils secure() {\n        return SECURE;\n    }\n\n    private final Supplier<RandomUtils> random;\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in standard programming. Instead, the class should\n     * be used as {@code RandomStringUtils.random(5);}.\n     *\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomStringUtils(final Supplier<RandomUtils> random) {\n        this.random = random;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers,\n            final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     * @since 3.16.0\n     */\n    public String next(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public String nextGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     * @since 3.16.0\n     */\n    public String nextPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.16.0\n     */\n    public String nextPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Gets the Random.\n     *\n     * @return the Random.\n     */\n    private Random random() {\n        return randomUtils().random();\n    }\n\n    /**\n     * Gets the RandomUtils.\n     *\n     * @return the RandomUtils.\n     */\n    private RandomUtils randomUtils() {\n        return random.get();\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomStringUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     * @since 3.16.0\n     */\n    public String next(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        return secure().next(count, chars);\n    }\n/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     * @since 3.16.0\n     */\n    public String next(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }",
        "diffSourceCode": "-  341:     /**\n-  342:      * Creates a random string whose length is the number of characters\n-  343:      * specified.\n-  344:      *\n-  345:      * <p>Characters will be chosen from the set of characters\n-  346:      * specified by the string, must not be empty.\n-  347:      * If null, the set of all characters is used.</p>\n-  348:      *\n-  349:      * @param count  the length of random string to create\n-  350:      * @param chars  the String containing the set of characters to use,\n-  351:      *  may be null, but must not be empty\n-  352:      * @return the random string\n-  353:      * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n-  354:      */\n-  355:     public static String random(final int count, final String chars) {\n-  356:         if (chars == null) {\n-  357:             return random(count, 0, 0, false, false, null, random());\n-  358:         }\n-  359:         return random(count, chars.toCharArray());\n-  360:     }\n-  361: \n-  362:     /**\n-  363:      * Creates a random string whose length is the number of characters\n-  364:      * specified.\n-  365:      *\n-  366:      * <p>Characters will be chosen from the set of Latin alphabetic\n-  367:      * characters (a-z, A-Z).</p>\n+  341:                 if (numberOfChars == 2) {\n+  342:                     count--;\n+  343:                 }\n+  344: \n+  345:             } else {\n+  346:                 count++;\n+  347:             }\n+  348:         }\n+  349:         return builder.toString();\n+  350:     }\n+  351: \n+  352:     /**\n+  353:      * Creates a random string whose length is the number of characters specified.\n+  354:      *\n+  355:      * <p>\n+  356:      * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n+  357:      * of all characters is used.\n+  358:      * </p>\n+  359:      *\n+  360:      * @param count the length of random string to create\n+  361:      * @param chars the String containing the set of characters to use, may be null, but must not be empty\n+  362:      * @return the random string\n+  363:      * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n+  364:      */\n+  365:     public static String random(final int count, final String chars) {\n+  366:         return secure().next(count, chars);\n+  367:     }\n+  695:     /**\n+  696:      * Creates a random string whose length is the number of characters specified.\n+  697:      *\n+  698:      * <p>\n+  699:      * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n+  700:      * of all characters is used.\n+  701:      * </p>\n+  702:      *\n+  703:      * @param count the length of random string to create\n+  704:      * @param chars the String containing the set of characters to use, may be null, but must not be empty\n+  705:      * @return the random string\n+  706:      * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n+  707:      * @since 3.16.0\n+  708:      */\n+  709:     public String next(final int count, final String chars) {\n+  710:         if (chars == null) {\n+  711:             return random(count, 0, 0, false, false, null, random());\n+  712:         }\n+  713:         return random(count, chars.toCharArray());\n+  714:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_341_360_695_714_352_367",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 16
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Generates a random string using the specified parameters and source of randomness.\n *\n * @param count    the length of the random string to create\n * @param start    the position in the set of characters to start at\n * @param end      the position in the set of characters to end before\n * @param letters  if true, generated string may include alphabetic characters\n * @param numbers  if true, generated string may include numeric characters\n * @param chars    the set of characters to choose random characters from\n * @param random   the source of randomness\n * @return the random string\n * @throws IllegalArgumentException if count is less than 0 or the provided chars array is empty\n */\nprivate static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {\n    // Method implementation remains the same\n    // No changes made to the method implementation\n    // This method has been extracted for better modularity and readability\n    // Original code remains intact\n    return RandomStringUtils.random(count, start, end, letters, numbers, chars, random);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic next(count int, start int, end int, letters boolean, numbers boolean, chars char...) : String extracted from public random(count int, start int, end int, letters boolean, numbers boolean, chars char...) : String in class org.apache.commons.lang3.RandomStringUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 150,
                "endLine": 175,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 168,
                "endLine": 190,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 671,
                "endLine": 693,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomStringUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomStringUtils#random",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}",
        "classSignatureBefore": "public class RandomStringUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils#random"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomStringUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\n * \"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\">\n * RandomStringGenerator</a> instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>\n * dedicated to pseudo-random number generation, that may be a better choice for applications with more stringent\n * requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the\n * values 56192 (db80) and 56319 (dbff) as we don't know how to handle them. High and low surrogates are correctly dealt\n * with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) then it is followed by a low\n * surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @see RandomUtils\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final Supplier<RandomUtils> SECURE_SUPPLIER = RandomUtils::secure;\n\n    private static RandomStringUtils INSECURE = new RandomStringUtils(RandomUtils::insecure);\n\n    private static RandomStringUtils SECURE = new RandomStringUtils(SECURE_SUPPLIER);\n\n    private static final char[] ALPHANUMERICAL_CHARS = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n            'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\n            'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1',\n            '2', '3', '4', '5', '6', '7', '8', '9' };\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return secure().next(count);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return secure().next(count, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers) {\n        return secure().next(count, start, end, letters, numbers);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers, final char... chars) {\n        return secure().next(count, start, end, letters, numbers, chars);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using supplied source of randomness.\n     *\n     * <p>\n     * If start and end are both {@code 0}, start and end are set to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both {@code false}, in which case, start and end are set\n     * to {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>\n     * If set is not {@code null}, characters between start and end are chosen.\n     * </p>\n     *\n     * <p>\n     * This method accepts a user-supplied {@link Random} instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call, the same random sequence of strings can be\n     * generated repeatedly and predictably.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at (inclusive)\n     * @param end     the position in set of chars to end before (exclusive)\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from, must not be empty. If {@code null}, then it will use the\n     *                set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n            final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \"\n                            + \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint) || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return secure().nextAlphabetic(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphabetic(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return secure().nextAlphanumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphanumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return secure().nextAscii(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAscii(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return secure().nextGraph(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextGraph(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return secure().nextNumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextNumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return secure().nextPrint(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextPrint(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils secure() {\n        return SECURE;\n    }\n\n    private final Supplier<RandomUtils> random;\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in standard programming. Instead, the class should\n     * be used as {@code RandomStringUtils.random(5);}.\n     *\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomStringUtils(final Supplier<RandomUtils> random) {\n        this.random = random;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers,\n            final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     * @since 3.16.0\n     */\n    public String next(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public String nextGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     * @since 3.16.0\n     */\n    public String nextPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.16.0\n     */\n    public String nextPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Gets the Random.\n     *\n     * @return the Random.\n     */\n    private Random random() {\n        return randomUtils().random();\n    }\n\n    /**\n     * Gets the RandomUtils.\n     *\n     * @return the RandomUtils.\n     */\n    private RandomUtils randomUtils() {\n        return random.get();\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomStringUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers,\n            final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers, final char... chars) {\n        return secure().next(count, start, end, letters, numbers, chars);\n    }\n/**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers,\n            final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }",
        "diffSourceCode": "-  150:     /**\n-  151:      * Creates a random string based on a variety of options, using\n-  152:      * default source of randomness.\n-  153:      *\n-  154:      * <p>This method has exactly the same semantics as\n-  155:      * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n-  156:      * instead of using an externally supplied source of randomness, it uses\n-  157:      * the internal static {@link Random} instance.</p>\n-  158:      *\n-  159:      * @param count  the length of random string to create\n-  160:      * @param start  the position in set of chars to start at\n-  161:      * @param end  the position in set of chars to end before\n-  162:      * @param letters  if {@code true}, generated string may include\n-  163:      *  alphabetic characters\n-  164:      * @param numbers  if {@code true}, generated string may include\n-  165:      *  numeric characters\n-  166:      * @param chars  the set of chars to choose randoms from.\n-  167:      *  If {@code null}, then it will use the set of all chars.\n-  168:      * @return the random string\n-  169:      * @throws ArrayIndexOutOfBoundsException if there are not\n-  170:      *  {@code (end - start) + 1} characters in the set array.\n-  171:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n-  172:      */\n-  173:     public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n-  174:         return random(count, start, end, letters, numbers, chars, random());\n-  175:     }\n-  176: \n-  177:     /**\n-  178:      * Creates a random string based on a variety of options, using\n-  179:      * supplied source of randomness.\n-  180:      *\n-  181:      * <p>If start and end are both {@code 0}, start and end are set\n-  182:      * to {@code ' '} and {@code 'z'}, the ASCII printable\n-  183:      * characters, will be used, unless letters and numbers are both\n-  184:      * {@code false}, in which case, start and end are set to\n-  185:      * {@code 0} and {@link Character#MAX_CODE_POINT}.\n-  186:      *\n-  187:      * <p>If set is not {@code null}, characters between start and\n-  188:      * end are chosen.</p>\n-  189:      *\n-  190:      * <p>This method accepts a user-supplied {@link Random}\n+  150:      *\n+  151:      * <p>\n+  152:      * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n+  153:      * </p>\n+  154:      *\n+  155:      * @param count   the length of random string to create\n+  156:      * @param start   the position in set of chars to start at\n+  157:      * @param end     the position in set of chars to end before\n+  158:      * @param letters if {@code true}, generated string may include alphabetic characters\n+  159:      * @param numbers if {@code true}, generated string may include numeric characters\n+  160:      * @return the random string\n+  161:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  162:      */\n+  163:     public static String random(final int count, final int start, final int end, final boolean letters,\n+  164:             final boolean numbers) {\n+  165:         return secure().next(count, start, end, letters, numbers);\n+  166:     }\n+  167: \n+  168:     /**\n+  169:      * Creates a random string based on a variety of options, using default source of randomness.\n+  170:      *\n+  171:      * <p>\n+  172:      * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n+  173:      * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n+  174:      * instance.\n+  175:      * </p>\n+  176:      *\n+  177:      * @param count   the length of random string to create\n+  178:      * @param start   the position in set of chars to start at\n+  179:      * @param end     the position in set of chars to end before\n+  180:      * @param letters if {@code true}, generated string may include alphabetic characters\n+  181:      * @param numbers if {@code true}, generated string may include numeric characters\n+  182:      * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n+  183:      * @return the random string\n+  184:      * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n+  185:      * @throws IllegalArgumentException       if {@code count} &lt; 0.\n+  186:      */\n+  187:     public static String random(final int count, final int start, final int end, final boolean letters,\n+  188:             final boolean numbers, final char... chars) {\n+  189:         return secure().next(count, start, end, letters, numbers, chars);\n+  190:     }\n+  671:     /**\n+  672:      * Creates a random string based on a variety of options, using default source of randomness.\n+  673:      *\n+  674:      * <p>\n+  675:      * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n+  676:      * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n+  677:      * instance.\n+  678:      * </p>\n+  679:      *\n+  680:      * @param count   the length of random string to create\n+  681:      * @param start   the position in set of chars to start at\n+  682:      * @param end     the position in set of chars to end before\n+  683:      * @param letters if {@code true}, generated string may include alphabetic characters\n+  684:      * @param numbers if {@code true}, generated string may include numeric characters\n+  685:      * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n+  686:      * @return the random string\n+  687:      * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n+  688:      * @throws IllegalArgumentException       if {@code count} &lt; 0.\n+  689:      */\n+  690:     public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers,\n+  691:             final char... chars) {\n+  692:         return random(count, start, end, letters, numbers, chars, random());\n+  693:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_150_175_671_693_168_190",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 16
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Creates a random string based on a variety of options, using\n * supplied source of randomness.\n *\n * <p>If start and end are both {@code 0}, start and end are set\n * to {@code ' '} and {@code 'z'}, the ASCII printable\n * characters, will be used, unless letters and numbers are both\n * {@code false}, in which case, start and end are set to\n * {@code 0} and {@link Character#MAX_CODE_POINT}.\n *\n * <p>If set is not {@code null}, characters between start and\n * end are chosen.</p>\n *\n * <p>This method accepts a user-supplied {@link Random}\n * instance to use as a source of randomness. By seeding a single\n * {@link Random} instance with a fixed seed and using it for each call,\n * the same random sequence of strings can be generated repeatedly\n * and predictably.</p>\n *\n * @param count  the length of random string to create\n * @param start  the position in set of chars to start at (inclusive)\n * @param end  the position in set of chars to end before (exclusive)\n * @param letters  if {@code true}, generated string may include\n *  alphabetic characters\n * @param numbers  if {@code true}, generated string may include\n *  numeric characters\n * @param chars  the set of chars to choose randoms from, must not be empty.\n *  If {@code null}, then it will use the set of all chars.\n * @param random  a source of randomness.\n * @return the random string\n * @throws ArrayIndexOutOfBoundsException if there are not\n *  {@code (end - start) + 1} characters in the set array.\n * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n * @since 2.0\n */\npublic static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                            final char[] chars, final Random random) {\n    if (count == 0) {\n        return StringUtils.EMPTY;\n    }\n    if (count < 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars != null && chars.length == 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n\n    if (start == 0 && end == 0) {\n        if (chars != null) {\n            end = chars.length;\n        } else if (!letters && !numbers) {\n            end = Character.MAX_CODE_POINT;\n        } else {\n            end = 'z' + 1;\n            start = ' ';\n        }\n    } else if (end <= start) {\n        throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n    } else if (start < 0 || end < 0) {\n        throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n    }\n\n    if (end > Character.MAX_CODE_POINT) {\n        // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n        // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n        end = Character.MAX_CODE_POINT;\n    }\n\n    // Optimize generation of full alphanumerical characters\n    // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n    // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n    // Instead we can pick directly from the right set of 62 characters, which requires\n    // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n    if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n        return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n    }\n\n    // Optimize start and end when filtering by letters and/or numbers:\n    // The range provided may be too large since we filter anyway afterward.\n    // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n    // since it is possible the range start/end excludes some of the letters/numbers,\n    // e.g., it is possible that start already is '1' when numbers = true, and start\n    // needs to stay equal to '1' in that case.\n    if (chars == null) {\n        if (letters && numbers) {\n            start = Math.max('0', start);\n            end = Math.min('z' + 1, end);\n        } else if (numbers) {\n            // just numbers, no letters\n            start = Math.max('0', start);\n            end = Math.min('9' + 1, end);\n        } else if (letters) {\n            // just letters, no numbers\n            start = Math.max('A', start);\n            end = Math.min('z' + 1, end);\n        }\n    }\n\n    final int zeroDigitAscii = 48;\n    final int firstLetterAscii = 65;\n\n    if (chars == null && (numbers && end <= zeroDigitAscii\n            || letters && end <= firstLetterAscii)) {\n        throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n    }\n\n    final StringBuilder builder = new StringBuilder(count);\n    final int gap = end - start;\n    final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n    // The size of the cache we use is an heuristic:\n    // about twice the number of bytes required if no rejection\n    // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n    // of randomness as well as the probability of rejection. It is however not easy to know\n    // those values programmatically for the general case.\n    final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n    while (count-- != 0) {\n        // Generate a random value between start (included) and end (excluded)\n        final int randomValue = arb.nextBits(gapBits) + start;\n        // Rejection sampling if value too large\n        if (randomValue >= end) {\n            count++;\n            continue;\n        }\n\n        final int codePoint;\n        if (chars == null) {\n            codePoint = randomValue;\n\n            switch (Character.getType(codePoint)) {\n            case Character.UNASSIGNED:\n            case Character.PRIVATE_USE:\n            case Character.SURROGATE:\n                count++;\n                continue;\n            }\n\n        } else {\n            codePoint = chars[randomValue];\n        }\n\n        final int numberOfChars = Character.charCount(codePoint);\n        if (count == 0 && numberOfChars > 1) {\n            count++;\n            continue;\n        }\n\n        if (letters && Character.isLetter(codePoint)\n                || numbers && Character.isDigit(codePoint)\n                || !letters && !numbers) {\n            builder.appendCodePoint(codePoint);\n\n            if (numberOfChars == 2) {\n                count--;\n            }\n\n        } else {\n            count++;\n        }\n    }\n    return builder.toString();\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic next(count int, start int, end int, letters boolean, numbers boolean) : String extracted from public random(count int, start int, end int, letters boolean, numbers boolean) : String in class org.apache.commons.lang3.RandomStringUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 129,
                "endLine": 148,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 148,
                "endLine": 166,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 651,
                "endLine": 669,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomStringUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomStringUtils#random",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}",
        "classSignatureBefore": "public class RandomStringUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils#random"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomStringUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\n * \"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\">\n * RandomStringGenerator</a> instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>\n * dedicated to pseudo-random number generation, that may be a better choice for applications with more stringent\n * requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the\n * values 56192 (db80) and 56319 (dbff) as we don't know how to handle them. High and low surrogates are correctly dealt\n * with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) then it is followed by a low\n * surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @see RandomUtils\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final Supplier<RandomUtils> SECURE_SUPPLIER = RandomUtils::secure;\n\n    private static RandomStringUtils INSECURE = new RandomStringUtils(RandomUtils::insecure);\n\n    private static RandomStringUtils SECURE = new RandomStringUtils(SECURE_SUPPLIER);\n\n    private static final char[] ALPHANUMERICAL_CHARS = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n            'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\n            'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1',\n            '2', '3', '4', '5', '6', '7', '8', '9' };\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return secure().next(count);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return secure().next(count, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers) {\n        return secure().next(count, start, end, letters, numbers);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers, final char... chars) {\n        return secure().next(count, start, end, letters, numbers, chars);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using supplied source of randomness.\n     *\n     * <p>\n     * If start and end are both {@code 0}, start and end are set to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both {@code false}, in which case, start and end are set\n     * to {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>\n     * If set is not {@code null}, characters between start and end are chosen.\n     * </p>\n     *\n     * <p>\n     * This method accepts a user-supplied {@link Random} instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call, the same random sequence of strings can be\n     * generated repeatedly and predictably.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at (inclusive)\n     * @param end     the position in set of chars to end before (exclusive)\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from, must not be empty. If {@code null}, then it will use the\n     *                set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n            final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \"\n                            + \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint) || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return secure().nextAlphabetic(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphabetic(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return secure().nextAlphanumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphanumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return secure().nextAscii(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAscii(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return secure().nextGraph(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextGraph(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return secure().nextNumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextNumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return secure().nextPrint(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextPrint(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils secure() {\n        return SECURE;\n    }\n\n    private final Supplier<RandomUtils> random;\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in standard programming. Instead, the class should\n     * be used as {@code RandomStringUtils.random(5);}.\n     *\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomStringUtils(final Supplier<RandomUtils> random) {\n        this.random = random;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers,\n            final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     * @since 3.16.0\n     */\n    public String next(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public String nextGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     * @since 3.16.0\n     */\n    public String nextPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.16.0\n     */\n    public String nextPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Gets the Random.\n     *\n     * @return the Random.\n     */\n    private Random random() {\n        return randomUtils().random();\n    }\n\n    /**\n     * Gets the RandomUtils.\n     *\n     * @return the RandomUtils.\n     */\n    private RandomUtils randomUtils() {\n        return random.get();\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomStringUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers) {\n        return secure().next(count, start, end, letters, numbers);\n    }\n/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }",
        "diffSourceCode": "-  129:     /**\n-  130:      * Creates a random string whose length is the number of characters\n-  131:      * specified.\n-  132:      *\n-  133:      * <p>Characters will be chosen from the set of alpha-numeric\n-  134:      * characters as indicated by the arguments.</p>\n-  135:      *\n-  136:      * @param count  the length of random string to create\n-  137:      * @param start  the position in set of chars to start at\n-  138:      * @param end  the position in set of chars to end before\n-  139:      * @param letters  if {@code true}, generated string may include\n-  140:      *  alphabetic characters\n-  141:      * @param numbers  if {@code true}, generated string may include\n-  142:      *  numeric characters\n-  143:      * @return the random string\n-  144:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n-  145:      */\n-  146:     public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n-  147:         return random(count, start, end, letters, numbers, null, random());\n-  148:     }\n-  149: \n-  150:     /**\n-  151:      * Creates a random string based on a variety of options, using\n-  152:      * default source of randomness.\n-  153:      *\n-  154:      * <p>This method has exactly the same semantics as\n-  155:      * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n-  156:      * instead of using an externally supplied source of randomness, it uses\n-  157:      * the internal static {@link Random} instance.</p>\n-  158:      *\n-  159:      * @param count  the length of random string to create\n-  160:      * @param start  the position in set of chars to start at\n-  161:      * @param end  the position in set of chars to end before\n-  162:      * @param letters  if {@code true}, generated string may include\n-  163:      *  alphabetic characters\n-  164:      * @param numbers  if {@code true}, generated string may include\n-  165:      *  numeric characters\n-  166:      * @param chars  the set of chars to choose randoms from.\n+  129:         return secure().next(count, letters, numbers);\n+  130:     }\n+  131: \n+  132:     /**\n+  133:      * Creates a random string whose length is the number of characters specified.\n+  134:      *\n+  135:      * <p>\n+  136:      * Characters will be chosen from the set of characters specified.\n+  137:      * </p>\n+  138:      *\n+  139:      * @param count the length of random string to create\n+  140:      * @param chars the character array containing the set of characters to use, may be null\n+  141:      * @return the random string\n+  142:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  143:      */\n+  144:     public static String random(final int count, final char... chars) {\n+  145:         return secure().next(count, chars);\n+  146:     }\n+  147: \n+  148:     /**\n+  149:      * Creates a random string whose length is the number of characters specified.\n+  150:      *\n+  151:      * <p>\n+  152:      * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n+  153:      * </p>\n+  154:      *\n+  155:      * @param count   the length of random string to create\n+  156:      * @param start   the position in set of chars to start at\n+  157:      * @param end     the position in set of chars to end before\n+  158:      * @param letters if {@code true}, generated string may include alphabetic characters\n+  159:      * @param numbers if {@code true}, generated string may include numeric characters\n+  160:      * @return the random string\n+  161:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  162:      */\n+  163:     public static String random(final int count, final int start, final int end, final boolean letters,\n+  164:             final boolean numbers) {\n+  165:         return secure().next(count, start, end, letters, numbers);\n+  166:     }\n+  651:     /**\n+  652:      * Creates a random string whose length is the number of characters specified.\n+  653:      *\n+  654:      * <p>\n+  655:      * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n+  656:      * </p>\n+  657:      *\n+  658:      * @param count   the length of random string to create\n+  659:      * @param start   the position in set of chars to start at\n+  660:      * @param end     the position in set of chars to end before\n+  661:      * @param letters if {@code true}, generated string may include alphabetic characters\n+  662:      * @param numbers if {@code true}, generated string may include numeric characters\n+  663:      * @return the random string\n+  664:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  665:      * @since 3.16.0\n+  666:      */\n+  667:     public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n+  668:         return random(count, start, end, letters, numbers, null, random());\n+  669:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_129_148_651_669_148_166",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 16
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Creates a random string based on a variety of options, using\n * supplied source of randomness.\n *\n * <p>If start and end are both {@code 0}, start and end are set\n * to {@code ' '} and {@code 'z'}, the ASCII printable\n * characters, will be used, unless letters and numbers are both\n * {@code false}, in which case, start and end are set to\n * {@code 0} and {@link Character#MAX_CODE_POINT}.\n *\n * <p>If set is not {@code null}, characters between start and\n * end are chosen.</p>\n *\n * <p>This method accepts a user-supplied {@link Random}\n * instance to use as a source of randomness. By seeding a single\n * {@link Random} instance with a fixed seed and using it for each call,\n * the same random sequence of strings can be generated repeatedly\n * and predictably.</p>\n *\n * @param count  the length of random string to create\n * @param start  the position in set of chars to start at (inclusive)\n * @param end  the position in set of chars to end before (exclusive)\n * @param letters  if {@code true}, generated string may include\n *  alphabetic characters\n * @param numbers  if {@code true}, generated string may include\n *  numeric characters\n * @param chars  the set of chars to choose randoms from, must not be empty.\n *  If {@code null}, then it will use the set of all chars.\n * @param random  a source of randomness.\n * @return the random string\n * @throws ArrayIndexOutOfBoundsException if there are not\n *  {@code (end - start) + 1} characters in the set array.\n * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n * @since 2.0\n */\npublic static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                            final char[] chars, final Random random) {\n    if (count == 0) {\n        return StringUtils.EMPTY;\n    }\n    if (count < 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars != null && chars.length == 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n\n    if (start == 0 && end == 0) {\n        if (chars != null) {\n            end = chars.length;\n        } else if (!letters && !numbers) {\n            end = Character.MAX_CODE_POINT;\n        } else {\n            end = 'z' + 1;\n            start = ' ';\n        }\n    } else if (end <= start) {\n        throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n    } else if (start < 0 || end < 0) {\n        throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n    }\n\n    if (end > Character.MAX_CODE_POINT) {\n        // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n        // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n        end = Character.MAX_CODE_POINT;\n    }\n\n    // Optimize generation of full alphanumerical characters\n    // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n    // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n    // Instead we can pick directly from the right set of 62 characters, which requires\n    // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n    if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n        return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n    }\n\n    // Optimize start and end when filtering by letters and/or numbers:\n    // The range provided may be too large since we filter anyway afterward.\n    // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n    // since it is possible the range start/end excludes some of the letters/numbers,\n    // e.g., it is possible that start already is '1' when numbers = true, and start\n    // needs to stay equal to '1' in that case.\n    if (chars == null) {\n        if (letters && numbers) {\n            start = Math.max('0', start);\n            end = Math.min('z' + 1, end);\n        } else if (numbers) {\n            // just numbers, no letters\n            start = Math.max('0', start);\n            end = Math.min('9' + 1, end);\n        } else if (letters) {\n            // just letters, no numbers\n            start = Math.max('A', start);\n            end = Math.min('z' + 1, end);\n        }\n    }\n\n    final int zeroDigitAscii = 48;\n    final int firstLetterAscii = 65;\n\n    if (chars == null && (numbers && end <= zeroDigitAscii\n            || letters && end <= firstLetterAscii)) {\n        throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n    }\n\n    final StringBuilder builder = new StringBuilder(count);\n    final int gap = end - start;\n    final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n    // The size of the cache we use is an heuristic:\n    // about twice the number of bytes required if no rejection\n    // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n    // of randomness as well as the probability of rejection. It is however not easy to know\n    // those values programmatically for the general case.\n    final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n    while (count-- != 0) {\n        // Generate a random value between start (included) and end (excluded)\n        final int randomValue = arb.nextBits(gapBits) + start;\n        // Rejection sampling if value too large\n        if (randomValue >= end) {\n            count++;\n            continue;\n        }\n\n        final int codePoint;\n        if (chars == null) {\n            codePoint = randomValue;\n\n            switch (Character.getType(codePoint)) {\n            case Character.UNASSIGNED:\n            case Character.PRIVATE_USE:\n            case Character.SURROGATE:\n                count++;\n                continue;\n            }\n\n        } else {\n            codePoint = chars[randomValue];\n        }\n\n        final int numberOfChars = Character.charCount(codePoint);\n        if (count == 0 && numberOfChars > 1) {\n            count++;\n            continue;\n        }\n\n        if (letters && Character.isLetter(codePoint)\n                || numbers && Character.isDigit(codePoint)\n                || !letters && !numbers) {\n            builder.appendCodePoint(codePoint);\n\n            if (numberOfChars == 2) {\n                count--;\n            }\n\n        } else {\n            count++;\n        }\n    }\n    return builder.toString();\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl() : AbstractBackgroundInitializerTestImpl extracted from public testSetExternalExecutorAfterStart() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 133,
                "endLine": 150,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 135,
                "endLine": 152,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 287,
                "endLine": 289,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testSetExternalExecutorAfterStart",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#setExternalExecutor\n methodBody: public final synchronized void setExternalExecutor(\n            final ExecutorService externalExecutor) {\nif(isStarted()){throw new IllegalStateException(\"Cannot set ExecutorService after start()!\");\n}this.externalExecutor=externalExecutor;\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testSetExternalExecutorAfterStart"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#setExternalExecutor\n methodBody: public final synchronized void setExternalExecutor(\n            final ExecutorService externalExecutor) {\nif(isStarted()){throw new IllegalStateException(\"Cannot set ExecutorService after start()!\");\n}this.externalExecutor=externalExecutor;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }",
        "diffSourceCode": "-  133:     /**\n-  134:      * Tests that setting an executor after start() causes an exception.\n-  135:      *\n-  136:      * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n-  137:      */\n-  138:     @Test\n-  139:     public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n-  140:         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-  141:         init.start();\n-  142:         final ExecutorService exec = Executors.newSingleThreadExecutor();\n-  143:         try {\n-  144:             assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n-  145:             init.get();\n-  146:         } finally {\n-  147:             exec.shutdown();\n-  148:             exec.awaitTermination(1, TimeUnit.SECONDS);\n-  149:         }\n-  150:     }\n-  151: \n-  152:     /**\n-  287:      * some methods that simplify testing.\n-  288:      */\n-  289:     private static final class BackgroundInitializerTestImpl extends\n+  133:     }\n+  134: \n+  135:     /**\n+  136:      * Tests that setting an executor after start() causes an exception.\n+  137:      *\n+  138:      * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n+  139:      */\n+  140:     @Test\n+  141:     public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n+  142:         final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n+  143:         init.start();\n+  144:         final ExecutorService exec = Executors.newSingleThreadExecutor();\n+  145:         try {\n+  146:             assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n+  147:             init.get();\n+  148:         } finally {\n+  149:             exec.shutdown();\n+  150:             exec.awaitTermination(1, TimeUnit.SECONDS);\n+  151:         }\n+  152:     }\n+  287:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n+  288:         return new MethodBackgroundInitializerTestImpl();\n+  289:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_133_150_287_289_135_152",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n/**\n * Asserts that setting an executor after start() causes an exception.\n *\n * @param init the BackgroundInitializerTestImpl instance\n * @param exec the ExecutorService instance\n * @throws ConcurrentException because the test implementation may throw it\n */\nprivate void assertSetExternalExecutorAfterStart(BackgroundInitializerTestImpl init, ExecutorService exec) throws ConcurrentException, InterruptedException {\n    init.start();\n    try {\n        assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n        init.get();\n    } finally {\n        exec.shutdown();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl() : AbstractBackgroundInitializerTestImpl extracted from public testSetExternalExecutor() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 113,
                "endLine": 131,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 115,
                "endLine": 133,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 287,
                "endLine": 289,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testSetExternalExecutor",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkInitialize\n methodBody: private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\nfinal int count=5;\nfor(int i=0; i < count; i++){initializer.addInitializer(CHILD_INIT + i,new ChildBackgroundInitializer());\n}initializer.start();\nfinal MultiBackgroundInitializer.MultiBackgroundInitializerResults res=initializer.get();\nassertEquals(count,res.initializerNames().size(),\"Wrong number of child initializers\");\nfor(int i=0; i < count; i++){final String key=CHILD_INIT + i;\nassertTrue(res.initializerNames().contains(key),\"Name not found: \" + key);\nassertEquals(Integer.valueOf(1),res.getResultObject(key),\"Wrong result object\");\nassertFalse(res.isException(key),\"Exception flag\");\nassertNull(res.getException(key),\"Got an exception\");\ncheckChild(res.getInitializer(key),initializer.getActiveExecutor());\n}return res;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#getActiveExecutor\n methodBody: protected final synchronized ExecutorService getActiveExecutor() {\nreturn executor;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest#checkInitialize\n methodBody: private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\nfinal Integer result=init.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,init.initializeCalls,\"Wrong number of invocations\");\nassertNotNull(init.getFuture(),\"No future\");\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#getExternalExecutor\n methodBody: public final synchronized ExecutorService getExternalExecutor() {\nreturn externalExecutor;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#setExternalExecutor\n methodBody: public final synchronized void setExternalExecutor(\n            final ExecutorService externalExecutor) {\nif(isStarted()){throw new IllegalStateException(\"Cannot set ExecutorService after start()!\");\n}this.externalExecutor=externalExecutor;\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testSetExternalExecutor"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkInitialize\n methodBody: private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\nfinal int count=5;\nfor(int i=0; i < count; i++){initializer.addInitializer(CHILD_INIT + i,new ChildBackgroundInitializer());\n}initializer.start();\nfinal MultiBackgroundInitializer.MultiBackgroundInitializerResults res=initializer.get();\nassertEquals(count,res.initializerNames().size(),\"Wrong number of child initializers\");\nfor(int i=0; i < count; i++){final String key=CHILD_INIT + i;\nassertTrue(res.initializerNames().contains(key),\"Name not found: \" + key);\nassertEquals(Integer.valueOf(1),res.getResultObject(key),\"Wrong result object\");\nassertFalse(res.isException(key),\"Exception flag\");\nassertNull(res.getException(key),\"Got an exception\");\ncheckChild(res.getInitializer(key),initializer.getActiveExecutor());\n}return res;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#getActiveExecutor\n methodBody: protected final synchronized ExecutorService getActiveExecutor() {\nreturn executor;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest#checkInitialize\n methodBody: private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\nfinal Integer result=init.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,init.initializeCalls,\"Wrong number of invocations\");\nassertNotNull(init.getFuture(),\"No future\");\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#getExternalExecutor\n methodBody: public final synchronized ExecutorService getExternalExecutor() {\nreturn externalExecutor;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#setExternalExecutor\n methodBody: public final synchronized void setExternalExecutor(\n            final ExecutorService externalExecutor) {\nif(isStarted()){throw new IllegalStateException(\"Cannot set ExecutorService after start()!\");\n}this.externalExecutor=externalExecutor;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }",
        "diffSourceCode": "-  113:     /**\n-  114:      * Tests whether an external executor can be set using the\n-  115:      * setExternalExecutor() method.\n-  116:      */\n-  117:     @Test\n-  118:     public void testSetExternalExecutor() throws ConcurrentException {\n-  119:         final ExecutorService exec = Executors.newCachedThreadPool();\n-  120:         try {\n-  121:             final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-  122:             init.setExternalExecutor(exec);\n-  123:             assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n-  124:             assertTrue(init.start(), \"Wrong result of start()\");\n-  125:             assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n-  126:             checkInitialize(init);\n-  127:             assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n-  128:         } finally {\n-  129:             exec.shutdown();\n-  130:         }\n-  131:     }\n-  132: \n-  133:     /**\n-  287:      * some methods that simplify testing.\n-  288:      */\n-  289:     private static final class BackgroundInitializerTestImpl extends\n+  113:     }\n+  114: \n+  115:     /**\n+  116:      * Tests whether an external executor can be set using the\n+  117:      * setExternalExecutor() method.\n+  118:      */\n+  119:     @Test\n+  120:     public void testSetExternalExecutor() throws ConcurrentException {\n+  121:         final ExecutorService exec = Executors.newCachedThreadPool();\n+  122:         try {\n+  123:             final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n+  124:             init.setExternalExecutor(exec);\n+  125:             assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n+  126:             assertTrue(init.start(), \"Wrong result of start()\");\n+  127:             assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n+  128:             checkInitialize(init);\n+  129:             assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n+  130:         } finally {\n+  131:             exec.shutdown();\n+  132:         }\n+  133:     }\n+  287:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n+  288:         return new MethodBackgroundInitializerTestImpl();\n+  289:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_113_131_287_289_115_133",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Helper method for checking whether the initialize() method was correctly\n * called. start() must already have been invoked.\n *\n * @param init the initializer to test\n */\nprivate void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n    final Integer result = init.get();\n    assertEquals(1, result.intValue(), \"Wrong result\");\n    assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n    assertNotNull(init.getFuture(), \"No future\");\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl() : AbstractBackgroundInitializerTestImpl extracted from public testInitializeTempExecutor() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 101,
                "endLine": 111,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 103,
                "endLine": 113,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 287,
                "endLine": 289,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testInitializeTempExecutor",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkInitialize\n methodBody: private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\nfinal int count=5;\nfor(int i=0; i < count; i++){initializer.addInitializer(CHILD_INIT + i,new ChildBackgroundInitializer());\n}initializer.start();\nfinal MultiBackgroundInitializer.MultiBackgroundInitializerResults res=initializer.get();\nassertEquals(count,res.initializerNames().size(),\"Wrong number of child initializers\");\nfor(int i=0; i < count; i++){final String key=CHILD_INIT + i;\nassertTrue(res.initializerNames().contains(key),\"Name not found: \" + key);\nassertEquals(Integer.valueOf(1),res.getResultObject(key),\"Wrong result object\");\nassertFalse(res.isException(key),\"Exception flag\");\nassertNull(res.getException(key),\"Got an exception\");\ncheckChild(res.getInitializer(key),initializer.getActiveExecutor());\n}return res;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#getActiveExecutor\n methodBody: protected final synchronized ExecutorService getActiveExecutor() {\nreturn executor;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest#checkInitialize\n methodBody: private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\nfinal Integer result=init.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,init.initializeCalls,\"Wrong number of invocations\");\nassertNotNull(init.getFuture(),\"No future\");\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testInitializeTempExecutor"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkInitialize\n methodBody: private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\nfinal int count=5;\nfor(int i=0; i < count; i++){initializer.addInitializer(CHILD_INIT + i,new ChildBackgroundInitializer());\n}initializer.start();\nfinal MultiBackgroundInitializer.MultiBackgroundInitializerResults res=initializer.get();\nassertEquals(count,res.initializerNames().size(),\"Wrong number of child initializers\");\nfor(int i=0; i < count; i++){final String key=CHILD_INIT + i;\nassertTrue(res.initializerNames().contains(key),\"Name not found: \" + key);\nassertEquals(Integer.valueOf(1),res.getResultObject(key),\"Wrong result object\");\nassertFalse(res.isException(key),\"Exception flag\");\nassertNull(res.getException(key),\"Got an exception\");\ncheckChild(res.getInitializer(key),initializer.getActiveExecutor());\n}return res;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#getActiveExecutor\n methodBody: protected final synchronized ExecutorService getActiveExecutor() {\nreturn executor;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest#checkInitialize\n methodBody: private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\nfinal Integer result=init.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,init.initializeCalls,\"Wrong number of invocations\");\nassertNotNull(init.getFuture(),\"No future\");\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }",
        "diffSourceCode": "-  101:     /**\n-  102:      * Tests the execution of the background task if a temporary executor has to\n-  103:      * be created.\n-  104:      */\n-  105:     @Test\n-  106:     public void testInitializeTempExecutor() throws ConcurrentException {\n-  107:         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-  108:         assertTrue(init.start(), \"Wrong result of start()\");\n-  109:         checkInitialize(init);\n-  110:         assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n-  111:     }\n-  112: \n-  113:     /**\n-  287:      * some methods that simplify testing.\n-  288:      */\n-  289:     private static final class BackgroundInitializerTestImpl extends\n+  101:     }\n+  102: \n+  103:     /**\n+  104:      * Tests the execution of the background task if a temporary executor has to\n+  105:      * be created.\n+  106:      */\n+  107:     @Test\n+  108:     public void testInitializeTempExecutor() throws ConcurrentException {\n+  109:         final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n+  110:         assertTrue(init.start(), \"Wrong result of start()\");\n+  111:         checkInitialize(init);\n+  112:         assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n+  113:     }\n+  287:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n+  288:         return new MethodBackgroundInitializerTestImpl();\n+  289:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_101_111_287_289_103_113",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Helper method for checking whether the initialize() method was correctly\n * called. start() must already have been invoked.\n *\n * @param init the initializer to test\n */\nprivate void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n    final Integer result = init.get();\n    assertEquals(1, result.intValue(), \"Wrong result\");\n    assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n    assertNotNull(init.getFuture(), \"No future\");\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl() : AbstractBackgroundInitializerTestImpl extracted from public testGetActiveExecutorTemp() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 90,
                "endLine": 99,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 92,
                "endLine": 101,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 287,
                "endLine": 289,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testGetActiveExecutorTemp",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkInitialize\n methodBody: private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\nfinal int count=5;\nfor(int i=0; i < count; i++){initializer.addInitializer(CHILD_INIT + i,new ChildBackgroundInitializer());\n}initializer.start();\nfinal MultiBackgroundInitializer.MultiBackgroundInitializerResults res=initializer.get();\nassertEquals(count,res.initializerNames().size(),\"Wrong number of child initializers\");\nfor(int i=0; i < count; i++){final String key=CHILD_INIT + i;\nassertTrue(res.initializerNames().contains(key),\"Name not found: \" + key);\nassertEquals(Integer.valueOf(1),res.getResultObject(key),\"Wrong result object\");\nassertFalse(res.isException(key),\"Exception flag\");\nassertNull(res.getException(key),\"Got an exception\");\ncheckChild(res.getInitializer(key),initializer.getActiveExecutor());\n}return res;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#getActiveExecutor\n methodBody: protected final synchronized ExecutorService getActiveExecutor() {\nreturn executor;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest#checkInitialize\n methodBody: private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\nfinal Integer result=init.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,init.initializeCalls,\"Wrong number of invocations\");\nassertNotNull(init.getFuture(),\"No future\");\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testGetActiveExecutorTemp"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkInitialize\n methodBody: private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\nfinal int count=5;\nfor(int i=0; i < count; i++){initializer.addInitializer(CHILD_INIT + i,new ChildBackgroundInitializer());\n}initializer.start();\nfinal MultiBackgroundInitializer.MultiBackgroundInitializerResults res=initializer.get();\nassertEquals(count,res.initializerNames().size(),\"Wrong number of child initializers\");\nfor(int i=0; i < count; i++){final String key=CHILD_INIT + i;\nassertTrue(res.initializerNames().contains(key),\"Name not found: \" + key);\nassertEquals(Integer.valueOf(1),res.getResultObject(key),\"Wrong result object\");\nassertFalse(res.isException(key),\"Exception flag\");\nassertNull(res.getException(key),\"Got an exception\");\ncheckChild(res.getInitializer(key),initializer.getActiveExecutor());\n}return res;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#getActiveExecutor\n methodBody: protected final synchronized ExecutorService getActiveExecutor() {\nreturn executor;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest#checkInitialize\n methodBody: private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\nfinal Integer result=init.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,init.initializeCalls,\"Wrong number of invocations\");\nassertNotNull(init.getFuture(),\"No future\");\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }",
        "diffSourceCode": "-   90:     /**\n-   91:      * Tests getActiveExecutor() for a temporary executor.\n-   92:      */\n-   93:     @Test\n-   94:     public void testGetActiveExecutorTemp() throws ConcurrentException {\n-   95:         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-   96:         init.start();\n-   97:         assertNotNull(init.getActiveExecutor(), \"No active executor\");\n-   98:         checkInitialize(init);\n-   99:     }\n-  100: \n-  101:     /**\n-  287:      * some methods that simplify testing.\n-  288:      */\n-  289:     private static final class BackgroundInitializerTestImpl extends\n+   90:     }\n+   91: \n+   92:     /**\n+   93:      * Tests getActiveExecutor() for a temporary executor.\n+   94:      */\n+   95:     @Test\n+   96:     public void testGetActiveExecutorTemp() throws ConcurrentException {\n+   97:         final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n+   98:         init.start();\n+   99:         assertNotNull(init.getActiveExecutor(), \"No active executor\");\n+  100:         checkInitialize(init);\n+  101:     }\n+  287:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n+  288:         return new MethodBackgroundInitializerTestImpl();\n+  289:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_90_99_287_289_92_101",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n/**\n * Helper method for testing the initialization process.\n *\n * @param init the initializer to test\n */\nprivate void testInitializationProcess(BackgroundInitializerTestImpl init) throws ConcurrentException {\n    init.start();\n    assertNotNull(init.getActiveExecutor(), \"No active executor\");\n    checkInitialize(init);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl(exec ExecutorService) : AbstractBackgroundInitializerTestImpl extracted from public testGetActiveExecutorExternal() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 72,
                "endLine": 88,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 74,
                "endLine": 90,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 291,
                "endLine": 293,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testGetActiveExecutorExternal",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkInitialize\n methodBody: private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\nfinal int count=5;\nfor(int i=0; i < count; i++){initializer.addInitializer(CHILD_INIT + i,new ChildBackgroundInitializer());\n}initializer.start();\nfinal MultiBackgroundInitializer.MultiBackgroundInitializerResults res=initializer.get();\nassertEquals(count,res.initializerNames().size(),\"Wrong number of child initializers\");\nfor(int i=0; i < count; i++){final String key=CHILD_INIT + i;\nassertTrue(res.initializerNames().contains(key),\"Name not found: \" + key);\nassertEquals(Integer.valueOf(1),res.getResultObject(key),\"Wrong result object\");\nassertFalse(res.isException(key),\"Exception flag\");\nassertNull(res.getException(key),\"Got an exception\");\ncheckChild(res.getInitializer(key),initializer.getActiveExecutor());\n}return res;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#getActiveExecutor\n methodBody: protected final synchronized ExecutorService getActiveExecutor() {\nreturn executor;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest#checkInitialize\n methodBody: private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\nfinal Integer result=init.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,init.initializeCalls,\"Wrong number of invocations\");\nassertNotNull(init.getFuture(),\"No future\");\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testGetActiveExecutorExternal"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkInitialize\n methodBody: private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\nfinal int count=5;\nfor(int i=0; i < count; i++){initializer.addInitializer(CHILD_INIT + i,new ChildBackgroundInitializer());\n}initializer.start();\nfinal MultiBackgroundInitializer.MultiBackgroundInitializerResults res=initializer.get();\nassertEquals(count,res.initializerNames().size(),\"Wrong number of child initializers\");\nfor(int i=0; i < count; i++){final String key=CHILD_INIT + i;\nassertTrue(res.initializerNames().contains(key),\"Name not found: \" + key);\nassertEquals(Integer.valueOf(1),res.getResultObject(key),\"Wrong result object\");\nassertFalse(res.isException(key),\"Exception flag\");\nassertNull(res.getException(key),\"Got an exception\");\ncheckChild(res.getInitializer(key),initializer.getActiveExecutor());\n}return res;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#getActiveExecutor\n methodBody: protected final synchronized ExecutorService getActiveExecutor() {\nreturn executor;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest#checkInitialize\n methodBody: private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\nfinal Integer result=init.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,init.initializeCalls,\"Wrong number of invocations\");\nassertNotNull(init.getFuture(),\"No future\");\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }",
        "diffSourceCode": "-   72:     /**\n-   73:      * Tests whether an external executor is correctly detected.\n-   74:      */\n-   75:     @Test\n-   76:     public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n-   77:         final ExecutorService exec = Executors.newSingleThreadExecutor();\n-   78:         try {\n-   79:             final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n-   80:                     exec);\n-   81:             init.start();\n-   82:             assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n-   83:             checkInitialize(init);\n-   84:         } finally {\n-   85:             exec.shutdown();\n-   86:             exec.awaitTermination(1, TimeUnit.SECONDS);\n-   87:         }\n-   88:     }\n-   89: \n-   90:     /**\n-  291:         /** An exception to be thrown by initialize(). */\n-  292:         Exception ex;\n-  293: \n+   72:     }\n+   73: \n+   74:     /**\n+   75:      * Tests whether an external executor is correctly detected.\n+   76:      */\n+   77:     @Test\n+   78:     public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n+   79:         final ExecutorService exec = Executors.newSingleThreadExecutor();\n+   80:         try {\n+   81:             final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n+   82:                     exec);\n+   83:             init.start();\n+   84:             assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n+   85:             checkInitialize(init);\n+   86:         } finally {\n+   87:             exec.shutdown();\n+   88:             exec.awaitTermination(1, TimeUnit.SECONDS);\n+   89:         }\n+   90:     }\n+  291:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n+  292:         return new MethodBackgroundInitializerTestImpl(exec);\n+  293:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_72_88_291_293_74_90",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Helper method for checking whether the initialize() method was correctly\n * called. start() must already have been invoked.\n *\n * @param init the initializer to test\n */\nprivate void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n    final Integer result = init.get();\n    assertEquals(1, result.intValue(), \"Wrong result\");\n    assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n    assertNotNull(init.getFuture(), \"No future\");\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl() : AbstractBackgroundInitializerTestImpl extracted from public testGetActiveExecutorBeforeStart() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 62,
                "endLine": 70,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 64,
                "endLine": 72,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 287,
                "endLine": 289,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testGetActiveExecutorBeforeStart",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#getActiveExecutor\n methodBody: protected final synchronized ExecutorService getActiveExecutor() {\nreturn executor;\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testGetActiveExecutorBeforeStart"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#getActiveExecutor\n methodBody: protected final synchronized ExecutorService getActiveExecutor() {\nreturn executor;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }",
        "diffSourceCode": "-   62:     /**\n-   63:      * Tries to obtain the executor before start(). It should not have been\n-   64:      * initialized yet.\n-   65:      */\n-   66:     @Test\n-   67:     public void testGetActiveExecutorBeforeStart() {\n-   68:         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-   69:         assertNull(init.getActiveExecutor(), \"Got an executor\");\n-   70:     }\n-   71: \n-   72:     /**\n-  287:      * some methods that simplify testing.\n-  288:      */\n-  289:     private static final class BackgroundInitializerTestImpl extends\n+   62:     }\n+   63: \n+   64:     /**\n+   65:      * Tries to obtain the executor before start(). It should not have been\n+   66:      * initialized yet.\n+   67:      */\n+   68:     @Test\n+   69:     public void testGetActiveExecutorBeforeStart() {\n+   70:         final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n+   71:         assertNull(init.getActiveExecutor(), \"Got an executor\");\n+   72:     }\n+  287:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n+  288:         return new MethodBackgroundInitializerTestImpl();\n+  289:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_62_70_287_289_64_72",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Helper method for checking whether the initialize() method was correctly\n * called. start() must already have been invoked.\n *\n * @param init the initializer to test\n */\nprivate void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n    final Integer result = init.get();\n    assertEquals(1, result.intValue(), \"Wrong result\");\n    assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n    assertNotNull(init.getFuture(), \"No future\");\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl() : AbstractBackgroundInitializerTestImpl extracted from public testInitialize() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 52,
                "endLine": 60,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 54,
                "endLine": 62,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 287,
                "endLine": 289,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testInitialize",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkInitialize\n methodBody: private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\nfinal int count=5;\nfor(int i=0; i < count; i++){initializer.addInitializer(CHILD_INIT + i,new ChildBackgroundInitializer());\n}initializer.start();\nfinal MultiBackgroundInitializer.MultiBackgroundInitializerResults res=initializer.get();\nassertEquals(count,res.initializerNames().size(),\"Wrong number of child initializers\");\nfor(int i=0; i < count; i++){final String key=CHILD_INIT + i;\nassertTrue(res.initializerNames().contains(key),\"Name not found: \" + key);\nassertEquals(Integer.valueOf(1),res.getResultObject(key),\"Wrong result object\");\nassertFalse(res.isException(key),\"Exception flag\");\nassertNull(res.getException(key),\"Got an exception\");\ncheckChild(res.getInitializer(key),initializer.getActiveExecutor());\n}return res;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest#checkInitialize\n methodBody: private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\nfinal Integer result=init.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,init.initializeCalls,\"Wrong number of invocations\");\nassertNotNull(init.getFuture(),\"No future\");\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testInitialize"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkInitialize\n methodBody: private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\nfinal int count=5;\nfor(int i=0; i < count; i++){initializer.addInitializer(CHILD_INIT + i,new ChildBackgroundInitializer());\n}initializer.start();\nfinal MultiBackgroundInitializer.MultiBackgroundInitializerResults res=initializer.get();\nassertEquals(count,res.initializerNames().size(),\"Wrong number of child initializers\");\nfor(int i=0; i < count; i++){final String key=CHILD_INIT + i;\nassertTrue(res.initializerNames().contains(key),\"Name not found: \" + key);\nassertEquals(Integer.valueOf(1),res.getResultObject(key),\"Wrong result object\");\nassertFalse(res.isException(key),\"Exception flag\");\nassertNull(res.getException(key),\"Got an exception\");\ncheckChild(res.getInitializer(key),initializer.getActiveExecutor());\n}return res;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest#checkInitialize\n methodBody: private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\nfinal Integer result=init.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,init.initializeCalls,\"Wrong number of invocations\");\nassertNotNull(init.getFuture(),\"No future\");\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }",
        "diffSourceCode": "-   52:     /**\n-   53:      * Tests whether initialize() is invoked.\n-   54:      */\n-   55:     @Test\n-   56:     public void testInitialize() throws ConcurrentException {\n-   57:         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-   58:         init.start();\n-   59:         checkInitialize(init);\n-   60:     }\n-   61: \n-   62:     /**\n-  287:      * some methods that simplify testing.\n-  288:      */\n-  289:     private static final class BackgroundInitializerTestImpl extends\n+   52:     }\n+   53: \n+   54:     /**\n+   55:      * Tests whether initialize() is invoked.\n+   56:      */\n+   57:     @Test\n+   58:     public void testInitialize() throws ConcurrentException {\n+   59:         final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n+   60:         init.start();\n+   61:         checkInitialize(init);\n+   62:     }\n+  287:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n+  288:         return new MethodBackgroundInitializerTestImpl();\n+  289:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_52_60_287_289_54_62",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Helper method for checking whether the initialize() method was correctly\n * called. start() must already have been invoked.\n *\n * @param init the initializer to test\n */\nprivate void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n    final Integer result = init.get();\n    assertEquals(1, result.intValue(), \"Wrong result\");\n    assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n    assertNotNull(init.getFuture(), \"No future\");\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getNoInit() : T extracted from public get() : T in class org.apache.commons.lang3.concurrent.AtomicInitializer",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/concurrent/AtomicInitializer.java",
                "startLine": 72,
                "endLine": 94,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/concurrent/AtomicInitializer.java",
                "startLine": 72,
                "endLine": 94,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/concurrent/AtomicInitializer.java",
                "startLine": 96,
                "endLine": 100,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Returns the object managed by this initializer. The object is created if\n     * it is not available yet and stored internally. This method always returns\n     * the same object.\n     *\n     * @return the object created by this {@link AtomicInitializer}\n     * @throws ConcurrentException if an error occurred during initialization of\n     * the object\n     */\n    @Override\n    public T get() throws ConcurrentException {\n        T result = reference.get();\n\n        if (result == (T) NO_INIT) {\n            result = initialize();\n            if (!reference.compareAndSet((T) NO_INIT, result)) {\n                // another thread has initialized the reference\n                result = reference.get();\n            }\n        }\n\n        return result;\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/concurrent/AtomicInitializer.java",
        "isPureRefactoring": true,
        "commitId": "4d63091bdc21465423ef006c3b1aac552ebca902",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.AtomicInitializer",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.AtomicInitializer#get",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == (T)NO_INIT){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == (T)NO_INIT){result=initialize();\nif(!reference.compareAndSet((T)NO_INIT,result)){result=reference.get();\n}}return result;\n}",
        "classSignatureBefore": "public abstract class AtomicInitializer<T> extends AbstractConcurrentInitializer<T, RuntimeException> ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.AtomicInitializer#get"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.AtomicInitializer"
        ],
        "classSignatureBeforeSet": [
            "public abstract class AtomicInitializer<T> extends AbstractConcurrentInitializer<T, RuntimeException> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * A specialized implementation of the {@link ConcurrentInitializer} interface\n * based on an {@link AtomicReference} variable.\n *\n * <p>\n * This class maintains a member field of type {@link AtomicReference}. It\n * implements the following algorithm to create and initialize an object in its\n * {@link #get()} method:\n * </p>\n * <ul>\n * <li>First it is checked whether the {@link AtomicReference} variable contains\n * already a value. If this is the case, the value is directly returned.</li>\n * <li>Otherwise the {@link #initialize()} method is called. This method must be\n * defined in concrete subclasses to actually create the managed object.</li>\n * <li>After the object was created by {@link #initialize()} it is checked\n * whether the {@link AtomicReference} variable is still undefined. This has to\n * be done because in the meantime another thread may have initialized the\n * object. If the reference is still empty, the newly created object is stored\n * in it and returned by this method.</li>\n * <li>Otherwise the value stored in the {@link AtomicReference} is returned.</li>\n * </ul>\n * <p>\n * Because atomic variables are used this class does not need any\n * synchronization. So there is no danger of deadlock, and access to the managed\n * object is efficient. However, if multiple threads access the {@code\n * AtomicInitializer} object before it has been initialized almost at the same\n * time, it can happen that {@link #initialize()} is called multiple times. The\n * algorithm outlined above guarantees that {@link #get()} always returns the\n * same object though.\n * </p>\n * <p>\n * Compared with the {@link LazyInitializer} class, this class can be more\n * efficient because it does not need synchronization. The drawback is that the\n * {@link #initialize()} method can be called multiple times which may be\n * problematic if the creation of the managed object is expensive. As a rule of\n * thumb this initializer implementation is preferable if there are not too many\n * threads involved and the probability that multiple threads access an\n * uninitialized object is small. If there is high parallelism,\n * {@link LazyInitializer} is more appropriate.\n * </p>\n *\n * @since 3.0\n * @param <T> the type of the object managed by this initializer class\n */\npublic abstract class AtomicInitializer<T> extends AbstractConcurrentInitializer<T, RuntimeException> {\n\n    private static final Object NO_INIT = new Object();\n\n    /** Holds the reference to the managed object. */\n    private final AtomicReference<T> reference = new AtomicReference<>((T) NO_INIT);\n\n    /**\n     * Returns the object managed by this initializer. The object is created if\n     * it is not available yet and stored internally. This method always returns\n     * the same object.\n     *\n     * @return the object created by this {@link AtomicInitializer}\n     * @throws ConcurrentException if an error occurred during initialization of\n     * the object\n     */\n    @Override\n    public T get() throws ConcurrentException {\n        T result = reference.get();\n\n        if (result == (T) NO_INIT) {\n            result = initialize();\n            if (!reference.compareAndSet((T) NO_INIT, result)) {\n                // another thread has initialized the reference\n                result = reference.get();\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Tests whether this instance is initialized. Once initialized, always returns true.\n     *\n     * @return whether this instance is initialized. Once initialized, always returns true.\n     * @since 3.14.0\n     */\n    @Override\n    public boolean isInitialized() {\n        return reference.get() != NO_INIT;\n    }\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/concurrent/AtomicInitializer.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * A specialized implementation of the {@link ConcurrentInitializer} interface\n * based on an {@link AtomicReference} variable.\n *\n * <p>\n * This class maintains a member field of type {@link AtomicReference}. It\n * implements the following algorithm to create and initialize an object in its\n * {@link #get()} method:\n * </p>\n * <ul>\n * <li>First it is checked whether the {@link AtomicReference} variable contains\n * already a value. If this is the case, the value is directly returned.</li>\n * <li>Otherwise the {@link #initialize()} method is called. This method must be\n * defined in concrete subclasses to actually create the managed object.</li>\n * <li>After the object was created by {@link #initialize()} it is checked\n * whether the {@link AtomicReference} variable is still undefined. This has to\n * be done because in the meantime another thread may have initialized the\n * object. If the reference is still empty, the newly created object is stored\n * in it and returned by this method.</li>\n * <li>Otherwise the value stored in the {@link AtomicReference} is returned.</li>\n * </ul>\n * <p>\n * Because atomic variables are used this class does not need any\n * synchronization. So there is no danger of deadlock, and access to the managed\n * object is efficient. However, if multiple threads access the {@code\n * AtomicInitializer} object before it has been initialized almost at the same\n * time, it can happen that {@link #initialize()} is called multiple times. The\n * algorithm outlined above guarantees that {@link #get()} always returns the\n * same object though.\n * </p>\n * <p>\n * Compared with the {@link LazyInitializer} class, this class can be more\n * efficient because it does not need synchronization. The drawback is that the\n * {@link #initialize()} method can be called multiple times which may be\n * problematic if the creation of the managed object is expensive. As a rule of\n * thumb this initializer implementation is preferable if there are not too many\n * threads involved and the probability that multiple threads access an\n * uninitialized object is small. If there is high parallelism,\n * {@link LazyInitializer} is more appropriate.\n * </p>\n *\n * @since 3.0\n * @param <T> the type of the object managed by this initializer class\n */\npublic abstract class AtomicInitializer<T> extends AbstractConcurrentInitializer<T, RuntimeException> {\n\n    private static final Object NO_INIT = new Object();\n\n    /** Holds the reference to the managed object. */\n    private final AtomicReference<T> reference = new AtomicReference<>(getNoInit());\n\n    /**\n     * Returns the object managed by this initializer. The object is created if\n     * it is not available yet and stored internally. This method always returns\n     * the same object.\n     *\n     * @return the object created by this {@link AtomicInitializer}\n     * @throws ConcurrentException if an error occurred during initialization of\n     * the object\n     */\n    @Override\n    public T get() throws ConcurrentException {\n        T result = reference.get();\n\n        if (result == getNoInit()) {\n            result = initialize();\n            if (!reference.compareAndSet(getNoInit(), result)) {\n                // another thread has initialized the reference\n                result = reference.get();\n            }\n        }\n\n        return result;\n    }\n\n    /** Gets the internal no-init object cast for this instance. */\n    @SuppressWarnings(\"unchecked\")\n    private T getNoInit() {\n        return (T) NO_INIT;\n    }\n\n    /**\n     * Tests whether this instance is initialized. Once initialized, always returns true.\n     *\n     * @return whether this instance is initialized. Once initialized, always returns true.\n     * @since 3.14.0\n     */\n    @Override\n    public boolean isInitialized() {\n        return reference.get() != NO_INIT;\n    }\n}\n",
        "diffSourceCodeSet": [
            "/** Gets the internal no-init object cast for this instance. */\n    @SuppressWarnings(\"unchecked\")\n    private T getNoInit() {\n        return (T) NO_INIT;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == (T)NO_INIT){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == (T)NO_INIT){result=initialize();\nif(!reference.compareAndSet((T)NO_INIT,result)){result=reference.get();\n}}return result;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Returns the object managed by this initializer. The object is created if\n     * it is not available yet and stored internally. This method always returns\n     * the same object.\n     *\n     * @return the object created by this {@link AtomicInitializer}\n     * @throws ConcurrentException if an error occurred during initialization of\n     * the object\n     */\n    @Override\n    public T get() throws ConcurrentException {\n        T result = reference.get();\n\n        if (result == getNoInit()) {\n            result = initialize();\n            if (!reference.compareAndSet(getNoInit(), result)) {\n                // another thread has initialized the reference\n                result = reference.get();\n            }\n        }\n\n        return result;\n    }\n/** Gets the internal no-init object cast for this instance. */\n    @SuppressWarnings(\"unchecked\")\n    private T getNoInit() {\n        return (T) NO_INIT;\n    }",
        "diffSourceCode": "    72:     /**\n    73:      * Returns the object managed by this initializer. The object is created if\n    74:      * it is not available yet and stored internally. This method always returns\n    75:      * the same object.\n    76:      *\n    77:      * @return the object created by this {@link AtomicInitializer}\n    78:      * @throws ConcurrentException if an error occurred during initialization of\n    79:      * the object\n    80:      */\n    81:     @Override\n    82:     public T get() throws ConcurrentException {\n    83:         T result = reference.get();\n    84: \n-   85:         if (result == (T) NO_INIT) {\n+   85:         if (result == getNoInit()) {\n    86:             result = initialize();\n-   87:             if (!reference.compareAndSet((T) NO_INIT, result)) {\n+   87:             if (!reference.compareAndSet(getNoInit(), result)) {\n    88:                 // another thread has initialized the reference\n    89:                 result = reference.get();\n    90:             }\n    91:         }\n    92: \n    93:         return result;\n    94:     }\n-   96:     /**\n-   97:      * Tests whether this instance is initialized. Once initialized, always returns true.\n-   98:      *\n-   99:      * @return whether this instance is initialized. Once initialized, always returns true.\n-  100:      * @since 3.14.0\n+   96:     /** Gets the internal no-init object cast for this instance. */\n+   97:     @SuppressWarnings(\"unchecked\")\n+   98:     private T getNoInit() {\n+   99:         return (T) NO_INIT;\n+  100:     }\n",
        "uniqueId": "4d63091bdc21465423ef006c3b1aac552ebca902_72_94_96_100_72_94",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 4,
                "covered": 18
            },
            "BRANCH": {
                "missed": 1,
                "covered": 3
            },
            "LINE": {
                "missed": 1,
                "covered": 5
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Initializes the object managed by this initializer.\n *\n * @return the initialized object\n * @throws ConcurrentException if an error occurred during initialization\n */\nprivate T initialize() throws ConcurrentException {\n    // Add implementation code here\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Returns the object managed by this initializer. The object is created if\n     * it is not available yet and stored internally. This method always returns\n     * the same object.\n     *\n     * @return the object created by this {@link AtomicInitializer}\n     * @throws ConcurrentException if an error occurred during initialization of\n     * the object\n     */\n    @Override\n    public T get() throws ConcurrentException {\n        T result = reference.get();\n\n        if (result == (T) NO_INIT) {\n            result = initialize();\n            if (!reference.compareAndSet((T) NO_INIT, result)) {\n                // another thread has initialized the reference\n                result = reference.get();\n            }\n        }\n\n        return result;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * A specialized implementation of the {@link ConcurrentInitializer} interface\n * based on an {@link AtomicReference} variable.\n *\n * <p>\n * This class maintains a member field of type {@link AtomicReference}. It\n * implements the following algorithm to create and initialize an object in its\n * {@link #get()} method:\n * </p>\n * <ul>\n * <li>First it is checked whether the {@link AtomicReference} variable contains\n * already a value. If this is the case, the value is directly returned.</li>\n * <li>Otherwise the {@link #initialize()} method is called. This method must be\n * defined in concrete subclasses to actually create the managed object.</li>\n * <li>After the object was created by {@link #initialize()} it is checked\n * whether the {@link AtomicReference} variable is still undefined. This has to\n * be done because in the meantime another thread may have initialized the\n * object. If the reference is still empty, the newly created object is stored\n * in it and returned by this method.</li>\n * <li>Otherwise the value stored in the {@link AtomicReference} is returned.</li>\n * </ul>\n * <p>\n * Because atomic variables are used this class does not need any\n * synchronization. So there is no danger of deadlock, and access to the managed\n * object is efficient. However, if multiple threads access the {@code\n * AtomicInitializer} object before it has been initialized almost at the same\n * time, it can happen that {@link #initialize()} is called multiple times. The\n * algorithm outlined above guarantees that {@link #get()} always returns the\n * same object though.\n * </p>\n * <p>\n * Compared with the {@link LazyInitializer} class, this class can be more\n * efficient because it does not need synchronization. The drawback is that the\n * {@link #initialize()} method can be called multiple times which may be\n * problematic if the creation of the managed object is expensive. As a rule of\n * thumb this initializer implementation is preferable if there are not too many\n * threads involved and the probability that multiple threads access an\n * uninitialized object is small. If there is high parallelism,\n * {@link LazyInitializer} is more appropriate.\n * </p>\n *\n * @since 3.0\n * @param <T> the type of the object managed by this initializer class\n */\npublic abstract class AtomicInitializer<T> extends AbstractConcurrentInitializer<T, RuntimeException> {\n\n    private static final Object NO_INIT = new Object();\n\n    /** Holds the reference to the managed object. */\n    private final AtomicReference<T> reference = new AtomicReference<>((T) NO_INIT);\n\n    /**\n     * Returns the object managed by this initializer. The object is created if\n     * it is not available yet and stored internally. This method always returns\n     * the same object.\n     *\n     * @return the object created by this {@link AtomicInitializer}\n     * @throws ConcurrentException if an error occurred during initialization of\n     * the object\n     */\n    @Override\n    public T get() throws ConcurrentException {\n        T result = reference.get();\n\n        if (result == (T) NO_INIT) {\n            result = initialize();\n            if (!reference.compareAndSet((T) NO_INIT, result)) {\n                // another thread has initialized the reference\n                result = reference.get();\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Tests whether this instance is initialized. Once initialized, always returns true.\n     *\n     * @return whether this instance is initialized. Once initialized, always returns true.\n     * @since 3.14.0\n     */\n    @Override\n    public boolean isInitialized() {\n        return reference.get() != NO_INIT;\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate testTimeZoneStrategyPattern(locale Locale, tzDefault TimeZone) : void extracted from package testTimeZoneStrategyPattern(locale Locale) : void in class org.apache.commons.lang3.time.FastDateParser_TimeZoneStrategyTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/time/FastDateParser_TimeZoneStrategyTest.java",
                "startLine": 44,
                "endLine": 66,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/time/FastDateParser_TimeZoneStrategyTest.java",
                "startLine": 45,
                "endLine": 49,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/time/FastDateParser_TimeZoneStrategyTest.java",
                "startLine": 51,
                "endLine": 70,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@ParameterizedTest\n    @MethodSource(\"java.util.Locale#getAvailableLocales\")\n    void testTimeZoneStrategyPattern(final Locale locale) {\n        final TimeZone tzDefault = TimeZone.getDefault();\n        final FastDateParser parser = new FastDateParser(\"z\", tzDefault, locale);\n        final String[][] zones = DateFormatSymbols.getInstance(locale).getZoneStrings();\n        for (final String[] zone : zones) {\n            for (int zIndex = 1; zIndex < zone.length; ++zIndex) {\n                final String tzDisplay = zone[zIndex];\n                if (tzDisplay == null) {\n                    break;\n                }\n                // An exception will be thrown and the test will fail if parsing isn't successful\n                try {\n                    parser.parse(tzDisplay);\n                } catch (ParseException e) {\n                    fail(String.format(\n                            \"%s: with tzDefault = %s, locale = %s, zones[][] size = '%s', zone[] size = '%s', zIndex = %,d, tzDisplay = '%s', parser = '%s'\", e,\n                            tzDefault, locale, zones.length, zone.length, zIndex, tzDisplay, parser.toStringAll()), e);\n                }\n            }\n        }\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/time/FastDateParser_TimeZoneStrategyTest.java",
        "isPureRefactoring": true,
        "commitId": "61ed7801188bb19acf5d755eb2e4b74fd9a0b1b0",
        "packageNameBefore": "org.apache.commons.lang3.time",
        "classNameBefore": "org.apache.commons.lang3.time.FastDateParser_TimeZoneStrategyTest",
        "methodNameBefore": "org.apache.commons.lang3.time.FastDateParser_TimeZoneStrategyTest#testTimeZoneStrategyPattern",
        "classSignatureBefore": "public class FastDateParser_TimeZoneStrategyTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.time.FastDateParser_TimeZoneStrategyTest#testTimeZoneStrategyPattern"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.time.FastDateParser_TimeZoneStrategyTest"
        ],
        "classSignatureBeforeSet": [
            "public class FastDateParser_TimeZoneStrategyTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.time;\n\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.text.DateFormatSymbols;\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FastDateParser_TimeZoneStrategyTest extends AbstractLangTest {\n\n    @Test\n    void testLang1219() throws ParseException {\n        final FastDateParser parser = new FastDateParser(\"dd.MM.yyyy HH:mm:ss z\", TimeZone.getDefault(), Locale.GERMAN);\n\n        final Date summer = parser.parse(\"26.10.2014 02:00:00 MESZ\");\n        final Date standard = parser.parse(\"26.10.2014 02:00:00 MEZ\");\n        assertNotEquals(summer.getTime(), standard.getTime());\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"java.util.Locale#getAvailableLocales\")\n    void testTimeZoneStrategyPattern(final Locale locale) {\n        final TimeZone tzDefault = TimeZone.getDefault();\n        final FastDateParser parser = new FastDateParser(\"z\", tzDefault, locale);\n        final String[][] zones = DateFormatSymbols.getInstance(locale).getZoneStrings();\n        for (final String[] zone : zones) {\n            for (int zIndex = 1; zIndex < zone.length; ++zIndex) {\n                final String tzDisplay = zone[zIndex];\n                if (tzDisplay == null) {\n                    break;\n                }\n                // An exception will be thrown and the test will fail if parsing isn't successful\n                try {\n                    parser.parse(tzDisplay);\n                } catch (ParseException e) {\n                    fail(String.format(\n                            \"%s: with tzDefault = %s, locale = %s, zones[][] size = '%s', zone[] size = '%s', zIndex = %,d, tzDisplay = '%s', parser = '%s'\", e,\n                            tzDefault, locale, zones.length, zone.length, zIndex, tzDisplay, parser.toStringAll()), e);\n                }\n            }\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/time/FastDateParser_TimeZoneStrategyTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.time;\n\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.text.DateFormatSymbols;\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FastDateParser_TimeZoneStrategyTest extends AbstractLangTest {\n\n    @Test\n    public void testLang1219() throws ParseException {\n        final FastDateParser parser = new FastDateParser(\"dd.MM.yyyy HH:mm:ss z\", TimeZone.getDefault(), Locale.GERMAN);\n\n        final Date summer = parser.parse(\"26.10.2014 02:00:00 MESZ\");\n        final Date standard = parser.parse(\"26.10.2014 02:00:00 MEZ\");\n        assertNotEquals(summer.getTime(), standard.getTime());\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"java.util.Locale#getAvailableLocales\")\n    public void testTimeZoneStrategyPattern(final Locale locale) {\n        testTimeZoneStrategyPattern(Objects.requireNonNull(locale, \"locale\"), TimeZone.getDefault());\n    }\n\n    private void testTimeZoneStrategyPattern(final Locale locale, final TimeZone tzDefault) {\n        final FastDateParser parser = new FastDateParser(\"z\", tzDefault, locale);\n        final String[][] zones = DateFormatSymbols.getInstance(locale).getZoneStrings();\n        for (final String[] zone : zones) {\n            for (int zIndex = 1; zIndex < zone.length; ++zIndex) {\n                final String tzDisplay = zone[zIndex];\n                if (tzDisplay == null) {\n                    break;\n                }\n                // An exception will be thrown and the test will fail if parsing isn't successful\n                try {\n                    parser.parse(tzDisplay);\n                } catch (ParseException e) {\n                    fail(String.format(\n                            \"%s: with tzDefault = %s, locale = %s, zones[][] size = '%s', zone[] size = '%s', zIndex = %,d, tzDisplay = '%s', parser = '%s'\", e,\n                            tzDefault, locale, zones.length, zone.length, zIndex, tzDisplay, parser.toStringAll()), e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Breaks randomly on GitHub.\n     */\n    @Test\n    public void testTimeZoneStrategyPatternPortugal() {\n        testTimeZoneStrategyPattern(Locale.forLanguageTag(\"pt_PT\"), TimeZone.getDefault());\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void testTimeZoneStrategyPattern(final Locale locale, final TimeZone tzDefault) {\n        final FastDateParser parser = new FastDateParser(\"z\", tzDefault, locale);\n        final String[][] zones = DateFormatSymbols.getInstance(locale).getZoneStrings();\n        for (final String[] zone : zones) {\n            for (int zIndex = 1; zIndex < zone.length; ++zIndex) {\n                final String tzDisplay = zone[zIndex];\n                if (tzDisplay == null) {\n                    break;\n                }\n                // An exception will be thrown and the test will fail if parsing isn't successful\n                try {\n                    parser.parse(tzDisplay);\n                } catch (ParseException e) {\n                    fail(String.format(\n                            \"%s: with tzDefault = %s, locale = %s, zones[][] size = '%s', zone[] size = '%s', zIndex = %,d, tzDisplay = '%s', parser = '%s'\", e,\n                            tzDefault, locale, zones.length, zone.length, zIndex, tzDisplay, parser.toStringAll()), e);\n                }\n            }\n        }\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@ParameterizedTest\n    @MethodSource(\"java.util.Locale#getAvailableLocales\")\n    public void testTimeZoneStrategyPattern(final Locale locale) {\n        testTimeZoneStrategyPattern(Objects.requireNonNull(locale, \"locale\"), TimeZone.getDefault());\n    }\nprivate void testTimeZoneStrategyPattern(final Locale locale, final TimeZone tzDefault) {\n        final FastDateParser parser = new FastDateParser(\"z\", tzDefault, locale);\n        final String[][] zones = DateFormatSymbols.getInstance(locale).getZoneStrings();\n        for (final String[] zone : zones) {\n            for (int zIndex = 1; zIndex < zone.length; ++zIndex) {\n                final String tzDisplay = zone[zIndex];\n                if (tzDisplay == null) {\n                    break;\n                }\n                // An exception will be thrown and the test will fail if parsing isn't successful\n                try {\n                    parser.parse(tzDisplay);\n                } catch (ParseException e) {\n                    fail(String.format(\n                            \"%s: with tzDefault = %s, locale = %s, zones[][] size = '%s', zone[] size = '%s', zIndex = %,d, tzDisplay = '%s', parser = '%s'\", e,\n                            tzDefault, locale, zones.length, zone.length, zIndex, tzDisplay, parser.toStringAll()), e);\n                }\n            }\n        }\n    }",
        "diffSourceCode": "-   44:     @ParameterizedTest\n-   45:     @MethodSource(\"java.util.Locale#getAvailableLocales\")\n-   46:     void testTimeZoneStrategyPattern(final Locale locale) {\n-   47:         final TimeZone tzDefault = TimeZone.getDefault();\n-   48:         final FastDateParser parser = new FastDateParser(\"z\", tzDefault, locale);\n-   49:         final String[][] zones = DateFormatSymbols.getInstance(locale).getZoneStrings();\n-   50:         for (final String[] zone : zones) {\n-   51:             for (int zIndex = 1; zIndex < zone.length; ++zIndex) {\n-   52:                 final String tzDisplay = zone[zIndex];\n-   53:                 if (tzDisplay == null) {\n-   54:                     break;\n-   55:                 }\n-   56:                 // An exception will be thrown and the test will fail if parsing isn't successful\n-   57:                 try {\n-   58:                     parser.parse(tzDisplay);\n-   59:                 } catch (ParseException e) {\n-   60:                     fail(String.format(\n-   61:                             \"%s: with tzDefault = %s, locale = %s, zones[][] size = '%s', zone[] size = '%s', zIndex = %,d, tzDisplay = '%s', parser = '%s'\", e,\n-   62:                             tzDefault, locale, zones.length, zone.length, zIndex, tzDisplay, parser.toStringAll()), e);\n-   63:                 }\n-   64:             }\n-   65:         }\n-   66:     }\n-   67: }\n+   44: \n+   45:     @ParameterizedTest\n+   46:     @MethodSource(\"java.util.Locale#getAvailableLocales\")\n+   47:     public void testTimeZoneStrategyPattern(final Locale locale) {\n+   48:         testTimeZoneStrategyPattern(Objects.requireNonNull(locale, \"locale\"), TimeZone.getDefault());\n+   49:     }\n+   50: \n+   51:     private void testTimeZoneStrategyPattern(final Locale locale, final TimeZone tzDefault) {\n+   52:         final FastDateParser parser = new FastDateParser(\"z\", tzDefault, locale);\n+   53:         final String[][] zones = DateFormatSymbols.getInstance(locale).getZoneStrings();\n+   54:         for (final String[] zone : zones) {\n+   55:             for (int zIndex = 1; zIndex < zone.length; ++zIndex) {\n+   56:                 final String tzDisplay = zone[zIndex];\n+   57:                 if (tzDisplay == null) {\n+   58:                     break;\n+   59:                 }\n+   60:                 // An exception will be thrown and the test will fail if parsing isn't successful\n+   61:                 try {\n+   62:                     parser.parse(tzDisplay);\n+   63:                 } catch (ParseException e) {\n+   64:                     fail(String.format(\n+   65:                             \"%s: with tzDefault = %s, locale = %s, zones[][] size = '%s', zone[] size = '%s', zIndex = %,d, tzDisplay = '%s', parser = '%s'\", e,\n+   66:                             tzDefault, locale, zones.length, zone.length, zIndex, tzDisplay, parser.toStringAll()), e);\n+   67:                 }\n+   68:             }\n+   69:         }\n+   70:     }\n",
        "uniqueId": "61ed7801188bb19acf5d755eb2e4b74fd9a0b1b0_44_66_51_70_45_49",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate void parseTimeZoneDisplay(final FastDateParser parser, final String[] zone, final Locale locale, final TimeZone tzDefault) {\n    for (int zIndex = 1; zIndex < zone.length; ++zIndex) {\n        final String tzDisplay = zone[zIndex];\n        if (tzDisplay == null) {\n            break;\n        }\n        // An exception will be thrown and the test will fail if parsing isn't successful\n        try {\n            parser.parse(tzDisplay);\n        } catch (ParseException e) {\n            fail(String.format(\n                    \"%s: with tzDefault = %s, locale = %s, zones[][] size = '%s', zone[] size = '%s', zIndex = %,d, tzDisplay = '%s', parser = '%s'\", e,\n                    tzDefault, locale, zones.length, zone.length, zIndex, tzDisplay, parser.toStringAll()), e);\n        }\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@ParameterizedTest\n    @MethodSource(\"java.util.Locale#getAvailableLocales\")\n    void testTimeZoneStrategyPattern(final Locale locale) {\n        final TimeZone tzDefault = TimeZone.getDefault();\n        final FastDateParser parser = new FastDateParser(\"z\", tzDefault, locale);\n        final String[][] zones = DateFormatSymbols.getInstance(locale).getZoneStrings();\n        for (final String[] zone : zones) {\n            for (int zIndex = 1; zIndex < zone.length; ++zIndex) {\n                final String tzDisplay = zone[zIndex];\n                if (tzDisplay == null) {\n                    break;\n                }\n                // An exception will be thrown and the test will fail if parsing isn't successful\n                try {\n                    parser.parse(tzDisplay);\n                } catch (ParseException e) {\n                    fail(String.format(\n                            \"%s: with tzDefault = %s, locale = %s, zones[][] size = '%s', zone[] size = '%s', zIndex = %,d, tzDisplay = '%s', parser = '%s'\", e,\n                            tzDefault, locale, zones.length, zone.length, zIndex, tzDisplay, parser.toStringAll()), e);\n                }\n            }\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.time;\n\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.text.DateFormatSymbols;\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FastDateParser_TimeZoneStrategyTest extends AbstractLangTest {\n\n    @Test\n    void testLang1219() throws ParseException {\n        final FastDateParser parser = new FastDateParser(\"dd.MM.yyyy HH:mm:ss z\", TimeZone.getDefault(), Locale.GERMAN);\n\n        final Date summer = parser.parse(\"26.10.2014 02:00:00 MESZ\");\n        final Date standard = parser.parse(\"26.10.2014 02:00:00 MEZ\");\n        assertNotEquals(summer.getTime(), standard.getTime());\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"java.util.Locale#getAvailableLocales\")\n    void testTimeZoneStrategyPattern(final Locale locale) {\n        final TimeZone tzDefault = TimeZone.getDefault();\n        final FastDateParser parser = new FastDateParser(\"z\", tzDefault, locale);\n        final String[][] zones = DateFormatSymbols.getInstance(locale).getZoneStrings();\n        for (final String[] zone : zones) {\n            for (int zIndex = 1; zIndex < zone.length; ++zIndex) {\n                final String tzDisplay = zone[zIndex];\n                if (tzDisplay == null) {\n                    break;\n                }\n                // An exception will be thrown and the test will fail if parsing isn't successful\n                try {\n                    parser.parse(tzDisplay);\n                } catch (ParseException e) {\n                    fail(String.format(\n                            \"%s: with tzDefault = %s, locale = %s, zones[][] size = '%s', zone[] size = '%s', zIndex = %,d, tzDisplay = '%s', parser = '%s'\", e,\n                            tzDefault, locale, zones.length, zone.length, zIndex, tzDisplay, parser.toStringAll()), e);\n                }\n            }\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic next(count int, chars char...) : String extracted from public random(count int, chars char...) : String in class org.apache.commons.lang3.RandomStringUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 110,
                "endLine": 127,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 132,
                "endLine": 146,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 631,
                "endLine": 649,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomStringUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomStringUtils#random",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}",
        "classSignatureBefore": "public class RandomStringUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils#random"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomStringUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\n * \"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\">\n * RandomStringGenerator</a> instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>\n * dedicated to pseudo-random number generation, that may be a better choice for applications with more stringent\n * requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the\n * values 56192 (db80) and 56319 (dbff) as we don't know how to handle them. High and low surrogates are correctly dealt\n * with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) then it is followed by a low\n * surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @see RandomUtils\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final Supplier<RandomUtils> SECURE_SUPPLIER = RandomUtils::secure;\n\n    private static RandomStringUtils INSECURE = new RandomStringUtils(RandomUtils::insecure);\n\n    private static RandomStringUtils SECURE = new RandomStringUtils(SECURE_SUPPLIER);\n\n    private static final char[] ALPHANUMERICAL_CHARS = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n            'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\n            'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1',\n            '2', '3', '4', '5', '6', '7', '8', '9' };\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return secure().next(count);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return secure().next(count, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers) {\n        return secure().next(count, start, end, letters, numbers);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers, final char... chars) {\n        return secure().next(count, start, end, letters, numbers, chars);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using supplied source of randomness.\n     *\n     * <p>\n     * If start and end are both {@code 0}, start and end are set to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both {@code false}, in which case, start and end are set\n     * to {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>\n     * If set is not {@code null}, characters between start and end are chosen.\n     * </p>\n     *\n     * <p>\n     * This method accepts a user-supplied {@link Random} instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call, the same random sequence of strings can be\n     * generated repeatedly and predictably.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at (inclusive)\n     * @param end     the position in set of chars to end before (exclusive)\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from, must not be empty. If {@code null}, then it will use the\n     *                set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n            final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \"\n                            + \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint) || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return secure().nextAlphabetic(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphabetic(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return secure().nextAlphanumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphanumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return secure().nextAscii(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAscii(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return secure().nextGraph(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextGraph(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return secure().nextNumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextNumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return secure().nextPrint(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextPrint(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils secure() {\n        return SECURE;\n    }\n\n    private final Supplier<RandomUtils> random;\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in standard programming. Instead, the class should\n     * be used as {@code RandomStringUtils.random(5);}.\n     *\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomStringUtils(final Supplier<RandomUtils> random) {\n        this.random = random;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers,\n            final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     * @since 3.16.0\n     */\n    public String next(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public String nextGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     * @since 3.16.0\n     */\n    public String nextPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.16.0\n     */\n    public String nextPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Gets the Random.\n     *\n     * @return the Random.\n     */\n    private Random random() {\n        return randomUtils().random();\n    }\n\n    /**\n     * Gets the RandomUtils.\n     *\n     * @return the RandomUtils.\n     */\n    private RandomUtils randomUtils() {\n        return random.get();\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomStringUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        return secure().next(count, chars);\n    }\n/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }",
        "diffSourceCode": "-  110:     /**\n-  111:      * Creates a random string whose length is the number of characters\n-  112:      * specified.\n-  113:      *\n-  114:      * <p>Characters will be chosen from the set of characters specified.</p>\n-  115:      *\n-  116:      * @param count  the length of random string to create\n-  117:      * @param chars  the character array containing the set of characters to use,\n-  118:      *  may be null\n-  119:      * @return the random string\n-  120:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n-  121:      */\n-  122:     public static String random(final int count, final char... chars) {\n-  123:         if (chars == null) {\n-  124:             return random(count, 0, 0, false, false, null, random());\n-  125:         }\n-  126:         return random(count, 0, chars.length, false, false, chars, random());\n-  127:     }\n-  132:      *\n-  133:      * <p>Characters will be chosen from the set of alpha-numeric\n-  134:      * characters as indicated by the arguments.</p>\n-  135:      *\n-  136:      * @param count  the length of random string to create\n-  137:      * @param start  the position in set of chars to start at\n-  138:      * @param end  the position in set of chars to end before\n-  139:      * @param letters  if {@code true}, generated string may include\n-  140:      *  alphabetic characters\n-  141:      * @param numbers  if {@code true}, generated string may include\n-  142:      *  numeric characters\n-  143:      * @return the random string\n-  144:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n-  145:      */\n-  146:     public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n+  110:      */\n+  111:     public static String random(final int count) {\n+  112:         return secure().next(count);\n+  113:     }\n+  114: \n+  115:     /**\n+  116:      * Creates a random string whose length is the number of characters specified.\n+  117:      *\n+  118:      * <p>\n+  119:      * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n+  120:      * </p>\n+  121:      *\n+  122:      * @param count   the length of random string to create\n+  123:      * @param letters if {@code true}, generated string may include alphabetic characters\n+  124:      * @param numbers if {@code true}, generated string may include numeric characters\n+  125:      * @return the random string\n+  126:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  127:      */\n+  132:     /**\n+  133:      * Creates a random string whose length is the number of characters specified.\n+  134:      *\n+  135:      * <p>\n+  136:      * Characters will be chosen from the set of characters specified.\n+  137:      * </p>\n+  138:      *\n+  139:      * @param count the length of random string to create\n+  140:      * @param chars the character array containing the set of characters to use, may be null\n+  141:      * @return the random string\n+  142:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  143:      */\n+  144:     public static String random(final int count, final char... chars) {\n+  145:         return secure().next(count, chars);\n+  146:     }\n+  631:     /**\n+  632:      * Creates a random string whose length is the number of characters specified.\n+  633:      *\n+  634:      * <p>\n+  635:      * Characters will be chosen from the set of characters specified.\n+  636:      * </p>\n+  637:      *\n+  638:      * @param count the length of random string to create\n+  639:      * @param chars the character array containing the set of characters to use, may be null\n+  640:      * @return the random string\n+  641:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  642:      * @since 3.16.0\n+  643:      */\n+  644:     public String next(final int count, final char... chars) {\n+  645:         if (chars == null) {\n+  646:             return random(count, 0, 0, false, false, null, random());\n+  647:         }\n+  648:         return random(count, 0, chars.length, false, false, chars, random());\n+  649:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_110_127_631_649_132_146",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 16
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Generates a random string using the specified parameters and source of randomness.\n *\n * @param count    the length of the random string to create\n * @param start    the position in the set of characters to start at\n * @param end      the position in the set of characters to end before\n * @param letters  if true, generated string may include alphabetic characters\n * @param numbers  if true, generated string may include numeric characters\n * @param chars    the set of characters to choose randoms from, null to use all characters\n * @param random   the source of randomness\n * @return the random string\n * @throws IllegalArgumentException if count is less than 0 or the provided chars array is empty\n */\npublic static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n    if (count == 0) {\n        return StringUtils.EMPTY;\n    }\n    if (count < 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars != null && chars.length == 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n\n    if (start == 0 && end == 0) {\n        if (chars != null) {\n            end = chars.length;\n        } else if (!letters && !numbers) {\n            end = Character.MAX_CODE_POINT;\n        } else {\n            end = 'z' + 1;\n            start = ' ';\n        }\n    } else if (end <= start) {\n        throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n    } else if (start < 0 || end < 0) {\n        throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n    }\n\n    if (end > Character.MAX_CODE_POINT) {\n        end = Character.MAX_CODE_POINT;\n    }\n\n    StringBuilder builder = new StringBuilder(count);\n    int gap = end - start;\n    int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n    CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n    while (count-- != 0) {\n        int randomValue = arb.nextBits(gapBits) + start;\n        if (randomValue >= end) {\n            count++;\n            continue;\n        }\n\n        int codePoint;\n        if (chars == null) {\n            codePoint = randomValue;\n\n            switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n            }\n\n        } else {\n            codePoint = chars[randomValue];\n        }\n\n        int numberOfChars = Character.charCount(codePoint);\n        if (count == 0 && numberOfChars > 1) {\n            count++;\n            continue;\n        }\n\n        if ((letters && Character.isLetter(codePoint)) || (numbers && Character.isDigit(codePoint)) || (!letters && !numbers)) {\n            builder.appendCodePoint(codePoint);\n\n            if (numberOfChars == 2) {\n                count--;\n            }\n\n        } else {\n            count++;\n        }\n    }\n    return builder.toString();\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic next(count int, letters boolean, numbers boolean) : String extracted from public random(count int, letters boolean, numbers boolean) : String in class org.apache.commons.lang3.RandomStringUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 91,
                "endLine": 108,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 115,
                "endLine": 130,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 613,
                "endLine": 629,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomStringUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomStringUtils#random",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}",
        "classSignatureBefore": "public class RandomStringUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils#random"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomStringUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\n * \"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\">\n * RandomStringGenerator</a> instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>\n * dedicated to pseudo-random number generation, that may be a better choice for applications with more stringent\n * requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the\n * values 56192 (db80) and 56319 (dbff) as we don't know how to handle them. High and low surrogates are correctly dealt\n * with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) then it is followed by a low\n * surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @see RandomUtils\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final Supplier<RandomUtils> SECURE_SUPPLIER = RandomUtils::secure;\n\n    private static RandomStringUtils INSECURE = new RandomStringUtils(RandomUtils::insecure);\n\n    private static RandomStringUtils SECURE = new RandomStringUtils(SECURE_SUPPLIER);\n\n    private static final char[] ALPHANUMERICAL_CHARS = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n            'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\n            'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1',\n            '2', '3', '4', '5', '6', '7', '8', '9' };\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return secure().next(count);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return secure().next(count, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers) {\n        return secure().next(count, start, end, letters, numbers);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers, final char... chars) {\n        return secure().next(count, start, end, letters, numbers, chars);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using supplied source of randomness.\n     *\n     * <p>\n     * If start and end are both {@code 0}, start and end are set to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both {@code false}, in which case, start and end are set\n     * to {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>\n     * If set is not {@code null}, characters between start and end are chosen.\n     * </p>\n     *\n     * <p>\n     * This method accepts a user-supplied {@link Random} instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call, the same random sequence of strings can be\n     * generated repeatedly and predictably.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at (inclusive)\n     * @param end     the position in set of chars to end before (exclusive)\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from, must not be empty. If {@code null}, then it will use the\n     *                set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n            final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \"\n                            + \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint) || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return secure().nextAlphabetic(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphabetic(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return secure().nextAlphanumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphanumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return secure().nextAscii(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAscii(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return secure().nextGraph(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextGraph(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return secure().nextNumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextNumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return secure().nextPrint(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextPrint(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils secure() {\n        return SECURE;\n    }\n\n    private final Supplier<RandomUtils> random;\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in standard programming. Instead, the class should\n     * be used as {@code RandomStringUtils.random(5);}.\n     *\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomStringUtils(final Supplier<RandomUtils> random) {\n        this.random = random;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers,\n            final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     * @since 3.16.0\n     */\n    public String next(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public String nextGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     * @since 3.16.0\n     */\n    public String nextPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.16.0\n     */\n    public String nextPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Gets the Random.\n     *\n     * @return the Random.\n     */\n    private Random random() {\n        return randomUtils().random();\n    }\n\n    /**\n     * Gets the RandomUtils.\n     *\n     * @return the RandomUtils.\n     */\n    private RandomUtils randomUtils() {\n        return random.get();\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomStringUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return secure().next(count, letters, numbers);\n    }\n/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }",
        "diffSourceCode": "-   91:     /**\n-   92:      * Creates a random string whose length is the number of characters\n-   93:      * specified.\n-   94:      *\n-   95:      * <p>Characters will be chosen from the set of alpha-numeric\n-   96:      * characters as indicated by the arguments.</p>\n-   97:      *\n-   98:      * @param count  the length of random string to create\n-   99:      * @param letters  if {@code true}, generated string may include\n-  100:      *  alphabetic characters\n-  101:      * @param numbers  if {@code true}, generated string may include\n-  102:      *  numeric characters\n-  103:      * @return the random string\n-  104:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n-  105:      */\n-  106:     public static String random(final int count, final boolean letters, final boolean numbers) {\n-  107:         return random(count, 0, 0, letters, numbers);\n-  108:     }\n-  115:      *\n-  116:      * @param count  the length of random string to create\n-  117:      * @param chars  the character array containing the set of characters to use,\n-  118:      *  may be null\n-  119:      * @return the random string\n-  120:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n-  121:      */\n-  122:     public static String random(final int count, final char... chars) {\n-  123:         if (chars == null) {\n-  124:             return random(count, 0, 0, false, false, null, random());\n-  125:         }\n-  126:         return random(count, 0, chars.length, false, false, chars, random());\n-  127:     }\n-  128: \n-  129:     /**\n-  130:      * Creates a random string whose length is the number of characters\n+   91:      * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n+   92:      * @see ThreadLocalRandom#current()\n+   93:      * @see #secure()\n+   94:      * @since 3.16.0\n+   95:      */\n+   96:     public static RandomStringUtils insecure() {\n+   97:         return INSECURE;\n+   98:     }\n+   99: \n+  100:     /**\n+  101:      * Creates a random string whose length is the number of characters specified.\n+  102:      *\n+  103:      * <p>\n+  104:      * Characters will be chosen from the set of all characters.\n+  105:      * </p>\n+  106:      *\n+  107:      * @param count the length of random string to create\n+  108:      * @return the random string\n+  115:     /**\n+  116:      * Creates a random string whose length is the number of characters specified.\n+  117:      *\n+  118:      * <p>\n+  119:      * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n+  120:      * </p>\n+  121:      *\n+  122:      * @param count   the length of random string to create\n+  123:      * @param letters if {@code true}, generated string may include alphabetic characters\n+  124:      * @param numbers if {@code true}, generated string may include numeric characters\n+  125:      * @return the random string\n+  126:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  127:      */\n+  128:     public static String random(final int count, final boolean letters, final boolean numbers) {\n+  129:         return secure().next(count, letters, numbers);\n+  130:     }\n+  613:     /**\n+  614:      * Creates a random string whose length is the number of characters specified.\n+  615:      *\n+  616:      * <p>\n+  617:      * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n+  618:      * </p>\n+  619:      *\n+  620:      * @param count   the length of random string to create\n+  621:      * @param letters if {@code true}, generated string may include alphabetic characters\n+  622:      * @param numbers if {@code true}, generated string may include numeric characters\n+  623:      * @return the random string\n+  624:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  625:      * @since 3.16.0\n+  626:      */\n+  627:     public String next(final int count, final boolean letters, final boolean numbers) {\n+  628:         return random(count, 0, 0, letters, numbers);\n+  629:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_91_108_613_629_115_130",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 16
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Generates a random string based on the specified parameters.\n *\n * @param count the length of the random string to create\n * @param start the position in the set of characters to start at\n * @param end the position in the set of characters to end before\n * @param letters if true, generated string may include alphabetic characters\n * @param numbers if true, generated string may include numeric characters\n * @param chars the set of characters to choose randoms from, null for all characters\n * @param random a source of randomness\n * @return the random string\n * @throws ArrayIndexOutOfBoundsException if there are not (end - start) + 1 characters in the set array\n * @throws IllegalArgumentException if count < 0 or the provided chars array is empty\n */\npublic static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n    if (count == 0) {\n        return StringUtils.EMPTY;\n    }\n    if (count < 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars != null && chars.length == 0) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n\n    if (start == 0 && end == 0) {\n        if (chars != null) {\n            end = chars.length;\n        } else if (!letters && !numbers) {\n            end = Character.MAX_CODE_POINT;\n        } else {\n            end = 'z' + 1;\n            start = ' ';\n        }\n    } else if (end <= start) {\n        throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n    } else if (start < 0 || end < 0) {\n        throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n    }\n\n    if (end > Character.MAX_CODE_POINT) {\n        end = Character.MAX_CODE_POINT;\n    }\n\n    // Optimize generation of full alphanumerical characters\n    if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n        return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random());\n    }\n\n    // Optimize start and end when filtering by letters and/or numbers\n    if (chars == null) {\n        if (letters && numbers) {\n            start = Math.max('0', start);\n            end = Math.min('z' + 1, end);\n        } else if (numbers) {\n            start = Math.max('0', start);\n            end = Math.min('9' + 1, end);\n        } else if (letters) {\n            start = Math.max('A', start);\n            end = Math.min('z' + 1, end);\n        }\n    }\n\n    final int zeroDigitAscii = 48;\n    final int firstLetterAscii = 65;\n\n    if (chars == null && (numbers && end <= zeroDigitAscii || letters && end <= firstLetterAscii)) {\n        throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n    }\n\n    final StringBuilder builder = new StringBuilder(count);\n    final int gap = end - start;\n    final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n    final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random());\n\n    while (count-- != 0) {\n        final int randomValue = arb.nextBits(gapBits) + start;\n        if (randomValue >= end) {\n            count++;\n            continue;\n        }\n\n        final int codePoint;\n        if (chars == null) {\n            codePoint = randomValue;\n\n            switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n            }\n\n        } else {\n            codePoint = chars[randomValue];\n        }\n\n        final int numberOfChars = Character.charCount(codePoint);\n        if (count == 0 && numberOfChars > 1) {\n            count++;\n            continue;\n        }\n\n        if (letters && Character.isLetter(codePoint) || numbers && Character.isDigit(codePoint) || !letters && !numbers) {\n            builder.appendCodePoint(codePoint);\n\n            if (numberOfChars == 2) {\n                count--;\n            }\n\n        } else {\n            count++;\n        }\n    }\n    return builder.toString();\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic next(count int) : String extracted from public random(count int) : String in class org.apache.commons.lang3.RandomStringUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 77,
                "endLine": 89,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 100,
                "endLine": 113,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
                "startLine": 597,
                "endLine": 611,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "isPureRefactoring": true,
        "commitId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.RandomStringUtils",
        "methodNameBefore": "org.apache.commons.lang3.RandomStringUtils#random",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}",
        "classSignatureBefore": "public class RandomStringUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils#random"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.RandomStringUtils"
        ],
        "classSignatureBeforeSet": [
            "public class RandomStringUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Supplier;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.16.0, this class uses {@link #secure()} for static methods and adds {@link #insecure()}.\n * </p>\n * <p>\n * Starting in version 3.15.0, this class uses {@link SecureRandom#getInstanceStrong()} for static methods.\n * </p>\n * <p>\n * Before version 3.15.0, this class used {@link ThreadLocalRandom#current()} for static methods, which is not\n * cryptographically secure.\n * </p>\n * <p>\n * Use {@link #secure()} to get the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an\n * algorithms/providers specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n * </p>\n * <p>\n * Use {@link #insecure()} to get the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not\n * cryptographically secure</b>.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\n * \"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\">\n * RandomStringGenerator</a> instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a>\n * dedicated to pseudo-random number generation, that may be a better choice for applications with more stringent\n * requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the\n * values 56192 (db80) and 56319 (dbff) as we don't know how to handle them. High and low surrogates are correctly dealt\n * with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) then it is followed by a low\n * surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @see RandomUtils\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final Supplier<RandomUtils> SECURE_SUPPLIER = RandomUtils::secure;\n\n    private static RandomStringUtils INSECURE = new RandomStringUtils(RandomUtils::insecure);\n\n    private static RandomStringUtils SECURE = new RandomStringUtils(SECURE_SUPPLIER);\n\n    private static final char[] ALPHANUMERICAL_CHARS = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n            'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\n            'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1',\n            '2', '3', '4', '5', '6', '7', '8', '9' };\n\n    /**\n     * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n     * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n     * {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link ThreadLocalRandom#current()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link ThreadLocalRandom#current()}.\n     * @see ThreadLocalRandom#current()\n     * @see #secure()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils insecure() {\n        return INSECURE;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return secure().next(count);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return secure().next(count, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers) {\n        return secure().next(count, start, end, letters, numbers);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters,\n            final boolean numbers, final char... chars) {\n        return secure().next(count, start, end, letters, numbers, chars);\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using supplied source of randomness.\n     *\n     * <p>\n     * If start and end are both {@code 0}, start and end are set to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both {@code false}, in which case, start and end are set\n     * to {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>\n     * If set is not {@code null}, characters between start and end are chosen.\n     * </p>\n     *\n     * <p>\n     * This method accepts a user-supplied {@link Random} instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call, the same random sequence of strings can be\n     * generated repeatedly and predictably.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at (inclusive)\n     * @param end     the position in set of chars to end before (exclusive)\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from, must not be empty. If {@code null}, then it will use the\n     *                set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n            final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\n                    \"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \"\n                            + \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint) || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        return secure().next(count, chars);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return secure().nextAlphabetic(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphabetic(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return secure().nextAlphanumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAlphanumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return secure().nextAscii(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextAscii(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return secure().nextGraph(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextGraph(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return secure().nextNumeric(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextNumeric(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return secure().nextPrint(count);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return secure().nextPrint(minLengthInclusive, maxLengthExclusive);\n    }\n\n    /**\n     * Gets the singleton instance based on {@link SecureRandom#getInstanceStrong()} which uses an algorithms/providers\n     * specified in the {@code securerandom.strongAlgorithms} {@link Security} property.\n     * <p>\n     * The method {@link SecureRandom#getInstanceStrong()} is called on-demand.\n     * </p>\n     *\n     * @return the singleton instance based on {@link SecureRandom#getInstanceStrong()}.\n     * @see SecureRandom#getInstanceStrong()\n     * @since 3.16.0\n     */\n    public static RandomStringUtils secure() {\n        return SECURE;\n    }\n\n    private final Supplier<RandomUtils> random;\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in standard programming. Instead, the class should\n     * be used as {@code RandomStringUtils.random(5);}.\n     *\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        this(SECURE_SUPPLIER);\n    }\n\n    private RandomStringUtils(final Supplier<RandomUtils> random) {\n        this.random = random;\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the character array containing the set of characters to use, may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using default source of randomness.\n     *\n     * <p>\n     * This method has exactly the same semantics as {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses the internal static {@link Random}\n     * instance.\n     * </p>\n     *\n     * @param count   the length of random string to create\n     * @param start   the position in set of chars to start at\n     * @param end     the position in set of chars to end before\n     * @param letters if {@code true}, generated string may include alphabetic characters\n     * @param numbers if {@code true}, generated string may include numeric characters\n     * @param chars   the set of chars to choose randoms from. If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException       if {@code count} &lt; 0.\n     */\n    public String next(final int count, final int start, final int end, final boolean letters, final boolean numbers,\n            final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters specified by the string, must not be empty. If null, the set\n     * of all characters is used.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @param chars the String containing the set of characters to use, may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     * @since 3.16.0\n     */\n    public String next(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z) and the digits 0-9.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters whose ASCII value is between {@code 32} and {@code 126}\n     * (inclusive).\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:graph:] regular expression character\n     * class. This class contains all visible ASCII characters (i.e. anything except spaces and control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public String nextGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Graph} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of numeric characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public String nextNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Digit} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public String nextNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of characters which match the POSIX [:print:] regular expression character\n     * class. This class includes all visible ASCII characters and spaces (i.e. anything except control characters).\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     * @since 3.16.0\n     */\n    public String nextPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and the exclusive maximum.\n     *\n     * <p>\n     * Characters will be chosen from the set of \\p{Print} characters.\n     * </p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.16.0\n     */\n    public String nextPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(randomUtils().randomInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Gets the Random.\n     *\n     * @return the Random.\n     */\n    private Random random() {\n        return randomUtils().random();\n    }\n\n    /**\n     * Gets the RandomUtils.\n     *\n     * @return the RandomUtils.\n     */\n    private RandomUtils randomUtils() {\n        return random.get();\n    }\n\n    @Override\n    public String toString() {\n        return \"RandomStringUtils [random=\" + random() + \"]\";\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count) {\n        return random(count, false, false);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.RandomStringUtils#random\n methodBody: public static String random(final int count, final String chars) {\nif(chars == null){return random(count,0,0,false,false,null,random());\n}return random(count,chars.toCharArray());\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return secure().next(count);\n    }\n/**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>\n     * Characters will be chosen from the set of all characters.\n     * </p>\n     *\n     * @param count the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.16.0\n     */\n    public String next(final int count) {\n        return random(count, false, false);\n    }",
        "diffSourceCode": "-   77:     /**\n-   78:      * Creates a random string whose length is the number of characters\n-   79:      * specified.\n-   80:      *\n-   81:      * <p>Characters will be chosen from the set of all characters.</p>\n-   82:      *\n-   83:      * @param count  the length of random string to create\n-   84:      * @return the random string\n-   85:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n-   86:      */\n-   87:     public static String random(final int count) {\n-   88:         return random(count, false, false);\n-   89:     }\n-  100:      *  alphabetic characters\n-  101:      * @param numbers  if {@code true}, generated string may include\n-  102:      *  numeric characters\n-  103:      * @return the random string\n-  104:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n-  105:      */\n-  106:     public static String random(final int count, final boolean letters, final boolean numbers) {\n-  107:         return random(count, 0, 0, letters, numbers);\n-  108:     }\n-  109: \n-  110:     /**\n-  111:      * Creates a random string whose length is the number of characters\n-  112:      * specified.\n-  113:      *\n+   77: \n+   78:     private static final char[] ALPHANUMERICAL_CHARS = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n+   79:             'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\n+   80:             'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1',\n+   81:             '2', '3', '4', '5', '6', '7', '8', '9' };\n+   82: \n+   83:     /**\n+   84:      * Gets the singleton instance based on {@link ThreadLocalRandom#current()}; <b>which is not cryptographically\n+   85:      * secure</b>; use {@link #secure()} to use an algorithms/providers specified in the\n+   86:      * {@code securerandom.strongAlgorithms} {@link Security} property.\n+   87:      * <p>\n+   88:      * The method {@link ThreadLocalRandom#current()} is called on-demand.\n+   89:      * </p>\n+  100:     /**\n+  101:      * Creates a random string whose length is the number of characters specified.\n+  102:      *\n+  103:      * <p>\n+  104:      * Characters will be chosen from the set of all characters.\n+  105:      * </p>\n+  106:      *\n+  107:      * @param count the length of random string to create\n+  108:      * @return the random string\n+  109:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  110:      */\n+  111:     public static String random(final int count) {\n+  112:         return secure().next(count);\n+  113:     }\n+  597:     /**\n+  598:      * Creates a random string whose length is the number of characters specified.\n+  599:      *\n+  600:      * <p>\n+  601:      * Characters will be chosen from the set of all characters.\n+  602:      * </p>\n+  603:      *\n+  604:      * @param count the length of random string to create\n+  605:      * @return the random string\n+  606:      * @throws IllegalArgumentException if {@code count} &lt; 0.\n+  607:      * @since 3.16.0\n+  608:      */\n+  609:     public String next(final int count) {\n+  610:         return random(count, false, false);\n+  611:     }\n",
        "uniqueId": "c95ee37dffd44b01d2b816e0d943013bc7bd866c_77_89_597_611_100_113",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 16
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Generates a random string of specified length using the given parameters.\n *\n * @param count    the length of the random string to create\n * @param start    the starting position in the character set\n * @param end      the ending position in the character set\n * @param letters  if true, include alphabetic characters\n * @param numbers  if true, include numeric characters\n * @param chars    the character array containing the set of characters to use\n * @param random   the source of randomness\n * @return the random string\n * @throws IllegalArgumentException if count is less than 0 or the provided chars array is empty\n */\npublic static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n    if (chars == null) {\n        return random(count, 0, 0, false, false, null, random());\n    }\n    return random(count, 0, chars.length, false, false, chars, random());\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.lang3.exception.UncheckedException;\n\n/**\n * Generates random {@link String}s.\n * <p>\n * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n * </p>\n * <p>\n * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n * </p>\n * <p>\n * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n * instead.\n * </p>\n * <p>\n * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n * </p>\n * <p>\n * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n * surrogate.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 1.0\n */\npublic class RandomStringUtils {\n\n    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n        try {\n            return SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new UncheckedException(e);\n        }\n    });\n\n    static SecureRandom random() {\n        return RANDOM.get();\n    }\n\n    private static final char[] ALPHANUMERICAL_CHARS = {\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    };\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of all characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count) {\n        return random(count, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final boolean letters, final boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters specified.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the character array containing the set of characters to use,\n     *  may be null\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, 0, chars.length, false, false, chars, random());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of alpha-numeric\n     * characters as indicated by the arguments.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n        return random(count, start, end, letters, numbers, null, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * default source of randomness.\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from.\n     *  If {@code null}, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n        return random(count, start, end, letters, numbers, chars, random());\n    }\n\n    /**\n     * Creates a random string based on a variety of options, using\n     * supplied source of randomness.\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive)\n     * @param end  the position in set of chars to end before (exclusive)\n     * @param letters  if {@code true}, generated string may include\n     *  alphabetic characters\n     * @param numbers  if {@code true}, generated string may include\n     *  numeric characters\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n                                final char[] chars, final Random random) {\n        if (count == 0) {\n            return StringUtils.EMPTY;\n        }\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else if (!letters && !numbers) {\n                end = Character.MAX_CODE_POINT;\n            } else {\n                end = 'z' + 1;\n                start = ' ';\n            }\n        } else if (end <= start) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n        } else if (start < 0 || end < 0) {\n            throw new IllegalArgumentException(\"Character positions MUST be >= 0\");\n        }\n\n        if (end > Character.MAX_CODE_POINT) {\n            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n            end = Character.MAX_CODE_POINT;\n        }\n\n        // Optimize generation of full alphanumerical characters\n        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n        // Instead we can pick directly from the right set of 62 characters, which requires\n        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n        }\n\n        // Optimize start and end when filtering by letters and/or numbers:\n        // The range provided may be too large since we filter anyway afterward.\n        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n        // since it is possible the range start/end excludes some of the letters/numbers,\n        // e.g., it is possible that start already is '1' when numbers = true, and start\n        // needs to stay equal to '1' in that case.\n        if (chars == null) {\n            if (letters && numbers) {\n                start = Math.max('0', start);\n                end = Math.min('z' + 1, end);\n            } else if (numbers) {\n                // just numbers, no letters\n                start = Math.max('0', start);\n                end = Math.min('9' + 1, end);\n            } else if (letters) {\n                // just letters, no numbers\n                start = Math.max('A', start);\n                end = Math.min('z' + 1, end);\n            }\n        }\n\n        final int zeroDigitAscii = 48;\n        final int firstLetterAscii = 65;\n\n        if (chars == null && (numbers && end <= zeroDigitAscii\n                || letters && end <= firstLetterAscii)) {\n            throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater then (\" + zeroDigitAscii + \") for generating digits \" +\n                    \"or greater then (\" + firstLetterAscii + \") for generating letters.\");\n        }\n\n        final StringBuilder builder = new StringBuilder(count);\n        final int gap = end - start;\n        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n        // The size of the cache we use is an heuristic:\n        // about twice the number of bytes required if no rejection\n        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n        // of randomness as well as the probability of rejection. It is however not easy to know\n        // those values programmatically for the general case.\n        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n\n        while (count-- != 0) {\n            // Generate a random value between start (included) and end (excluded)\n            final int randomValue = arb.nextBits(gapBits) + start;\n            // Rejection sampling if value too large\n            if (randomValue >= end) {\n                count++;\n                continue;\n            }\n\n            final int codePoint;\n            if (chars == null) {\n                codePoint = randomValue;\n\n                switch (Character.getType(codePoint)) {\n                case Character.UNASSIGNED:\n                case Character.PRIVATE_USE:\n                case Character.SURROGATE:\n                    count++;\n                    continue;\n                }\n\n            } else {\n                codePoint = chars[randomValue];\n            }\n\n            final int numberOfChars = Character.charCount(codePoint);\n            if (count == 0 && numberOfChars > 1) {\n                count++;\n                continue;\n            }\n\n            if (letters && Character.isLetter(codePoint)\n                    || numbers && Character.isDigit(codePoint)\n                    || !letters && !numbers) {\n                builder.appendCodePoint(codePoint);\n\n                if (numberOfChars == 2) {\n                    count--;\n                }\n\n            } else {\n                count++;\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters\n     * specified by the string, must not be empty.\n     * If null, the set of all characters is used.</p>\n     *\n     * @param count  the length of random string to create\n     * @param chars  the String containing the set of characters to use,\n     *  may be null, but must not be empty\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n     */\n    public static String random(final int count, final String chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, random());\n        }\n        return random(count, chars.toCharArray());\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphabetic(final int count) {\n        return random(count, true, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic characters (a-z, A-Z).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphabetic(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphabetic(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAlphanumeric(final int count) {\n        return random(count, true, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of Latin alphabetic\n     * characters (a-z, A-Z) and the digits 0-9.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAlphanumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAlphanumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomAscii(final int count) {\n        return random(count, 32, 127, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of characters whose\n     * ASCII value is between {@code 32} and {@code 126} (inclusive).</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomAscii(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomAscii(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:graph:]\n     * regular expression character class. This class contains all visible ASCII characters\n     * (i.e. anything except spaces and control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomGraph(final int count) {\n        return random(count, 33, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Graph} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomGraph(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomGraph(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters\n     * specified.\n     *\n     * <p>Characters will be chosen from the set of numeric\n     * characters.</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     */\n    public static String randomNumeric(final int count) {\n        return random(count, false, true);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Digit} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomNumeric(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomNumeric(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * Creates a random string whose length is the number of characters specified.\n     *\n     * <p>Characters will be chosen from the set of characters which match the POSIX [:print:]\n     * regular expression character class. This class includes all visible ASCII characters and spaces\n     * (i.e. anything except control characters).</p>\n     *\n     * @param count  the length of random string to create\n     * @return the random string\n     * @throws IllegalArgumentException if {@code count} &lt; 0.\n     * @since 3.5\n     */\n    public static String randomPrint(final int count) {\n        return random(count, 32, 126, false, false);\n    }\n\n    /**\n     * Creates a random string whose length is between the inclusive minimum and\n     * the exclusive maximum.\n     *\n     * <p>Characters will be chosen from the set of \\p{Print} characters.</p>\n     *\n     * @param minLengthInclusive the inclusive minimum length of the string to generate\n     * @param maxLengthExclusive the exclusive maximum length of the string to generate\n     * @return the random string\n     * @since 3.5\n     */\n    public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n        return randomPrint(RandomUtils.nextInt(minLengthInclusive, maxLengthExclusive));\n    }\n\n    /**\n     * {@link RandomStringUtils} instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * {@code RandomStringUtils.random(5);}.\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public RandomStringUtils() {\n        // empty\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate set(watch StopWatch, nanos long) : StopWatch extracted from private createMockStopWatch(nanos long) : StopWatch in class org.apache.commons.lang3.time.StopWatchTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/time/StopWatchTest.java",
                "startLine": 53,
                "endLine": 83,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/time/StopWatchTest.java",
                "startLine": 53,
                "endLine": 76,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/time/StopWatchTest.java",
                "startLine": 78,
                "endLine": 87,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * <p>\n     * Creates a suspended StopWatch object which appears to have elapsed for the requested amount of time in\n     * nanoseconds.\n     * <p>\n     * <p>\n     *\n     * <pre>\n     * // Create a mock StopWatch with a time of 2:59:01.999\n     * final long nanos = TimeUnit.HOURS.toNanos(2)\n     *         + TimeUnit.MINUTES.toNanos(59)\n     *         + TimeUnit.SECONDS.toNanos(1)\n     *         + TimeUnit.MILLISECONDS.toNanos(999);\n     * final StopWatch watch = createMockStopWatch(nanos);\n     * </pre>\n     *\n     * @param nanos Time in nanoseconds to have elapsed on the stop watch\n     * @return StopWatch in a suspended state with the elapsed time\n     */\n    private StopWatch createMockStopWatch(final long nanos) {\n        final StopWatch watch = StopWatch.createStarted();\n        watch.suspend();\n        try {\n            final long currentNanos = System.nanoTime();\n            FieldUtils.writeField(watch, \"startTimeNanos\", currentNanos - nanos, true);\n            FieldUtils.writeField(watch, \"stopTimeNanos\", currentNanos, true);\n        } catch (final IllegalAccessException e) {\n            return null;\n        }\n        return watch;\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/time/StopWatchTest.java",
        "isPureRefactoring": true,
        "commitId": "2875a65756da4c72e8d188555b9639857e73684a",
        "packageNameBefore": "org.apache.commons.lang3.time",
        "classNameBefore": "org.apache.commons.lang3.time.StopWatchTest",
        "methodNameBefore": "org.apache.commons.lang3.time.StopWatchTest#createMockStopWatch",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.time.StopWatch#createStarted\n methodBody: public static StopWatch createStarted() {\nfinal StopWatch sw=new StopWatch();\nsw.start();\nreturn sw;\n}\nmethodSignature: org.apache.commons.lang3.time.StopWatch#suspend\n methodBody: public void suspend() {\nif(this.runningState != State.RUNNING){throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n}this.stopTimeNanos=System.nanoTime();\nthis.stopTimeMillis=System.currentTimeMillis();\nthis.runningState=State.SUSPENDED;\n}",
        "classSignatureBefore": "public class StopWatchTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.time.StopWatchTest#createMockStopWatch"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.time.StopWatchTest"
        ],
        "classSignatureBeforeSet": [
            "public class StopWatchTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.time;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.allOf;\nimport static org.hamcrest.Matchers.greaterThanOrEqualTo;\nimport static org.hamcrest.Matchers.lessThan;\nimport static org.hamcrest.Matchers.lessThanOrEqualTo;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.startsWith;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link StopWatch}.\n */\npublic class StopWatchTest extends AbstractLangTest {\n\n    private static final Duration MILLIS_200 = Duration.ofMillis(200);\n    private static final Duration MILLIS_550 = Duration.ofMillis(550);\n    private static final String MESSAGE = \"Baking cookies\";\n    private static final Duration MIN_SLEEP = Duration.ofMillis(20);\n    private static final String ZERO_HOURS_PREFIX = \"00:\";\n    private static final String ZERO_TIME_ELAPSED = \"00:00:00.000\";\n\n    /**\n     * <p>\n     * Creates a suspended StopWatch object which appears to have elapsed for the requested amount of time in\n     * nanoseconds.\n     * <p>\n     * <p>\n     *\n     * <pre>\n     * // Create a mock StopWatch with a time of 2:59:01.999\n     * final long nanos = TimeUnit.HOURS.toNanos(2)\n     *         + TimeUnit.MINUTES.toNanos(59)\n     *         + TimeUnit.SECONDS.toNanos(1)\n     *         + TimeUnit.MILLISECONDS.toNanos(999);\n     * final StopWatch watch = createMockStopWatch(nanos);\n     * </pre>\n     *\n     * @param nanos Time in nanoseconds to have elapsed on the stop watch\n     * @return StopWatch in a suspended state with the elapsed time\n     */\n    private StopWatch createMockStopWatch(final long nanos) {\n        final StopWatch watch = StopWatch.createStarted();\n        watch.suspend();\n        try {\n            final long currentNanos = System.nanoTime();\n            FieldUtils.writeField(watch, \"startTimeNanos\", currentNanos - nanos, true);\n            FieldUtils.writeField(watch, \"stopTimeNanos\", currentNanos, true);\n        } catch (final IllegalAccessException e) {\n            return null;\n        }\n        return watch;\n    }\n\n    private void sleep(final Duration duration) throws InterruptedException {\n        ThreadUtils.sleep(duration);\n    }\n\n    // test bad states\n    @Test\n    public void testBadStates() {\n        final StopWatch watch = new StopWatch();\n        assertThrows(IllegalStateException.class, watch::stop,\n            \"Calling stop on an unstarted StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::suspend,\n            \"Calling suspend on an unstarted StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::split,\n            \"Calling split on a non-running StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::unsplit,\n            \"Calling unsplit on an unsplit StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::resume,\n            \"Calling resume on an unsuspended StopWatch should throw an exception. \");\n\n        watch.start();\n\n        assertThrows(IllegalStateException.class, watch::start,\n            \"Calling start on a started StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::unsplit,\n            \"Calling unsplit on an unsplit StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::getSplitTime,\n            \"Calling getSplitTime on an unsplit StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::resume,\n            \"Calling resume on an unsuspended StopWatch should throw an exception. \");\n\n        watch.stop();\n\n        assertThrows(IllegalStateException.class, watch::start,\n            \"Calling start on a stopped StopWatch should throw an exception as it needs to be reset. \");\n    }\n\n    @Test\n    public void testBooleanStates() {\n        final StopWatch watch = new StopWatch();\n        assertFalse(watch.isStarted());\n        assertFalse(watch.isSuspended());\n        assertTrue(watch.isStopped());\n\n        watch.start();\n        assertTrue(watch.isStarted());\n        assertFalse(watch.isSuspended());\n        assertFalse(watch.isStopped());\n\n        watch.suspend();\n        assertTrue(watch.isStarted());\n        assertTrue(watch.isSuspended());\n        assertFalse(watch.isStopped());\n\n        watch.stop();\n        assertFalse(watch.isStarted());\n        assertFalse(watch.isSuspended());\n        assertTrue(watch.isStopped());\n    }\n\n    @Test\n    public void testFormatSplitTime() {\n        final StopWatch watch = StopWatch.createStarted();\n        ThreadUtils.sleepQuietly(MIN_SLEEP);\n        watch.split();\n        final String formatSplitTime = watch.formatSplitTime();\n        assertNotEquals(ZERO_TIME_ELAPSED, formatSplitTime);\n        assertThat(\"formatSplitTime\", formatSplitTime, startsWith(ZERO_HOURS_PREFIX));\n    }\n\n    @Test\n    public void testFormatSplitTimeWithMessage() {\n        final StopWatch watch = new StopWatch(MESSAGE);\n        watch.start();\n        ThreadUtils.sleepQuietly(MIN_SLEEP);\n        watch.split();\n        final String formatSplitTime = watch.formatSplitTime();\n        assertThat(\"formatSplitTime\", formatSplitTime, not(startsWith(MESSAGE)));\n        assertThat(\"formatSplitTime\", formatSplitTime, startsWith(ZERO_HOURS_PREFIX));\n    }\n\n    @Test\n    public void testFormatTime() {\n        final StopWatch watch = StopWatch.create();\n        final String formatTime = watch.formatTime();\n        assertEquals(ZERO_TIME_ELAPSED, formatTime);\n        assertThat(\"formatTime\", formatTime, startsWith(ZERO_HOURS_PREFIX));\n    }\n\n    @Test\n    public void testFormatTimeWithMessage() {\n        final StopWatch watch = new StopWatch(MESSAGE);\n        final String formatTime = watch.formatTime();\n        assertThat(\"formatTime\", formatTime, not(startsWith(MESSAGE)));\n    }\n\n    @Test\n    public void testGetStartTime() {\n        final long beforeStopWatchMillis = System.currentTimeMillis();\n        final StopWatch watch = new StopWatch();\n        assertThrows(IllegalStateException.class, watch::getStartTime,\n            \"Calling getStartTime on an unstarted StopWatch should throw an exception\");\n        watch.start();\n\n        watch.getStartTime();\n        assertThat(\"getStartTime\", watch.getStartTime(), greaterThanOrEqualTo(beforeStopWatchMillis));\n\n        watch.reset();\n        assertThrows(IllegalStateException.class, watch::getStartTime,\n            \"Calling getStartTime on a reset, but unstarted StopWatch should throw an exception\");\n    }\n\n    @Test\n    public void testLang315() throws InterruptedException {\n        final StopWatch watch = StopWatch.createStarted();\n        sleep(MILLIS_200);\n        watch.suspend();\n        final long suspendTime = watch.getTime();\n        sleep(MILLIS_200);\n        watch.stop();\n        final long totalTime = watch.getTime();\n        assertEquals(suspendTime, totalTime);\n    }\n\n    @Test\n    public void testMessage() {\n        assertNull(StopWatch.create().getMessage());\n        final StopWatch stopWatch = new StopWatch(MESSAGE);\n        assertEquals(MESSAGE, stopWatch.getMessage());\n        assertThat(\"stopWatch.toString\", stopWatch.toString(), startsWith(MESSAGE));\n        stopWatch.start();\n        stopWatch.split();\n        assertThat(\"stopWatch.toSplitString\", stopWatch.toSplitString(), startsWith(MESSAGE));\n    }\n\n    @Test\n    public void testStopTimeSimple() throws InterruptedException {\n        final StopWatch watch = StopWatch.createStarted();\n        final long testStartMillis = System.currentTimeMillis();\n        sleep(MILLIS_550);\n        watch.stop();\n        final long testEndMillis = System.currentTimeMillis();\n        final long stopTime = watch.getStopTime();\n        assertEquals(stopTime, watch.getStopTime());\n\n        assertThat(\"stopTime\", stopTime, allOf(greaterThanOrEqualTo(testStartMillis), lessThanOrEqualTo(testEndMillis)));\n    }\n\n    @Test\n    public void testStopWatchGetWithTimeUnit() {\n        // Create a mock StopWatch with a time of 2:59:01.999\n        // @formatter:off\n        final StopWatch watch = createMockStopWatch(\n            TimeUnit.HOURS.toNanos(2)\n                    + TimeUnit.MINUTES.toNanos(59)\n                    + TimeUnit.SECONDS.toNanos(1)\n                    + TimeUnit.MILLISECONDS.toNanos(999));\n        // @formatter:on\n\n        assertEquals(2L, watch.getTime(TimeUnit.HOURS));\n        assertEquals(179L, watch.getTime(TimeUnit.MINUTES));\n        assertEquals(10741L, watch.getTime(TimeUnit.SECONDS));\n        assertEquals(10741999L, watch.getTime(TimeUnit.MILLISECONDS));\n    }\n\n    @Test\n    public void testStopWatchSimple() throws InterruptedException {\n        final StopWatch watch = StopWatch.createStarted();\n        sleep(MILLIS_550);\n        watch.stop();\n        final long time = watch.getTime();\n        assertEquals(time, watch.getTime());\n\n        assertThat(\"time\", time, allOf(greaterThanOrEqualTo(500L), lessThan(2000L)));\n\n        watch.reset();\n        assertEquals(0, watch.getTime());\n    }\n\n    @Test\n    public void testStopWatchSimpleGet() throws InterruptedException {\n        final StopWatch watch = new StopWatch();\n        assertEquals(0, watch.getTime());\n        assertEquals(ZERO_TIME_ELAPSED, watch.toString());\n\n        watch.start();\n        sleep(MILLIS_550);\n        assertThat(\"watch.getTime()\", watch.getTime(), lessThan(2000L));\n    }\n\n    @Test\n    public void testStopWatchSplit() throws InterruptedException {\n        final StopWatch watch = StopWatch.createStarted();\n        sleep(MILLIS_550);\n        // slept ~550 millis\n        watch.split();\n        final long splitTime = watch.getSplitTime();\n        final String splitStr = watch.toSplitString();\n        sleep(MILLIS_550);\n        // slept ~1100 millis\n        watch.unsplit();\n        sleep(MILLIS_550);\n        // slept ~1650 millis\n        watch.stop();\n        final long totalTime = watch.getTime();\n\n        assertEquals(12, splitStr.length(), \"Formatted split string not the correct length\");\n        assertThat(\"splitTime\", splitTime, allOf(greaterThanOrEqualTo(500L), lessThan(1000L)));\n        assertThat(\"totalTime\", totalTime, allOf(greaterThanOrEqualTo(1500L), lessThan(2100L)));\n    }\n\n    @Test\n    public void testStopWatchStatic() {\n        final StopWatch watch = StopWatch.createStarted();\n        assertTrue(watch.isStarted());\n    }\n\n    @Test\n    public void testStopWatchSuspend() throws InterruptedException {\n        // Watch out comparing measurements from System.currentTimeMillis() vs. System.nanoTime()\n        final StopWatch watch = StopWatch.createStarted();\n        final long testStartMillis = System.currentTimeMillis();\n        final long testStartNanos = System.nanoTime();\n        sleep(MILLIS_550);\n        watch.suspend();\n        final long testSuspendMillis = System.currentTimeMillis();\n        final long testSuspendNanos = System.nanoTime();\n        final long testSuspendTimeNanos = testSuspendNanos - testStartNanos;\n        final long suspendTimeFromNanos = watch.getTime();\n        final long stopTimeMillis = watch.getStopTime();\n\n        assertThat(\"testStartMillis <= stopTimeMillis\", testStartMillis, lessThanOrEqualTo(stopTimeMillis));\n        assertThat(\"testSuspendMillis <= stopTimeMillis\", testSuspendMillis, lessThanOrEqualTo(stopTimeMillis));\n\n        sleep(MILLIS_550);\n        watch.resume();\n        sleep(MILLIS_550);\n        watch.stop();\n        final long totalTimeFromNanos = watch.getTime();\n\n        assertThat(\"suspendTimeFromNanos\", suspendTimeFromNanos, greaterThanOrEqualTo(500L));\n        assertThat(\"suspendTimeFromNanos <= testSuspendTimeNanos\", suspendTimeFromNanos, lessThanOrEqualTo(testSuspendTimeNanos));\n        assertThat(\"totalTimeFromNanos\", totalTimeFromNanos, greaterThanOrEqualTo(1000L));\n        // Be lenient for slow running builds\n        assertThat(\"totalTimeFromNanos\", totalTimeFromNanos, lessThan(2500L));\n    }\n\n    @Test\n    public void testToSplitString() throws InterruptedException {\n        final StopWatch watch = StopWatch.createStarted();\n        sleep(MILLIS_550);\n        watch.split();\n        final String splitStr = watch.toSplitString();\n        assertEquals(12, splitStr.length(), \"Formatted split string not the correct length\");\n    }\n\n    @Test\n    public void testToSplitStringWithMessage() throws InterruptedException {\n        final StopWatch watch = new StopWatch(MESSAGE);\n        watch.start();\n        sleep(MILLIS_550);\n        watch.split();\n        final String splitStr = watch.toSplitString();\n        assertEquals(12 + MESSAGE.length() + 1, splitStr.length(), \"Formatted split string not the correct length\");\n    }\n\n    @Test\n    public void testToString() throws InterruptedException {\n        //\n        final StopWatch watch = StopWatch.createStarted();\n        sleep(MILLIS_550);\n        watch.split();\n        final String splitStr = watch.toString();\n        assertEquals(12, splitStr.length(), \"Formatted split string not the correct length\");\n    }\n\n    @Test\n    public void testToStringWithMessage() throws InterruptedException {\n        assertThat(\"message\", new StopWatch(MESSAGE).toString(), startsWith(MESSAGE));\n        //\n        final StopWatch watch = new StopWatch(MESSAGE);\n        watch.start();\n        sleep(MILLIS_550);\n        watch.split();\n        final String splitStr = watch.toString();\n        assertEquals(12 + MESSAGE.length() + 1, splitStr.length(), \"Formatted split string not the correct length\");\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/time/StopWatchTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.time;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.allOf;\nimport static org.hamcrest.Matchers.greaterThanOrEqualTo;\nimport static org.hamcrest.Matchers.lessThan;\nimport static org.hamcrest.Matchers.lessThanOrEqualTo;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.startsWith;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link StopWatch}.\n */\npublic class StopWatchTest extends AbstractLangTest {\n\n    private static final Duration MILLIS_200 = Duration.ofMillis(200);\n    private static final Duration MILLIS_550 = Duration.ofMillis(550);\n    private static final String MESSAGE = \"Baking cookies\";\n    private static final Duration MIN_SLEEP = Duration.ofMillis(20);\n    private static final String ZERO_HOURS_PREFIX = \"00:\";\n    private static final String ZERO_TIME_ELAPSED = \"00:00:00.000\";\n\n    /**\n     * <p>\n     * Creates a suspended StopWatch object which appears to have elapsed for the requested amount of time in\n     * nanoseconds.\n     * <p>\n     * <p>\n     *\n     * <pre>\n     * // Create a mock StopWatch with a time of 2:59:01.999\n     * final long nanos = TimeUnit.HOURS.toNanos(2)\n     *         + TimeUnit.MINUTES.toNanos(59)\n     *         + TimeUnit.SECONDS.toNanos(1)\n     *         + TimeUnit.MILLISECONDS.toNanos(999);\n     * final StopWatch watch = createMockStopWatch(nanos);\n     * </pre>\n     *\n     * @param nanos Time in nanoseconds to have elapsed on the stop watch\n     * @return StopWatch in a suspended state with the elapsed time\n     */\n    private StopWatch createMockStopWatch(final long nanos) {\n        final StopWatch watch = StopWatch.createStarted();\n        watch.suspend();\n        return set(watch, nanos);\n    }\n\n    private StopWatch set(final StopWatch watch, final long nanos) {\n        try {\n            final long currentNanos = System.nanoTime();\n            FieldUtils.writeField(watch, \"startTimeNanos\", currentNanos - nanos, true);\n            FieldUtils.writeField(watch, \"stopTimeNanos\", currentNanos, true);\n        } catch (final IllegalAccessException e) {\n            return null;\n        }\n        return watch;\n    }\n\n    private void sleep(final Duration duration) throws InterruptedException {\n        ThreadUtils.sleep(duration);\n    }\n\n    /**\n     * Tests bad states.\n     */\n    @Test\n    public void testBadStates() {\n        final StopWatch watch = new StopWatch();\n        assertThrows(IllegalStateException.class, watch::stop,\n            \"Calling stop on an unstarted StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::suspend,\n            \"Calling suspend on an unstarted StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::split,\n            \"Calling split on a non-running StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::unsplit,\n            \"Calling unsplit on an unsplit StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::resume,\n            \"Calling resume on an unsuspended StopWatch should throw an exception. \");\n\n        watch.start();\n\n        assertThrows(IllegalStateException.class, watch::start,\n            \"Calling start on a started StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::unsplit,\n            \"Calling unsplit on an unsplit StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::getSplitTime,\n                \"Calling getSplitTime on an unsplit StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::getSplitDuration,\n                \"Calling getSplitTime on an unsplit StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::resume,\n            \"Calling resume on an unsuspended StopWatch should throw an exception. \");\n\n        watch.stop();\n\n        assertThrows(IllegalStateException.class, watch::start,\n            \"Calling start on a stopped StopWatch should throw an exception as it needs to be reset. \");\n    }\n\n    @Test\n    public void testBooleanStates() {\n        final StopWatch watch = new StopWatch();\n        assertFalse(watch.isStarted());\n        assertFalse(watch.isSuspended());\n        assertTrue(watch.isStopped());\n\n        watch.start();\n        assertTrue(watch.isStarted());\n        assertFalse(watch.isSuspended());\n        assertFalse(watch.isStopped());\n\n        watch.suspend();\n        assertTrue(watch.isStarted());\n        assertTrue(watch.isSuspended());\n        assertFalse(watch.isStopped());\n\n        watch.stop();\n        assertFalse(watch.isStarted());\n        assertFalse(watch.isSuspended());\n        assertTrue(watch.isStopped());\n    }\n\n    @Test\n    public void testFormatSplitTime() {\n        final StopWatch watch = StopWatch.createStarted();\n        ThreadUtils.sleepQuietly(MIN_SLEEP);\n        watch.split();\n        final String formatSplitTime = watch.formatSplitTime();\n        assertNotEquals(ZERO_TIME_ELAPSED, formatSplitTime);\n        assertThat(\"formatSplitTime\", formatSplitTime, startsWith(ZERO_HOURS_PREFIX));\n    }\n\n    @Test\n    public void testFormatSplitTimeWithMessage() {\n        final StopWatch watch = new StopWatch(MESSAGE);\n        watch.start();\n        ThreadUtils.sleepQuietly(MIN_SLEEP);\n        watch.split();\n        final String formatSplitTime = watch.formatSplitTime();\n        assertThat(\"formatSplitTime\", formatSplitTime, not(startsWith(MESSAGE)));\n        assertThat(\"formatSplitTime\", formatSplitTime, startsWith(ZERO_HOURS_PREFIX));\n    }\n\n    @Test\n    public void testFormatTime() {\n        final StopWatch watch = StopWatch.create();\n        final String formatTime = watch.formatTime();\n        assertEquals(ZERO_TIME_ELAPSED, formatTime);\n        assertThat(\"formatTime\", formatTime, startsWith(ZERO_HOURS_PREFIX));\n    }\n\n    @Test\n    public void testFormatTimeWithMessage() {\n        final StopWatch watch = new StopWatch(MESSAGE);\n        final String formatTime = watch.formatTime();\n        assertThat(\"formatTime\", formatTime, not(startsWith(MESSAGE)));\n    }\n\n    @Test\n    public void testGetSplitDuration() {\n        // Create a mock StopWatch with a time of 2:59:01.999\n        // @formatter:off\n        final StopWatch watch = StopWatch.createStarted();\n        watch.split();\n        set(watch, 123456);\n        // @formatter:on\n        assertEquals(Duration.ofNanos(123456), watch.getSplitDuration());\n    }\n\n    @Test\n    public void testGetStartTime() {\n        final long beforeStopWatchMillis = System.currentTimeMillis();\n        final StopWatch watch = new StopWatch();\n        assertThrows(IllegalStateException.class, watch::getStartTime,\n            \"Calling getStartTime on an unstarted StopWatch should throw an exception\");\n        watch.start();\n\n        watch.getStartTime();\n        assertThat(\"getStartTime\", watch.getStartTime(), greaterThanOrEqualTo(beforeStopWatchMillis));\n\n        watch.reset();\n        assertThrows(IllegalStateException.class, watch::getStartTime,\n            \"Calling getStartTime on a reset, but unstarted StopWatch should throw an exception\");\n    }\n\n    @Test\n    public void testLang315() throws InterruptedException {\n        final StopWatch watch = StopWatch.createStarted();\n        sleep(MILLIS_200);\n        watch.suspend();\n        final long suspendTime = watch.getTime();\n        sleep(MILLIS_200);\n        watch.stop();\n        final long totalTime = watch.getTime();\n        assertEquals(suspendTime, totalTime);\n    }\n\n    @Test\n    public void testMessage() {\n        assertNull(StopWatch.create().getMessage());\n        final StopWatch stopWatch = new StopWatch(MESSAGE);\n        assertEquals(MESSAGE, stopWatch.getMessage());\n        assertThat(\"stopWatch.toString\", stopWatch.toString(), startsWith(MESSAGE));\n        stopWatch.start();\n        stopWatch.split();\n        assertThat(\"stopWatch.toSplitString\", stopWatch.toSplitString(), startsWith(MESSAGE));\n    }\n\n    @Test\n    public void testStopTimeSimple() throws InterruptedException {\n        final StopWatch watch = StopWatch.createStarted();\n        final long testStartMillis = System.currentTimeMillis();\n        sleep(MILLIS_550);\n        watch.stop();\n        final long testEndMillis = System.currentTimeMillis();\n        final long stopTime = watch.getStopTime();\n        assertEquals(stopTime, watch.getStopTime());\n\n        assertThat(\"stopTime\", stopTime, allOf(greaterThanOrEqualTo(testStartMillis), lessThanOrEqualTo(testEndMillis)));\n    }\n\n    @Test\n    public void testStopWatchGetWithTimeUnit() {\n        // Create a mock StopWatch with a time of 2:59:01.999\n        // @formatter:off\n        final StopWatch watch = createMockStopWatch(\n            TimeUnit.HOURS.toNanos(2)\n                    + TimeUnit.MINUTES.toNanos(59)\n                    + TimeUnit.SECONDS.toNanos(1)\n                    + TimeUnit.MILLISECONDS.toNanos(999));\n        // @formatter:on\n        assertEquals(2L, watch.getTime(TimeUnit.HOURS));\n        assertEquals(179L, watch.getTime(TimeUnit.MINUTES));\n        assertEquals(10741L, watch.getTime(TimeUnit.SECONDS));\n        assertEquals(10741999L, watch.getTime(TimeUnit.MILLISECONDS));\n    }\n\n    @Test\n    public void testStopWatchSimple() throws InterruptedException {\n        final StopWatch watch = StopWatch.createStarted();\n        sleep(MILLIS_550);\n        watch.stop();\n        final long time = watch.getTime();\n        assertEquals(time, watch.getTime());\n\n        assertThat(\"time\", time, allOf(greaterThanOrEqualTo(500L), lessThan(2000L)));\n\n        watch.reset();\n        assertEquals(0, watch.getTime());\n    }\n\n    @Test\n    public void testStopWatchSimpleGet() throws InterruptedException {\n        final StopWatch watch = new StopWatch();\n        assertEquals(0, watch.getTime());\n        assertEquals(ZERO_TIME_ELAPSED, watch.toString());\n\n        watch.start();\n        sleep(MILLIS_550);\n        assertThat(\"watch.getTime()\", watch.getTime(), lessThan(2000L));\n    }\n\n    @Test\n    public void testStopWatchSplit() throws InterruptedException {\n        final StopWatch watch = StopWatch.createStarted();\n        sleep(MILLIS_550);\n        // slept ~550 millis\n        watch.split();\n        final long splitTime = watch.getSplitTime();\n        assertEquals(splitTime, watch.getSplitDuration().toMillis());\n        final String splitStr = watch.toSplitString();\n        sleep(MILLIS_550);\n        // slept ~1100 millis\n        watch.unsplit();\n        sleep(MILLIS_550);\n        // slept ~1650 millis\n        watch.stop();\n        final long totalTime = watch.getTime();\n\n        assertEquals(12, splitStr.length(), \"Formatted split string not the correct length\");\n        assertThat(\"splitTime\", splitTime, allOf(greaterThanOrEqualTo(500L), lessThan(1000L)));\n        assertThat(\"totalTime\", totalTime, allOf(greaterThanOrEqualTo(1500L), lessThan(2100L)));\n    }\n\n    @Test\n    public void testStopWatchStatic() {\n        final StopWatch watch = StopWatch.createStarted();\n        assertTrue(watch.isStarted());\n    }\n\n    @Test\n    public void testStopWatchSuspend() throws InterruptedException {\n        // Watch out comparing measurements from System.currentTimeMillis() vs. System.nanoTime()\n        final StopWatch watch = StopWatch.createStarted();\n        final long testStartMillis = System.currentTimeMillis();\n        final long testStartNanos = System.nanoTime();\n        sleep(MILLIS_550);\n        watch.suspend();\n        final long testSuspendMillis = System.currentTimeMillis();\n        final long testSuspendNanos = System.nanoTime();\n        final long testSuspendTimeNanos = testSuspendNanos - testStartNanos;\n        final long suspendTimeFromNanos = watch.getTime();\n        final long stopTimeMillis = watch.getStopTime();\n\n        assertThat(\"testStartMillis <= stopTimeMillis\", testStartMillis, lessThanOrEqualTo(stopTimeMillis));\n        assertThat(\"testSuspendMillis <= stopTimeMillis\", testSuspendMillis, lessThanOrEqualTo(stopTimeMillis));\n\n        sleep(MILLIS_550);\n        watch.resume();\n        sleep(MILLIS_550);\n        watch.stop();\n        final long totalTimeFromNanos = watch.getTime();\n\n        assertThat(\"suspendTimeFromNanos\", suspendTimeFromNanos, greaterThanOrEqualTo(500L));\n        assertThat(\"suspendTimeFromNanos <= testSuspendTimeNanos\", suspendTimeFromNanos, lessThanOrEqualTo(testSuspendTimeNanos));\n        assertThat(\"totalTimeFromNanos\", totalTimeFromNanos, greaterThanOrEqualTo(1000L));\n        // Be lenient for slow running builds\n        assertThat(\"totalTimeFromNanos\", totalTimeFromNanos, lessThan(2500L));\n    }\n\n    @Test\n    public void testToSplitString() throws InterruptedException {\n        final StopWatch watch = StopWatch.createStarted();\n        sleep(MILLIS_550);\n        watch.split();\n        final String splitStr = watch.toSplitString();\n        assertEquals(12, splitStr.length(), \"Formatted split string not the correct length\");\n    }\n\n    @Test\n    public void testToSplitStringWithMessage() throws InterruptedException {\n        final StopWatch watch = new StopWatch(MESSAGE);\n        watch.start();\n        sleep(MILLIS_550);\n        watch.split();\n        final String splitStr = watch.toSplitString();\n        assertEquals(12 + MESSAGE.length() + 1, splitStr.length(), \"Formatted split string not the correct length\");\n    }\n\n    @Test\n    public void testToString() throws InterruptedException {\n        //\n        final StopWatch watch = StopWatch.createStarted();\n        sleep(MILLIS_550);\n        watch.split();\n        final String splitStr = watch.toString();\n        assertEquals(12, splitStr.length(), \"Formatted split string not the correct length\");\n    }\n\n    @Test\n    public void testToStringWithMessage() throws InterruptedException {\n        assertThat(\"message\", new StopWatch(MESSAGE).toString(), startsWith(MESSAGE));\n        //\n        final StopWatch watch = new StopWatch(MESSAGE);\n        watch.start();\n        sleep(MILLIS_550);\n        watch.split();\n        final String splitStr = watch.toString();\n        assertEquals(12 + MESSAGE.length() + 1, splitStr.length(), \"Formatted split string not the correct length\");\n    }\n}\n",
        "diffSourceCodeSet": [
            "private StopWatch set(final StopWatch watch, final long nanos) {\n        try {\n            final long currentNanos = System.nanoTime();\n            FieldUtils.writeField(watch, \"startTimeNanos\", currentNanos - nanos, true);\n            FieldUtils.writeField(watch, \"stopTimeNanos\", currentNanos, true);\n        } catch (final IllegalAccessException e) {\n            return null;\n        }\n        return watch;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.time.StopWatch#createStarted\n methodBody: public static StopWatch createStarted() {\nfinal StopWatch sw=new StopWatch();\nsw.start();\nreturn sw;\n}",
            "methodSignature: org.apache.commons.lang3.time.StopWatch#suspend\n methodBody: public void suspend() {\nif(this.runningState != State.RUNNING){throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n}this.stopTimeNanos=System.nanoTime();\nthis.stopTimeMillis=System.currentTimeMillis();\nthis.runningState=State.SUSPENDED;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * <p>\n     * Creates a suspended StopWatch object which appears to have elapsed for the requested amount of time in\n     * nanoseconds.\n     * <p>\n     * <p>\n     *\n     * <pre>\n     * // Create a mock StopWatch with a time of 2:59:01.999\n     * final long nanos = TimeUnit.HOURS.toNanos(2)\n     *         + TimeUnit.MINUTES.toNanos(59)\n     *         + TimeUnit.SECONDS.toNanos(1)\n     *         + TimeUnit.MILLISECONDS.toNanos(999);\n     * final StopWatch watch = createMockStopWatch(nanos);\n     * </pre>\n     *\n     * @param nanos Time in nanoseconds to have elapsed on the stop watch\n     * @return StopWatch in a suspended state with the elapsed time\n     */\n    private StopWatch createMockStopWatch(final long nanos) {\n        final StopWatch watch = StopWatch.createStarted();\n        watch.suspend();\n        return set(watch, nanos);\n    }\nprivate StopWatch set(final StopWatch watch, final long nanos) {\n        try {\n            final long currentNanos = System.nanoTime();\n            FieldUtils.writeField(watch, \"startTimeNanos\", currentNanos - nanos, true);\n            FieldUtils.writeField(watch, \"stopTimeNanos\", currentNanos, true);\n        } catch (final IllegalAccessException e) {\n            return null;\n        }\n        return watch;\n    }",
        "diffSourceCode": "    53:     /**\n    54:      * <p>\n    55:      * Creates a suspended StopWatch object which appears to have elapsed for the requested amount of time in\n    56:      * nanoseconds.\n    57:      * <p>\n    58:      * <p>\n    59:      *\n    60:      * <pre>\n    61:      * // Create a mock StopWatch with a time of 2:59:01.999\n    62:      * final long nanos = TimeUnit.HOURS.toNanos(2)\n    63:      *         + TimeUnit.MINUTES.toNanos(59)\n    64:      *         + TimeUnit.SECONDS.toNanos(1)\n    65:      *         + TimeUnit.MILLISECONDS.toNanos(999);\n    66:      * final StopWatch watch = createMockStopWatch(nanos);\n    67:      * </pre>\n    68:      *\n    69:      * @param nanos Time in nanoseconds to have elapsed on the stop watch\n    70:      * @return StopWatch in a suspended state with the elapsed time\n    71:      */\n    72:     private StopWatch createMockStopWatch(final long nanos) {\n    73:         final StopWatch watch = StopWatch.createStarted();\n    74:         watch.suspend();\n-   75:         try {\n-   76:             final long currentNanos = System.nanoTime();\n-   77:             FieldUtils.writeField(watch, \"startTimeNanos\", currentNanos - nanos, true);\n-   78:             FieldUtils.writeField(watch, \"stopTimeNanos\", currentNanos, true);\n-   79:         } catch (final IllegalAccessException e) {\n-   80:             return null;\n-   81:         }\n-   82:         return watch;\n-   83:     }\n-   84: \n-   85:     private void sleep(final Duration duration) throws InterruptedException {\n-   86:         ThreadUtils.sleep(duration);\n+   75:         return set(watch, nanos);\n+   76:     }\n+   77: \n+   78:     private StopWatch set(final StopWatch watch, final long nanos) {\n+   79:         try {\n+   80:             final long currentNanos = System.nanoTime();\n+   81:             FieldUtils.writeField(watch, \"startTimeNanos\", currentNanos - nanos, true);\n+   82:             FieldUtils.writeField(watch, \"stopTimeNanos\", currentNanos, true);\n+   83:         } catch (final IllegalAccessException e) {\n+   84:             return null;\n+   85:         }\n+   86:         return watch;\n    87:     }\n",
        "uniqueId": "2875a65756da4c72e8d188555b9639857e73684a_53_83_78_87_53_76",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": true,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n/**\n * Creates a suspended StopWatch object with the given elapsed time in nanoseconds.\n *\n * @param nanos Time in nanoseconds to have elapsed on the stop watch\n * @return StopWatch in a suspended state with the elapsed time\n */\nprivate StopWatch createMockStopWatch(final long nanos) {\n    final StopWatch watch = StopWatch.createStarted();\n    watch.suspend();\n    setStopWatchTime(watch, nanos);\n    return watch;\n}\n\n/**\n * Sets the start and stop time of the StopWatch based on the elapsed time in nanoseconds.\n *\n * @param watch StopWatch object to set the time for\n * @param nanos Time in nanoseconds to have elapsed on the stop watch\n */\nprivate void setStopWatchTime(StopWatch watch, long nanos) {\n    try {\n        final long currentNanos = System.nanoTime();\n        FieldUtils.writeField(watch, \"startTimeNanos\", currentNanos - nanos, true);\n        FieldUtils.writeField(watch, \"stopTimeNanos\", currentNanos, true);\n    } catch (final IllegalAccessException e) {\n        e.printStackTrace();\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * <p>\n     * Creates a suspended StopWatch object which appears to have elapsed for the requested amount of time in\n     * nanoseconds.\n     * <p>\n     * <p>\n     *\n     * <pre>\n     * // Create a mock StopWatch with a time of 2:59:01.999\n     * final long nanos = TimeUnit.HOURS.toNanos(2)\n     *         + TimeUnit.MINUTES.toNanos(59)\n     *         + TimeUnit.SECONDS.toNanos(1)\n     *         + TimeUnit.MILLISECONDS.toNanos(999);\n     * final StopWatch watch = createMockStopWatch(nanos);\n     * </pre>\n     *\n     * @param nanos Time in nanoseconds to have elapsed on the stop watch\n     * @return StopWatch in a suspended state with the elapsed time\n     */\n    private StopWatch createMockStopWatch(final long nanos) {\n        final StopWatch watch = StopWatch.createStarted();\n        watch.suspend();\n        try {\n            final long currentNanos = System.nanoTime();\n            FieldUtils.writeField(watch, \"startTimeNanos\", currentNanos - nanos, true);\n            FieldUtils.writeField(watch, \"stopTimeNanos\", currentNanos, true);\n        } catch (final IllegalAccessException e) {\n            return null;\n        }\n        return watch;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.time;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.allOf;\nimport static org.hamcrest.Matchers.greaterThanOrEqualTo;\nimport static org.hamcrest.Matchers.lessThan;\nimport static org.hamcrest.Matchers.lessThanOrEqualTo;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.startsWith;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link StopWatch}.\n */\npublic class StopWatchTest extends AbstractLangTest {\n\n    private static final Duration MILLIS_200 = Duration.ofMillis(200);\n    private static final Duration MILLIS_550 = Duration.ofMillis(550);\n    private static final String MESSAGE = \"Baking cookies\";\n    private static final Duration MIN_SLEEP = Duration.ofMillis(20);\n    private static final String ZERO_HOURS_PREFIX = \"00:\";\n    private static final String ZERO_TIME_ELAPSED = \"00:00:00.000\";\n\n    /**\n     * <p>\n     * Creates a suspended StopWatch object which appears to have elapsed for the requested amount of time in\n     * nanoseconds.\n     * <p>\n     * <p>\n     *\n     * <pre>\n     * // Create a mock StopWatch with a time of 2:59:01.999\n     * final long nanos = TimeUnit.HOURS.toNanos(2)\n     *         + TimeUnit.MINUTES.toNanos(59)\n     *         + TimeUnit.SECONDS.toNanos(1)\n     *         + TimeUnit.MILLISECONDS.toNanos(999);\n     * final StopWatch watch = createMockStopWatch(nanos);\n     * </pre>\n     *\n     * @param nanos Time in nanoseconds to have elapsed on the stop watch\n     * @return StopWatch in a suspended state with the elapsed time\n     */\n    private StopWatch createMockStopWatch(final long nanos) {\n        final StopWatch watch = StopWatch.createStarted();\n        watch.suspend();\n        try {\n            final long currentNanos = System.nanoTime();\n            FieldUtils.writeField(watch, \"startTimeNanos\", currentNanos - nanos, true);\n            FieldUtils.writeField(watch, \"stopTimeNanos\", currentNanos, true);\n        } catch (final IllegalAccessException e) {\n            return null;\n        }\n        return watch;\n    }\n\n    private void sleep(final Duration duration) throws InterruptedException {\n        ThreadUtils.sleep(duration);\n    }\n\n    // test bad states\n    @Test\n    public void testBadStates() {\n        final StopWatch watch = new StopWatch();\n        assertThrows(IllegalStateException.class, watch::stop,\n            \"Calling stop on an unstarted StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::suspend,\n            \"Calling suspend on an unstarted StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::split,\n            \"Calling split on a non-running StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::unsplit,\n            \"Calling unsplit on an unsplit StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::resume,\n            \"Calling resume on an unsuspended StopWatch should throw an exception. \");\n\n        watch.start();\n\n        assertThrows(IllegalStateException.class, watch::start,\n            \"Calling start on a started StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::unsplit,\n            \"Calling unsplit on an unsplit StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::getSplitTime,\n            \"Calling getSplitTime on an unsplit StopWatch should throw an exception. \");\n\n        assertThrows(IllegalStateException.class, watch::resume,\n            \"Calling resume on an unsuspended StopWatch should throw an exception. \");\n\n        watch.stop();\n\n        assertThrows(IllegalStateException.class, watch::start,\n            \"Calling start on a stopped StopWatch should throw an exception as it needs to be reset. \");\n    }\n\n    @Test\n    public void testBooleanStates() {\n        final StopWatch watch = new StopWatch();\n        assertFalse(watch.isStarted());\n        assertFalse(watch.isSuspended());\n        assertTrue(watch.isStopped());\n\n        watch.start();\n        assertTrue(watch.isStarted());\n        assertFalse(watch.isSuspended());\n        assertFalse(watch.isStopped());\n\n        watch.suspend();\n        assertTrue(watch.isStarted());\n        assertTrue(watch.isSuspended());\n        assertFalse(watch.isStopped());\n\n        watch.stop();\n        assertFalse(watch.isStarted());\n        assertFalse(watch.isSuspended());\n        assertTrue(watch.isStopped());\n    }\n\n    @Test\n    public void testFormatSplitTime() {\n        final StopWatch watch = StopWatch.createStarted();\n        ThreadUtils.sleepQuietly(MIN_SLEEP);\n        watch.split();\n        final String formatSplitTime = watch.formatSplitTime();\n        assertNotEquals(ZERO_TIME_ELAPSED, formatSplitTime);\n        assertThat(\"formatSplitTime\", formatSplitTime, startsWith(ZERO_HOURS_PREFIX));\n    }\n\n    @Test\n    public void testFormatSplitTimeWithMessage() {\n        final StopWatch watch = new StopWatch(MESSAGE);\n        watch.start();\n        ThreadUtils.sleepQuietly(MIN_SLEEP);\n        watch.split();\n        final String formatSplitTime = watch.formatSplitTime();\n        assertThat(\"formatSplitTime\", formatSplitTime, not(startsWith(MESSAGE)));\n        assertThat(\"formatSplitTime\", formatSplitTime, startsWith(ZERO_HOURS_PREFIX));\n    }\n\n    @Test\n    public void testFormatTime() {\n        final StopWatch watch = StopWatch.create();\n        final String formatTime = watch.formatTime();\n        assertEquals(ZERO_TIME_ELAPSED, formatTime);\n        assertThat(\"formatTime\", formatTime, startsWith(ZERO_HOURS_PREFIX));\n    }\n\n    @Test\n    public void testFormatTimeWithMessage() {\n        final StopWatch watch = new StopWatch(MESSAGE);\n        final String formatTime = watch.formatTime();\n        assertThat(\"formatTime\", formatTime, not(startsWith(MESSAGE)));\n    }\n\n    @Test\n    public void testGetStartTime() {\n        final long beforeStopWatchMillis = System.currentTimeMillis();\n        final StopWatch watch = new StopWatch();\n        assertThrows(IllegalStateException.class, watch::getStartTime,\n            \"Calling getStartTime on an unstarted StopWatch should throw an exception\");\n        watch.start();\n\n        watch.getStartTime();\n        assertThat(\"getStartTime\", watch.getStartTime(), greaterThanOrEqualTo(beforeStopWatchMillis));\n\n        watch.reset();\n        assertThrows(IllegalStateException.class, watch::getStartTime,\n            \"Calling getStartTime on a reset, but unstarted StopWatch should throw an exception\");\n    }\n\n    @Test\n    public void testLang315() throws InterruptedException {\n        final StopWatch watch = StopWatch.createStarted();\n        sleep(MILLIS_200);\n        watch.suspend();\n        final long suspendTime = watch.getTime();\n        sleep(MILLIS_200);\n        watch.stop();\n        final long totalTime = watch.getTime();\n        assertEquals(suspendTime, totalTime);\n    }\n\n    @Test\n    public void testMessage() {\n        assertNull(StopWatch.create().getMessage());\n        final StopWatch stopWatch = new StopWatch(MESSAGE);\n        assertEquals(MESSAGE, stopWatch.getMessage());\n        assertThat(\"stopWatch.toString\", stopWatch.toString(), startsWith(MESSAGE));\n        stopWatch.start();\n        stopWatch.split();\n        assertThat(\"stopWatch.toSplitString\", stopWatch.toSplitString(), startsWith(MESSAGE));\n    }\n\n    @Test\n    public void testStopTimeSimple() throws InterruptedException {\n        final StopWatch watch = StopWatch.createStarted();\n        final long testStartMillis = System.currentTimeMillis();\n        sleep(MILLIS_550);\n        watch.stop();\n        final long testEndMillis = System.currentTimeMillis();\n        final long stopTime = watch.getStopTime();\n        assertEquals(stopTime, watch.getStopTime());\n\n        assertThat(\"stopTime\", stopTime, allOf(greaterThanOrEqualTo(testStartMillis), lessThanOrEqualTo(testEndMillis)));\n    }\n\n    @Test\n    public void testStopWatchGetWithTimeUnit() {\n        // Create a mock StopWatch with a time of 2:59:01.999\n        // @formatter:off\n        final StopWatch watch = createMockStopWatch(\n            TimeUnit.HOURS.toNanos(2)\n                    + TimeUnit.MINUTES.toNanos(59)\n                    + TimeUnit.SECONDS.toNanos(1)\n                    + TimeUnit.MILLISECONDS.toNanos(999));\n        // @formatter:on\n\n        assertEquals(2L, watch.getTime(TimeUnit.HOURS));\n        assertEquals(179L, watch.getTime(TimeUnit.MINUTES));\n        assertEquals(10741L, watch.getTime(TimeUnit.SECONDS));\n        assertEquals(10741999L, watch.getTime(TimeUnit.MILLISECONDS));\n    }\n\n    @Test\n    public void testStopWatchSimple() throws InterruptedException {\n        final StopWatch watch = StopWatch.createStarted();\n        sleep(MILLIS_550);\n        watch.stop();\n        final long time = watch.getTime();\n        assertEquals(time, watch.getTime());\n\n        assertThat(\"time\", time, allOf(greaterThanOrEqualTo(500L), lessThan(2000L)));\n\n        watch.reset();\n        assertEquals(0, watch.getTime());\n    }\n\n    @Test\n    public void testStopWatchSimpleGet() throws InterruptedException {\n        final StopWatch watch = new StopWatch();\n        assertEquals(0, watch.getTime());\n        assertEquals(ZERO_TIME_ELAPSED, watch.toString());\n\n        watch.start();\n        sleep(MILLIS_550);\n        assertThat(\"watch.getTime()\", watch.getTime(), lessThan(2000L));\n    }\n\n    @Test\n    public void testStopWatchSplit() throws InterruptedException {\n        final StopWatch watch = StopWatch.createStarted();\n        sleep(MILLIS_550);\n        // slept ~550 millis\n        watch.split();\n        final long splitTime = watch.getSplitTime();\n        final String splitStr = watch.toSplitString();\n        sleep(MILLIS_550);\n        // slept ~1100 millis\n        watch.unsplit();\n        sleep(MILLIS_550);\n        // slept ~1650 millis\n        watch.stop();\n        final long totalTime = watch.getTime();\n\n        assertEquals(12, splitStr.length(), \"Formatted split string not the correct length\");\n        assertThat(\"splitTime\", splitTime, allOf(greaterThanOrEqualTo(500L), lessThan(1000L)));\n        assertThat(\"totalTime\", totalTime, allOf(greaterThanOrEqualTo(1500L), lessThan(2100L)));\n    }\n\n    @Test\n    public void testStopWatchStatic() {\n        final StopWatch watch = StopWatch.createStarted();\n        assertTrue(watch.isStarted());\n    }\n\n    @Test\n    public void testStopWatchSuspend() throws InterruptedException {\n        // Watch out comparing measurements from System.currentTimeMillis() vs. System.nanoTime()\n        final StopWatch watch = StopWatch.createStarted();\n        final long testStartMillis = System.currentTimeMillis();\n        final long testStartNanos = System.nanoTime();\n        sleep(MILLIS_550);\n        watch.suspend();\n        final long testSuspendMillis = System.currentTimeMillis();\n        final long testSuspendNanos = System.nanoTime();\n        final long testSuspendTimeNanos = testSuspendNanos - testStartNanos;\n        final long suspendTimeFromNanos = watch.getTime();\n        final long stopTimeMillis = watch.getStopTime();\n\n        assertThat(\"testStartMillis <= stopTimeMillis\", testStartMillis, lessThanOrEqualTo(stopTimeMillis));\n        assertThat(\"testSuspendMillis <= stopTimeMillis\", testSuspendMillis, lessThanOrEqualTo(stopTimeMillis));\n\n        sleep(MILLIS_550);\n        watch.resume();\n        sleep(MILLIS_550);\n        watch.stop();\n        final long totalTimeFromNanos = watch.getTime();\n\n        assertThat(\"suspendTimeFromNanos\", suspendTimeFromNanos, greaterThanOrEqualTo(500L));\n        assertThat(\"suspendTimeFromNanos <= testSuspendTimeNanos\", suspendTimeFromNanos, lessThanOrEqualTo(testSuspendTimeNanos));\n        assertThat(\"totalTimeFromNanos\", totalTimeFromNanos, greaterThanOrEqualTo(1000L));\n        // Be lenient for slow running builds\n        assertThat(\"totalTimeFromNanos\", totalTimeFromNanos, lessThan(2500L));\n    }\n\n    @Test\n    public void testToSplitString() throws InterruptedException {\n        final StopWatch watch = StopWatch.createStarted();\n        sleep(MILLIS_550);\n        watch.split();\n        final String splitStr = watch.toSplitString();\n        assertEquals(12, splitStr.length(), \"Formatted split string not the correct length\");\n    }\n\n    @Test\n    public void testToSplitStringWithMessage() throws InterruptedException {\n        final StopWatch watch = new StopWatch(MESSAGE);\n        watch.start();\n        sleep(MILLIS_550);\n        watch.split();\n        final String splitStr = watch.toSplitString();\n        assertEquals(12 + MESSAGE.length() + 1, splitStr.length(), \"Formatted split string not the correct length\");\n    }\n\n    @Test\n    public void testToString() throws InterruptedException {\n        //\n        final StopWatch watch = StopWatch.createStarted();\n        sleep(MILLIS_550);\n        watch.split();\n        final String splitStr = watch.toString();\n        assertEquals(12, splitStr.length(), \"Formatted split string not the correct length\");\n    }\n\n    @Test\n    public void testToStringWithMessage() throws InterruptedException {\n        assertThat(\"message\", new StopWatch(MESSAGE).toString(), startsWith(MESSAGE));\n        //\n        final StopWatch watch = new StopWatch(MESSAGE);\n        watch.start();\n        sleep(MILLIS_550);\n        watch.split();\n        final String splitStr = watch.toString();\n        assertEquals(12 + MESSAGE.length() + 1, splitStr.length(), \"Formatted split string not the correct length\");\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": "/**\n * Creates a suspended StopWatch object with the given elapsed time in nanoseconds.\n *\n * @param nanos Time in nanoseconds to have elapsed on the stop watch\n * @return StopWatch in a suspended state with the elapsed time\n */\nprivate StopWatch createMockStopWatch(final long nanos) {\n    final StopWatch watch = StopWatch.createStarted();\n    watch.suspend();\n    setStopWatchTime(watch, nanos);\n    return watch;\n}\n\n/**\n * Sets the start and stop time of the StopWatch based on the elapsed time in nanoseconds.\n *\n * @param watch StopWatch object to set the time for\n * @param nanos Time in nanoseconds to have elapsed on the stop watch\n */\nprivate void setStopWatchTime(StopWatch watch, long nanos) {\n    try {\n        final long currentNanos = System.nanoTime();\n        FieldUtils.writeField(watch, \"startTimeNanos\", currentNanos - nanos, true);\n        FieldUtils.writeField(watch, \"stopTimeNanos\", currentNanos, true);\n    } catch (final IllegalAccessException e) {\n        e.printStackTrace();\n    }\n}",
        "codebleu": 0.6915250987400458,
        "ngram_match_score": 0.518082845172885,
        "syntax_match_score": 0.7692307692307693,
        "weighted_ngram_match_score": 0.5172483190180669,
        "dataflow_match_score": 0.9615384615384616
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpackage getPrimitiveClass(className String) : Class<?> extracted from public getClass(classLoader ClassLoader, className String, initialize boolean) : Class<?> in class org.apache.commons.lang3.ClassUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/ClassUtils.java",
                "startLine": 517,
                "endLine": 548,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/ClassUtils.java",
                "startLine": 517,
                "endLine": 548,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/ClassUtils.java",
                "startLine": 753,
                "endLine": 761,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Returns the class represented by {@code className} using the {@code classLoader}. This implementation supports the\n     * syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\", \"{@code [Ljava.util.Map.Entry;}\", and\n     * \"{@code [Ljava.util.Map$Entry;}\".\n     *\n     * @param classLoader the class loader to use to load the class\n     * @param className the class name\n     * @param initialize whether the class must be initialized\n     * @return the class represented by {@code className} using the {@code classLoader}\n     * @throws NullPointerException if the className is null\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {\n        try {\n            final Class<?> clazz = namePrimitiveMap.get(className);\n            return clazz != null ? clazz : Class.forName(toCanonicalName(className), initialize, classLoader);\n        } catch (final ClassNotFoundException ex) {\n            // allow path separators (.) as inner class name separators\n            final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n\n            if (lastDotIndex != -1) {\n                try {\n                    return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1),\n                        initialize);\n                } catch (final ClassNotFoundException ignored) {\n                    // ignore exception\n                }\n            }\n\n            throw ex;\n        }\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/ClassUtils.java",
        "isPureRefactoring": true,
        "commitId": "45a955702a06d817aa18007a9b099c37ee2ec20a",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.ClassUtils",
        "methodNameBefore": "org.apache.commons.lang3.ClassUtils#getClass",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.ClassUtils#toCanonicalName\n methodBody: private static String toCanonicalName(final String className) {\nString canonicalName=StringUtils.deleteWhitespace(className);\nObjects.requireNonNull(canonicalName,\"className\");\nif(canonicalName.endsWith(\"[]\")){final StringBuilder classNameBuffer=new StringBuilder();\nwhile(canonicalName.endsWith(\"[]\")){canonicalName=canonicalName.substring(0,canonicalName.length() - 2);\nclassNameBuffer.append(\"[\");\n}final String abbreviation=abbreviationMap.get(canonicalName);\nif(abbreviation != null){classNameBuffer.append(abbreviation);\n}{classNameBuffer.append(\"L\").append(canonicalName).append(\";\");\n}canonicalName=classNameBuffer.toString();\n}return canonicalName;\n}\nmethodSignature: org.apache.commons.lang3.ClassUtils#getClass\n methodBody: public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {\nfinal ClassLoader contextCL=Thread.currentThread().getContextClassLoader();\nfinal ClassLoader loader=contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\nreturn getClass(loader,className,initialize);\n}",
        "classSignatureBefore": "public class ClassUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.ClassUtils#getClass"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.ClassUtils"
        ],
        "classSignatureBeforeSet": [
            "public class ClassUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.lang3.mutable.MutableObject;\n\n/**\n * Operates on classes without using reflection.\n *\n * <p>\n * This class handles invalid {@code null} inputs as best it can. Each method documents its behavior in more detail.\n * </p>\n *\n * <p>\n * The notion of a {@code canonical name} includes the human readable name for the type, for example {@code int[]}. The\n * non-canonical method variants work with the JVM names, such as {@code [I}.\n * </p>\n *\n * @since 2.0\n */\npublic class ClassUtils {\n\n    /**\n     * Inclusivity literals for {@link #hierarchy(Class, Interfaces)}.\n     *\n     * @since 3.2\n     */\n    public enum Interfaces {\n\n        /** Includes interfaces. */\n        INCLUDE,\n\n        /** Excludes interfaces. */\n        EXCLUDE\n    }\n\n    private static final Comparator<Class<?>> COMPARATOR = (o1, o2) -> Objects.compare(getName(o1), getName(o2), String::compareTo);\n\n    /**\n     * The package separator character: {@code '&#x2e;' == {@value}}.\n     */\n    public static final char PACKAGE_SEPARATOR_CHAR = '.';\n\n    /**\n     * The package separator String: {@code \"&#x2e;\"}.\n     */\n    public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR);\n\n    /**\n     * The inner class separator character: {@code '$' == {@value}}.\n     */\n    public static final char INNER_CLASS_SEPARATOR_CHAR = '$';\n\n    /**\n     * The inner class separator String: {@code \"$\"}.\n     */\n    public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR);\n\n    /**\n     * Maps names of primitives to their corresponding primitive {@link Class}es.\n     */\n    private static final Map<String, Class<?>> namePrimitiveMap = new HashMap<>();\n\n    static {\n        namePrimitiveMap.put(Boolean.TYPE.getSimpleName(), Boolean.TYPE);\n        namePrimitiveMap.put(Byte.TYPE.getSimpleName(), Byte.TYPE);\n        namePrimitiveMap.put(Character.TYPE.getSimpleName(), Character.TYPE);\n        namePrimitiveMap.put(Double.TYPE.getSimpleName(), Double.TYPE);\n        namePrimitiveMap.put(Float.TYPE.getSimpleName(), Float.TYPE);\n        namePrimitiveMap.put(Integer.TYPE.getSimpleName(), Integer.TYPE);\n        namePrimitiveMap.put(Long.TYPE.getSimpleName(), Long.TYPE);\n        namePrimitiveMap.put(Short.TYPE.getSimpleName(), Short.TYPE);\n        namePrimitiveMap.put(Void.TYPE.getSimpleName(), Void.TYPE);\n    }\n\n    /**\n     * Maps primitive {@link Class}es to their corresponding wrapper {@link Class}.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<>();\n\n    static {\n        primitiveWrapperMap.put(Boolean.TYPE, Boolean.class);\n        primitiveWrapperMap.put(Byte.TYPE, Byte.class);\n        primitiveWrapperMap.put(Character.TYPE, Character.class);\n        primitiveWrapperMap.put(Short.TYPE, Short.class);\n        primitiveWrapperMap.put(Integer.TYPE, Integer.class);\n        primitiveWrapperMap.put(Long.TYPE, Long.class);\n        primitiveWrapperMap.put(Double.TYPE, Double.class);\n        primitiveWrapperMap.put(Float.TYPE, Float.class);\n        primitiveWrapperMap.put(Void.TYPE, Void.TYPE);\n    }\n\n    /**\n     * Maps wrapper {@link Class}es to their corresponding primitive types.\n     */\n    private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<>();\n\n    static {\n        primitiveWrapperMap.forEach((primitiveClass, wrapperClass) -> {\n            if (!primitiveClass.equals(wrapperClass)) {\n                wrapperPrimitiveMap.put(wrapperClass, primitiveClass);\n            }\n        });\n    }\n\n    /**\n     * Maps a primitive class name to its corresponding abbreviation used in array class names.\n     */\n    private static final Map<String, String> abbreviationMap;\n\n    /**\n     * Maps an abbreviation used in array class names to corresponding primitive class name.\n     */\n    private static final Map<String, String> reverseAbbreviationMap;\n\n    /** Feed abbreviation maps. */\n    static {\n        final Map<String, String> map = new HashMap<>();\n        map.put(\"int\", \"I\");\n        map.put(\"boolean\", \"Z\");\n        map.put(\"float\", \"F\");\n        map.put(\"long\", \"J\");\n        map.put(\"short\", \"S\");\n        map.put(\"byte\", \"B\");\n        map.put(\"double\", \"D\");\n        map.put(\"char\", \"C\");\n        abbreviationMap = Collections.unmodifiableMap(map);\n        reverseAbbreviationMap = Collections.unmodifiableMap(map.entrySet().stream().collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey)));\n    }\n\n    /**\n     * Gets the class comparator, comparing by class name.\n     *\n     * @return the class comparator.\n     * @since 3.13.0\n     */\n    public static Comparator<Class<?>> comparator() {\n        return COMPARATOR;\n    }\n\n    /**\n     * Given a {@link List} of {@link Class} objects, this method converts them into class names.\n     *\n     * <p>\n     * A new {@link List} is returned. {@code null} objects will be copied into the returned list as {@code null}.\n     * </p>\n     *\n     * @param classes the classes to change\n     * @return a {@link List} of class names corresponding to the Class objects, {@code null} if null input\n     * @throws ClassCastException if {@code classes} contains a non-{@link Class} entry\n     */\n    public static List<String> convertClassesToClassNames(final List<Class<?>> classes) {\n        return classes == null ? null : classes.stream().map(e -> getName(e, null)).collect(Collectors.toList());\n    }\n\n    /**\n     * Given a {@link List} of class names, this method converts them into classes.\n     *\n     * <p>\n     * A new {@link List} is returned. If the class name cannot be found, {@code null} is stored in the {@link List}. If the\n     * class name in the {@link List} is {@code null}, {@code null} is stored in the output {@link List}.\n     * </p>\n     *\n     * @param classNames the classNames to change\n     * @return a {@link List} of Class objects corresponding to the class names, {@code null} if null input\n     * @throws ClassCastException if classNames contains a non String entry\n     */\n    public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) {\n        if (classNames == null) {\n            return null;\n        }\n        final List<Class<?>> classes = new ArrayList<>(classNames.size());\n        classNames.forEach(className -> {\n            try {\n                classes.add(Class.forName(className));\n            } catch (final Exception ex) {\n                classes.add(null);\n            }\n        });\n        return classes;\n    }\n\n    /**\n     * Gets the abbreviated name of a {@link Class}.\n     *\n     * @param cls the class to get the abbreviated name for, may be {@code null}\n     * @param lengthHint the desired length of the abbreviated name\n     * @return the abbreviated name or an empty string\n     * @throws IllegalArgumentException if len &lt;= 0\n     * @see #getAbbreviatedName(String, int)\n     * @since 3.4\n     */\n    public static String getAbbreviatedName(final Class<?> cls, final int lengthHint) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getAbbreviatedName(cls.getName(), lengthHint);\n    }\n\n    /**\n     * Gets the abbreviated class name from a {@link String}.\n     *\n     * <p>\n     * The string passed in is assumed to be a class name - it is not checked.\n     * </p>\n     *\n     * <p>\n     * The abbreviation algorithm will shorten the class name, usually without significant loss of meaning.\n     * </p>\n     *\n     * <p>\n     * The abbreviated class name will always include the complete package hierarchy. If enough space is available,\n     * rightmost sub-packages will be displayed in full length. The abbreviated package names will be shortened to a single\n     * character.\n     * </p>\n     * <p>\n     * Only package names are shortened, the class simple name remains untouched. (See examples.)\n     * </p>\n     * <p>\n     * The result will be longer than the desired length only if all the package names shortened to a single character plus\n     * the class simple name with the separating dots together are longer than the desired length. In other words, when the\n     * class name cannot be shortened to the desired length.\n     * </p>\n     * <p>\n     * If the class name can be shortened then the final length will be at most {@code lengthHint} characters.\n     * </p>\n     * <p>\n     * If the {@code lengthHint} is zero or negative then the method throws exception. If you want to achieve the shortest\n     * possible version then use {@code 1} as a {@code lengthHint}.\n     * </p>\n     *\n     * <table>\n     * <caption>Examples</caption>\n     * <tr>\n     * <td>className</td>\n     * <td>len</td>\n     * <td>return</td>\n     * </tr>\n     * <tr>\n     * <td>null</td>\n     * <td>1</td>\n     * <td>\"\"</td>\n     * </tr>\n     * <tr>\n     * <td>\"java.lang.String\"</td>\n     * <td>5</td>\n     * <td>\"j.l.String\"</td>\n     * </tr>\n     * <tr>\n     * <td>\"java.lang.String\"</td>\n     * <td>15</td>\n     * <td>\"j.lang.String\"</td>\n     * </tr>\n     * <tr>\n     * <td>\"java.lang.String\"</td>\n     * <td>30</td>\n     * <td>\"java.lang.String\"</td>\n     * </tr>\n     * <tr>\n     * <td>\"org.apache.commons.lang3.ClassUtils\"</td>\n     * <td>18</td>\n     * <td>\"o.a.c.l.ClassUtils\"</td>\n     * </tr>\n     * </table>\n     *\n     * @param className the className to get the abbreviated name for, may be {@code null}\n     * @param lengthHint the desired length of the abbreviated name\n     * @return the abbreviated name or an empty string if the specified class name is {@code null} or empty string. The\n     *         abbreviated name may be longer than the desired length if it cannot be abbreviated to the desired length.\n     * @throws IllegalArgumentException if {@code len <= 0}\n     * @since 3.4\n     */\n    public static String getAbbreviatedName(final String className, final int lengthHint) {\n        if (lengthHint <= 0) {\n            throw new IllegalArgumentException(\"len must be > 0\");\n        }\n        if (className == null) {\n            return StringUtils.EMPTY;\n        }\n        if (className.length() <= lengthHint) {\n            return className;\n        }\n        final char[] abbreviated = className.toCharArray();\n        int target = 0;\n        int source = 0;\n        while (source < abbreviated.length) {\n            // copy the next part\n            int runAheadTarget = target;\n            while (source < abbreviated.length && abbreviated[source] != '.') {\n                abbreviated[runAheadTarget++] = abbreviated[source++];\n            }\n\n            ++target;\n            if (useFull(runAheadTarget, source, abbreviated.length, lengthHint) || target > runAheadTarget) {\n                target = runAheadTarget;\n            }\n\n            // copy the '.' unless it was the last part\n            if (source < abbreviated.length) {\n                abbreviated[target++] = abbreviated[source++];\n            }\n        }\n        return new String(abbreviated, 0, target);\n    }\n\n    /**\n     * Gets a {@link List} of all interfaces implemented by the given class and its superclasses.\n     *\n     * <p>\n     * The order is determined by looking through each interface in turn as declared in the source file and following its\n     * hierarchy up. Then each superclass is considered in the same way. Later duplicates are ignored, so the order is\n     * maintained.\n     * </p>\n     *\n     * @param cls the class to look up, may be {@code null}\n     * @return the {@link List} of interfaces in order, {@code null} if null input\n     */\n    public static List<Class<?>> getAllInterfaces(final Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n\n        final LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<>();\n        getAllInterfaces(cls, interfacesFound);\n\n        return new ArrayList<>(interfacesFound);\n    }\n\n    /**\n     * Gets the interfaces for the specified class.\n     *\n     * @param cls the class to look up, may be {@code null}\n     * @param interfacesFound the {@link Set} of interfaces for the class\n     */\n    private static void getAllInterfaces(Class<?> cls, final HashSet<Class<?>> interfacesFound) {\n        while (cls != null) {\n            final Class<?>[] interfaces = cls.getInterfaces();\n\n            for (final Class<?> i : interfaces) {\n                if (interfacesFound.add(i)) {\n                    getAllInterfaces(i, interfacesFound);\n                }\n            }\n\n            cls = cls.getSuperclass();\n        }\n    }\n\n    /**\n     * Gets a {@link List} of superclasses for the given class.\n     *\n     * @param cls the class to look up, may be {@code null}\n     * @return the {@link List} of superclasses in order going up from this one {@code null} if null input\n     */\n    public static List<Class<?>> getAllSuperclasses(final Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n        final List<Class<?>> classes = new ArrayList<>();\n        Class<?> superclass = cls.getSuperclass();\n        while (superclass != null) {\n            classes.add(superclass);\n            superclass = superclass.getSuperclass();\n        }\n        return classes;\n    }\n\n    /**\n     * Gets the canonical class name for a {@link Class}.\n     *\n     * @param cls the class for which to get the canonical class name; may be null\n     * @return the canonical name of the class, or the empty String\n     * @since 3.7\n     * @see Class#getCanonicalName()\n     */\n    public static String getCanonicalName(final Class<?> cls) {\n        return getCanonicalName(cls, StringUtils.EMPTY);\n    }\n\n    /**\n     * Gets the canonical name for a {@link Class}.\n     *\n     * @param cls the class for which to get the canonical class name; may be null\n     * @param valueIfNull the return value if null\n     * @return the canonical name of the class, or {@code valueIfNull}\n     * @since 3.7\n     * @see Class#getCanonicalName()\n     */\n    public static String getCanonicalName(final Class<?> cls, final String valueIfNull) {\n        if (cls == null) {\n            return valueIfNull;\n        }\n        final String canonicalName = cls.getCanonicalName();\n        return canonicalName == null ? valueIfNull : canonicalName;\n    }\n\n    /**\n     * Gets the canonical name for an {@link Object}.\n     *\n     * @param object the object for which to get the canonical class name; may be null\n     * @return the canonical name of the object, or the empty String\n     * @since 3.7\n     * @see Class#getCanonicalName()\n     */\n    public static String getCanonicalName(final Object object) {\n        return getCanonicalName(object, StringUtils.EMPTY);\n    }\n\n    /**\n     * Gets the canonical name for an {@link Object}.\n     *\n     * @param object the object for which to get the canonical class name; may be null\n     * @param valueIfNull the return value if null\n     * @return the canonical name of the object or {@code valueIfNull}\n     * @since 3.7\n     * @see Class#getCanonicalName()\n     */\n    public static String getCanonicalName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        final String canonicalName = object.getClass().getCanonicalName();\n        return canonicalName == null ? valueIfNull : canonicalName;\n    }\n\n    /**\n     * Converts a given name of class into canonical format. If name of class is not a name of array class it returns\n     * unchanged name.\n     *\n     * <p>\n     * The method does not change the {@code $} separators in case the class is inner class.\n     * </p>\n     *\n     * <p>\n     * Example:\n     * <ul>\n     * <li>{@code getCanonicalName(\"[I\") = \"int[]\"}</li>\n     * <li>{@code getCanonicalName(\"[Ljava.lang.String;\") = \"java.lang.String[]\"}</li>\n     * <li>{@code getCanonicalName(\"java.lang.String\") = \"java.lang.String\"}</li>\n     * </ul>\n     * </p>\n     *\n     * @param className the name of class\n     * @return canonical form of class name\n     * @since 2.4\n     */\n    private static String getCanonicalName(String className) {\n        className = StringUtils.deleteWhitespace(className);\n        if (className == null) {\n            return null;\n        }\n        int dim = 0;\n        while (className.startsWith(\"[\")) {\n            dim++;\n            className = className.substring(1);\n        }\n        if (dim < 1) {\n            return className;\n        }\n        if (className.startsWith(\"L\")) {\n            className = className.substring(1, className.endsWith(\";\") ? className.length() - 1 : className.length());\n        } else if (!className.isEmpty()) {\n            className = reverseAbbreviationMap.get(className.substring(0, 1));\n        }\n        final StringBuilder canonicalClassNameBuffer = new StringBuilder(className);\n        for (int i = 0; i < dim; i++) {\n            canonicalClassNameBuffer.append(\"[]\");\n        }\n        return canonicalClassNameBuffer.toString();\n    }\n\n    /**\n     * Returns the (initialized) class represented by {@code className} using the {@code classLoader}. This implementation\n     * supports the syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\",\n     * \"{@code [Ljava.util.Map.Entry;}\", and \"{@code [Ljava.util.Map$Entry;}\".\n     *\n     * @param classLoader the class loader to use to load the class\n     * @param className the class name\n     * @return the class represented by {@code className} using the {@code classLoader}\n     * @throws NullPointerException if the className is null\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(final ClassLoader classLoader, final String className) throws ClassNotFoundException {\n        return getClass(classLoader, className, true);\n    }\n\n    /**\n     * Returns the class represented by {@code className} using the {@code classLoader}. This implementation supports the\n     * syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\", \"{@code [Ljava.util.Map.Entry;}\", and\n     * \"{@code [Ljava.util.Map$Entry;}\".\n     *\n     * @param classLoader the class loader to use to load the class\n     * @param className the class name\n     * @param initialize whether the class must be initialized\n     * @return the class represented by {@code className} using the {@code classLoader}\n     * @throws NullPointerException if the className is null\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {\n        try {\n            final Class<?> clazz = namePrimitiveMap.get(className);\n            return clazz != null ? clazz : Class.forName(toCanonicalName(className), initialize, classLoader);\n        } catch (final ClassNotFoundException ex) {\n            // allow path separators (.) as inner class name separators\n            final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n\n            if (lastDotIndex != -1) {\n                try {\n                    return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1),\n                        initialize);\n                } catch (final ClassNotFoundException ignored) {\n                    // ignore exception\n                }\n            }\n\n            throw ex;\n        }\n    }\n\n    /**\n     * Returns the (initialized) class represented by {@code className} using the current thread's context class loader.\n     * This implementation supports the syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\",\n     * \"{@code [Ljava.util.Map.Entry;}\", and \"{@code [Ljava.util.Map$Entry;}\".\n     *\n     * @param className the class name\n     * @return the class represented by {@code className} using the current thread's context class loader\n     * @throws NullPointerException if the className is null\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(final String className) throws ClassNotFoundException {\n        return getClass(className, true);\n    }\n\n    /**\n     * Returns the class represented by {@code className} using the current thread's context class loader. This\n     * implementation supports the syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\",\n     * \"{@code [Ljava.util.Map.Entry;}\", and \"{@code [Ljava.util.Map$Entry;}\".\n     *\n     * @param className the class name\n     * @param initialize whether the class must be initialized\n     * @return the class represented by {@code className} using the current thread's context class loader\n     * @throws NullPointerException if the className is null\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {\n        final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n        return getClass(loader, className, initialize);\n    }\n\n    /**\n     * Delegates to {@link Class#getComponentType()} using generics.\n     *\n     * @param <T> The array class type.\n     * @param cls A class or null.\n     * @return The array component type or null.\n     * @see Class#getComponentType()\n     * @since 3.13.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Class<T> getComponentType(final Class<T[]> cls) {\n        return cls == null ? null : (Class<T>) cls.getComponentType();\n    }\n\n    /**\n     * Null-safe version of {@code cls.getName()}\n     *\n     * @param cls the class for which to get the class name; may be null\n     * @return the class name or the empty string in case the argument is {@code null}\n     * @since 3.7\n     * @see Class#getSimpleName()\n     */\n    public static String getName(final Class<?> cls) {\n        return getName(cls, StringUtils.EMPTY);\n    }\n\n    /**\n     * Null-safe version of {@code cls.getName()}\n     *\n     * @param cls the class for which to get the class name; may be null\n     * @param valueIfNull the return value if the argument {@code cls} is {@code null}\n     * @return the class name or {@code valueIfNull}\n     * @since 3.7\n     * @see Class#getName()\n     */\n    public static String getName(final Class<?> cls, final String valueIfNull) {\n        return cls == null ? valueIfNull : cls.getName();\n    }\n\n    /**\n     * Null-safe version of {@code object.getClass().getName()}\n     *\n     * @param object the object for which to get the class name; may be null\n     * @return the class name or the empty String\n     * @since 3.7\n     * @see Class#getSimpleName()\n     */\n    public static String getName(final Object object) {\n        return getName(object, StringUtils.EMPTY);\n    }\n\n    /**\n     * Null-safe version of {@code object.getClass().getSimpleName()}\n     *\n     * @param object the object for which to get the class name; may be null\n     * @param valueIfNull the value to return if {@code object} is {@code null}\n     * @return the class name or {@code valueIfNull}\n     * @since 3.0\n     * @see Class#getName()\n     */\n    public static String getName(final Object object, final String valueIfNull) {\n        return object == null ? valueIfNull : object.getClass().getName();\n    }\n\n    /**\n     * Gets the package name from the canonical name of a {@link Class}.\n     *\n     * @param cls the class to get the package name for, may be {@code null}.\n     * @return the package name or an empty string\n     * @since 2.4\n     */\n    public static String getPackageCanonicalName(final Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageCanonicalName(cls.getName());\n    }\n\n    /**\n     * Gets the package name from the class name of an {@link Object}.\n     *\n     * @param object the class to get the package name for, may be null\n     * @param valueIfNull the value to return if null\n     * @return the package name of the object, or the null value\n     * @since 2.4\n     */\n    public static String getPackageCanonicalName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageCanonicalName(object.getClass().getName());\n    }\n\n    /**\n     * Gets the package name from the class name.\n     *\n     * <p>\n     * The string passed in is assumed to be a class name - it is not checked.\n     * </p>\n     * <p>\n     * If the class is in the default package, return an empty string.\n     * </p>\n     *\n     * @param name the name to get the package name for, may be {@code null}\n     * @return the package name or an empty string\n     * @since 2.4\n     */\n    public static String getPackageCanonicalName(final String name) {\n        return getPackageName(getCanonicalName(name));\n    }\n\n    /**\n     * Gets the package name of a {@link Class}.\n     *\n     * @param cls the class to get the package name for, may be {@code null}.\n     * @return the package name or an empty string\n     */\n    public static String getPackageName(final Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageName(cls.getName());\n    }\n\n    /**\n     * Gets the package name of an {@link Object}.\n     *\n     * @param object the class to get the package name for, may be null\n     * @param valueIfNull the value to return if null\n     * @return the package name of the object, or the null value\n     */\n    public static String getPackageName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageName(object.getClass());\n    }\n\n    /**\n     * Gets the package name from a {@link String}.\n     *\n     * <p>\n     * The string passed in is assumed to be a class name - it is not checked.\n     * </p>\n     * <p>\n     * If the class is unpackaged, return an empty string.\n     * </p>\n     *\n     * @param className the className to get the package name for, may be {@code null}\n     * @return the package name or an empty string\n     */\n    public static String getPackageName(String className) {\n        if (StringUtils.isEmpty(className)) {\n            return StringUtils.EMPTY;\n        }\n\n        // Strip array encoding\n        while (className.charAt(0) == '[') {\n            className = className.substring(1);\n        }\n        // Strip Object type encoding\n        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n            className = className.substring(1);\n        }\n\n        final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        if (i == -1) {\n            return StringUtils.EMPTY;\n        }\n        return className.substring(0, i);\n    }\n\n    /**\n     * Returns the desired Method much like {@code Class.getMethod}, however it ensures that the returned Method is from a\n     * public class or interface and not from an anonymous inner class. This means that the Method is invokable and doesn't\n     * fall foul of Java bug <a href=\"https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4071957\">4071957</a>).\n     *\n     * <pre>\n     *  <code>Set set = Collections.unmodifiableSet(...);\n     *  Method method = ClassUtils.getPublicMethod(set.getClass(), \"isEmpty\",  new Class[0]);\n     *  Object result = method.invoke(set, new Object[]);</code>\n     * </pre>\n     *\n     * @param cls the class to check, not null\n     * @param methodName the name of the method\n     * @param parameterTypes the list of parameters\n     * @return the method\n     * @throws NullPointerException if the class is null\n     * @throws SecurityException if a security violation occurred\n     * @throws NoSuchMethodException if the method is not found in the given class or if the method doesn't conform with the\n     *         requirements\n     */\n    public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws NoSuchMethodException {\n\n        final Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n        if (isPublic(declaredMethod.getDeclaringClass())) {\n            return declaredMethod;\n        }\n\n        final List<Class<?>> candidateClasses = new ArrayList<>(getAllInterfaces(cls));\n        candidateClasses.addAll(getAllSuperclasses(cls));\n\n        for (final Class<?> candidateClass : candidateClasses) {\n            if (!isPublic(candidateClass)) {\n                continue;\n            }\n            final Method candidateMethod;\n            try {\n                candidateMethod = candidateClass.getMethod(methodName, parameterTypes);\n            } catch (final NoSuchMethodException ex) {\n                continue;\n            }\n            if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {\n                return candidateMethod;\n            }\n        }\n\n        throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes));\n    }\n\n    /**\n     * Gets the canonical name minus the package name from a {@link Class}.\n     *\n     * @param cls the class for which to get the short canonical class name; may be null\n     * @return the canonical name without the package name or an empty string\n     * @since 2.4\n     * @see Class#getCanonicalName()\n     */\n    public static String getShortCanonicalName(final Class<?> cls) {\n        return cls == null ? StringUtils.EMPTY : getShortCanonicalName(cls.getCanonicalName());\n    }\n\n    /**\n     * Gets the canonical name minus the package name for an {@link Object}.\n     *\n     * @param object the class to get the short name for, may be null\n     * @param valueIfNull the value to return if null\n     * @return the canonical name of the object without the package name, or the null value\n     * @since 2.4\n     * @see Class#getCanonicalName()\n     */\n    public static String getShortCanonicalName(final Object object, final String valueIfNull) {\n        return object == null ? valueIfNull : getShortCanonicalName(object.getClass().getCanonicalName());\n    }\n\n    /**\n     * Gets the canonical name minus the package name from a String.\n     *\n     * <p>\n     * The string passed in is assumed to be a class name - it is not checked.\n     * </p>\n     *\n     * <p>\n     * Note that this method is mainly designed to handle the arrays and primitives properly. If the class is an inner class\n     * then the result value will not contain the outer classes. This way the behavior of this method is different from\n     * {@link #getShortClassName(String)}. The argument in that case is class name and not canonical name and the return\n     * value retains the outer classes.\n     * </p>\n     *\n     * <p>\n     * Note that there is no way to reliably identify the part of the string representing the package hierarchy and the part\n     * that is the outer class or classes in case of an inner class. Trying to find the class would require reflective call\n     * and the class itself may not even be on the class path. Relying on the fact that class names start with capital\n     * letter and packages with lower case is heuristic.\n     * </p>\n     *\n     * <p>\n     * It is recommended to use {@link #getShortClassName(String)} for cases when the class is an inner class and use this\n     * method for cases it is designed for.\n     * </p>\n     *\n     * <table>\n     * <caption>Examples</caption>\n     * <tr>\n     * <td>return value</td>\n     * <td>input</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"\"}</td>\n     * <td>{@code (String)null}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"Map.Entry\"}</td>\n     * <td>{@code java.util.Map.Entry.class.getName()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"Entry\"}</td>\n     * <td>{@code java.util.Map.Entry.class.getCanonicalName()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"ClassUtils\"}</td>\n     * <td>{@code \"org.apache.commons.lang3.ClassUtils\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"ClassUtils[]\"}</td>\n     * <td>{@code \"[Lorg.apache.commons.lang3.ClassUtils;\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"ClassUtils[][]\"}</td>\n     * <td>{@code \"[[Lorg.apache.commons.lang3.ClassUtils;\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"ClassUtils[]\"}</td>\n     * <td>{@code \"org.apache.commons.lang3.ClassUtils[]\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"ClassUtils[][]\"}</td>\n     * <td>{@code \"org.apache.commons.lang3.ClassUtils[][]\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[]\"}</td>\n     * <td>{@code \"[I\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[]\"}</td>\n     * <td>{@code int[].class.getCanonicalName()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[]\"}</td>\n     * <td>{@code int[].class.getName()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[][]\"}</td>\n     * <td>{@code \"[[I\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[]\"}</td>\n     * <td>{@code \"int[]\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[][]\"}</td>\n     * <td>{@code \"int[][]\"}</td>\n     * </tr>\n     * </table>\n     *\n     * @param canonicalName the class name to get the short name for\n     * @return the canonical name of the class without the package name or an empty string\n     * @since 2.4\n     */\n    public static String getShortCanonicalName(final String canonicalName) {\n        return getShortClassName(getCanonicalName(canonicalName));\n    }\n\n    /**\n     * Gets the class name minus the package name from a {@link Class}.\n     *\n     * <p>\n     * This method simply gets the name using {@code Class.getName()} and then calls {@link #getShortClassName(String)}. See\n     * relevant notes there.\n     * </p>\n     *\n     * @param cls the class to get the short name for.\n     * @return the class name without the package name or an empty string. If the class is an inner class then the returned\n     *         value will contain the outer class or classes separated with {@code .} (dot) character.\n     */\n    public static String getShortClassName(final Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortClassName(cls.getName());\n    }\n\n    /**\n     * Gets the class name of the {@code object} without the package name or names.\n     *\n     * <p>\n     * The method looks up the class of the object and then converts the name of the class invoking\n     * {@link #getShortClassName(Class)} (see relevant notes there).\n     * </p>\n     *\n     * @param object the class to get the short name for, may be {@code null}\n     * @param valueIfNull the value to return if the object is {@code null}\n     * @return the class name of the object without the package name, or {@code valueIfNull} if the argument {@code object}\n     *         is {@code null}\n     */\n    public static String getShortClassName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortClassName(object.getClass());\n    }\n\n    /**\n     * Gets the class name minus the package name from a String.\n     *\n     * <p>\n     * The string passed in is assumed to be a class name - it is not checked. The string has to be formatted the way as the\n     * JDK method {@code Class.getName()} returns it, and not the usual way as we write it, for example in import\n     * statements, or as it is formatted by {@code Class.getCanonicalName()}.\n     * </p>\n     *\n     * <p>\n     * The difference is is significant only in case of classes that are inner classes of some other classes. In this case\n     * the separator between the outer and inner class (possibly on multiple hierarchy level) has to be {@code $} (dollar\n     * sign) and not {@code .} (dot), as it is returned by {@code Class.getName()}\n     * </p>\n     *\n     * <p>\n     * Note that this method is called from the {@link #getShortClassName(Class)} method using the string returned by\n     * {@code Class.getName()}.\n     * </p>\n     *\n     * <p>\n     * Note that this method differs from {@link #getSimpleName(Class)} in that this will return, for example\n     * {@code \"Map.Entry\"} whilst the {@link Class} variant will simply return {@code \"Entry\"}. In this example\n     * the argument {@code className} is the string {@code java.util.Map$Entry} (note the {@code $} sign.\n     * </p>\n     *\n     * @param className the className to get the short name for. It has to be formatted as returned by\n     *        {@code Class.getName()} and not {@code Class.getCanonicalName()}\n     * @return the class name of the class without the package name or an empty string. If the class is an inner class then\n     *         value contains the outer class or classes and the separator is replaced to be {@code .} (dot) character.\n     */\n    public static String getShortClassName(String className) {\n        if (StringUtils.isEmpty(className)) {\n            return StringUtils.EMPTY;\n        }\n\n        final StringBuilder arrayPrefix = new StringBuilder();\n\n        // Handle array encoding\n        if (className.startsWith(\"[\")) {\n            while (className.charAt(0) == '[') {\n                className = className.substring(1);\n                arrayPrefix.append(\"[]\");\n            }\n            // Strip Object type encoding\n            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n                className = className.substring(1, className.length() - 1);\n            }\n\n            if (reverseAbbreviationMap.containsKey(className)) {\n                className = reverseAbbreviationMap.get(className);\n            }\n        }\n\n        final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n        String out = className.substring(lastDotIdx + 1);\n        if (innerIdx != -1) {\n            out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n        }\n        return out + arrayPrefix;\n    }\n\n    /**\n     * Null-safe version of {@code cls.getSimpleName()}\n     *\n     * @param cls the class for which to get the simple name; may be null\n     * @return the simple class name or the empty string in case the argument is {@code null}\n     * @since 3.0\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Class<?> cls) {\n        return getSimpleName(cls, StringUtils.EMPTY);\n    }\n\n    /**\n     * Null-safe version of {@code cls.getSimpleName()}\n     *\n     * @param cls the class for which to get the simple name; may be null\n     * @param valueIfNull the value to return if null\n     * @return the simple class name or {@code valueIfNull} if the argument {@code cls} is {@code null}\n     * @since 3.0\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Class<?> cls, final String valueIfNull) {\n        return cls == null ? valueIfNull : cls.getSimpleName();\n    }\n\n    /**\n     * Null-safe version of {@code object.getClass().getSimpleName()}\n     *\n     * <p>\n     * It is to note that this method is overloaded and in case the argument {@code object} is a {@link Class} object then\n     * the {@link #getSimpleName(Class)} will be invoked. If this is a significant possibility then the caller should check\n     * this case and call {@code\n     * getSimpleName(Class.class)} or just simply use the string literal {@code \"Class\"}, which is the result of the method\n     * in that case.\n     * </p>\n     *\n     * @param object the object for which to get the simple class name; may be null\n     * @return the simple class name or the empty string in case the argument is {@code null}\n     * @since 3.7\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Object object) {\n        return getSimpleName(object, StringUtils.EMPTY);\n    }\n\n    /**\n     * Null-safe version of {@code object.getClass().getSimpleName()}\n     *\n     * @param object the object for which to get the simple class name; may be null\n     * @param valueIfNull the value to return if {@code object} is {@code null}\n     * @return the simple class name or {@code valueIfNull} if the argument {@code object} is {@code null}\n     * @since 3.0\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Object object, final String valueIfNull) {\n        return object == null ? valueIfNull : object.getClass().getSimpleName();\n    }\n\n    /**\n     * Gets an {@link Iterable} that can iterate over a class hierarchy in ascending (subclass to superclass) order,\n     * excluding interfaces.\n     *\n     * @param type the type to get the class hierarchy from\n     * @return Iterable an Iterable over the class hierarchy of the given class\n     * @since 3.2\n     */\n    public static Iterable<Class<?>> hierarchy(final Class<?> type) {\n        return hierarchy(type, Interfaces.EXCLUDE);\n    }\n\n    /**\n     * Gets an {@link Iterable} that can iterate over a class hierarchy in ascending (subclass to superclass) order.\n     *\n     * @param type the type to get the class hierarchy from\n     * @param interfacesBehavior switch indicating whether to include or exclude interfaces\n     * @return Iterable an Iterable over the class hierarchy of the given class\n     * @since 3.2\n     */\n    public static Iterable<Class<?>> hierarchy(final Class<?> type, final Interfaces interfacesBehavior) {\n        final Iterable<Class<?>> classes = () -> {\n            final MutableObject<Class<?>> next = new MutableObject<>(type);\n            return new Iterator<Class<?>>() {\n\n                @Override\n                public boolean hasNext() {\n                    return next.getValue() != null;\n                }\n\n                @Override\n                public Class<?> next() {\n                    final Class<?> result = next.getValue();\n                    next.setValue(result.getSuperclass());\n                    return result;\n                }\n\n                @Override\n                public void remove() {\n                    throw new UnsupportedOperationException();\n                }\n\n            };\n        };\n        if (interfacesBehavior != Interfaces.INCLUDE) {\n            return classes;\n        }\n        return () -> {\n            final Set<Class<?>> seenInterfaces = new HashSet<>();\n            final Iterator<Class<?>> wrapped = classes.iterator();\n\n            return new Iterator<Class<?>>() {\n                Iterator<Class<?>> interfaces = Collections.emptyIterator();\n\n                @Override\n                public boolean hasNext() {\n                    return interfaces.hasNext() || wrapped.hasNext();\n                }\n\n                @Override\n                public Class<?> next() {\n                    if (interfaces.hasNext()) {\n                        final Class<?> nextInterface = interfaces.next();\n                        seenInterfaces.add(nextInterface);\n                        return nextInterface;\n                    }\n                    final Class<?> nextSuperclass = wrapped.next();\n                    final Set<Class<?>> currentInterfaces = new LinkedHashSet<>();\n                    walkInterfaces(currentInterfaces, nextSuperclass);\n                    interfaces = currentInterfaces.iterator();\n                    return nextSuperclass;\n                }\n\n                @Override\n                public void remove() {\n                    throw new UnsupportedOperationException();\n                }\n\n                private void walkInterfaces(final Set<Class<?>> addTo, final Class<?> c) {\n                    for (final Class<?> iface : c.getInterfaces()) {\n                        if (!seenInterfaces.contains(iface)) {\n                            addTo.add(iface);\n                        }\n                        walkInterfaces(addTo, iface);\n                    }\n                }\n\n            };\n        };\n    }\n\n    /**\n     * Checks if one {@link Class} can be assigned to a variable of another {@link Class}.\n     *\n     * <p>\n     * Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into account widenings of\n     * primitive classes and {@code null}s.\n     * </p>\n     *\n     * <p>\n     * Primitive widenings allow an int to be assigned to a long, float or double. This method returns the correct result\n     * for these cases.\n     * </p>\n     *\n     * <p>\n     * {@code null} may be assigned to any reference type. This method will return {@code true} if {@code null} is passed in\n     * and the toClass is non-primitive.\n     * </p>\n     *\n     * <p>\n     * Specifically, this method tests whether the type represented by the specified {@link Class} parameter can be\n     * converted to the type represented by this {@link Class} object via an identity conversion widening primitive or\n     * widening reference conversion. See <em><a href=\"https://docs.oracle.com/javase/specs/\">The Java Language\n     * Specification</a></em>, sections 5.1.1, 5.1.2 and 5.1.4 for details.\n     * </p>\n     *\n     * <p>\n     * <strong>Since Lang 3.0,</strong> this method will default behavior for calculating assignability between primitive\n     * and wrapper types <em>corresponding to the running Java version</em>; i.e. autoboxing will be the default behavior in\n     * VMs running Java versions &gt; 1.5.\n     * </p>\n     *\n     * @param cls the Class to check, may be null\n     * @param toClass the Class to try to assign into, returns false if null\n     * @return {@code true} if assignment possible\n     */\n    public static boolean isAssignable(final Class<?> cls, final Class<?> toClass) {\n        return isAssignable(cls, toClass, true);\n    }\n\n    /**\n     * Checks if one {@link Class} can be assigned to a variable of another {@link Class}.\n     *\n     * <p>\n     * Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into account widenings of\n     * primitive classes and {@code null}s.\n     * </p>\n     *\n     * <p>\n     * Primitive widenings allow an int to be assigned to a long, float or double. This method returns the correct result\n     * for these cases.\n     * </p>\n     *\n     * <p>\n     * {@code null} may be assigned to any reference type. This method will return {@code true} if {@code null} is passed in\n     * and the toClass is non-primitive.\n     * </p>\n     *\n     * <p>\n     * Specifically, this method tests whether the type represented by the specified {@link Class} parameter can be\n     * converted to the type represented by this {@link Class} object via an identity conversion widening primitive or\n     * widening reference conversion. See <em><a href=\"https://docs.oracle.com/javase/specs/\">The Java Language\n     * Specification</a></em>, sections 5.1.1, 5.1.2 and 5.1.4 for details.\n     * </p>\n     *\n     * @param cls the Class to check, may be null\n     * @param toClass the Class to try to assign into, returns false if null\n     * @param autoboxing whether to use implicit autoboxing/unboxing between primitives and wrappers\n     * @return {@code true} if assignment possible\n     */\n    public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {\n        if (toClass == null) {\n            return false;\n        }\n        // have to check for null, as isAssignableFrom doesn't\n        if (cls == null) {\n            return !toClass.isPrimitive();\n        }\n        // autoboxing:\n        if (autoboxing) {\n            if (cls.isPrimitive() && !toClass.isPrimitive()) {\n                cls = primitiveToWrapper(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n            if (toClass.isPrimitive() && !cls.isPrimitive()) {\n                cls = wrapperToPrimitive(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n        }\n        if (cls.equals(toClass)) {\n            return true;\n        }\n        if (cls.isPrimitive()) {\n            if (!toClass.isPrimitive()) {\n                return false;\n            }\n            if (Integer.TYPE.equals(cls)) {\n                return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);\n            }\n            if (Long.TYPE.equals(cls)) {\n                return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);\n            }\n            if (Boolean.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Double.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Float.TYPE.equals(cls)) {\n                return Double.TYPE.equals(toClass);\n            }\n            if (Character.TYPE.equals(cls)  || Short.TYPE.equals(cls)) {\n                return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);\n            }\n            if (Byte.TYPE.equals(cls)) {\n                return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            // should never get here\n            return false;\n        }\n        return toClass.isAssignableFrom(cls);\n    }\n\n    /**\n     * Checks if an array of Classes can be assigned to another array of Classes.\n     *\n     * <p>\n     * This method calls {@link #isAssignable(Class, Class) isAssignable} for each Class pair in the input arrays. It can be\n     * used to check if a set of arguments (the first parameter) are suitably compatible with a set of method parameter\n     * types (the second parameter).\n     * </p>\n     *\n     * <p>\n     * Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into account widenings of\n     * primitive classes and {@code null}s.\n     * </p>\n     *\n     * <p>\n     * Primitive widenings allow an int to be assigned to a {@code long}, {@code float} or {@code double}. This method\n     * returns the correct result for these cases.\n     * </p>\n     *\n     * <p>\n     * {@code null} may be assigned to any reference type. This method will return {@code true} if {@code null} is passed in\n     * and the toClass is non-primitive.\n     * </p>\n     *\n     * <p>\n     * Specifically, this method tests whether the type represented by the specified {@link Class} parameter can be\n     * converted to the type represented by this {@link Class} object via an identity conversion widening primitive or\n     * widening reference conversion. See <em><a href=\"https://docs.oracle.com/javase/specs/\">The Java Language\n     * Specification</a></em>, sections 5.1.1, 5.1.2 and 5.1.4 for details.\n     * </p>\n     *\n     * <p>\n     * <strong>Since Lang 3.0,</strong> this method will default behavior for calculating assignability between primitive\n     * and wrapper types <em>corresponding to the running Java version</em>; i.e. autoboxing will be the default behavior in\n     * VMs running Java versions &gt; 1.5.\n     * </p>\n     *\n     * @param classArray the array of Classes to check, may be {@code null}\n     * @param toClassArray the array of Classes to try to assign into, may be {@code null}\n     * @return {@code true} if assignment possible\n     */\n    public static boolean isAssignable(final Class<?>[] classArray, final Class<?>... toClassArray) {\n        return isAssignable(classArray, toClassArray, true);\n    }\n\n    /**\n     * Checks if an array of Classes can be assigned to another array of Classes.\n     *\n     * <p>\n     * This method calls {@link #isAssignable(Class, Class) isAssignable} for each Class pair in the input arrays. It can be\n     * used to check if a set of arguments (the first parameter) are suitably compatible with a set of method parameter\n     * types (the second parameter).\n     * </p>\n     *\n     * <p>\n     * Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into account widenings of\n     * primitive classes and {@code null}s.\n     * </p>\n     *\n     * <p>\n     * Primitive widenings allow an int to be assigned to a {@code long}, {@code float} or {@code double}. This method\n     * returns the correct result for these cases.\n     * </p>\n     *\n     * <p>\n     * {@code null} may be assigned to any reference type. This method will return {@code true} if {@code null} is passed in\n     * and the toClass is non-primitive.\n     * </p>\n     *\n     * <p>\n     * Specifically, this method tests whether the type represented by the specified {@link Class} parameter can be\n     * converted to the type represented by this {@link Class} object via an identity conversion widening primitive or\n     * widening reference conversion. See <em><a href=\"https://docs.oracle.com/javase/specs/\">The Java Language\n     * Specification</a></em>, sections 5.1.1, 5.1.2 and 5.1.4 for details.\n     * </p>\n     *\n     * @param classArray the array of Classes to check, may be {@code null}\n     * @param toClassArray the array of Classes to try to assign into, may be {@code null}\n     * @param autoboxing whether to use implicit autoboxing/unboxing between primitives and wrappers\n     * @return {@code true} if assignment possible\n     */\n    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, final boolean autoboxing) {\n        if (!ArrayUtils.isSameLength(classArray, toClassArray)) {\n            return false;\n        }\n        classArray = ArrayUtils.nullToEmpty(classArray);\n        toClassArray = ArrayUtils.nullToEmpty(toClassArray);\n        for (int i = 0; i < classArray.length; i++) {\n            if (!isAssignable(classArray[i], toClassArray[i], autoboxing)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Is the specified class an inner class or static nested class.\n     *\n     * @param cls the class to check, may be null\n     * @return {@code true} if the class is an inner or static nested class, false if not or {@code null}\n     */\n    public static boolean isInnerClass(final Class<?> cls) {\n        return cls != null && cls.getEnclosingClass() != null;\n    }\n\n    /**\n     * Returns whether the given {@code type} is a primitive or primitive wrapper ({@link Boolean}, {@link Byte},\n     * {@link Character}, {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n     *\n     * @param type The class to query or null.\n     * @return true if the given {@code type} is a primitive or primitive wrapper ({@link Boolean}, {@link Byte},\n     *         {@link Character}, {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n     * @since 3.1\n     */\n    public static boolean isPrimitiveOrWrapper(final Class<?> type) {\n        if (type == null) {\n            return false;\n        }\n        return type.isPrimitive() || isPrimitiveWrapper(type);\n    }\n    /**\n     * Returns whether the given {@code type} is a primitive wrapper ({@link Boolean}, {@link Byte}, {@link Character},\n     * {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n     *\n     * @param type The class to query or null.\n     * @return true if the given {@code type} is a primitive wrapper ({@link Boolean}, {@link Byte}, {@link Character},\n     *         {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n     * @since 3.1\n     */\n    public static boolean isPrimitiveWrapper(final Class<?> type) {\n        return wrapperPrimitiveMap.containsKey(type);\n    }\n\n    /**\n     * Tests whether a {@link Class} is public.\n     * @param cls Class to test.\n     * @return {@code true} if {@code cls} is public.\n     * @since 3.13.0\n     */\n    public static boolean isPublic(final Class<?> cls) {\n        return Modifier.isPublic(cls.getModifiers());\n    }\n\n    /**\n     * Converts the specified array of primitive Class objects to an array of its corresponding wrapper Class objects.\n     *\n     * @param classes the class array to convert, may be null or empty\n     * @return an array which contains for each given class, the wrapper class or the original class if class is not a\n     *         primitive. {@code null} if null input. Empty array if an empty array passed in.\n     * @since 2.1\n     */\n    public static Class<?>[] primitivesToWrappers(final Class<?>... classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        final Class<?>[] convertedClasses = new Class[classes.length];\n        Arrays.setAll(convertedClasses, i -> primitiveToWrapper(classes[i]));\n        return convertedClasses;\n    }\n\n    /**\n     * Converts the specified primitive Class object to its corresponding wrapper Class object.\n     *\n     * <p>\n     * NOTE: From v2.2, this method handles {@code Void.TYPE}, returning {@code Void.TYPE}.\n     * </p>\n     *\n     * @param cls the class to convert, may be null\n     * @return the wrapper class for {@code cls} or {@code cls} if {@code cls} is not a primitive. {@code null} if null\n     *         input.\n     * @since 2.1\n     */\n    public static Class<?> primitiveToWrapper(final Class<?> cls) {\n        Class<?> convertedClass = cls;\n        if (cls != null && cls.isPrimitive()) {\n            convertedClass = primitiveWrapperMap.get(cls);\n        }\n        return convertedClass;\n    }\n\n    /**\n     * Converts a class name to a JLS style class name.\n     *\n     * @param className the class name\n     * @return the converted name\n     * @throws NullPointerException if the className is null\n     */\n    private static String toCanonicalName(final String className) {\n        String canonicalName = StringUtils.deleteWhitespace(className);\n        Objects.requireNonNull(canonicalName, \"className\");\n        if (canonicalName.endsWith(\"[]\")) {\n            final StringBuilder classNameBuffer = new StringBuilder();\n            while (canonicalName.endsWith(\"[]\")) {\n                canonicalName = canonicalName.substring(0, canonicalName.length() - 2);\n                classNameBuffer.append(\"[\");\n            }\n            final String abbreviation = abbreviationMap.get(canonicalName);\n            if (abbreviation != null) {\n                classNameBuffer.append(abbreviation);\n            } else {\n                classNameBuffer.append(\"L\").append(canonicalName).append(\";\");\n            }\n            canonicalName = classNameBuffer.toString();\n        }\n        return canonicalName;\n    }\n\n    /**\n     * Converts an array of {@link Object} in to an array of {@link Class} objects. If any of these objects is null, a null\n     * element will be inserted into the array.\n     *\n     * <p>\n     * This method returns {@code null} for a {@code null} input array.\n     * </p>\n     *\n     * @param array an {@link Object} array\n     * @return a {@link Class} array, {@code null} if null array input\n     * @since 2.4\n     */\n    public static Class<?>[] toClass(final Object... array) {\n        if (array == null) {\n            return null;\n        }\n        if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        final Class<?>[] classes = new Class[array.length];\n        Arrays.setAll(classes, i -> array[i] == null ? null : array[i].getClass());\n        return classes;\n    }\n\n    /**\n     * Decides if the part that was just copied to its destination location in the work array can be kept as it was copied\n     * or must be abbreviated. It must be kept when the part is the last one, which is the simple name of the class. In this\n     * case the {@code source} index, from where the characters are copied points one position after the last character,\n     * a.k.a. {@code source ==\n     * originalLength}\n     *\n     * <p>\n     * If the part is not the last one then it can be kept unabridged if the number of the characters copied so far plus the\n     * character that are to be copied is less than or equal to the desired length.\n     * </p>\n     *\n     * @param runAheadTarget the target index (where the characters were copied to) pointing after the last character copied\n     *        when the current part was copied\n     * @param source the source index (where the characters were copied from) pointing after the last character copied when\n     *        the current part was copied\n     * @param originalLength the original length of the class full name, which is abbreviated\n     * @param desiredLength the desired length of the abbreviated class name\n     * @return {@code true} if it can be kept in its original length {@code false} if the current part has to be abbreviated\n     *         and\n     */\n    private static boolean useFull(final int runAheadTarget, final int source, final int originalLength, final int desiredLength) {\n        return source >= originalLength || runAheadTarget + originalLength - source <= desiredLength;\n    }\n\n    /**\n     * Converts the specified array of wrapper Class objects to an array of its corresponding primitive Class objects.\n     *\n     * <p>\n     * This method invokes {@code wrapperToPrimitive()} for each element of the passed in array.\n     * </p>\n     *\n     * @param classes the class array to convert, may be null or empty\n     * @return an array which contains for each given class, the primitive class or <b>null</b> if the original class is not\n     *         a wrapper class. {@code null} if null input. Empty array if an empty array passed in.\n     * @see #wrapperToPrimitive(Class)\n     * @since 2.4\n     */\n    public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        final Class<?>[] convertedClasses = new Class[classes.length];\n        Arrays.setAll(convertedClasses, i -> wrapperToPrimitive(classes[i]));\n        return convertedClasses;\n    }\n\n    /**\n     * Converts the specified wrapper class to its corresponding primitive class.\n     *\n     * <p>\n     * This method is the counter part of {@code primitiveToWrapper()}. If the passed in class is a wrapper class for a\n     * primitive type, this primitive type will be returned (e.g. {@code Integer.TYPE} for {@code Integer.class}). For other\n     * classes, or if the parameter is <b>null</b>, the return value is <b>null</b>.\n     * </p>\n     *\n     * @param cls the class to convert, may be <b>null</b>\n     * @return the corresponding primitive type if {@code cls} is a wrapper class, <b>null</b> otherwise\n     * @see #primitiveToWrapper(Class)\n     * @since 2.4\n     */\n    public static Class<?> wrapperToPrimitive(final Class<?> cls) {\n        return wrapperPrimitiveMap.get(cls);\n    }\n\n    /**\n     * ClassUtils instances should NOT be constructed in standard programming. Instead, the class should be used as\n     * {@code ClassUtils.getShortClassName(cls)}.\n     *\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public ClassUtils() {\n        // empty\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/ClassUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.lang3.mutable.MutableObject;\n\n/**\n * Operates on classes without using reflection.\n *\n * <p>\n * This class handles invalid {@code null} inputs as best it can. Each method documents its behavior in more detail.\n * </p>\n *\n * <p>\n * The notion of a {@code canonical name} includes the human readable name for the type, for example {@code int[]}. The\n * non-canonical method variants work with the JVM names, such as {@code [I}.\n * </p>\n *\n * @since 2.0\n */\npublic class ClassUtils {\n\n    /**\n     * Inclusivity literals for {@link #hierarchy(Class, Interfaces)}.\n     *\n     * @since 3.2\n     */\n    public enum Interfaces {\n\n        /** Includes interfaces. */\n        INCLUDE,\n\n        /** Excludes interfaces. */\n        EXCLUDE\n    }\n\n    private static final Comparator<Class<?>> COMPARATOR = (o1, o2) -> Objects.compare(getName(o1), getName(o2), String::compareTo);\n\n    /**\n     * The package separator character: {@code '&#x2e;' == {@value}}.\n     */\n    public static final char PACKAGE_SEPARATOR_CHAR = '.';\n\n    /**\n     * The package separator String: {@code \"&#x2e;\"}.\n     */\n    public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR);\n\n    /**\n     * The inner class separator character: {@code '$' == {@value}}.\n     */\n    public static final char INNER_CLASS_SEPARATOR_CHAR = '$';\n\n    /**\n     * The inner class separator String: {@code \"$\"}.\n     */\n    public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR);\n\n    /**\n     * Maps names of primitives to their corresponding primitive {@link Class}es.\n     */\n    private static final Map<String, Class<?>> namePrimitiveMap = new HashMap<>();\n\n    static {\n        namePrimitiveMap.put(Boolean.TYPE.getSimpleName(), Boolean.TYPE);\n        namePrimitiveMap.put(Byte.TYPE.getSimpleName(), Byte.TYPE);\n        namePrimitiveMap.put(Character.TYPE.getSimpleName(), Character.TYPE);\n        namePrimitiveMap.put(Double.TYPE.getSimpleName(), Double.TYPE);\n        namePrimitiveMap.put(Float.TYPE.getSimpleName(), Float.TYPE);\n        namePrimitiveMap.put(Integer.TYPE.getSimpleName(), Integer.TYPE);\n        namePrimitiveMap.put(Long.TYPE.getSimpleName(), Long.TYPE);\n        namePrimitiveMap.put(Short.TYPE.getSimpleName(), Short.TYPE);\n        namePrimitiveMap.put(Void.TYPE.getSimpleName(), Void.TYPE);\n    }\n\n    /**\n     * Maps primitive {@link Class}es to their corresponding wrapper {@link Class}.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<>();\n\n    static {\n        primitiveWrapperMap.put(Boolean.TYPE, Boolean.class);\n        primitiveWrapperMap.put(Byte.TYPE, Byte.class);\n        primitiveWrapperMap.put(Character.TYPE, Character.class);\n        primitiveWrapperMap.put(Short.TYPE, Short.class);\n        primitiveWrapperMap.put(Integer.TYPE, Integer.class);\n        primitiveWrapperMap.put(Long.TYPE, Long.class);\n        primitiveWrapperMap.put(Double.TYPE, Double.class);\n        primitiveWrapperMap.put(Float.TYPE, Float.class);\n        primitiveWrapperMap.put(Void.TYPE, Void.TYPE);\n    }\n\n    /**\n     * Maps wrapper {@link Class}es to their corresponding primitive types.\n     */\n    private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<>();\n\n    static {\n        primitiveWrapperMap.forEach((primitiveClass, wrapperClass) -> {\n            if (!primitiveClass.equals(wrapperClass)) {\n                wrapperPrimitiveMap.put(wrapperClass, primitiveClass);\n            }\n        });\n    }\n\n    /**\n     * Maps a primitive class name to its corresponding abbreviation used in array class names.\n     */\n    private static final Map<String, String> abbreviationMap;\n\n    /**\n     * Maps an abbreviation used in array class names to corresponding primitive class name.\n     */\n    private static final Map<String, String> reverseAbbreviationMap;\n\n    /** Feed abbreviation maps. */\n    static {\n        final Map<String, String> map = new HashMap<>();\n        map.put(\"int\", \"I\");\n        map.put(\"boolean\", \"Z\");\n        map.put(\"float\", \"F\");\n        map.put(\"long\", \"J\");\n        map.put(\"short\", \"S\");\n        map.put(\"byte\", \"B\");\n        map.put(\"double\", \"D\");\n        map.put(\"char\", \"C\");\n        abbreviationMap = Collections.unmodifiableMap(map);\n        reverseAbbreviationMap = Collections.unmodifiableMap(map.entrySet().stream().collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey)));\n    }\n\n    /**\n     * Gets the class comparator, comparing by class name.\n     *\n     * @return the class comparator.\n     * @since 3.13.0\n     */\n    public static Comparator<Class<?>> comparator() {\n        return COMPARATOR;\n    }\n\n    /**\n     * Given a {@link List} of {@link Class} objects, this method converts them into class names.\n     *\n     * <p>\n     * A new {@link List} is returned. {@code null} objects will be copied into the returned list as {@code null}.\n     * </p>\n     *\n     * @param classes the classes to change\n     * @return a {@link List} of class names corresponding to the Class objects, {@code null} if null input\n     * @throws ClassCastException if {@code classes} contains a non-{@link Class} entry\n     */\n    public static List<String> convertClassesToClassNames(final List<Class<?>> classes) {\n        return classes == null ? null : classes.stream().map(e -> getName(e, null)).collect(Collectors.toList());\n    }\n\n    /**\n     * Given a {@link List} of class names, this method converts them into classes.\n     *\n     * <p>\n     * A new {@link List} is returned. If the class name cannot be found, {@code null} is stored in the {@link List}. If the\n     * class name in the {@link List} is {@code null}, {@code null} is stored in the output {@link List}.\n     * </p>\n     *\n     * @param classNames the classNames to change\n     * @return a {@link List} of Class objects corresponding to the class names, {@code null} if null input\n     * @throws ClassCastException if classNames contains a non String entry\n     */\n    public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) {\n        if (classNames == null) {\n            return null;\n        }\n        final List<Class<?>> classes = new ArrayList<>(classNames.size());\n        classNames.forEach(className -> {\n            try {\n                classes.add(Class.forName(className));\n            } catch (final Exception ex) {\n                classes.add(null);\n            }\n        });\n        return classes;\n    }\n\n    /**\n     * Gets the abbreviated name of a {@link Class}.\n     *\n     * @param cls the class to get the abbreviated name for, may be {@code null}\n     * @param lengthHint the desired length of the abbreviated name\n     * @return the abbreviated name or an empty string\n     * @throws IllegalArgumentException if len &lt;= 0\n     * @see #getAbbreviatedName(String, int)\n     * @since 3.4\n     */\n    public static String getAbbreviatedName(final Class<?> cls, final int lengthHint) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getAbbreviatedName(cls.getName(), lengthHint);\n    }\n\n    /**\n     * Gets the abbreviated class name from a {@link String}.\n     *\n     * <p>\n     * The string passed in is assumed to be a class name - it is not checked.\n     * </p>\n     *\n     * <p>\n     * The abbreviation algorithm will shorten the class name, usually without significant loss of meaning.\n     * </p>\n     *\n     * <p>\n     * The abbreviated class name will always include the complete package hierarchy. If enough space is available,\n     * rightmost sub-packages will be displayed in full length. The abbreviated package names will be shortened to a single\n     * character.\n     * </p>\n     * <p>\n     * Only package names are shortened, the class simple name remains untouched. (See examples.)\n     * </p>\n     * <p>\n     * The result will be longer than the desired length only if all the package names shortened to a single character plus\n     * the class simple name with the separating dots together are longer than the desired length. In other words, when the\n     * class name cannot be shortened to the desired length.\n     * </p>\n     * <p>\n     * If the class name can be shortened then the final length will be at most {@code lengthHint} characters.\n     * </p>\n     * <p>\n     * If the {@code lengthHint} is zero or negative then the method throws exception. If you want to achieve the shortest\n     * possible version then use {@code 1} as a {@code lengthHint}.\n     * </p>\n     *\n     * <table>\n     * <caption>Examples</caption>\n     * <tr>\n     * <td>className</td>\n     * <td>len</td>\n     * <td>return</td>\n     * </tr>\n     * <tr>\n     * <td>null</td>\n     * <td>1</td>\n     * <td>\"\"</td>\n     * </tr>\n     * <tr>\n     * <td>\"java.lang.String\"</td>\n     * <td>5</td>\n     * <td>\"j.l.String\"</td>\n     * </tr>\n     * <tr>\n     * <td>\"java.lang.String\"</td>\n     * <td>15</td>\n     * <td>\"j.lang.String\"</td>\n     * </tr>\n     * <tr>\n     * <td>\"java.lang.String\"</td>\n     * <td>30</td>\n     * <td>\"java.lang.String\"</td>\n     * </tr>\n     * <tr>\n     * <td>\"org.apache.commons.lang3.ClassUtils\"</td>\n     * <td>18</td>\n     * <td>\"o.a.c.l.ClassUtils\"</td>\n     * </tr>\n     * </table>\n     *\n     * @param className the className to get the abbreviated name for, may be {@code null}\n     * @param lengthHint the desired length of the abbreviated name\n     * @return the abbreviated name or an empty string if the specified class name is {@code null} or empty string. The\n     *         abbreviated name may be longer than the desired length if it cannot be abbreviated to the desired length.\n     * @throws IllegalArgumentException if {@code len <= 0}\n     * @since 3.4\n     */\n    public static String getAbbreviatedName(final String className, final int lengthHint) {\n        if (lengthHint <= 0) {\n            throw new IllegalArgumentException(\"len must be > 0\");\n        }\n        if (className == null) {\n            return StringUtils.EMPTY;\n        }\n        if (className.length() <= lengthHint) {\n            return className;\n        }\n        final char[] abbreviated = className.toCharArray();\n        int target = 0;\n        int source = 0;\n        while (source < abbreviated.length) {\n            // copy the next part\n            int runAheadTarget = target;\n            while (source < abbreviated.length && abbreviated[source] != '.') {\n                abbreviated[runAheadTarget++] = abbreviated[source++];\n            }\n\n            ++target;\n            if (useFull(runAheadTarget, source, abbreviated.length, lengthHint) || target > runAheadTarget) {\n                target = runAheadTarget;\n            }\n\n            // copy the '.' unless it was the last part\n            if (source < abbreviated.length) {\n                abbreviated[target++] = abbreviated[source++];\n            }\n        }\n        return new String(abbreviated, 0, target);\n    }\n\n    /**\n     * Gets a {@link List} of all interfaces implemented by the given class and its superclasses.\n     *\n     * <p>\n     * The order is determined by looking through each interface in turn as declared in the source file and following its\n     * hierarchy up. Then each superclass is considered in the same way. Later duplicates are ignored, so the order is\n     * maintained.\n     * </p>\n     *\n     * @param cls the class to look up, may be {@code null}\n     * @return the {@link List} of interfaces in order, {@code null} if null input\n     */\n    public static List<Class<?>> getAllInterfaces(final Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n\n        final LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<>();\n        getAllInterfaces(cls, interfacesFound);\n\n        return new ArrayList<>(interfacesFound);\n    }\n\n    /**\n     * Gets the interfaces for the specified class.\n     *\n     * @param cls the class to look up, may be {@code null}\n     * @param interfacesFound the {@link Set} of interfaces for the class\n     */\n    private static void getAllInterfaces(Class<?> cls, final HashSet<Class<?>> interfacesFound) {\n        while (cls != null) {\n            final Class<?>[] interfaces = cls.getInterfaces();\n\n            for (final Class<?> i : interfaces) {\n                if (interfacesFound.add(i)) {\n                    getAllInterfaces(i, interfacesFound);\n                }\n            }\n\n            cls = cls.getSuperclass();\n        }\n    }\n\n    /**\n     * Gets a {@link List} of superclasses for the given class.\n     *\n     * @param cls the class to look up, may be {@code null}\n     * @return the {@link List} of superclasses in order going up from this one {@code null} if null input\n     */\n    public static List<Class<?>> getAllSuperclasses(final Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n        final List<Class<?>> classes = new ArrayList<>();\n        Class<?> superclass = cls.getSuperclass();\n        while (superclass != null) {\n            classes.add(superclass);\n            superclass = superclass.getSuperclass();\n        }\n        return classes;\n    }\n\n    /**\n     * Gets the canonical class name for a {@link Class}.\n     *\n     * @param cls the class for which to get the canonical class name; may be null\n     * @return the canonical name of the class, or the empty String\n     * @since 3.7\n     * @see Class#getCanonicalName()\n     */\n    public static String getCanonicalName(final Class<?> cls) {\n        return getCanonicalName(cls, StringUtils.EMPTY);\n    }\n\n    /**\n     * Gets the canonical name for a {@link Class}.\n     *\n     * @param cls the class for which to get the canonical class name; may be null\n     * @param valueIfNull the return value if null\n     * @return the canonical name of the class, or {@code valueIfNull}\n     * @since 3.7\n     * @see Class#getCanonicalName()\n     */\n    public static String getCanonicalName(final Class<?> cls, final String valueIfNull) {\n        if (cls == null) {\n            return valueIfNull;\n        }\n        final String canonicalName = cls.getCanonicalName();\n        return canonicalName == null ? valueIfNull : canonicalName;\n    }\n\n    /**\n     * Gets the canonical name for an {@link Object}.\n     *\n     * @param object the object for which to get the canonical class name; may be null\n     * @return the canonical name of the object, or the empty String\n     * @since 3.7\n     * @see Class#getCanonicalName()\n     */\n    public static String getCanonicalName(final Object object) {\n        return getCanonicalName(object, StringUtils.EMPTY);\n    }\n\n    /**\n     * Gets the canonical name for an {@link Object}.\n     *\n     * @param object the object for which to get the canonical class name; may be null\n     * @param valueIfNull the return value if null\n     * @return the canonical name of the object or {@code valueIfNull}\n     * @since 3.7\n     * @see Class#getCanonicalName()\n     */\n    public static String getCanonicalName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        final String canonicalName = object.getClass().getCanonicalName();\n        return canonicalName == null ? valueIfNull : canonicalName;\n    }\n\n    /**\n     * Converts a given name of class into canonical format. If name of class is not a name of array class it returns\n     * unchanged name.\n     *\n     * <p>\n     * The method does not change the {@code $} separators in case the class is inner class.\n     * </p>\n     *\n     * <p>\n     * Example:\n     * <ul>\n     * <li>{@code getCanonicalName(\"[I\") = \"int[]\"}</li>\n     * <li>{@code getCanonicalName(\"[Ljava.lang.String;\") = \"java.lang.String[]\"}</li>\n     * <li>{@code getCanonicalName(\"java.lang.String\") = \"java.lang.String\"}</li>\n     * </ul>\n     * </p>\n     *\n     * @param className the name of class\n     * @return canonical form of class name\n     * @since 2.4\n     */\n    private static String getCanonicalName(String className) {\n        className = StringUtils.deleteWhitespace(className);\n        if (className == null) {\n            return null;\n        }\n        int dim = 0;\n        while (className.startsWith(\"[\")) {\n            dim++;\n            className = className.substring(1);\n        }\n        if (dim < 1) {\n            return className;\n        }\n        if (className.startsWith(\"L\")) {\n            className = className.substring(1, className.endsWith(\";\") ? className.length() - 1 : className.length());\n        } else if (!className.isEmpty()) {\n            className = reverseAbbreviationMap.get(className.substring(0, 1));\n        }\n        final StringBuilder canonicalClassNameBuffer = new StringBuilder(className);\n        for (int i = 0; i < dim; i++) {\n            canonicalClassNameBuffer.append(\"[]\");\n        }\n        return canonicalClassNameBuffer.toString();\n    }\n\n    /**\n     * Returns the (initialized) class represented by {@code className} using the {@code classLoader}. This implementation\n     * supports the syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\",\n     * \"{@code [Ljava.util.Map.Entry;}\", and \"{@code [Ljava.util.Map$Entry;}\".\n     *\n     * @param classLoader the class loader to use to load the class\n     * @param className the class name\n     * @return the class represented by {@code className} using the {@code classLoader}\n     * @throws NullPointerException if the className is null\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(final ClassLoader classLoader, final String className) throws ClassNotFoundException {\n        return getClass(classLoader, className, true);\n    }\n\n    /**\n     * Returns the class represented by {@code className} using the {@code classLoader}. This implementation supports the\n     * syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\", \"{@code [Ljava.util.Map.Entry;}\", and\n     * \"{@code [Ljava.util.Map$Entry;}\".\n     *\n     * @param classLoader the class loader to use to load the class\n     * @param className the class name\n     * @param initialize whether the class must be initialized\n     * @return the class represented by {@code className} using the {@code classLoader}\n     * @throws NullPointerException if the className is null\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {\n        try {\n            final Class<?> clazz = getPrimitiveClass(className);\n            return clazz != null ? clazz : Class.forName(toCanonicalName(className), initialize, classLoader);\n        } catch (final ClassNotFoundException ex) {\n            // allow path separators (.) as inner class name separators\n            final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n\n            if (lastDotIndex != -1) {\n                try {\n                    return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1),\n                        initialize);\n                } catch (final ClassNotFoundException ignored) {\n                    // ignore exception\n                }\n            }\n\n            throw ex;\n        }\n    }\n\n    /**\n     * Returns the (initialized) class represented by {@code className} using the current thread's context class loader.\n     * This implementation supports the syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\",\n     * \"{@code [Ljava.util.Map.Entry;}\", and \"{@code [Ljava.util.Map$Entry;}\".\n     *\n     * @param className the class name\n     * @return the class represented by {@code className} using the current thread's context class loader\n     * @throws NullPointerException if the className is null\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(final String className) throws ClassNotFoundException {\n        return getClass(className, true);\n    }\n\n    /**\n     * Returns the class represented by {@code className} using the current thread's context class loader. This\n     * implementation supports the syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\",\n     * \"{@code [Ljava.util.Map.Entry;}\", and \"{@code [Ljava.util.Map$Entry;}\".\n     *\n     * @param className the class name\n     * @param initialize whether the class must be initialized\n     * @return the class represented by {@code className} using the current thread's context class loader\n     * @throws NullPointerException if the className is null\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {\n        final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n        return getClass(loader, className, initialize);\n    }\n\n    /**\n     * Delegates to {@link Class#getComponentType()} using generics.\n     *\n     * @param <T> The array class type.\n     * @param cls A class or null.\n     * @return The array component type or null.\n     * @see Class#getComponentType()\n     * @since 3.13.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Class<T> getComponentType(final Class<T[]> cls) {\n        return cls == null ? null : (Class<T>) cls.getComponentType();\n    }\n\n    /**\n     * Null-safe version of {@code cls.getName()}\n     *\n     * @param cls the class for which to get the class name; may be null\n     * @return the class name or the empty string in case the argument is {@code null}\n     * @since 3.7\n     * @see Class#getSimpleName()\n     */\n    public static String getName(final Class<?> cls) {\n        return getName(cls, StringUtils.EMPTY);\n    }\n\n    /**\n     * Null-safe version of {@code cls.getName()}\n     *\n     * @param cls the class for which to get the class name; may be null\n     * @param valueIfNull the return value if the argument {@code cls} is {@code null}\n     * @return the class name or {@code valueIfNull}\n     * @since 3.7\n     * @see Class#getName()\n     */\n    public static String getName(final Class<?> cls, final String valueIfNull) {\n        return cls == null ? valueIfNull : cls.getName();\n    }\n\n    /**\n     * Null-safe version of {@code object.getClass().getName()}\n     *\n     * @param object the object for which to get the class name; may be null\n     * @return the class name or the empty String\n     * @since 3.7\n     * @see Class#getSimpleName()\n     */\n    public static String getName(final Object object) {\n        return getName(object, StringUtils.EMPTY);\n    }\n\n    /**\n     * Null-safe version of {@code object.getClass().getSimpleName()}\n     *\n     * @param object the object for which to get the class name; may be null\n     * @param valueIfNull the value to return if {@code object} is {@code null}\n     * @return the class name or {@code valueIfNull}\n     * @since 3.0\n     * @see Class#getName()\n     */\n    public static String getName(final Object object, final String valueIfNull) {\n        return object == null ? valueIfNull : object.getClass().getName();\n    }\n\n    /**\n     * Gets the package name from the canonical name of a {@link Class}.\n     *\n     * @param cls the class to get the package name for, may be {@code null}.\n     * @return the package name or an empty string\n     * @since 2.4\n     */\n    public static String getPackageCanonicalName(final Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageCanonicalName(cls.getName());\n    }\n\n    /**\n     * Gets the package name from the class name of an {@link Object}.\n     *\n     * @param object the class to get the package name for, may be null\n     * @param valueIfNull the value to return if null\n     * @return the package name of the object, or the null value\n     * @since 2.4\n     */\n    public static String getPackageCanonicalName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageCanonicalName(object.getClass().getName());\n    }\n\n    /**\n     * Gets the package name from the class name.\n     *\n     * <p>\n     * The string passed in is assumed to be a class name - it is not checked.\n     * </p>\n     * <p>\n     * If the class is in the default package, return an empty string.\n     * </p>\n     *\n     * @param name the name to get the package name for, may be {@code null}\n     * @return the package name or an empty string\n     * @since 2.4\n     */\n    public static String getPackageCanonicalName(final String name) {\n        return getPackageName(getCanonicalName(name));\n    }\n\n    /**\n     * Gets the package name of a {@link Class}.\n     *\n     * @param cls the class to get the package name for, may be {@code null}.\n     * @return the package name or an empty string\n     */\n    public static String getPackageName(final Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageName(cls.getName());\n    }\n\n    /**\n     * Gets the package name of an {@link Object}.\n     *\n     * @param object the class to get the package name for, may be null\n     * @param valueIfNull the value to return if null\n     * @return the package name of the object, or the null value\n     */\n    public static String getPackageName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageName(object.getClass());\n    }\n\n    /**\n     * Gets the package name from a {@link String}.\n     *\n     * <p>\n     * The string passed in is assumed to be a class name - it is not checked.\n     * </p>\n     * <p>\n     * If the class is unpackaged, return an empty string.\n     * </p>\n     *\n     * @param className the className to get the package name for, may be {@code null}\n     * @return the package name or an empty string\n     */\n    public static String getPackageName(String className) {\n        if (StringUtils.isEmpty(className)) {\n            return StringUtils.EMPTY;\n        }\n\n        // Strip array encoding\n        while (className.charAt(0) == '[') {\n            className = className.substring(1);\n        }\n        // Strip Object type encoding\n        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n            className = className.substring(1);\n        }\n\n        final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        if (i == -1) {\n            return StringUtils.EMPTY;\n        }\n        return className.substring(0, i);\n    }\n\n    /**\n     * Gets the primitive class for the given class name, for example \"byte\".\n     *\n     * @param className the primitive class for the given class name.\n     * @return the primitive class.\n     */\n    static Class<?> getPrimitiveClass(final String className) {\n        return namePrimitiveMap.get(className);\n    }\n\n    /**\n     * Returns the desired Method much like {@code Class.getMethod}, however it ensures that the returned Method is from a\n     * public class or interface and not from an anonymous inner class. This means that the Method is invokable and doesn't\n     * fall foul of Java bug <a href=\"https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4071957\">4071957</a>).\n     *\n     * <pre>\n     *  <code>Set set = Collections.unmodifiableSet(...);\n     *  Method method = ClassUtils.getPublicMethod(set.getClass(), \"isEmpty\",  new Class[0]);\n     *  Object result = method.invoke(set, new Object[]);</code>\n     * </pre>\n     *\n     * @param cls the class to check, not null\n     * @param methodName the name of the method\n     * @param parameterTypes the list of parameters\n     * @return the method\n     * @throws NullPointerException if the class is null\n     * @throws SecurityException if a security violation occurred\n     * @throws NoSuchMethodException if the method is not found in the given class or if the method doesn't conform with the\n     *         requirements\n     */\n    public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws NoSuchMethodException {\n\n        final Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n        if (isPublic(declaredMethod.getDeclaringClass())) {\n            return declaredMethod;\n        }\n\n        final List<Class<?>> candidateClasses = new ArrayList<>(getAllInterfaces(cls));\n        candidateClasses.addAll(getAllSuperclasses(cls));\n\n        for (final Class<?> candidateClass : candidateClasses) {\n            if (!isPublic(candidateClass)) {\n                continue;\n            }\n            final Method candidateMethod;\n            try {\n                candidateMethod = candidateClass.getMethod(methodName, parameterTypes);\n            } catch (final NoSuchMethodException ex) {\n                continue;\n            }\n            if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {\n                return candidateMethod;\n            }\n        }\n\n        throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes));\n    }\n\n    /**\n     * Gets the canonical name minus the package name from a {@link Class}.\n     *\n     * @param cls the class for which to get the short canonical class name; may be null\n     * @return the canonical name without the package name or an empty string\n     * @since 2.4\n     * @see Class#getCanonicalName()\n     */\n    public static String getShortCanonicalName(final Class<?> cls) {\n        return cls == null ? StringUtils.EMPTY : getShortCanonicalName(cls.getCanonicalName());\n    }\n\n    /**\n     * Gets the canonical name minus the package name for an {@link Object}.\n     *\n     * @param object the class to get the short name for, may be null\n     * @param valueIfNull the value to return if null\n     * @return the canonical name of the object without the package name, or the null value\n     * @since 2.4\n     * @see Class#getCanonicalName()\n     */\n    public static String getShortCanonicalName(final Object object, final String valueIfNull) {\n        return object == null ? valueIfNull : getShortCanonicalName(object.getClass().getCanonicalName());\n    }\n\n    /**\n     * Gets the canonical name minus the package name from a String.\n     *\n     * <p>\n     * The string passed in is assumed to be a class name - it is not checked.\n     * </p>\n     *\n     * <p>\n     * Note that this method is mainly designed to handle the arrays and primitives properly. If the class is an inner class\n     * then the result value will not contain the outer classes. This way the behavior of this method is different from\n     * {@link #getShortClassName(String)}. The argument in that case is class name and not canonical name and the return\n     * value retains the outer classes.\n     * </p>\n     *\n     * <p>\n     * Note that there is no way to reliably identify the part of the string representing the package hierarchy and the part\n     * that is the outer class or classes in case of an inner class. Trying to find the class would require reflective call\n     * and the class itself may not even be on the class path. Relying on the fact that class names start with capital\n     * letter and packages with lower case is heuristic.\n     * </p>\n     *\n     * <p>\n     * It is recommended to use {@link #getShortClassName(String)} for cases when the class is an inner class and use this\n     * method for cases it is designed for.\n     * </p>\n     *\n     * <table>\n     * <caption>Examples</caption>\n     * <tr>\n     * <td>return value</td>\n     * <td>input</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"\"}</td>\n     * <td>{@code (String)null}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"Map.Entry\"}</td>\n     * <td>{@code java.util.Map.Entry.class.getName()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"Entry\"}</td>\n     * <td>{@code java.util.Map.Entry.class.getCanonicalName()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"ClassUtils\"}</td>\n     * <td>{@code \"org.apache.commons.lang3.ClassUtils\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"ClassUtils[]\"}</td>\n     * <td>{@code \"[Lorg.apache.commons.lang3.ClassUtils;\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"ClassUtils[][]\"}</td>\n     * <td>{@code \"[[Lorg.apache.commons.lang3.ClassUtils;\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"ClassUtils[]\"}</td>\n     * <td>{@code \"org.apache.commons.lang3.ClassUtils[]\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"ClassUtils[][]\"}</td>\n     * <td>{@code \"org.apache.commons.lang3.ClassUtils[][]\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[]\"}</td>\n     * <td>{@code \"[I\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[]\"}</td>\n     * <td>{@code int[].class.getCanonicalName()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[]\"}</td>\n     * <td>{@code int[].class.getName()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[][]\"}</td>\n     * <td>{@code \"[[I\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[]\"}</td>\n     * <td>{@code \"int[]\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[][]\"}</td>\n     * <td>{@code \"int[][]\"}</td>\n     * </tr>\n     * </table>\n     *\n     * @param canonicalName the class name to get the short name for\n     * @return the canonical name of the class without the package name or an empty string\n     * @since 2.4\n     */\n    public static String getShortCanonicalName(final String canonicalName) {\n        return getShortClassName(getCanonicalName(canonicalName));\n    }\n\n    /**\n     * Gets the class name minus the package name from a {@link Class}.\n     *\n     * <p>\n     * This method simply gets the name using {@code Class.getName()} and then calls {@link #getShortClassName(String)}. See\n     * relevant notes there.\n     * </p>\n     *\n     * @param cls the class to get the short name for.\n     * @return the class name without the package name or an empty string. If the class is an inner class then the returned\n     *         value will contain the outer class or classes separated with {@code .} (dot) character.\n     */\n    public static String getShortClassName(final Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortClassName(cls.getName());\n    }\n\n    /**\n     * Gets the class name of the {@code object} without the package name or names.\n     *\n     * <p>\n     * The method looks up the class of the object and then converts the name of the class invoking\n     * {@link #getShortClassName(Class)} (see relevant notes there).\n     * </p>\n     *\n     * @param object the class to get the short name for, may be {@code null}\n     * @param valueIfNull the value to return if the object is {@code null}\n     * @return the class name of the object without the package name, or {@code valueIfNull} if the argument {@code object}\n     *         is {@code null}\n     */\n    public static String getShortClassName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortClassName(object.getClass());\n    }\n\n    /**\n     * Gets the class name minus the package name from a String.\n     *\n     * <p>\n     * The string passed in is assumed to be a class name - it is not checked. The string has to be formatted the way as the\n     * JDK method {@code Class.getName()} returns it, and not the usual way as we write it, for example in import\n     * statements, or as it is formatted by {@code Class.getCanonicalName()}.\n     * </p>\n     *\n     * <p>\n     * The difference is is significant only in case of classes that are inner classes of some other classes. In this case\n     * the separator between the outer and inner class (possibly on multiple hierarchy level) has to be {@code $} (dollar\n     * sign) and not {@code .} (dot), as it is returned by {@code Class.getName()}\n     * </p>\n     *\n     * <p>\n     * Note that this method is called from the {@link #getShortClassName(Class)} method using the string returned by\n     * {@code Class.getName()}.\n     * </p>\n     *\n     * <p>\n     * Note that this method differs from {@link #getSimpleName(Class)} in that this will return, for example\n     * {@code \"Map.Entry\"} whilst the {@link Class} variant will simply return {@code \"Entry\"}. In this example\n     * the argument {@code className} is the string {@code java.util.Map$Entry} (note the {@code $} sign.\n     * </p>\n     *\n     * @param className the className to get the short name for. It has to be formatted as returned by\n     *        {@code Class.getName()} and not {@code Class.getCanonicalName()}\n     * @return the class name of the class without the package name or an empty string. If the class is an inner class then\n     *         value contains the outer class or classes and the separator is replaced to be {@code .} (dot) character.\n     */\n    public static String getShortClassName(String className) {\n        if (StringUtils.isEmpty(className)) {\n            return StringUtils.EMPTY;\n        }\n\n        final StringBuilder arrayPrefix = new StringBuilder();\n\n        // Handle array encoding\n        if (className.startsWith(\"[\")) {\n            while (className.charAt(0) == '[') {\n                className = className.substring(1);\n                arrayPrefix.append(\"[]\");\n            }\n            // Strip Object type encoding\n            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n                className = className.substring(1, className.length() - 1);\n            }\n\n            if (reverseAbbreviationMap.containsKey(className)) {\n                className = reverseAbbreviationMap.get(className);\n            }\n        }\n\n        final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n        String out = className.substring(lastDotIdx + 1);\n        if (innerIdx != -1) {\n            out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n        }\n        return out + arrayPrefix;\n    }\n\n    /**\n     * Null-safe version of {@code cls.getSimpleName()}\n     *\n     * @param cls the class for which to get the simple name; may be null\n     * @return the simple class name or the empty string in case the argument is {@code null}\n     * @since 3.0\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Class<?> cls) {\n        return getSimpleName(cls, StringUtils.EMPTY);\n    }\n\n    /**\n     * Null-safe version of {@code cls.getSimpleName()}\n     *\n     * @param cls the class for which to get the simple name; may be null\n     * @param valueIfNull the value to return if null\n     * @return the simple class name or {@code valueIfNull} if the argument {@code cls} is {@code null}\n     * @since 3.0\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Class<?> cls, final String valueIfNull) {\n        return cls == null ? valueIfNull : cls.getSimpleName();\n    }\n\n    /**\n     * Null-safe version of {@code object.getClass().getSimpleName()}\n     *\n     * <p>\n     * It is to note that this method is overloaded and in case the argument {@code object} is a {@link Class} object then\n     * the {@link #getSimpleName(Class)} will be invoked. If this is a significant possibility then the caller should check\n     * this case and call {@code\n     * getSimpleName(Class.class)} or just simply use the string literal {@code \"Class\"}, which is the result of the method\n     * in that case.\n     * </p>\n     *\n     * @param object the object for which to get the simple class name; may be null\n     * @return the simple class name or the empty string in case the argument is {@code null}\n     * @since 3.7\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Object object) {\n        return getSimpleName(object, StringUtils.EMPTY);\n    }\n\n    /**\n     * Null-safe version of {@code object.getClass().getSimpleName()}\n     *\n     * @param object the object for which to get the simple class name; may be null\n     * @param valueIfNull the value to return if {@code object} is {@code null}\n     * @return the simple class name or {@code valueIfNull} if the argument {@code object} is {@code null}\n     * @since 3.0\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Object object, final String valueIfNull) {\n        return object == null ? valueIfNull : object.getClass().getSimpleName();\n    }\n\n    /**\n     * Gets an {@link Iterable} that can iterate over a class hierarchy in ascending (subclass to superclass) order,\n     * excluding interfaces.\n     *\n     * @param type the type to get the class hierarchy from\n     * @return Iterable an Iterable over the class hierarchy of the given class\n     * @since 3.2\n     */\n    public static Iterable<Class<?>> hierarchy(final Class<?> type) {\n        return hierarchy(type, Interfaces.EXCLUDE);\n    }\n\n    /**\n     * Gets an {@link Iterable} that can iterate over a class hierarchy in ascending (subclass to superclass) order.\n     *\n     * @param type the type to get the class hierarchy from\n     * @param interfacesBehavior switch indicating whether to include or exclude interfaces\n     * @return Iterable an Iterable over the class hierarchy of the given class\n     * @since 3.2\n     */\n    public static Iterable<Class<?>> hierarchy(final Class<?> type, final Interfaces interfacesBehavior) {\n        final Iterable<Class<?>> classes = () -> {\n            final MutableObject<Class<?>> next = new MutableObject<>(type);\n            return new Iterator<Class<?>>() {\n\n                @Override\n                public boolean hasNext() {\n                    return next.getValue() != null;\n                }\n\n                @Override\n                public Class<?> next() {\n                    final Class<?> result = next.getValue();\n                    next.setValue(result.getSuperclass());\n                    return result;\n                }\n\n                @Override\n                public void remove() {\n                    throw new UnsupportedOperationException();\n                }\n\n            };\n        };\n        if (interfacesBehavior != Interfaces.INCLUDE) {\n            return classes;\n        }\n        return () -> {\n            final Set<Class<?>> seenInterfaces = new HashSet<>();\n            final Iterator<Class<?>> wrapped = classes.iterator();\n\n            return new Iterator<Class<?>>() {\n                Iterator<Class<?>> interfaces = Collections.emptyIterator();\n\n                @Override\n                public boolean hasNext() {\n                    return interfaces.hasNext() || wrapped.hasNext();\n                }\n\n                @Override\n                public Class<?> next() {\n                    if (interfaces.hasNext()) {\n                        final Class<?> nextInterface = interfaces.next();\n                        seenInterfaces.add(nextInterface);\n                        return nextInterface;\n                    }\n                    final Class<?> nextSuperclass = wrapped.next();\n                    final Set<Class<?>> currentInterfaces = new LinkedHashSet<>();\n                    walkInterfaces(currentInterfaces, nextSuperclass);\n                    interfaces = currentInterfaces.iterator();\n                    return nextSuperclass;\n                }\n\n                @Override\n                public void remove() {\n                    throw new UnsupportedOperationException();\n                }\n\n                private void walkInterfaces(final Set<Class<?>> addTo, final Class<?> c) {\n                    for (final Class<?> iface : c.getInterfaces()) {\n                        if (!seenInterfaces.contains(iface)) {\n                            addTo.add(iface);\n                        }\n                        walkInterfaces(addTo, iface);\n                    }\n                }\n\n            };\n        };\n    }\n\n    /**\n     * Checks if one {@link Class} can be assigned to a variable of another {@link Class}.\n     *\n     * <p>\n     * Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into account widenings of\n     * primitive classes and {@code null}s.\n     * </p>\n     *\n     * <p>\n     * Primitive widenings allow an int to be assigned to a long, float or double. This method returns the correct result\n     * for these cases.\n     * </p>\n     *\n     * <p>\n     * {@code null} may be assigned to any reference type. This method will return {@code true} if {@code null} is passed in\n     * and the toClass is non-primitive.\n     * </p>\n     *\n     * <p>\n     * Specifically, this method tests whether the type represented by the specified {@link Class} parameter can be\n     * converted to the type represented by this {@link Class} object via an identity conversion widening primitive or\n     * widening reference conversion. See <em><a href=\"https://docs.oracle.com/javase/specs/\">The Java Language\n     * Specification</a></em>, sections 5.1.1, 5.1.2 and 5.1.4 for details.\n     * </p>\n     *\n     * <p>\n     * <strong>Since Lang 3.0,</strong> this method will default behavior for calculating assignability between primitive\n     * and wrapper types <em>corresponding to the running Java version</em>; i.e. autoboxing will be the default behavior in\n     * VMs running Java versions &gt; 1.5.\n     * </p>\n     *\n     * @param cls the Class to check, may be null\n     * @param toClass the Class to try to assign into, returns false if null\n     * @return {@code true} if assignment possible\n     */\n    public static boolean isAssignable(final Class<?> cls, final Class<?> toClass) {\n        return isAssignable(cls, toClass, true);\n    }\n\n    /**\n     * Checks if one {@link Class} can be assigned to a variable of another {@link Class}.\n     *\n     * <p>\n     * Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into account widenings of\n     * primitive classes and {@code null}s.\n     * </p>\n     *\n     * <p>\n     * Primitive widenings allow an int to be assigned to a long, float or double. This method returns the correct result\n     * for these cases.\n     * </p>\n     *\n     * <p>\n     * {@code null} may be assigned to any reference type. This method will return {@code true} if {@code null} is passed in\n     * and the toClass is non-primitive.\n     * </p>\n     *\n     * <p>\n     * Specifically, this method tests whether the type represented by the specified {@link Class} parameter can be\n     * converted to the type represented by this {@link Class} object via an identity conversion widening primitive or\n     * widening reference conversion. See <em><a href=\"https://docs.oracle.com/javase/specs/\">The Java Language\n     * Specification</a></em>, sections 5.1.1, 5.1.2 and 5.1.4 for details.\n     * </p>\n     *\n     * @param cls the Class to check, may be null\n     * @param toClass the Class to try to assign into, returns false if null\n     * @param autoboxing whether to use implicit autoboxing/unboxing between primitives and wrappers\n     * @return {@code true} if assignment possible\n     */\n    public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {\n        if (toClass == null) {\n            return false;\n        }\n        // have to check for null, as isAssignableFrom doesn't\n        if (cls == null) {\n            return !toClass.isPrimitive();\n        }\n        // autoboxing:\n        if (autoboxing) {\n            if (cls.isPrimitive() && !toClass.isPrimitive()) {\n                cls = primitiveToWrapper(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n            if (toClass.isPrimitive() && !cls.isPrimitive()) {\n                cls = wrapperToPrimitive(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n        }\n        if (cls.equals(toClass)) {\n            return true;\n        }\n        if (cls.isPrimitive()) {\n            if (!toClass.isPrimitive()) {\n                return false;\n            }\n            if (Integer.TYPE.equals(cls)) {\n                return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);\n            }\n            if (Long.TYPE.equals(cls)) {\n                return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);\n            }\n            if (Boolean.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Double.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Float.TYPE.equals(cls)) {\n                return Double.TYPE.equals(toClass);\n            }\n            if (Character.TYPE.equals(cls)  || Short.TYPE.equals(cls)) {\n                return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);\n            }\n            if (Byte.TYPE.equals(cls)) {\n                return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            // should never get here\n            return false;\n        }\n        return toClass.isAssignableFrom(cls);\n    }\n\n    /**\n     * Checks if an array of Classes can be assigned to another array of Classes.\n     *\n     * <p>\n     * This method calls {@link #isAssignable(Class, Class) isAssignable} for each Class pair in the input arrays. It can be\n     * used to check if a set of arguments (the first parameter) are suitably compatible with a set of method parameter\n     * types (the second parameter).\n     * </p>\n     *\n     * <p>\n     * Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into account widenings of\n     * primitive classes and {@code null}s.\n     * </p>\n     *\n     * <p>\n     * Primitive widenings allow an int to be assigned to a {@code long}, {@code float} or {@code double}. This method\n     * returns the correct result for these cases.\n     * </p>\n     *\n     * <p>\n     * {@code null} may be assigned to any reference type. This method will return {@code true} if {@code null} is passed in\n     * and the toClass is non-primitive.\n     * </p>\n     *\n     * <p>\n     * Specifically, this method tests whether the type represented by the specified {@link Class} parameter can be\n     * converted to the type represented by this {@link Class} object via an identity conversion widening primitive or\n     * widening reference conversion. See <em><a href=\"https://docs.oracle.com/javase/specs/\">The Java Language\n     * Specification</a></em>, sections 5.1.1, 5.1.2 and 5.1.4 for details.\n     * </p>\n     *\n     * <p>\n     * <strong>Since Lang 3.0,</strong> this method will default behavior for calculating assignability between primitive\n     * and wrapper types <em>corresponding to the running Java version</em>; i.e. autoboxing will be the default behavior in\n     * VMs running Java versions &gt; 1.5.\n     * </p>\n     *\n     * @param classArray the array of Classes to check, may be {@code null}\n     * @param toClassArray the array of Classes to try to assign into, may be {@code null}\n     * @return {@code true} if assignment possible\n     */\n    public static boolean isAssignable(final Class<?>[] classArray, final Class<?>... toClassArray) {\n        return isAssignable(classArray, toClassArray, true);\n    }\n\n    /**\n     * Checks if an array of Classes can be assigned to another array of Classes.\n     *\n     * <p>\n     * This method calls {@link #isAssignable(Class, Class) isAssignable} for each Class pair in the input arrays. It can be\n     * used to check if a set of arguments (the first parameter) are suitably compatible with a set of method parameter\n     * types (the second parameter).\n     * </p>\n     *\n     * <p>\n     * Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into account widenings of\n     * primitive classes and {@code null}s.\n     * </p>\n     *\n     * <p>\n     * Primitive widenings allow an int to be assigned to a {@code long}, {@code float} or {@code double}. This method\n     * returns the correct result for these cases.\n     * </p>\n     *\n     * <p>\n     * {@code null} may be assigned to any reference type. This method will return {@code true} if {@code null} is passed in\n     * and the toClass is non-primitive.\n     * </p>\n     *\n     * <p>\n     * Specifically, this method tests whether the type represented by the specified {@link Class} parameter can be\n     * converted to the type represented by this {@link Class} object via an identity conversion widening primitive or\n     * widening reference conversion. See <em><a href=\"https://docs.oracle.com/javase/specs/\">The Java Language\n     * Specification</a></em>, sections 5.1.1, 5.1.2 and 5.1.4 for details.\n     * </p>\n     *\n     * @param classArray the array of Classes to check, may be {@code null}\n     * @param toClassArray the array of Classes to try to assign into, may be {@code null}\n     * @param autoboxing whether to use implicit autoboxing/unboxing between primitives and wrappers\n     * @return {@code true} if assignment possible\n     */\n    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, final boolean autoboxing) {\n        if (!ArrayUtils.isSameLength(classArray, toClassArray)) {\n            return false;\n        }\n        classArray = ArrayUtils.nullToEmpty(classArray);\n        toClassArray = ArrayUtils.nullToEmpty(toClassArray);\n        for (int i = 0; i < classArray.length; i++) {\n            if (!isAssignable(classArray[i], toClassArray[i], autoboxing)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Is the specified class an inner class or static nested class.\n     *\n     * @param cls the class to check, may be null\n     * @return {@code true} if the class is an inner or static nested class, false if not or {@code null}\n     */\n    public static boolean isInnerClass(final Class<?> cls) {\n        return cls != null && cls.getEnclosingClass() != null;\n    }\n\n    /**\n     * Returns whether the given {@code type} is a primitive or primitive wrapper ({@link Boolean}, {@link Byte},\n     * {@link Character}, {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n     *\n     * @param type The class to query or null.\n     * @return true if the given {@code type} is a primitive or primitive wrapper ({@link Boolean}, {@link Byte},\n     *         {@link Character}, {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n     * @since 3.1\n     */\n    public static boolean isPrimitiveOrWrapper(final Class<?> type) {\n        if (type == null) {\n            return false;\n        }\n        return type.isPrimitive() || isPrimitiveWrapper(type);\n    }\n    /**\n     * Returns whether the given {@code type} is a primitive wrapper ({@link Boolean}, {@link Byte}, {@link Character},\n     * {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n     *\n     * @param type The class to query or null.\n     * @return true if the given {@code type} is a primitive wrapper ({@link Boolean}, {@link Byte}, {@link Character},\n     *         {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n     * @since 3.1\n     */\n    public static boolean isPrimitiveWrapper(final Class<?> type) {\n        return wrapperPrimitiveMap.containsKey(type);\n    }\n\n    /**\n     * Tests whether a {@link Class} is public.\n     * @param cls Class to test.\n     * @return {@code true} if {@code cls} is public.\n     * @since 3.13.0\n     */\n    public static boolean isPublic(final Class<?> cls) {\n        return Modifier.isPublic(cls.getModifiers());\n    }\n\n    /**\n     * Converts the specified array of primitive Class objects to an array of its corresponding wrapper Class objects.\n     *\n     * @param classes the class array to convert, may be null or empty\n     * @return an array which contains for each given class, the wrapper class or the original class if class is not a\n     *         primitive. {@code null} if null input. Empty array if an empty array passed in.\n     * @since 2.1\n     */\n    public static Class<?>[] primitivesToWrappers(final Class<?>... classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        final Class<?>[] convertedClasses = new Class[classes.length];\n        Arrays.setAll(convertedClasses, i -> primitiveToWrapper(classes[i]));\n        return convertedClasses;\n    }\n\n    /**\n     * Converts the specified primitive Class object to its corresponding wrapper Class object.\n     *\n     * <p>\n     * NOTE: From v2.2, this method handles {@code Void.TYPE}, returning {@code Void.TYPE}.\n     * </p>\n     *\n     * @param cls the class to convert, may be null\n     * @return the wrapper class for {@code cls} or {@code cls} if {@code cls} is not a primitive. {@code null} if null\n     *         input.\n     * @since 2.1\n     */\n    public static Class<?> primitiveToWrapper(final Class<?> cls) {\n        Class<?> convertedClass = cls;\n        if (cls != null && cls.isPrimitive()) {\n            convertedClass = primitiveWrapperMap.get(cls);\n        }\n        return convertedClass;\n    }\n\n    /**\n     * Converts a class name to a JLS style class name.\n     *\n     * @param className the class name\n     * @return the converted name\n     * @throws NullPointerException if the className is null\n     */\n    private static String toCanonicalName(final String className) {\n        String canonicalName = StringUtils.deleteWhitespace(className);\n        Objects.requireNonNull(canonicalName, \"className\");\n        if (canonicalName.endsWith(\"[]\")) {\n            final StringBuilder classNameBuffer = new StringBuilder();\n            while (canonicalName.endsWith(\"[]\")) {\n                canonicalName = canonicalName.substring(0, canonicalName.length() - 2);\n                classNameBuffer.append(\"[\");\n            }\n            final String abbreviation = abbreviationMap.get(canonicalName);\n            if (abbreviation != null) {\n                classNameBuffer.append(abbreviation);\n            } else {\n                classNameBuffer.append(\"L\").append(canonicalName).append(\";\");\n            }\n            canonicalName = classNameBuffer.toString();\n        }\n        return canonicalName;\n    }\n\n    /**\n     * Converts an array of {@link Object} in to an array of {@link Class} objects. If any of these objects is null, a null\n     * element will be inserted into the array.\n     *\n     * <p>\n     * This method returns {@code null} for a {@code null} input array.\n     * </p>\n     *\n     * @param array an {@link Object} array\n     * @return a {@link Class} array, {@code null} if null array input\n     * @since 2.4\n     */\n    public static Class<?>[] toClass(final Object... array) {\n        if (array == null) {\n            return null;\n        }\n        if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        final Class<?>[] classes = new Class[array.length];\n        Arrays.setAll(classes, i -> array[i] == null ? null : array[i].getClass());\n        return classes;\n    }\n\n    /**\n     * Decides if the part that was just copied to its destination location in the work array can be kept as it was copied\n     * or must be abbreviated. It must be kept when the part is the last one, which is the simple name of the class. In this\n     * case the {@code source} index, from where the characters are copied points one position after the last character,\n     * a.k.a. {@code source ==\n     * originalLength}\n     *\n     * <p>\n     * If the part is not the last one then it can be kept unabridged if the number of the characters copied so far plus the\n     * character that are to be copied is less than or equal to the desired length.\n     * </p>\n     *\n     * @param runAheadTarget the target index (where the characters were copied to) pointing after the last character copied\n     *        when the current part was copied\n     * @param source the source index (where the characters were copied from) pointing after the last character copied when\n     *        the current part was copied\n     * @param originalLength the original length of the class full name, which is abbreviated\n     * @param desiredLength the desired length of the abbreviated class name\n     * @return {@code true} if it can be kept in its original length {@code false} if the current part has to be abbreviated\n     *         and\n     */\n    private static boolean useFull(final int runAheadTarget, final int source, final int originalLength, final int desiredLength) {\n        return source >= originalLength || runAheadTarget + originalLength - source <= desiredLength;\n    }\n\n    /**\n     * Converts the specified array of wrapper Class objects to an array of its corresponding primitive Class objects.\n     *\n     * <p>\n     * This method invokes {@code wrapperToPrimitive()} for each element of the passed in array.\n     * </p>\n     *\n     * @param classes the class array to convert, may be null or empty\n     * @return an array which contains for each given class, the primitive class or <b>null</b> if the original class is not\n     *         a wrapper class. {@code null} if null input. Empty array if an empty array passed in.\n     * @see #wrapperToPrimitive(Class)\n     * @since 2.4\n     */\n    public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        final Class<?>[] convertedClasses = new Class[classes.length];\n        Arrays.setAll(convertedClasses, i -> wrapperToPrimitive(classes[i]));\n        return convertedClasses;\n    }\n\n    /**\n     * Converts the specified wrapper class to its corresponding primitive class.\n     *\n     * <p>\n     * This method is the counter part of {@code primitiveToWrapper()}. If the passed in class is a wrapper class for a\n     * primitive type, this primitive type will be returned (e.g. {@code Integer.TYPE} for {@code Integer.class}). For other\n     * classes, or if the parameter is <b>null</b>, the return value is <b>null</b>.\n     * </p>\n     *\n     * @param cls the class to convert, may be <b>null</b>\n     * @return the corresponding primitive type if {@code cls} is a wrapper class, <b>null</b> otherwise\n     * @see #primitiveToWrapper(Class)\n     * @since 2.4\n     */\n    public static Class<?> wrapperToPrimitive(final Class<?> cls) {\n        return wrapperPrimitiveMap.get(cls);\n    }\n\n    /**\n     * ClassUtils instances should NOT be constructed in standard programming. Instead, the class should be used as\n     * {@code ClassUtils.getShortClassName(cls)}.\n     *\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public ClassUtils() {\n        // empty\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Gets the primitive class for the given class name, for example \"byte\".\n     *\n     * @param className the primitive class for the given class name.\n     * @return the primitive class.\n     */\n    static Class<?> getPrimitiveClass(final String className) {\n        return namePrimitiveMap.get(className);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.ClassUtils#toCanonicalName\n methodBody: private static String toCanonicalName(final String className) {\nString canonicalName=StringUtils.deleteWhitespace(className);\nObjects.requireNonNull(canonicalName,\"className\");\nif(canonicalName.endsWith(\"[]\")){final StringBuilder classNameBuffer=new StringBuilder();\nwhile(canonicalName.endsWith(\"[]\")){canonicalName=canonicalName.substring(0,canonicalName.length() - 2);\nclassNameBuffer.append(\"[\");\n}final String abbreviation=abbreviationMap.get(canonicalName);\nif(abbreviation != null){classNameBuffer.append(abbreviation);\n}{classNameBuffer.append(\"L\").append(canonicalName).append(\";\");\n}canonicalName=classNameBuffer.toString();\n}return canonicalName;\n}",
            "methodSignature: org.apache.commons.lang3.ClassUtils#getClass\n methodBody: public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {\nfinal ClassLoader contextCL=Thread.currentThread().getContextClassLoader();\nfinal ClassLoader loader=contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\nreturn getClass(loader,className,initialize);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Returns the class represented by {@code className} using the {@code classLoader}. This implementation supports the\n     * syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\", \"{@code [Ljava.util.Map.Entry;}\", and\n     * \"{@code [Ljava.util.Map$Entry;}\".\n     *\n     * @param classLoader the class loader to use to load the class\n     * @param className the class name\n     * @param initialize whether the class must be initialized\n     * @return the class represented by {@code className} using the {@code classLoader}\n     * @throws NullPointerException if the className is null\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {\n        try {\n            final Class<?> clazz = getPrimitiveClass(className);\n            return clazz != null ? clazz : Class.forName(toCanonicalName(className), initialize, classLoader);\n        } catch (final ClassNotFoundException ex) {\n            // allow path separators (.) as inner class name separators\n            final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n\n            if (lastDotIndex != -1) {\n                try {\n                    return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1),\n                        initialize);\n                } catch (final ClassNotFoundException ignored) {\n                    // ignore exception\n                }\n            }\n\n            throw ex;\n        }\n    }\n/**\n     * Gets the primitive class for the given class name, for example \"byte\".\n     *\n     * @param className the primitive class for the given class name.\n     * @return the primitive class.\n     */\n    static Class<?> getPrimitiveClass(final String className) {\n        return namePrimitiveMap.get(className);\n    }",
        "diffSourceCode": "   517:     /**\n   518:      * Returns the class represented by {@code className} using the {@code classLoader}. This implementation supports the\n   519:      * syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\", \"{@code [Ljava.util.Map.Entry;}\", and\n   520:      * \"{@code [Ljava.util.Map$Entry;}\".\n   521:      *\n   522:      * @param classLoader the class loader to use to load the class\n   523:      * @param className the class name\n   524:      * @param initialize whether the class must be initialized\n   525:      * @return the class represented by {@code className} using the {@code classLoader}\n   526:      * @throws NullPointerException if the className is null\n   527:      * @throws ClassNotFoundException if the class is not found\n   528:      */\n   529:     public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {\n   530:         try {\n-  531:             final Class<?> clazz = namePrimitiveMap.get(className);\n+  531:             final Class<?> clazz = getPrimitiveClass(className);\n   532:             return clazz != null ? clazz : Class.forName(toCanonicalName(className), initialize, classLoader);\n   533:         } catch (final ClassNotFoundException ex) {\n   534:             // allow path separators (.) as inner class name separators\n   535:             final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n   536: \n   537:             if (lastDotIndex != -1) {\n   538:                 try {\n   539:                     return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1),\n   540:                         initialize);\n   541:                 } catch (final ClassNotFoundException ignored) {\n   542:                     // ignore exception\n   543:                 }\n   544:             }\n   545: \n   546:             throw ex;\n   547:         }\n   548:     }\n   753:     /**\n-  754:      * Returns the desired Method much like {@code Class.getMethod}, however it ensures that the returned Method is from a\n-  755:      * public class or interface and not from an anonymous inner class. This means that the Method is invokable and doesn't\n-  756:      * fall foul of Java bug <a href=\"https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4071957\">4071957</a>).\n-  757:      *\n-  758:      * <pre>\n-  759:      *  <code>Set set = Collections.unmodifiableSet(...);\n-  760:      *  Method method = ClassUtils.getPublicMethod(set.getClass(), \"isEmpty\",  new Class[0]);\n-  761:      *  Object result = method.invoke(set, new Object[]);</code>\n+  754:      * Gets the primitive class for the given class name, for example \"byte\".\n+  755:      *\n+  756:      * @param className the primitive class for the given class name.\n+  757:      * @return the primitive class.\n+  758:      */\n+  759:     static Class<?> getPrimitiveClass(final String className) {\n+  760:         return namePrimitiveMap.get(className);\n+  761:     }\n",
        "uniqueId": "45a955702a06d817aa18007a9b099c37ee2ec20a_517_548_753_761_517_548",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 3,
                "covered": 12
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nRefactored Code:\n\nprivate static String getCanonicalName(String className) {\n    className = StringUtils.deleteWhitespace(className);\n    Objects.requireNonNull(className, \"className\");\n    if (className.endsWith(\"[]\")) {\n        StringBuilder classNameBuffer = new StringBuilder();\n        while (className.endsWith(\"[]\")) {\n            className = className.substring(0, className.length() - 2);\n            classNameBuffer.append(\"[\");\n        }\n        String abbreviation = abbreviationMap.get(className);\n        if (abbreviation != null) {\n            classNameBuffer.append(abbreviation);\n        } else {\n            classNameBuffer.append(\"L\").append(className).append(\";\");\n        }\n        className = classNameBuffer.toString();\n    }\n    return className;\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Returns the class represented by {@code className} using the {@code classLoader}. This implementation supports the\n     * syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\", \"{@code [Ljava.util.Map.Entry;}\", and\n     * \"{@code [Ljava.util.Map$Entry;}\".\n     *\n     * @param classLoader the class loader to use to load the class\n     * @param className the class name\n     * @param initialize whether the class must be initialized\n     * @return the class represented by {@code className} using the {@code classLoader}\n     * @throws NullPointerException if the className is null\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {\n        try {\n            final Class<?> clazz = namePrimitiveMap.get(className);\n            return clazz != null ? clazz : Class.forName(toCanonicalName(className), initialize, classLoader);\n        } catch (final ClassNotFoundException ex) {\n            // allow path separators (.) as inner class name separators\n            final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n\n            if (lastDotIndex != -1) {\n                try {\n                    return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1),\n                        initialize);\n                } catch (final ClassNotFoundException ignored) {\n                    // ignore exception\n                }\n            }\n\n            throw ex;\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.lang3.mutable.MutableObject;\n\n/**\n * Operates on classes without using reflection.\n *\n * <p>\n * This class handles invalid {@code null} inputs as best it can. Each method documents its behavior in more detail.\n * </p>\n *\n * <p>\n * The notion of a {@code canonical name} includes the human readable name for the type, for example {@code int[]}. The\n * non-canonical method variants work with the JVM names, such as {@code [I}.\n * </p>\n *\n * @since 2.0\n */\npublic class ClassUtils {\n\n    /**\n     * Inclusivity literals for {@link #hierarchy(Class, Interfaces)}.\n     *\n     * @since 3.2\n     */\n    public enum Interfaces {\n\n        /** Includes interfaces. */\n        INCLUDE,\n\n        /** Excludes interfaces. */\n        EXCLUDE\n    }\n\n    private static final Comparator<Class<?>> COMPARATOR = (o1, o2) -> Objects.compare(getName(o1), getName(o2), String::compareTo);\n\n    /**\n     * The package separator character: {@code '&#x2e;' == {@value}}.\n     */\n    public static final char PACKAGE_SEPARATOR_CHAR = '.';\n\n    /**\n     * The package separator String: {@code \"&#x2e;\"}.\n     */\n    public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR);\n\n    /**\n     * The inner class separator character: {@code '$' == {@value}}.\n     */\n    public static final char INNER_CLASS_SEPARATOR_CHAR = '$';\n\n    /**\n     * The inner class separator String: {@code \"$\"}.\n     */\n    public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR);\n\n    /**\n     * Maps names of primitives to their corresponding primitive {@link Class}es.\n     */\n    private static final Map<String, Class<?>> namePrimitiveMap = new HashMap<>();\n\n    static {\n        namePrimitiveMap.put(Boolean.TYPE.getSimpleName(), Boolean.TYPE);\n        namePrimitiveMap.put(Byte.TYPE.getSimpleName(), Byte.TYPE);\n        namePrimitiveMap.put(Character.TYPE.getSimpleName(), Character.TYPE);\n        namePrimitiveMap.put(Double.TYPE.getSimpleName(), Double.TYPE);\n        namePrimitiveMap.put(Float.TYPE.getSimpleName(), Float.TYPE);\n        namePrimitiveMap.put(Integer.TYPE.getSimpleName(), Integer.TYPE);\n        namePrimitiveMap.put(Long.TYPE.getSimpleName(), Long.TYPE);\n        namePrimitiveMap.put(Short.TYPE.getSimpleName(), Short.TYPE);\n        namePrimitiveMap.put(Void.TYPE.getSimpleName(), Void.TYPE);\n    }\n\n    /**\n     * Maps primitive {@link Class}es to their corresponding wrapper {@link Class}.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<>();\n\n    static {\n        primitiveWrapperMap.put(Boolean.TYPE, Boolean.class);\n        primitiveWrapperMap.put(Byte.TYPE, Byte.class);\n        primitiveWrapperMap.put(Character.TYPE, Character.class);\n        primitiveWrapperMap.put(Short.TYPE, Short.class);\n        primitiveWrapperMap.put(Integer.TYPE, Integer.class);\n        primitiveWrapperMap.put(Long.TYPE, Long.class);\n        primitiveWrapperMap.put(Double.TYPE, Double.class);\n        primitiveWrapperMap.put(Float.TYPE, Float.class);\n        primitiveWrapperMap.put(Void.TYPE, Void.TYPE);\n    }\n\n    /**\n     * Maps wrapper {@link Class}es to their corresponding primitive types.\n     */\n    private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<>();\n\n    static {\n        primitiveWrapperMap.forEach((primitiveClass, wrapperClass) -> {\n            if (!primitiveClass.equals(wrapperClass)) {\n                wrapperPrimitiveMap.put(wrapperClass, primitiveClass);\n            }\n        });\n    }\n\n    /**\n     * Maps a primitive class name to its corresponding abbreviation used in array class names.\n     */\n    private static final Map<String, String> abbreviationMap;\n\n    /**\n     * Maps an abbreviation used in array class names to corresponding primitive class name.\n     */\n    private static final Map<String, String> reverseAbbreviationMap;\n\n    /** Feed abbreviation maps. */\n    static {\n        final Map<String, String> map = new HashMap<>();\n        map.put(\"int\", \"I\");\n        map.put(\"boolean\", \"Z\");\n        map.put(\"float\", \"F\");\n        map.put(\"long\", \"J\");\n        map.put(\"short\", \"S\");\n        map.put(\"byte\", \"B\");\n        map.put(\"double\", \"D\");\n        map.put(\"char\", \"C\");\n        abbreviationMap = Collections.unmodifiableMap(map);\n        reverseAbbreviationMap = Collections.unmodifiableMap(map.entrySet().stream().collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey)));\n    }\n\n    /**\n     * Gets the class comparator, comparing by class name.\n     *\n     * @return the class comparator.\n     * @since 3.13.0\n     */\n    public static Comparator<Class<?>> comparator() {\n        return COMPARATOR;\n    }\n\n    /**\n     * Given a {@link List} of {@link Class} objects, this method converts them into class names.\n     *\n     * <p>\n     * A new {@link List} is returned. {@code null} objects will be copied into the returned list as {@code null}.\n     * </p>\n     *\n     * @param classes the classes to change\n     * @return a {@link List} of class names corresponding to the Class objects, {@code null} if null input\n     * @throws ClassCastException if {@code classes} contains a non-{@link Class} entry\n     */\n    public static List<String> convertClassesToClassNames(final List<Class<?>> classes) {\n        return classes == null ? null : classes.stream().map(e -> getName(e, null)).collect(Collectors.toList());\n    }\n\n    /**\n     * Given a {@link List} of class names, this method converts them into classes.\n     *\n     * <p>\n     * A new {@link List} is returned. If the class name cannot be found, {@code null} is stored in the {@link List}. If the\n     * class name in the {@link List} is {@code null}, {@code null} is stored in the output {@link List}.\n     * </p>\n     *\n     * @param classNames the classNames to change\n     * @return a {@link List} of Class objects corresponding to the class names, {@code null} if null input\n     * @throws ClassCastException if classNames contains a non String entry\n     */\n    public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) {\n        if (classNames == null) {\n            return null;\n        }\n        final List<Class<?>> classes = new ArrayList<>(classNames.size());\n        classNames.forEach(className -> {\n            try {\n                classes.add(Class.forName(className));\n            } catch (final Exception ex) {\n                classes.add(null);\n            }\n        });\n        return classes;\n    }\n\n    /**\n     * Gets the abbreviated name of a {@link Class}.\n     *\n     * @param cls the class to get the abbreviated name for, may be {@code null}\n     * @param lengthHint the desired length of the abbreviated name\n     * @return the abbreviated name or an empty string\n     * @throws IllegalArgumentException if len &lt;= 0\n     * @see #getAbbreviatedName(String, int)\n     * @since 3.4\n     */\n    public static String getAbbreviatedName(final Class<?> cls, final int lengthHint) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getAbbreviatedName(cls.getName(), lengthHint);\n    }\n\n    /**\n     * Gets the abbreviated class name from a {@link String}.\n     *\n     * <p>\n     * The string passed in is assumed to be a class name - it is not checked.\n     * </p>\n     *\n     * <p>\n     * The abbreviation algorithm will shorten the class name, usually without significant loss of meaning.\n     * </p>\n     *\n     * <p>\n     * The abbreviated class name will always include the complete package hierarchy. If enough space is available,\n     * rightmost sub-packages will be displayed in full length. The abbreviated package names will be shortened to a single\n     * character.\n     * </p>\n     * <p>\n     * Only package names are shortened, the class simple name remains untouched. (See examples.)\n     * </p>\n     * <p>\n     * The result will be longer than the desired length only if all the package names shortened to a single character plus\n     * the class simple name with the separating dots together are longer than the desired length. In other words, when the\n     * class name cannot be shortened to the desired length.\n     * </p>\n     * <p>\n     * If the class name can be shortened then the final length will be at most {@code lengthHint} characters.\n     * </p>\n     * <p>\n     * If the {@code lengthHint} is zero or negative then the method throws exception. If you want to achieve the shortest\n     * possible version then use {@code 1} as a {@code lengthHint}.\n     * </p>\n     *\n     * <table>\n     * <caption>Examples</caption>\n     * <tr>\n     * <td>className</td>\n     * <td>len</td>\n     * <td>return</td>\n     * </tr>\n     * <tr>\n     * <td>null</td>\n     * <td>1</td>\n     * <td>\"\"</td>\n     * </tr>\n     * <tr>\n     * <td>\"java.lang.String\"</td>\n     * <td>5</td>\n     * <td>\"j.l.String\"</td>\n     * </tr>\n     * <tr>\n     * <td>\"java.lang.String\"</td>\n     * <td>15</td>\n     * <td>\"j.lang.String\"</td>\n     * </tr>\n     * <tr>\n     * <td>\"java.lang.String\"</td>\n     * <td>30</td>\n     * <td>\"java.lang.String\"</td>\n     * </tr>\n     * <tr>\n     * <td>\"org.apache.commons.lang3.ClassUtils\"</td>\n     * <td>18</td>\n     * <td>\"o.a.c.l.ClassUtils\"</td>\n     * </tr>\n     * </table>\n     *\n     * @param className the className to get the abbreviated name for, may be {@code null}\n     * @param lengthHint the desired length of the abbreviated name\n     * @return the abbreviated name or an empty string if the specified class name is {@code null} or empty string. The\n     *         abbreviated name may be longer than the desired length if it cannot be abbreviated to the desired length.\n     * @throws IllegalArgumentException if {@code len <= 0}\n     * @since 3.4\n     */\n    public static String getAbbreviatedName(final String className, final int lengthHint) {\n        if (lengthHint <= 0) {\n            throw new IllegalArgumentException(\"len must be > 0\");\n        }\n        if (className == null) {\n            return StringUtils.EMPTY;\n        }\n        if (className.length() <= lengthHint) {\n            return className;\n        }\n        final char[] abbreviated = className.toCharArray();\n        int target = 0;\n        int source = 0;\n        while (source < abbreviated.length) {\n            // copy the next part\n            int runAheadTarget = target;\n            while (source < abbreviated.length && abbreviated[source] != '.') {\n                abbreviated[runAheadTarget++] = abbreviated[source++];\n            }\n\n            ++target;\n            if (useFull(runAheadTarget, source, abbreviated.length, lengthHint) || target > runAheadTarget) {\n                target = runAheadTarget;\n            }\n\n            // copy the '.' unless it was the last part\n            if (source < abbreviated.length) {\n                abbreviated[target++] = abbreviated[source++];\n            }\n        }\n        return new String(abbreviated, 0, target);\n    }\n\n    /**\n     * Gets a {@link List} of all interfaces implemented by the given class and its superclasses.\n     *\n     * <p>\n     * The order is determined by looking through each interface in turn as declared in the source file and following its\n     * hierarchy up. Then each superclass is considered in the same way. Later duplicates are ignored, so the order is\n     * maintained.\n     * </p>\n     *\n     * @param cls the class to look up, may be {@code null}\n     * @return the {@link List} of interfaces in order, {@code null} if null input\n     */\n    public static List<Class<?>> getAllInterfaces(final Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n\n        final LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<>();\n        getAllInterfaces(cls, interfacesFound);\n\n        return new ArrayList<>(interfacesFound);\n    }\n\n    /**\n     * Gets the interfaces for the specified class.\n     *\n     * @param cls the class to look up, may be {@code null}\n     * @param interfacesFound the {@link Set} of interfaces for the class\n     */\n    private static void getAllInterfaces(Class<?> cls, final HashSet<Class<?>> interfacesFound) {\n        while (cls != null) {\n            final Class<?>[] interfaces = cls.getInterfaces();\n\n            for (final Class<?> i : interfaces) {\n                if (interfacesFound.add(i)) {\n                    getAllInterfaces(i, interfacesFound);\n                }\n            }\n\n            cls = cls.getSuperclass();\n        }\n    }\n\n    /**\n     * Gets a {@link List} of superclasses for the given class.\n     *\n     * @param cls the class to look up, may be {@code null}\n     * @return the {@link List} of superclasses in order going up from this one {@code null} if null input\n     */\n    public static List<Class<?>> getAllSuperclasses(final Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n        final List<Class<?>> classes = new ArrayList<>();\n        Class<?> superclass = cls.getSuperclass();\n        while (superclass != null) {\n            classes.add(superclass);\n            superclass = superclass.getSuperclass();\n        }\n        return classes;\n    }\n\n    /**\n     * Gets the canonical class name for a {@link Class}.\n     *\n     * @param cls the class for which to get the canonical class name; may be null\n     * @return the canonical name of the class, or the empty String\n     * @since 3.7\n     * @see Class#getCanonicalName()\n     */\n    public static String getCanonicalName(final Class<?> cls) {\n        return getCanonicalName(cls, StringUtils.EMPTY);\n    }\n\n    /**\n     * Gets the canonical name for a {@link Class}.\n     *\n     * @param cls the class for which to get the canonical class name; may be null\n     * @param valueIfNull the return value if null\n     * @return the canonical name of the class, or {@code valueIfNull}\n     * @since 3.7\n     * @see Class#getCanonicalName()\n     */\n    public static String getCanonicalName(final Class<?> cls, final String valueIfNull) {\n        if (cls == null) {\n            return valueIfNull;\n        }\n        final String canonicalName = cls.getCanonicalName();\n        return canonicalName == null ? valueIfNull : canonicalName;\n    }\n\n    /**\n     * Gets the canonical name for an {@link Object}.\n     *\n     * @param object the object for which to get the canonical class name; may be null\n     * @return the canonical name of the object, or the empty String\n     * @since 3.7\n     * @see Class#getCanonicalName()\n     */\n    public static String getCanonicalName(final Object object) {\n        return getCanonicalName(object, StringUtils.EMPTY);\n    }\n\n    /**\n     * Gets the canonical name for an {@link Object}.\n     *\n     * @param object the object for which to get the canonical class name; may be null\n     * @param valueIfNull the return value if null\n     * @return the canonical name of the object or {@code valueIfNull}\n     * @since 3.7\n     * @see Class#getCanonicalName()\n     */\n    public static String getCanonicalName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        final String canonicalName = object.getClass().getCanonicalName();\n        return canonicalName == null ? valueIfNull : canonicalName;\n    }\n\n    /**\n     * Converts a given name of class into canonical format. If name of class is not a name of array class it returns\n     * unchanged name.\n     *\n     * <p>\n     * The method does not change the {@code $} separators in case the class is inner class.\n     * </p>\n     *\n     * <p>\n     * Example:\n     * <ul>\n     * <li>{@code getCanonicalName(\"[I\") = \"int[]\"}</li>\n     * <li>{@code getCanonicalName(\"[Ljava.lang.String;\") = \"java.lang.String[]\"}</li>\n     * <li>{@code getCanonicalName(\"java.lang.String\") = \"java.lang.String\"}</li>\n     * </ul>\n     * </p>\n     *\n     * @param className the name of class\n     * @return canonical form of class name\n     * @since 2.4\n     */\n    private static String getCanonicalName(String className) {\n        className = StringUtils.deleteWhitespace(className);\n        if (className == null) {\n            return null;\n        }\n        int dim = 0;\n        while (className.startsWith(\"[\")) {\n            dim++;\n            className = className.substring(1);\n        }\n        if (dim < 1) {\n            return className;\n        }\n        if (className.startsWith(\"L\")) {\n            className = className.substring(1, className.endsWith(\";\") ? className.length() - 1 : className.length());\n        } else if (!className.isEmpty()) {\n            className = reverseAbbreviationMap.get(className.substring(0, 1));\n        }\n        final StringBuilder canonicalClassNameBuffer = new StringBuilder(className);\n        for (int i = 0; i < dim; i++) {\n            canonicalClassNameBuffer.append(\"[]\");\n        }\n        return canonicalClassNameBuffer.toString();\n    }\n\n    /**\n     * Returns the (initialized) class represented by {@code className} using the {@code classLoader}. This implementation\n     * supports the syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\",\n     * \"{@code [Ljava.util.Map.Entry;}\", and \"{@code [Ljava.util.Map$Entry;}\".\n     *\n     * @param classLoader the class loader to use to load the class\n     * @param className the class name\n     * @return the class represented by {@code className} using the {@code classLoader}\n     * @throws NullPointerException if the className is null\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(final ClassLoader classLoader, final String className) throws ClassNotFoundException {\n        return getClass(classLoader, className, true);\n    }\n\n    /**\n     * Returns the class represented by {@code className} using the {@code classLoader}. This implementation supports the\n     * syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\", \"{@code [Ljava.util.Map.Entry;}\", and\n     * \"{@code [Ljava.util.Map$Entry;}\".\n     *\n     * @param classLoader the class loader to use to load the class\n     * @param className the class name\n     * @param initialize whether the class must be initialized\n     * @return the class represented by {@code className} using the {@code classLoader}\n     * @throws NullPointerException if the className is null\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {\n        try {\n            final Class<?> clazz = namePrimitiveMap.get(className);\n            return clazz != null ? clazz : Class.forName(toCanonicalName(className), initialize, classLoader);\n        } catch (final ClassNotFoundException ex) {\n            // allow path separators (.) as inner class name separators\n            final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n\n            if (lastDotIndex != -1) {\n                try {\n                    return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1),\n                        initialize);\n                } catch (final ClassNotFoundException ignored) {\n                    // ignore exception\n                }\n            }\n\n            throw ex;\n        }\n    }\n\n    /**\n     * Returns the (initialized) class represented by {@code className} using the current thread's context class loader.\n     * This implementation supports the syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\",\n     * \"{@code [Ljava.util.Map.Entry;}\", and \"{@code [Ljava.util.Map$Entry;}\".\n     *\n     * @param className the class name\n     * @return the class represented by {@code className} using the current thread's context class loader\n     * @throws NullPointerException if the className is null\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(final String className) throws ClassNotFoundException {\n        return getClass(className, true);\n    }\n\n    /**\n     * Returns the class represented by {@code className} using the current thread's context class loader. This\n     * implementation supports the syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\",\n     * \"{@code [Ljava.util.Map.Entry;}\", and \"{@code [Ljava.util.Map$Entry;}\".\n     *\n     * @param className the class name\n     * @param initialize whether the class must be initialized\n     * @return the class represented by {@code className} using the current thread's context class loader\n     * @throws NullPointerException if the className is null\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {\n        final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n        return getClass(loader, className, initialize);\n    }\n\n    /**\n     * Delegates to {@link Class#getComponentType()} using generics.\n     *\n     * @param <T> The array class type.\n     * @param cls A class or null.\n     * @return The array component type or null.\n     * @see Class#getComponentType()\n     * @since 3.13.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Class<T> getComponentType(final Class<T[]> cls) {\n        return cls == null ? null : (Class<T>) cls.getComponentType();\n    }\n\n    /**\n     * Null-safe version of {@code cls.getName()}\n     *\n     * @param cls the class for which to get the class name; may be null\n     * @return the class name or the empty string in case the argument is {@code null}\n     * @since 3.7\n     * @see Class#getSimpleName()\n     */\n    public static String getName(final Class<?> cls) {\n        return getName(cls, StringUtils.EMPTY);\n    }\n\n    /**\n     * Null-safe version of {@code cls.getName()}\n     *\n     * @param cls the class for which to get the class name; may be null\n     * @param valueIfNull the return value if the argument {@code cls} is {@code null}\n     * @return the class name or {@code valueIfNull}\n     * @since 3.7\n     * @see Class#getName()\n     */\n    public static String getName(final Class<?> cls, final String valueIfNull) {\n        return cls == null ? valueIfNull : cls.getName();\n    }\n\n    /**\n     * Null-safe version of {@code object.getClass().getName()}\n     *\n     * @param object the object for which to get the class name; may be null\n     * @return the class name or the empty String\n     * @since 3.7\n     * @see Class#getSimpleName()\n     */\n    public static String getName(final Object object) {\n        return getName(object, StringUtils.EMPTY);\n    }\n\n    /**\n     * Null-safe version of {@code object.getClass().getSimpleName()}\n     *\n     * @param object the object for which to get the class name; may be null\n     * @param valueIfNull the value to return if {@code object} is {@code null}\n     * @return the class name or {@code valueIfNull}\n     * @since 3.0\n     * @see Class#getName()\n     */\n    public static String getName(final Object object, final String valueIfNull) {\n        return object == null ? valueIfNull : object.getClass().getName();\n    }\n\n    /**\n     * Gets the package name from the canonical name of a {@link Class}.\n     *\n     * @param cls the class to get the package name for, may be {@code null}.\n     * @return the package name or an empty string\n     * @since 2.4\n     */\n    public static String getPackageCanonicalName(final Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageCanonicalName(cls.getName());\n    }\n\n    /**\n     * Gets the package name from the class name of an {@link Object}.\n     *\n     * @param object the class to get the package name for, may be null\n     * @param valueIfNull the value to return if null\n     * @return the package name of the object, or the null value\n     * @since 2.4\n     */\n    public static String getPackageCanonicalName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageCanonicalName(object.getClass().getName());\n    }\n\n    /**\n     * Gets the package name from the class name.\n     *\n     * <p>\n     * The string passed in is assumed to be a class name - it is not checked.\n     * </p>\n     * <p>\n     * If the class is in the default package, return an empty string.\n     * </p>\n     *\n     * @param name the name to get the package name for, may be {@code null}\n     * @return the package name or an empty string\n     * @since 2.4\n     */\n    public static String getPackageCanonicalName(final String name) {\n        return getPackageName(getCanonicalName(name));\n    }\n\n    /**\n     * Gets the package name of a {@link Class}.\n     *\n     * @param cls the class to get the package name for, may be {@code null}.\n     * @return the package name or an empty string\n     */\n    public static String getPackageName(final Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageName(cls.getName());\n    }\n\n    /**\n     * Gets the package name of an {@link Object}.\n     *\n     * @param object the class to get the package name for, may be null\n     * @param valueIfNull the value to return if null\n     * @return the package name of the object, or the null value\n     */\n    public static String getPackageName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageName(object.getClass());\n    }\n\n    /**\n     * Gets the package name from a {@link String}.\n     *\n     * <p>\n     * The string passed in is assumed to be a class name - it is not checked.\n     * </p>\n     * <p>\n     * If the class is unpackaged, return an empty string.\n     * </p>\n     *\n     * @param className the className to get the package name for, may be {@code null}\n     * @return the package name or an empty string\n     */\n    public static String getPackageName(String className) {\n        if (StringUtils.isEmpty(className)) {\n            return StringUtils.EMPTY;\n        }\n\n        // Strip array encoding\n        while (className.charAt(0) == '[') {\n            className = className.substring(1);\n        }\n        // Strip Object type encoding\n        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n            className = className.substring(1);\n        }\n\n        final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        if (i == -1) {\n            return StringUtils.EMPTY;\n        }\n        return className.substring(0, i);\n    }\n\n    /**\n     * Returns the desired Method much like {@code Class.getMethod}, however it ensures that the returned Method is from a\n     * public class or interface and not from an anonymous inner class. This means that the Method is invokable and doesn't\n     * fall foul of Java bug <a href=\"https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4071957\">4071957</a>).\n     *\n     * <pre>\n     *  <code>Set set = Collections.unmodifiableSet(...);\n     *  Method method = ClassUtils.getPublicMethod(set.getClass(), \"isEmpty\",  new Class[0]);\n     *  Object result = method.invoke(set, new Object[]);</code>\n     * </pre>\n     *\n     * @param cls the class to check, not null\n     * @param methodName the name of the method\n     * @param parameterTypes the list of parameters\n     * @return the method\n     * @throws NullPointerException if the class is null\n     * @throws SecurityException if a security violation occurred\n     * @throws NoSuchMethodException if the method is not found in the given class or if the method doesn't conform with the\n     *         requirements\n     */\n    public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) throws NoSuchMethodException {\n\n        final Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n        if (isPublic(declaredMethod.getDeclaringClass())) {\n            return declaredMethod;\n        }\n\n        final List<Class<?>> candidateClasses = new ArrayList<>(getAllInterfaces(cls));\n        candidateClasses.addAll(getAllSuperclasses(cls));\n\n        for (final Class<?> candidateClass : candidateClasses) {\n            if (!isPublic(candidateClass)) {\n                continue;\n            }\n            final Method candidateMethod;\n            try {\n                candidateMethod = candidateClass.getMethod(methodName, parameterTypes);\n            } catch (final NoSuchMethodException ex) {\n                continue;\n            }\n            if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {\n                return candidateMethod;\n            }\n        }\n\n        throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes));\n    }\n\n    /**\n     * Gets the canonical name minus the package name from a {@link Class}.\n     *\n     * @param cls the class for which to get the short canonical class name; may be null\n     * @return the canonical name without the package name or an empty string\n     * @since 2.4\n     * @see Class#getCanonicalName()\n     */\n    public static String getShortCanonicalName(final Class<?> cls) {\n        return cls == null ? StringUtils.EMPTY : getShortCanonicalName(cls.getCanonicalName());\n    }\n\n    /**\n     * Gets the canonical name minus the package name for an {@link Object}.\n     *\n     * @param object the class to get the short name for, may be null\n     * @param valueIfNull the value to return if null\n     * @return the canonical name of the object without the package name, or the null value\n     * @since 2.4\n     * @see Class#getCanonicalName()\n     */\n    public static String getShortCanonicalName(final Object object, final String valueIfNull) {\n        return object == null ? valueIfNull : getShortCanonicalName(object.getClass().getCanonicalName());\n    }\n\n    /**\n     * Gets the canonical name minus the package name from a String.\n     *\n     * <p>\n     * The string passed in is assumed to be a class name - it is not checked.\n     * </p>\n     *\n     * <p>\n     * Note that this method is mainly designed to handle the arrays and primitives properly. If the class is an inner class\n     * then the result value will not contain the outer classes. This way the behavior of this method is different from\n     * {@link #getShortClassName(String)}. The argument in that case is class name and not canonical name and the return\n     * value retains the outer classes.\n     * </p>\n     *\n     * <p>\n     * Note that there is no way to reliably identify the part of the string representing the package hierarchy and the part\n     * that is the outer class or classes in case of an inner class. Trying to find the class would require reflective call\n     * and the class itself may not even be on the class path. Relying on the fact that class names start with capital\n     * letter and packages with lower case is heuristic.\n     * </p>\n     *\n     * <p>\n     * It is recommended to use {@link #getShortClassName(String)} for cases when the class is an inner class and use this\n     * method for cases it is designed for.\n     * </p>\n     *\n     * <table>\n     * <caption>Examples</caption>\n     * <tr>\n     * <td>return value</td>\n     * <td>input</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"\"}</td>\n     * <td>{@code (String)null}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"Map.Entry\"}</td>\n     * <td>{@code java.util.Map.Entry.class.getName()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"Entry\"}</td>\n     * <td>{@code java.util.Map.Entry.class.getCanonicalName()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"ClassUtils\"}</td>\n     * <td>{@code \"org.apache.commons.lang3.ClassUtils\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"ClassUtils[]\"}</td>\n     * <td>{@code \"[Lorg.apache.commons.lang3.ClassUtils;\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"ClassUtils[][]\"}</td>\n     * <td>{@code \"[[Lorg.apache.commons.lang3.ClassUtils;\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"ClassUtils[]\"}</td>\n     * <td>{@code \"org.apache.commons.lang3.ClassUtils[]\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"ClassUtils[][]\"}</td>\n     * <td>{@code \"org.apache.commons.lang3.ClassUtils[][]\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[]\"}</td>\n     * <td>{@code \"[I\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[]\"}</td>\n     * <td>{@code int[].class.getCanonicalName()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[]\"}</td>\n     * <td>{@code int[].class.getName()}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[][]\"}</td>\n     * <td>{@code \"[[I\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[]\"}</td>\n     * <td>{@code \"int[]\"}</td>\n     * </tr>\n     * <tr>\n     * <td>{@code \"int[][]\"}</td>\n     * <td>{@code \"int[][]\"}</td>\n     * </tr>\n     * </table>\n     *\n     * @param canonicalName the class name to get the short name for\n     * @return the canonical name of the class without the package name or an empty string\n     * @since 2.4\n     */\n    public static String getShortCanonicalName(final String canonicalName) {\n        return getShortClassName(getCanonicalName(canonicalName));\n    }\n\n    /**\n     * Gets the class name minus the package name from a {@link Class}.\n     *\n     * <p>\n     * This method simply gets the name using {@code Class.getName()} and then calls {@link #getShortClassName(String)}. See\n     * relevant notes there.\n     * </p>\n     *\n     * @param cls the class to get the short name for.\n     * @return the class name without the package name or an empty string. If the class is an inner class then the returned\n     *         value will contain the outer class or classes separated with {@code .} (dot) character.\n     */\n    public static String getShortClassName(final Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortClassName(cls.getName());\n    }\n\n    /**\n     * Gets the class name of the {@code object} without the package name or names.\n     *\n     * <p>\n     * The method looks up the class of the object and then converts the name of the class invoking\n     * {@link #getShortClassName(Class)} (see relevant notes there).\n     * </p>\n     *\n     * @param object the class to get the short name for, may be {@code null}\n     * @param valueIfNull the value to return if the object is {@code null}\n     * @return the class name of the object without the package name, or {@code valueIfNull} if the argument {@code object}\n     *         is {@code null}\n     */\n    public static String getShortClassName(final Object object, final String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortClassName(object.getClass());\n    }\n\n    /**\n     * Gets the class name minus the package name from a String.\n     *\n     * <p>\n     * The string passed in is assumed to be a class name - it is not checked. The string has to be formatted the way as the\n     * JDK method {@code Class.getName()} returns it, and not the usual way as we write it, for example in import\n     * statements, or as it is formatted by {@code Class.getCanonicalName()}.\n     * </p>\n     *\n     * <p>\n     * The difference is is significant only in case of classes that are inner classes of some other classes. In this case\n     * the separator between the outer and inner class (possibly on multiple hierarchy level) has to be {@code $} (dollar\n     * sign) and not {@code .} (dot), as it is returned by {@code Class.getName()}\n     * </p>\n     *\n     * <p>\n     * Note that this method is called from the {@link #getShortClassName(Class)} method using the string returned by\n     * {@code Class.getName()}.\n     * </p>\n     *\n     * <p>\n     * Note that this method differs from {@link #getSimpleName(Class)} in that this will return, for example\n     * {@code \"Map.Entry\"} whilst the {@link Class} variant will simply return {@code \"Entry\"}. In this example\n     * the argument {@code className} is the string {@code java.util.Map$Entry} (note the {@code $} sign.\n     * </p>\n     *\n     * @param className the className to get the short name for. It has to be formatted as returned by\n     *        {@code Class.getName()} and not {@code Class.getCanonicalName()}\n     * @return the class name of the class without the package name or an empty string. If the class is an inner class then\n     *         value contains the outer class or classes and the separator is replaced to be {@code .} (dot) character.\n     */\n    public static String getShortClassName(String className) {\n        if (StringUtils.isEmpty(className)) {\n            return StringUtils.EMPTY;\n        }\n\n        final StringBuilder arrayPrefix = new StringBuilder();\n\n        // Handle array encoding\n        if (className.startsWith(\"[\")) {\n            while (className.charAt(0) == '[') {\n                className = className.substring(1);\n                arrayPrefix.append(\"[]\");\n            }\n            // Strip Object type encoding\n            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n                className = className.substring(1, className.length() - 1);\n            }\n\n            if (reverseAbbreviationMap.containsKey(className)) {\n                className = reverseAbbreviationMap.get(className);\n            }\n        }\n\n        final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n        String out = className.substring(lastDotIdx + 1);\n        if (innerIdx != -1) {\n            out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n        }\n        return out + arrayPrefix;\n    }\n\n    /**\n     * Null-safe version of {@code cls.getSimpleName()}\n     *\n     * @param cls the class for which to get the simple name; may be null\n     * @return the simple class name or the empty string in case the argument is {@code null}\n     * @since 3.0\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Class<?> cls) {\n        return getSimpleName(cls, StringUtils.EMPTY);\n    }\n\n    /**\n     * Null-safe version of {@code cls.getSimpleName()}\n     *\n     * @param cls the class for which to get the simple name; may be null\n     * @param valueIfNull the value to return if null\n     * @return the simple class name or {@code valueIfNull} if the argument {@code cls} is {@code null}\n     * @since 3.0\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Class<?> cls, final String valueIfNull) {\n        return cls == null ? valueIfNull : cls.getSimpleName();\n    }\n\n    /**\n     * Null-safe version of {@code object.getClass().getSimpleName()}\n     *\n     * <p>\n     * It is to note that this method is overloaded and in case the argument {@code object} is a {@link Class} object then\n     * the {@link #getSimpleName(Class)} will be invoked. If this is a significant possibility then the caller should check\n     * this case and call {@code\n     * getSimpleName(Class.class)} or just simply use the string literal {@code \"Class\"}, which is the result of the method\n     * in that case.\n     * </p>\n     *\n     * @param object the object for which to get the simple class name; may be null\n     * @return the simple class name or the empty string in case the argument is {@code null}\n     * @since 3.7\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Object object) {\n        return getSimpleName(object, StringUtils.EMPTY);\n    }\n\n    /**\n     * Null-safe version of {@code object.getClass().getSimpleName()}\n     *\n     * @param object the object for which to get the simple class name; may be null\n     * @param valueIfNull the value to return if {@code object} is {@code null}\n     * @return the simple class name or {@code valueIfNull} if the argument {@code object} is {@code null}\n     * @since 3.0\n     * @see Class#getSimpleName()\n     */\n    public static String getSimpleName(final Object object, final String valueIfNull) {\n        return object == null ? valueIfNull : object.getClass().getSimpleName();\n    }\n\n    /**\n     * Gets an {@link Iterable} that can iterate over a class hierarchy in ascending (subclass to superclass) order,\n     * excluding interfaces.\n     *\n     * @param type the type to get the class hierarchy from\n     * @return Iterable an Iterable over the class hierarchy of the given class\n     * @since 3.2\n     */\n    public static Iterable<Class<?>> hierarchy(final Class<?> type) {\n        return hierarchy(type, Interfaces.EXCLUDE);\n    }\n\n    /**\n     * Gets an {@link Iterable} that can iterate over a class hierarchy in ascending (subclass to superclass) order.\n     *\n     * @param type the type to get the class hierarchy from\n     * @param interfacesBehavior switch indicating whether to include or exclude interfaces\n     * @return Iterable an Iterable over the class hierarchy of the given class\n     * @since 3.2\n     */\n    public static Iterable<Class<?>> hierarchy(final Class<?> type, final Interfaces interfacesBehavior) {\n        final Iterable<Class<?>> classes = () -> {\n            final MutableObject<Class<?>> next = new MutableObject<>(type);\n            return new Iterator<Class<?>>() {\n\n                @Override\n                public boolean hasNext() {\n                    return next.getValue() != null;\n                }\n\n                @Override\n                public Class<?> next() {\n                    final Class<?> result = next.getValue();\n                    next.setValue(result.getSuperclass());\n                    return result;\n                }\n\n                @Override\n                public void remove() {\n                    throw new UnsupportedOperationException();\n                }\n\n            };\n        };\n        if (interfacesBehavior != Interfaces.INCLUDE) {\n            return classes;\n        }\n        return () -> {\n            final Set<Class<?>> seenInterfaces = new HashSet<>();\n            final Iterator<Class<?>> wrapped = classes.iterator();\n\n            return new Iterator<Class<?>>() {\n                Iterator<Class<?>> interfaces = Collections.emptyIterator();\n\n                @Override\n                public boolean hasNext() {\n                    return interfaces.hasNext() || wrapped.hasNext();\n                }\n\n                @Override\n                public Class<?> next() {\n                    if (interfaces.hasNext()) {\n                        final Class<?> nextInterface = interfaces.next();\n                        seenInterfaces.add(nextInterface);\n                        return nextInterface;\n                    }\n                    final Class<?> nextSuperclass = wrapped.next();\n                    final Set<Class<?>> currentInterfaces = new LinkedHashSet<>();\n                    walkInterfaces(currentInterfaces, nextSuperclass);\n                    interfaces = currentInterfaces.iterator();\n                    return nextSuperclass;\n                }\n\n                @Override\n                public void remove() {\n                    throw new UnsupportedOperationException();\n                }\n\n                private void walkInterfaces(final Set<Class<?>> addTo, final Class<?> c) {\n                    for (final Class<?> iface : c.getInterfaces()) {\n                        if (!seenInterfaces.contains(iface)) {\n                            addTo.add(iface);\n                        }\n                        walkInterfaces(addTo, iface);\n                    }\n                }\n\n            };\n        };\n    }\n\n    /**\n     * Checks if one {@link Class} can be assigned to a variable of another {@link Class}.\n     *\n     * <p>\n     * Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into account widenings of\n     * primitive classes and {@code null}s.\n     * </p>\n     *\n     * <p>\n     * Primitive widenings allow an int to be assigned to a long, float or double. This method returns the correct result\n     * for these cases.\n     * </p>\n     *\n     * <p>\n     * {@code null} may be assigned to any reference type. This method will return {@code true} if {@code null} is passed in\n     * and the toClass is non-primitive.\n     * </p>\n     *\n     * <p>\n     * Specifically, this method tests whether the type represented by the specified {@link Class} parameter can be\n     * converted to the type represented by this {@link Class} object via an identity conversion widening primitive or\n     * widening reference conversion. See <em><a href=\"https://docs.oracle.com/javase/specs/\">The Java Language\n     * Specification</a></em>, sections 5.1.1, 5.1.2 and 5.1.4 for details.\n     * </p>\n     *\n     * <p>\n     * <strong>Since Lang 3.0,</strong> this method will default behavior for calculating assignability between primitive\n     * and wrapper types <em>corresponding to the running Java version</em>; i.e. autoboxing will be the default behavior in\n     * VMs running Java versions &gt; 1.5.\n     * </p>\n     *\n     * @param cls the Class to check, may be null\n     * @param toClass the Class to try to assign into, returns false if null\n     * @return {@code true} if assignment possible\n     */\n    public static boolean isAssignable(final Class<?> cls, final Class<?> toClass) {\n        return isAssignable(cls, toClass, true);\n    }\n\n    /**\n     * Checks if one {@link Class} can be assigned to a variable of another {@link Class}.\n     *\n     * <p>\n     * Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into account widenings of\n     * primitive classes and {@code null}s.\n     * </p>\n     *\n     * <p>\n     * Primitive widenings allow an int to be assigned to a long, float or double. This method returns the correct result\n     * for these cases.\n     * </p>\n     *\n     * <p>\n     * {@code null} may be assigned to any reference type. This method will return {@code true} if {@code null} is passed in\n     * and the toClass is non-primitive.\n     * </p>\n     *\n     * <p>\n     * Specifically, this method tests whether the type represented by the specified {@link Class} parameter can be\n     * converted to the type represented by this {@link Class} object via an identity conversion widening primitive or\n     * widening reference conversion. See <em><a href=\"https://docs.oracle.com/javase/specs/\">The Java Language\n     * Specification</a></em>, sections 5.1.1, 5.1.2 and 5.1.4 for details.\n     * </p>\n     *\n     * @param cls the Class to check, may be null\n     * @param toClass the Class to try to assign into, returns false if null\n     * @param autoboxing whether to use implicit autoboxing/unboxing between primitives and wrappers\n     * @return {@code true} if assignment possible\n     */\n    public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {\n        if (toClass == null) {\n            return false;\n        }\n        // have to check for null, as isAssignableFrom doesn't\n        if (cls == null) {\n            return !toClass.isPrimitive();\n        }\n        // autoboxing:\n        if (autoboxing) {\n            if (cls.isPrimitive() && !toClass.isPrimitive()) {\n                cls = primitiveToWrapper(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n            if (toClass.isPrimitive() && !cls.isPrimitive()) {\n                cls = wrapperToPrimitive(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n        }\n        if (cls.equals(toClass)) {\n            return true;\n        }\n        if (cls.isPrimitive()) {\n            if (!toClass.isPrimitive()) {\n                return false;\n            }\n            if (Integer.TYPE.equals(cls)) {\n                return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);\n            }\n            if (Long.TYPE.equals(cls)) {\n                return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);\n            }\n            if (Boolean.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Double.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Float.TYPE.equals(cls)) {\n                return Double.TYPE.equals(toClass);\n            }\n            if (Character.TYPE.equals(cls)  || Short.TYPE.equals(cls)) {\n                return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);\n            }\n            if (Byte.TYPE.equals(cls)) {\n                return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            // should never get here\n            return false;\n        }\n        return toClass.isAssignableFrom(cls);\n    }\n\n    /**\n     * Checks if an array of Classes can be assigned to another array of Classes.\n     *\n     * <p>\n     * This method calls {@link #isAssignable(Class, Class) isAssignable} for each Class pair in the input arrays. It can be\n     * used to check if a set of arguments (the first parameter) are suitably compatible with a set of method parameter\n     * types (the second parameter).\n     * </p>\n     *\n     * <p>\n     * Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into account widenings of\n     * primitive classes and {@code null}s.\n     * </p>\n     *\n     * <p>\n     * Primitive widenings allow an int to be assigned to a {@code long}, {@code float} or {@code double}. This method\n     * returns the correct result for these cases.\n     * </p>\n     *\n     * <p>\n     * {@code null} may be assigned to any reference type. This method will return {@code true} if {@code null} is passed in\n     * and the toClass is non-primitive.\n     * </p>\n     *\n     * <p>\n     * Specifically, this method tests whether the type represented by the specified {@link Class} parameter can be\n     * converted to the type represented by this {@link Class} object via an identity conversion widening primitive or\n     * widening reference conversion. See <em><a href=\"https://docs.oracle.com/javase/specs/\">The Java Language\n     * Specification</a></em>, sections 5.1.1, 5.1.2 and 5.1.4 for details.\n     * </p>\n     *\n     * <p>\n     * <strong>Since Lang 3.0,</strong> this method will default behavior for calculating assignability between primitive\n     * and wrapper types <em>corresponding to the running Java version</em>; i.e. autoboxing will be the default behavior in\n     * VMs running Java versions &gt; 1.5.\n     * </p>\n     *\n     * @param classArray the array of Classes to check, may be {@code null}\n     * @param toClassArray the array of Classes to try to assign into, may be {@code null}\n     * @return {@code true} if assignment possible\n     */\n    public static boolean isAssignable(final Class<?>[] classArray, final Class<?>... toClassArray) {\n        return isAssignable(classArray, toClassArray, true);\n    }\n\n    /**\n     * Checks if an array of Classes can be assigned to another array of Classes.\n     *\n     * <p>\n     * This method calls {@link #isAssignable(Class, Class) isAssignable} for each Class pair in the input arrays. It can be\n     * used to check if a set of arguments (the first parameter) are suitably compatible with a set of method parameter\n     * types (the second parameter).\n     * </p>\n     *\n     * <p>\n     * Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into account widenings of\n     * primitive classes and {@code null}s.\n     * </p>\n     *\n     * <p>\n     * Primitive widenings allow an int to be assigned to a {@code long}, {@code float} or {@code double}. This method\n     * returns the correct result for these cases.\n     * </p>\n     *\n     * <p>\n     * {@code null} may be assigned to any reference type. This method will return {@code true} if {@code null} is passed in\n     * and the toClass is non-primitive.\n     * </p>\n     *\n     * <p>\n     * Specifically, this method tests whether the type represented by the specified {@link Class} parameter can be\n     * converted to the type represented by this {@link Class} object via an identity conversion widening primitive or\n     * widening reference conversion. See <em><a href=\"https://docs.oracle.com/javase/specs/\">The Java Language\n     * Specification</a></em>, sections 5.1.1, 5.1.2 and 5.1.4 for details.\n     * </p>\n     *\n     * @param classArray the array of Classes to check, may be {@code null}\n     * @param toClassArray the array of Classes to try to assign into, may be {@code null}\n     * @param autoboxing whether to use implicit autoboxing/unboxing between primitives and wrappers\n     * @return {@code true} if assignment possible\n     */\n    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, final boolean autoboxing) {\n        if (!ArrayUtils.isSameLength(classArray, toClassArray)) {\n            return false;\n        }\n        classArray = ArrayUtils.nullToEmpty(classArray);\n        toClassArray = ArrayUtils.nullToEmpty(toClassArray);\n        for (int i = 0; i < classArray.length; i++) {\n            if (!isAssignable(classArray[i], toClassArray[i], autoboxing)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Is the specified class an inner class or static nested class.\n     *\n     * @param cls the class to check, may be null\n     * @return {@code true} if the class is an inner or static nested class, false if not or {@code null}\n     */\n    public static boolean isInnerClass(final Class<?> cls) {\n        return cls != null && cls.getEnclosingClass() != null;\n    }\n\n    /**\n     * Returns whether the given {@code type} is a primitive or primitive wrapper ({@link Boolean}, {@link Byte},\n     * {@link Character}, {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n     *\n     * @param type The class to query or null.\n     * @return true if the given {@code type} is a primitive or primitive wrapper ({@link Boolean}, {@link Byte},\n     *         {@link Character}, {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n     * @since 3.1\n     */\n    public static boolean isPrimitiveOrWrapper(final Class<?> type) {\n        if (type == null) {\n            return false;\n        }\n        return type.isPrimitive() || isPrimitiveWrapper(type);\n    }\n    /**\n     * Returns whether the given {@code type} is a primitive wrapper ({@link Boolean}, {@link Byte}, {@link Character},\n     * {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n     *\n     * @param type The class to query or null.\n     * @return true if the given {@code type} is a primitive wrapper ({@link Boolean}, {@link Byte}, {@link Character},\n     *         {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n     * @since 3.1\n     */\n    public static boolean isPrimitiveWrapper(final Class<?> type) {\n        return wrapperPrimitiveMap.containsKey(type);\n    }\n\n    /**\n     * Tests whether a {@link Class} is public.\n     * @param cls Class to test.\n     * @return {@code true} if {@code cls} is public.\n     * @since 3.13.0\n     */\n    public static boolean isPublic(final Class<?> cls) {\n        return Modifier.isPublic(cls.getModifiers());\n    }\n\n    /**\n     * Converts the specified array of primitive Class objects to an array of its corresponding wrapper Class objects.\n     *\n     * @param classes the class array to convert, may be null or empty\n     * @return an array which contains for each given class, the wrapper class or the original class if class is not a\n     *         primitive. {@code null} if null input. Empty array if an empty array passed in.\n     * @since 2.1\n     */\n    public static Class<?>[] primitivesToWrappers(final Class<?>... classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        final Class<?>[] convertedClasses = new Class[classes.length];\n        Arrays.setAll(convertedClasses, i -> primitiveToWrapper(classes[i]));\n        return convertedClasses;\n    }\n\n    /**\n     * Converts the specified primitive Class object to its corresponding wrapper Class object.\n     *\n     * <p>\n     * NOTE: From v2.2, this method handles {@code Void.TYPE}, returning {@code Void.TYPE}.\n     * </p>\n     *\n     * @param cls the class to convert, may be null\n     * @return the wrapper class for {@code cls} or {@code cls} if {@code cls} is not a primitive. {@code null} if null\n     *         input.\n     * @since 2.1\n     */\n    public static Class<?> primitiveToWrapper(final Class<?> cls) {\n        Class<?> convertedClass = cls;\n        if (cls != null && cls.isPrimitive()) {\n            convertedClass = primitiveWrapperMap.get(cls);\n        }\n        return convertedClass;\n    }\n\n    /**\n     * Converts a class name to a JLS style class name.\n     *\n     * @param className the class name\n     * @return the converted name\n     * @throws NullPointerException if the className is null\n     */\n    private static String toCanonicalName(final String className) {\n        String canonicalName = StringUtils.deleteWhitespace(className);\n        Objects.requireNonNull(canonicalName, \"className\");\n        if (canonicalName.endsWith(\"[]\")) {\n            final StringBuilder classNameBuffer = new StringBuilder();\n            while (canonicalName.endsWith(\"[]\")) {\n                canonicalName = canonicalName.substring(0, canonicalName.length() - 2);\n                classNameBuffer.append(\"[\");\n            }\n            final String abbreviation = abbreviationMap.get(canonicalName);\n            if (abbreviation != null) {\n                classNameBuffer.append(abbreviation);\n            } else {\n                classNameBuffer.append(\"L\").append(canonicalName).append(\";\");\n            }\n            canonicalName = classNameBuffer.toString();\n        }\n        return canonicalName;\n    }\n\n    /**\n     * Converts an array of {@link Object} in to an array of {@link Class} objects. If any of these objects is null, a null\n     * element will be inserted into the array.\n     *\n     * <p>\n     * This method returns {@code null} for a {@code null} input array.\n     * </p>\n     *\n     * @param array an {@link Object} array\n     * @return a {@link Class} array, {@code null} if null array input\n     * @since 2.4\n     */\n    public static Class<?>[] toClass(final Object... array) {\n        if (array == null) {\n            return null;\n        }\n        if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        final Class<?>[] classes = new Class[array.length];\n        Arrays.setAll(classes, i -> array[i] == null ? null : array[i].getClass());\n        return classes;\n    }\n\n    /**\n     * Decides if the part that was just copied to its destination location in the work array can be kept as it was copied\n     * or must be abbreviated. It must be kept when the part is the last one, which is the simple name of the class. In this\n     * case the {@code source} index, from where the characters are copied points one position after the last character,\n     * a.k.a. {@code source ==\n     * originalLength}\n     *\n     * <p>\n     * If the part is not the last one then it can be kept unabridged if the number of the characters copied so far plus the\n     * character that are to be copied is less than or equal to the desired length.\n     * </p>\n     *\n     * @param runAheadTarget the target index (where the characters were copied to) pointing after the last character copied\n     *        when the current part was copied\n     * @param source the source index (where the characters were copied from) pointing after the last character copied when\n     *        the current part was copied\n     * @param originalLength the original length of the class full name, which is abbreviated\n     * @param desiredLength the desired length of the abbreviated class name\n     * @return {@code true} if it can be kept in its original length {@code false} if the current part has to be abbreviated\n     *         and\n     */\n    private static boolean useFull(final int runAheadTarget, final int source, final int originalLength, final int desiredLength) {\n        return source >= originalLength || runAheadTarget + originalLength - source <= desiredLength;\n    }\n\n    /**\n     * Converts the specified array of wrapper Class objects to an array of its corresponding primitive Class objects.\n     *\n     * <p>\n     * This method invokes {@code wrapperToPrimitive()} for each element of the passed in array.\n     * </p>\n     *\n     * @param classes the class array to convert, may be null or empty\n     * @return an array which contains for each given class, the primitive class or <b>null</b> if the original class is not\n     *         a wrapper class. {@code null} if null input. Empty array if an empty array passed in.\n     * @see #wrapperToPrimitive(Class)\n     * @since 2.4\n     */\n    public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        final Class<?>[] convertedClasses = new Class[classes.length];\n        Arrays.setAll(convertedClasses, i -> wrapperToPrimitive(classes[i]));\n        return convertedClasses;\n    }\n\n    /**\n     * Converts the specified wrapper class to its corresponding primitive class.\n     *\n     * <p>\n     * This method is the counter part of {@code primitiveToWrapper()}. If the passed in class is a wrapper class for a\n     * primitive type, this primitive type will be returned (e.g. {@code Integer.TYPE} for {@code Integer.class}). For other\n     * classes, or if the parameter is <b>null</b>, the return value is <b>null</b>.\n     * </p>\n     *\n     * @param cls the class to convert, may be <b>null</b>\n     * @return the corresponding primitive type if {@code cls} is a wrapper class, <b>null</b> otherwise\n     * @see #primitiveToWrapper(Class)\n     * @since 2.4\n     */\n    public static Class<?> wrapperToPrimitive(final Class<?> cls) {\n        return wrapperPrimitiveMap.get(cls);\n    }\n\n    /**\n     * ClassUtils instances should NOT be constructed in standard programming. Instead, the class should be used as\n     * {@code ClassUtils.getShortClassName(cls)}.\n     *\n     * <p>\n     * This constructor is public to permit tools that require a JavaBean instance to operate.\n     * </p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public ClassUtils() {\n        // empty\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic getMethodObject(cls Class<?>, name String, parameterTypes Class<?>...) : Method extracted from private getAccessibleMethodFromSuperclass(cls Class<?>, methodName String, parameterTypes Class<?>...) : Method in class org.apache.commons.lang3.reflect.MethodUtils",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java",
                "startLine": 199,
                "endLine": 223,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java",
                "startLine": 191,
                "endLine": 211,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java",
                "startLine": 427,
                "endLine": 443,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Gets an accessible method (that is, one that can be invoked via\n     * reflection) by scanning through the superclasses. If no such method\n     * can be found, return {@code null}.\n     *\n     * @param cls Class to be checked\n     * @param methodName Method name of the method we wish to call\n     * @param parameterTypes The parameter type signatures\n     * @return the accessible method or {@code null} if not found\n     */\n    private static Method getAccessibleMethodFromSuperclass(final Class<?> cls,\n            final String methodName, final Class<?>... parameterTypes) {\n        Class<?> parentClass = cls.getSuperclass();\n        while (parentClass != null) {\n            if (ClassUtils.isPublic(parentClass)) {\n                try {\n                    return parentClass.getMethod(methodName, parameterTypes);\n                } catch (final NoSuchMethodException e) {\n                    return null;\n                }\n            }\n            parentClass = parentClass.getSuperclass();\n        }\n        return null;\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java",
        "isPureRefactoring": true,
        "commitId": "c290aebffa83b382a24d74117755904017f82b7c",
        "packageNameBefore": "org.apache.commons.lang3.reflect",
        "classNameBefore": "org.apache.commons.lang3.reflect.MethodUtils",
        "methodNameBefore": "org.apache.commons.lang3.reflect.MethodUtils#getAccessibleMethodFromSuperclass",
        "classSignatureBefore": "public class MethodUtils ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.reflect.MethodUtils#getAccessibleMethodFromSuperclass"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.reflect.MethodUtils"
        ],
        "classSignatureBeforeSet": [
            "public class MethodUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All the mappings are matched! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.reflect;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.ClassUtils;\nimport org.apache.commons.lang3.ClassUtils.Interfaces;\nimport org.apache.commons.lang3.Validate;\n\n/**\n * Utility reflection methods focused on {@link Method}s, originally from Commons BeanUtils.\n * Differences from the BeanUtils version may be noted, especially where similar functionality\n * already existed within Lang.\n *\n * <h2>Known Limitations</h2>\n * <h3>Accessing Public Methods In A Default Access Superclass</h3>\n * <p>There is an issue when invoking {@code public} methods contained in a default access superclass on JREs prior to 1.4.\n * Reflection locates these methods fine and correctly assigns them as {@code public}.\n * However, an {@link IllegalAccessException} is thrown if the method is invoked.</p>\n *\n * <p>{@link MethodUtils} contains a workaround for this situation.\n * It will attempt to call {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} on this method.\n * If this call succeeds, then the method can be invoked as normal.\n * This call will only succeed when the application has sufficient security privileges.\n * If this call fails then the method may fail.</p>\n *\n * @since 2.5\n */\npublic class MethodUtils {\n\n    private static final Comparator<Method> METHOD_BY_SIGNATURE = Comparator.comparing(Method::toString);\n\n    /**\n     * Returns the aggregate number of inheritance hops between assignable argument class types.  Returns -1\n     * if the arguments aren't assignable.  Fills a specific purpose for getMatchingMethod and is not generalized.\n     *\n     * @param fromClassArray the Class array to calculate the distance from.\n     * @param toClassArray the Class array to calculate the distance to.\n     * @return the aggregate number of inheritance hops between assignable argument class types.\n     */\n    private static int distance(final Class<?>[] fromClassArray, final Class<?>[] toClassArray) {\n        int answer = 0;\n\n        if (!ClassUtils.isAssignable(fromClassArray, toClassArray, true)) {\n            return -1;\n        }\n        for (int offset = 0; offset < fromClassArray.length; offset++) {\n            // Note InheritanceUtils.distance() uses different scoring system.\n            final Class<?> aClass = fromClassArray[offset];\n            final Class<?> toClass = toClassArray[offset];\n            if (aClass == null || aClass.equals(toClass)) {\n                continue;\n            }\n            if (ClassUtils.isAssignable(aClass, toClass, true)\n                    && !ClassUtils.isAssignable(aClass, toClass, false)) {\n                answer++;\n            } else {\n                answer += 2;\n            }\n        }\n\n        return answer;\n    }\n\n    /**\n     * Gets an accessible method (that is, one that can be invoked via\n     * reflection) with given name and parameters. If no such method\n     * can be found, return {@code null}.\n     * This is just a convenience wrapper for\n     * {@link #getAccessibleMethod(Method)}.\n     *\n     * @param cls get method from this class\n     * @param methodName get method with this name\n     * @param parameterTypes with these parameters types\n     * @return The accessible method\n     */\n    public static Method getAccessibleMethod(final Class<?> cls, final String methodName,\n        final Class<?>... parameterTypes) {\n        try {\n            return getAccessibleMethod(cls.getMethod(methodName, parameterTypes));\n        } catch (final NoSuchMethodException e) {\n            return null;\n        }\n    }\n\n    /**\n     * Gets an accessible method (that is, one that can be invoked via\n     * reflection) that implements the specified Method. If no such method\n     * can be found, return {@code null}.\n     *\n     * @param method The method that we wish to call\n     * @return The accessible method\n     */\n    public static Method getAccessibleMethod(Method method) {\n        if (!MemberUtils.isAccessible(method)) {\n            return null;\n        }\n        // If the declaring class is public, we are done\n        final Class<?> cls = method.getDeclaringClass();\n        if (ClassUtils.isPublic(cls)) {\n            return method;\n        }\n        final String methodName = method.getName();\n        final Class<?>[] parameterTypes = method.getParameterTypes();\n\n        // Check the implemented interfaces and subinterfaces\n        method = getAccessibleMethodFromInterfaceNest(cls, methodName,\n                parameterTypes);\n\n        // Check the superclass chain\n        if (method == null) {\n            method = getAccessibleMethodFromSuperclass(cls, methodName,\n                    parameterTypes);\n        }\n        return method;\n    }\n\n    /**\n     * Gets an accessible method (that is, one that can be invoked via\n     * reflection) that implements the specified method, by scanning through\n     * all implemented interfaces and subinterfaces. If no such method\n     * can be found, return {@code null}.\n     *\n     * <p>There isn't any good reason why this method must be {@code private}.\n     * It is because there doesn't seem any reason why other classes should\n     * call this rather than the higher level methods.</p>\n     *\n     * @param cls Parent class for the interfaces to be checked\n     * @param methodName Method name of the method we wish to call\n     * @param parameterTypes The parameter type signatures\n     * @return the accessible method or {@code null} if not found\n     */\n    private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls,\n            final String methodName, final Class<?>... parameterTypes) {\n        // Search up the superclass chain\n        for (; cls != null; cls = cls.getSuperclass()) {\n\n            // Check the implemented interfaces of the parent class\n            final Class<?>[] interfaces = cls.getInterfaces();\n            for (final Class<?> anInterface : interfaces) {\n                // Is this interface public?\n                if (!ClassUtils.isPublic(anInterface)) {\n                    continue;\n                }\n                // Does the method exist on this interface?\n                try {\n                    return anInterface.getDeclaredMethod(methodName,\n                            parameterTypes);\n                } catch (final NoSuchMethodException ignored) {\n                    /*\n                     * Swallow, if no method is found after the loop then this\n                     * method returns null.\n                     */\n                }\n                // Recursively check our parent interfaces\n                final Method method = getAccessibleMethodFromInterfaceNest(anInterface,\n                        methodName, parameterTypes);\n                if (method != null) {\n                    return method;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Gets an accessible method (that is, one that can be invoked via\n     * reflection) by scanning through the superclasses. If no such method\n     * can be found, return {@code null}.\n     *\n     * @param cls Class to be checked\n     * @param methodName Method name of the method we wish to call\n     * @param parameterTypes The parameter type signatures\n     * @return the accessible method or {@code null} if not found\n     */\n    private static Method getAccessibleMethodFromSuperclass(final Class<?> cls,\n            final String methodName, final Class<?>... parameterTypes) {\n        Class<?> parentClass = cls.getSuperclass();\n        while (parentClass != null) {\n            if (ClassUtils.isPublic(parentClass)) {\n                try {\n                    return parentClass.getMethod(methodName, parameterTypes);\n                } catch (final NoSuchMethodException e) {\n                    return null;\n                }\n            }\n            parentClass = parentClass.getSuperclass();\n        }\n        return null;\n    }\n\n    /**\n     * Gets a combination of {@link ClassUtils#getAllSuperclasses(Class)} and\n     * {@link ClassUtils#getAllInterfaces(Class)}, one from superclasses, one\n     * from interfaces, and so on in a breadth first way.\n     *\n     * @param cls  the class to look up, may be {@code null}\n     * @return the combined {@link List} of superclasses and interfaces in order\n     * going up from this one\n     *  {@code null} if null input\n     */\n    private static List<Class<?>> getAllSuperclassesAndInterfaces(final Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n\n        final List<Class<?>> allSuperClassesAndInterfaces = new ArrayList<>();\n        final List<Class<?>> allSuperclasses = ClassUtils.getAllSuperclasses(cls);\n        int superClassIndex = 0;\n        final List<Class<?>> allInterfaces = ClassUtils.getAllInterfaces(cls);\n        int interfaceIndex = 0;\n        while (interfaceIndex < allInterfaces.size() ||\n                superClassIndex < allSuperclasses.size()) {\n            final Class<?> acls;\n            if (interfaceIndex >= allInterfaces.size()) {\n                acls = allSuperclasses.get(superClassIndex++);\n            } else if (superClassIndex >= allSuperclasses.size() || !(superClassIndex < interfaceIndex)) {\n                acls = allInterfaces.get(interfaceIndex++);\n            } else {\n                acls = allSuperclasses.get(superClassIndex++);\n            }\n            allSuperClassesAndInterfaces.add(acls);\n        }\n        return allSuperClassesAndInterfaces;\n    }\n\n    /**\n     * Gets the annotation object with the given annotation type that is present on the given method\n     * or optionally on any equivalent method in super classes and interfaces. Returns null if the annotation\n     * type was not present.\n     *\n     * <p>Stops searching for an annotation once the first annotation of the specified type has been\n     * found. Additional annotations of the specified type will be silently ignored.</p>\n     * @param <A>\n     *            the annotation type\n     * @param method\n     *            the {@link Method} to query\n     * @param annotationCls\n     *            the {@link Annotation} to check if is present on the method\n     * @param searchSupers\n     *            determines if a lookup in the entire inheritance hierarchy of the given class is performed\n     *            if the annotation was not directly present\n     * @param ignoreAccess\n     *            determines if underlying method has to be accessible\n     * @return the first matching annotation, or {@code null} if not found\n     * @throws NullPointerException if either the method or annotation class is {@code null}\n     * @since 3.6\n     */\n    public static <A extends Annotation> A getAnnotation(final Method method, final Class<A> annotationCls,\n                                                         final boolean searchSupers, final boolean ignoreAccess) {\n\n        Objects.requireNonNull(method, \"method\");\n        Objects.requireNonNull(annotationCls, \"annotationCls\");\n        if (!ignoreAccess && !MemberUtils.isAccessible(method)) {\n            return null;\n        }\n\n        A annotation = method.getAnnotation(annotationCls);\n\n        if (annotation == null && searchSupers) {\n            final Class<?> mcls = method.getDeclaringClass();\n            final List<Class<?>> classes = getAllSuperclassesAndInterfaces(mcls);\n            for (final Class<?> acls : classes) {\n                final Method equivalentMethod = ignoreAccess ? getMatchingMethod(acls, method.getName(), method.getParameterTypes())\n                        : getMatchingAccessibleMethod(acls, method.getName(), method.getParameterTypes());\n                if (equivalentMethod != null) {\n                    annotation = equivalentMethod.getAnnotation(annotationCls);\n                    if (annotation != null) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return annotation;\n    }\n\n    /**\n     * Gets an accessible method that matches the given name and has compatible parameters.\n     * Compatible parameters mean that every method parameter is assignable from\n     * the given parameters.\n     * In other words, it finds a method with the given name\n     * that will take the parameters given.\n     *\n     * <p>This method is used by\n     * {@link\n     * #invokeMethod(Object object, String methodName, Object[] args, Class[] parameterTypes)}.\n     * </p>\n     *\n     * <p>This method can match primitive parameter by passing in wrapper classes.\n     * For example, a {@link Boolean} will match a primitive {@code boolean}\n     * parameter.\n     * </p>\n     *\n     * @param cls find method in this class\n     * @param methodName find method with this name\n     * @param parameterTypes find method with most compatible parameters\n     * @return The accessible method\n     */\n    public static Method getMatchingAccessibleMethod(final Class<?> cls,\n        final String methodName, final Class<?>... parameterTypes) {\n        try {\n            return MemberUtils.setAccessibleWorkaround(cls.getMethod(methodName, parameterTypes));\n        } catch (final NoSuchMethodException ignored) {\n            // Swallow the exception\n        }\n        // search through all methods\n        final Method[] methods = cls.getMethods();\n        final List<Method> matchingMethods = Stream.of(methods)\n            .filter(method -> method.getName().equals(methodName) && MemberUtils.isMatchingMethod(method, parameterTypes)).collect(Collectors.toList());\n\n        // Sort methods by signature to force deterministic result\n        matchingMethods.sort(METHOD_BY_SIGNATURE);\n\n        Method bestMatch = null;\n        for (final Method method : matchingMethods) {\n            // get accessible version of method\n            final Method accessibleMethod = getAccessibleMethod(method);\n            if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareMethodFit(accessibleMethod, bestMatch, parameterTypes) < 0)) {\n                bestMatch = accessibleMethod;\n            }\n        }\n        if (bestMatch != null) {\n            MemberUtils.setAccessibleWorkaround(bestMatch);\n        }\n\n        if (bestMatch != null && bestMatch.isVarArgs() && bestMatch.getParameterTypes().length > 0 && parameterTypes.length > 0) {\n            final Class<?>[] methodParameterTypes = bestMatch.getParameterTypes();\n            final Class<?> methodParameterComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType();\n            final String methodParameterComponentTypeName = ClassUtils.primitiveToWrapper(methodParameterComponentType).getName();\n\n            final Class<?> lastParameterType = parameterTypes[parameterTypes.length - 1];\n            final String parameterTypeName = lastParameterType == null ? null : lastParameterType.getName();\n            final String parameterTypeSuperClassName = lastParameterType == null ? null : lastParameterType.getSuperclass().getName();\n\n            if (parameterTypeName != null && parameterTypeSuperClassName != null && !methodParameterComponentTypeName.equals(parameterTypeName)\n                && !methodParameterComponentTypeName.equals(parameterTypeSuperClassName)) {\n                return null;\n            }\n        }\n\n        return bestMatch;\n    }\n\n    /**\n     * Gets a method whether or not it's accessible. If no such method\n     * can be found, return {@code null}.\n     *\n     * @param cls The class that will be subjected to the method search\n     * @param methodName The method that we wish to call\n     * @param parameterTypes Argument class types\n     * @throws IllegalStateException if there is no unique result\n     * @throws NullPointerException if the class is {@code null}\n     * @return The method\n     *\n     * @since 3.5\n     */\n    public static Method getMatchingMethod(final Class<?> cls, final String methodName,\n            final Class<?>... parameterTypes) {\n        Objects.requireNonNull(cls, \"cls\");\n        Validate.notEmpty(methodName, \"methodName\");\n\n        final List<Method> methods = Stream.of(cls.getDeclaredMethods())\n                .filter(method -> method.getName().equals(methodName))\n                .collect(Collectors.toList());\n\n        ClassUtils.getAllSuperclasses(cls).stream()\n                .map(Class::getDeclaredMethods)\n                .flatMap(Stream::of)\n                .filter(method -> method.getName().equals(methodName))\n                .forEach(methods::add);\n\n        for (final Method method : methods) {\n            if (Arrays.deepEquals(method.getParameterTypes(), parameterTypes)) {\n                return method;\n            }\n        }\n\n        final TreeMap<Integer, List<Method>> candidates = new TreeMap<>();\n\n        methods.stream()\n                .filter(method -> ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true))\n                .forEach(method -> {\n                    final int distance = distance(parameterTypes, method.getParameterTypes());\n                    final List<Method> candidatesAtDistance = candidates.computeIfAbsent(distance, k -> new ArrayList<>());\n                    candidatesAtDistance.add(method);\n                });\n\n        if (candidates.isEmpty()) {\n            return null;\n        }\n\n        final List<Method> bestCandidates = candidates.values().iterator().next();\n        if (bestCandidates.size() == 1 || !Objects.equals(bestCandidates.get(0).getDeclaringClass(),\n                bestCandidates.get(1).getDeclaringClass())) {\n            return bestCandidates.get(0);\n        }\n\n        throw new IllegalStateException(\n                String.format(\"Found multiple candidates for method %s on class %s : %s\",\n                        methodName + Stream.of(parameterTypes).map(String::valueOf).collect(Collectors.joining(\",\", \"(\", \")\")),\n                        cls.getName(),\n                        bestCandidates.stream().map(Method::toString).collect(Collectors.joining(\",\", \"[\", \"]\")))\n        );\n    }\n\n    /**\n     * Gets all class level public methods of the given class that are annotated with the given annotation.\n     * @param cls\n     *            the {@link Class} to query\n     * @param annotationCls\n     *            the {@link Annotation} that must be present on a method to be matched\n     * @return a list of Methods (possibly empty).\n     * @throws NullPointerException\n     *            if the class or annotation are {@code null}\n     * @since 3.4\n     */\n    public static List<Method> getMethodsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls) {\n        return getMethodsListWithAnnotation(cls, annotationCls, false, false);\n    }\n\n    /**\n     * Gets all methods of the given class that are annotated with the given annotation.\n     *\n     * @param cls\n     *            the {@link Class} to query\n     * @param annotationCls\n     *            the {@link Annotation} that must be present on a method to be matched\n     * @param searchSupers\n     *            determines if a lookup in the entire inheritance hierarchy of the given class should be performed\n     * @param ignoreAccess\n     *            determines if non-public methods should be considered\n     * @return a list of Methods (possibly empty).\n     * @throws NullPointerException if either the class or annotation class is {@code null}\n     * @since 3.6\n     */\n    public static List<Method> getMethodsListWithAnnotation(final Class<?> cls,\n                                                            final Class<? extends Annotation> annotationCls,\n                                                            final boolean searchSupers, final boolean ignoreAccess) {\n\n        Objects.requireNonNull(cls, \"cls\");\n        Objects.requireNonNull(annotationCls, \"annotationCls\");\n        final List<Class<?>> classes = searchSupers ? getAllSuperclassesAndInterfaces(cls) : new ArrayList<>();\n        classes.add(0, cls);\n        final List<Method> annotatedMethods = new ArrayList<>();\n        classes.forEach(acls -> {\n            final Method[] methods = ignoreAccess ? acls.getDeclaredMethods() : acls.getMethods();\n            Stream.of(methods).filter(method -> method.isAnnotationPresent(annotationCls)).forEachOrdered(annotatedMethods::add);\n        });\n        return annotatedMethods;\n    }\n\n    /**\n     * Gets all class level public methods of the given class that are annotated with the given annotation.\n     *\n     * @param cls\n     *            the {@link Class} to query\n     * @param annotationCls\n     *            the {@link java.lang.annotation.Annotation} that must be present on a method to be matched\n     * @return an array of Methods (possibly empty).\n     * @throws NullPointerException if the class or annotation are {@code null}\n     * @since 3.4\n     */\n    public static Method[] getMethodsWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls) {\n        return getMethodsWithAnnotation(cls, annotationCls, false, false);\n    }\n\n    /**\n     * Gets all methods of the given class that are annotated with the given annotation.\n     *\n     * @param cls\n     *            the {@link Class} to query\n     * @param annotationCls\n     *            the {@link java.lang.annotation.Annotation} that must be present on a method to be matched\n     * @param searchSupers\n     *            determines if a lookup in the entire inheritance hierarchy of the given class should be performed\n     * @param ignoreAccess\n     *            determines if non-public methods should be considered\n     * @return an array of Methods (possibly empty).\n     * @throws NullPointerException if the class or annotation are {@code null}\n     * @since 3.6\n     */\n    public static Method[] getMethodsWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls,\n        final boolean searchSupers, final boolean ignoreAccess) {\n        return getMethodsListWithAnnotation(cls, annotationCls, searchSupers, ignoreAccess).toArray(ArrayUtils.EMPTY_METHOD_ARRAY);\n    }\n\n    /**\n     * Gets the hierarchy of overridden methods down to {@code result} respecting generics.\n     *\n     * @param method lowest to consider\n     * @param interfacesBehavior whether to search interfaces, {@code null} {@code implies} false\n     * @return Set&lt;Method&gt; in ascending order from sub- to superclass\n     * @throws NullPointerException if the specified method is {@code null}\n     * @since 3.2\n     */\n    public static Set<Method> getOverrideHierarchy(final Method method, final Interfaces interfacesBehavior) {\n        Objects.requireNonNull(method, \"method\");\n        final Set<Method> result = new LinkedHashSet<>();\n        result.add(method);\n\n        final Class<?>[] parameterTypes = method.getParameterTypes();\n\n        final Class<?> declaringClass = method.getDeclaringClass();\n\n        final Iterator<Class<?>> hierarchy = ClassUtils.hierarchy(declaringClass, interfacesBehavior).iterator();\n        //skip the declaring class :P\n        hierarchy.next();\n        hierarchyTraversal: while (hierarchy.hasNext()) {\n            final Class<?> c = hierarchy.next();\n            final Method m = getMatchingAccessibleMethod(c, method.getName(), parameterTypes);\n            if (m == null) {\n                continue;\n            }\n            if (Arrays.equals(m.getParameterTypes(), parameterTypes)) {\n                // matches without generics\n                result.add(m);\n                continue;\n            }\n            // necessary to get arguments every time in the case that we are including interfaces\n            final Map<TypeVariable<?>, Type> typeArguments = TypeUtils.getTypeArguments(declaringClass, m.getDeclaringClass());\n            for (int i = 0; i < parameterTypes.length; i++) {\n                final Type childType = TypeUtils.unrollVariables(typeArguments, method.getGenericParameterTypes()[i]);\n                final Type parentType = TypeUtils.unrollVariables(typeArguments, m.getGenericParameterTypes()[i]);\n                if (!TypeUtils.equals(childType, parentType)) {\n                    continue hierarchyTraversal;\n                }\n            }\n            result.add(m);\n        }\n        return result;\n    }\n\n    /**\n     * Gets an array of arguments in the canonical form, given an arguments array passed to a varargs method,\n     * for example an array with the declared number of parameters, and whose last parameter is an array of the varargs type.\n     *\n     * @param args the array of arguments passed to the varags method\n     * @param methodParameterTypes the declared array of method parameter types\n     * @return an array of the variadic arguments passed to the method\n     * @since 3.5\n     */\n    static Object[] getVarArgs(final Object[] args, final Class<?>[] methodParameterTypes) {\n        if (args.length == methodParameterTypes.length\n                && (args[args.length - 1] == null || args[args.length - 1].getClass().equals(methodParameterTypes[methodParameterTypes.length - 1]))) {\n            // The args array is already in the canonical form for the method.\n            return args;\n        }\n\n        // Construct a new array matching the method's declared parameter types.\n        // Copy the normal (non-varargs) parameters\n        final Object[] newArgs = ArrayUtils.arraycopy(args, 0, 0, methodParameterTypes.length - 1, () -> new Object[methodParameterTypes.length]);\n\n        // Construct a new array for the variadic parameters\n        final Class<?> varArgComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType();\n        final int varArgLength = args.length - methodParameterTypes.length + 1;\n\n        // Copy the variadic arguments into the varargs array.\n        Object varArgsArray = ArrayUtils.arraycopy(args, methodParameterTypes.length - 1, 0, varArgLength,\n                s -> Array.newInstance(ClassUtils.primitiveToWrapper(varArgComponentType), varArgLength));\n\n        if (varArgComponentType.isPrimitive()) {\n            // unbox from wrapper type to primitive type\n            varArgsArray = ArrayUtils.toPrimitive(varArgsArray);\n        }\n\n        // Store the varargs array in the last position of the array to return\n        newArgs[methodParameterTypes.length - 1] = varArgsArray;\n\n        // Return the canonical varargs array.\n        return newArgs;\n    }\n\n    /**\n     * Invokes a method whose parameter types match exactly the object\n     * types.\n     *\n     * <p>This uses reflection to invoke the method obtained from a call to\n     * {@link #getAccessibleMethod}(Class, String, Class[])}.</p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     *\n     * @since 3.4\n     */\n    public static Object invokeExactMethod(final Object object, final String methodName) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        return invokeExactMethod(object, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n    }\n\n    /**\n     * Invokes a method with no parameters.\n     *\n     * <p>This uses reflection to invoke the method obtained from a call to\n     * {@link #getAccessibleMethod}(Class, String, Class[])}.</p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     * @throws NullPointerException if the object or method name are {@code null}\n     */\n    public static Object invokeExactMethod(final Object object, final String methodName,\n            Object... args) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        return invokeExactMethod(object, methodName, args, ClassUtils.toClass(args));\n    }\n\n    /**\n     * Invokes a method whose parameter types match exactly the parameter\n     * types given.\n     *\n     * <p>This uses reflection to invoke the method obtained from a call to\n     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @param parameterTypes match these parameters - treat {@code null} as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     * @throws NullPointerException if the object or method name are {@code null}\n     */\n    public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes)\n        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n        Objects.requireNonNull(object, \"object\");\n        args = ArrayUtils.nullToEmpty(args);\n        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n        final Class<?> cls = object.getClass();\n        final Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n        if (method == null) {\n            throw new NoSuchMethodException(\"No such accessible method: \" + methodName + \"() on object: \" + cls.getName());\n        }\n        return method.invoke(object, args);\n    }\n\n    /**\n     * Invokes a {@code static} method whose parameter types match exactly the object\n     * types.\n     *\n     * <p>This uses reflection to invoke the method obtained from a call to\n     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * @param cls invoke static method on this class\n     * @param methodName get method with this name\n     * @param args use these arguments - treat {@code null} as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     */\n    public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName,\n            Object... args) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        return invokeExactStaticMethod(cls, methodName, args, ClassUtils.toClass(args));\n    }\n\n    /**\n     * Invokes a {@code static} method whose parameter types match exactly the parameter\n     * types given.\n     *\n     * <p>This uses reflection to invoke the method obtained from a call to\n     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * @param cls invoke static method on this class\n     * @param methodName get method with this name\n     * @param args use these arguments - treat {@code null} as empty array\n     * @param parameterTypes match these parameters - treat {@code null} as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     */\n    public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName,\n            Object[] args, Class<?>[] parameterTypes)\n            throws NoSuchMethodException, IllegalAccessException,\n            InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n        final Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n        if (method == null) {\n            throw new NoSuchMethodException(\"No such accessible method: \"\n                    + methodName + \"() on class: \" + cls.getName());\n        }\n        return method.invoke(null, args);\n    }\n\n    /**\n     * Invokes a named method without parameters.\n     *\n     * <p>This is a convenient wrapper for\n     * {@link #invokeMethod(Object object, boolean forceAccess, String methodName, Object[] args, Class[] parameterTypes)}.\n     * </p>\n     *\n     * @param object invoke method on this object\n     * @param forceAccess force access to invoke method even if it's not accessible\n     * @param methodName get method with this name\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     *\n     * @since 3.5\n     */\n    public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName)\n            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n        return invokeMethod(object, forceAccess, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n    }\n\n    /**\n     * Invokes a named method whose parameter type matches the object type.\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} object\n     * would match a {@code boolean} primitive.</p>\n     *\n     * <p>This is a convenient wrapper for\n     * {@link #invokeMethod(Object object, boolean forceAccess, String methodName, Object[] args, Class[] parameterTypes)}.\n     * </p>\n     *\n     * @param object invoke method on this object\n     * @param forceAccess force access to invoke method even if it's not accessible\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     * @throws NullPointerException if the object or method name are {@code null}\n     * @since 3.5\n     */\n    public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName,\n            Object... args) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        return invokeMethod(object, forceAccess, methodName, args, ClassUtils.toClass(args));\n    }\n\n    /**\n     * Invokes a named method whose parameter type matches the object type.\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} object\n     * would match a {@code boolean} primitive.</p>\n     *\n     * @param object invoke method on this object\n     * @param forceAccess force access to invoke method even if it's not accessible\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @param parameterTypes match these parameters - treat null as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     * @throws NullPointerException if the object or method name are {@code null}\n     * @since 3.5\n     */\n    public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName, Object[] args, Class<?>[] parameterTypes)\n        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n        Objects.requireNonNull(object, \"object\");\n        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n        args = ArrayUtils.nullToEmpty(args);\n\n        final String messagePrefix;\n        final Method method;\n\n        final Class<? extends Object> cls = object.getClass();\n        if (forceAccess) {\n            messagePrefix = \"No such method: \";\n            method = getMatchingMethod(cls, methodName, parameterTypes);\n            if (method != null && !method.isAccessible()) {\n                method.setAccessible(true);\n            }\n        } else {\n            messagePrefix = \"No such accessible method: \";\n            method = getMatchingAccessibleMethod(cls, methodName, parameterTypes);\n        }\n\n        if (method == null) {\n            throw new NoSuchMethodException(messagePrefix + methodName + \"() on object: \" + cls.getName());\n        }\n        args = toVarArgs(method, args);\n\n        return method.invoke(object, args);\n    }\n\n    /**\n     * Invokes a named method without parameters.\n     *\n     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * <p>This is a convenient wrapper for\n     * {@link #invokeMethod(Object object, String methodName, Object[] args, Class[] parameterTypes)}.\n     * </p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     *\n     *  @since 3.4\n     */\n    public static Object invokeMethod(final Object object, final String methodName) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        return invokeMethod(object, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n    }\n\n    /**\n     * Invokes a named method whose parameter type matches the object type.\n     *\n     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} object\n     * would match a {@code boolean} primitive.</p>\n     *\n     * <p>This is a convenient wrapper for\n     * {@link #invokeMethod(Object object, String methodName, Object[] args, Class[] parameterTypes)}.\n     * </p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     * @throws NullPointerException if the object or method name are {@code null}\n     */\n    public static Object invokeMethod(final Object object, final String methodName,\n            Object... args) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        return invokeMethod(object, methodName, args, ClassUtils.toClass(args));\n    }\n\n    /**\n     * Invokes a named method whose parameter type matches the object type.\n     *\n     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} object\n     * would match a {@code boolean} primitive.</p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @param parameterTypes match these parameters - treat null as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     */\n    public static Object invokeMethod(final Object object, final String methodName,\n            final Object[] args, final Class<?>[] parameterTypes)\n            throws NoSuchMethodException, IllegalAccessException,\n            InvocationTargetException {\n        return invokeMethod(object, false, methodName, args, parameterTypes);\n    }\n\n    /**\n     * Invokes a named {@code static} method whose parameter type matches the object type.\n     *\n     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} class\n     * would match a {@code boolean} primitive.</p>\n     *\n     * <p>This is a convenient wrapper for\n     * {@link #invokeStaticMethod(Class, String, Object[], Class[])}.\n     * </p>\n     *\n     * @param cls invoke static method on this class\n     * @param methodName get method with this name\n     * @param args use these arguments - treat {@code null} as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     */\n    public static Object invokeStaticMethod(final Class<?> cls, final String methodName,\n            Object... args) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        return invokeStaticMethod(cls, methodName, args, ClassUtils.toClass(args));\n    }\n\n    /**\n     * Invokes a named {@code static} method whose parameter type matches the object type.\n     *\n     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} class\n     * would match a {@code boolean} primitive.</p>\n     *\n     * @param cls invoke static method on this class\n     * @param methodName get method with this name\n     * @param args use these arguments - treat {@code null} as empty array\n     * @param parameterTypes match these parameters - treat {@code null} as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     */\n    public static Object invokeStaticMethod(final Class<?> cls, final String methodName,\n            Object[] args, Class<?>[] parameterTypes)\n            throws NoSuchMethodException, IllegalAccessException,\n            InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n        final Method method = getMatchingAccessibleMethod(cls, methodName,\n                parameterTypes);\n        if (method == null) {\n            throw new NoSuchMethodException(\"No such accessible method: \"\n                    + methodName + \"() on class: \" + cls.getName());\n        }\n        args = toVarArgs(method, args);\n        return method.invoke(null, args);\n    }\n\n    private static Object[] toVarArgs(final Method method, Object[] args) {\n        if (method.isVarArgs()) {\n            final Class<?>[] methodParameterTypes = method.getParameterTypes();\n            args = getVarArgs(args, methodParameterTypes);\n        }\n        return args;\n    }\n\n    /**\n     * {@link MethodUtils} instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as\n     * {@code MethodUtils.getAccessibleMethod(method)}.\n     *\n     * <p>This constructor is {@code public} to permit tools that require a JavaBean\n     * instance to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public MethodUtils() {\n        // empty\n    }\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.reflect;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.ClassUtils;\nimport org.apache.commons.lang3.ClassUtils.Interfaces;\nimport org.apache.commons.lang3.Validate;\n\n/**\n * Utility reflection methods focused on {@link Method}s, originally from Commons BeanUtils.\n * Differences from the BeanUtils version may be noted, especially where similar functionality\n * already existed within Lang.\n *\n * <h2>Known Limitations</h2>\n * <h3>Accessing Public Methods In A Default Access Superclass</h3>\n * <p>There is an issue when invoking {@code public} methods contained in a default access superclass on JREs prior to 1.4.\n * Reflection locates these methods fine and correctly assigns them as {@code public}.\n * However, an {@link IllegalAccessException} is thrown if the method is invoked.</p>\n *\n * <p>{@link MethodUtils} contains a workaround for this situation.\n * It will attempt to call {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} on this method.\n * If this call succeeds, then the method can be invoked as normal.\n * This call will only succeed when the application has sufficient security privileges.\n * If this call fails then the method may fail.</p>\n *\n * @since 2.5\n */\npublic class MethodUtils {\n\n    private static final Comparator<Method> METHOD_BY_SIGNATURE = Comparator.comparing(Method::toString);\n\n    /**\n     * Returns the aggregate number of inheritance hops between assignable argument class types.  Returns -1\n     * if the arguments aren't assignable.  Fills a specific purpose for getMatchingMethod and is not generalized.\n     *\n     * @param fromClassArray the Class array to calculate the distance from.\n     * @param toClassArray the Class array to calculate the distance to.\n     * @return the aggregate number of inheritance hops between assignable argument class types.\n     */\n    private static int distance(final Class<?>[] fromClassArray, final Class<?>[] toClassArray) {\n        int answer = 0;\n\n        if (!ClassUtils.isAssignable(fromClassArray, toClassArray, true)) {\n            return -1;\n        }\n        for (int offset = 0; offset < fromClassArray.length; offset++) {\n            // Note InheritanceUtils.distance() uses different scoring system.\n            final Class<?> aClass = fromClassArray[offset];\n            final Class<?> toClass = toClassArray[offset];\n            if (aClass == null || aClass.equals(toClass)) {\n                continue;\n            }\n            if (ClassUtils.isAssignable(aClass, toClass, true)\n                    && !ClassUtils.isAssignable(aClass, toClass, false)) {\n                answer++;\n            } else {\n                answer += 2;\n            }\n        }\n\n        return answer;\n    }\n\n    /**\n     * Gets an accessible method (that is, one that can be invoked via reflection) with given name and parameters. If no such method can be found, return\n     * {@code null}. This is just a convenience wrapper for {@link #getAccessibleMethod(Method)}.\n     *\n     * @param cls            get method from this class\n     * @param methodName     get method with this name\n     * @param parameterTypes with these parameters types\n     * @return The accessible method\n     */\n    public static Method getAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {\n        return getAccessibleMethod(getMethodObject(cls, methodName, parameterTypes));\n    }\n\n    /**\n     * Gets an accessible method (that is, one that can be invoked via\n     * reflection) that implements the specified Method. If no such method\n     * can be found, return {@code null}.\n     *\n     * @param method The method that we wish to call, may be null.\n     * @return The accessible method\n     */\n    public static Method getAccessibleMethod(Method method) {\n        if (!MemberUtils.isAccessible(method)) {\n            return null;\n        }\n        // If the declaring class is public, we are done\n        final Class<?> cls = method.getDeclaringClass();\n        if (ClassUtils.isPublic(cls)) {\n            return method;\n        }\n        final String methodName = method.getName();\n        final Class<?>[] parameterTypes = method.getParameterTypes();\n\n        // Check the implemented interfaces and subinterfaces\n        method = getAccessibleMethodFromInterfaceNest(cls, methodName,\n                parameterTypes);\n\n        // Check the superclass chain\n        if (method == null) {\n            method = getAccessibleMethodFromSuperclass(cls, methodName,\n                    parameterTypes);\n        }\n        return method;\n    }\n\n    /**\n     * Gets an accessible method (that is, one that can be invoked via\n     * reflection) that implements the specified method, by scanning through\n     * all implemented interfaces and subinterfaces. If no such method\n     * can be found, return {@code null}.\n     *\n     * <p>There isn't any good reason why this method must be {@code private}.\n     * It is because there doesn't seem any reason why other classes should\n     * call this rather than the higher level methods.</p>\n     *\n     * @param cls Parent class for the interfaces to be checked\n     * @param methodName Method name of the method we wish to call\n     * @param parameterTypes The parameter type signatures\n     * @return the accessible method or {@code null} if not found\n     */\n    private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls,\n            final String methodName, final Class<?>... parameterTypes) {\n        // Search up the superclass chain\n        for (; cls != null; cls = cls.getSuperclass()) {\n\n            // Check the implemented interfaces of the parent class\n            final Class<?>[] interfaces = cls.getInterfaces();\n            for (final Class<?> anInterface : interfaces) {\n                // Is this interface public?\n                if (!ClassUtils.isPublic(anInterface)) {\n                    continue;\n                }\n                // Does the method exist on this interface?\n                try {\n                    return anInterface.getDeclaredMethod(methodName,\n                            parameterTypes);\n                } catch (final NoSuchMethodException ignored) {\n                    /*\n                     * Swallow, if no method is found after the loop then this\n                     * method returns null.\n                     */\n                }\n                // Recursively check our parent interfaces\n                final Method method = getAccessibleMethodFromInterfaceNest(anInterface,\n                        methodName, parameterTypes);\n                if (method != null) {\n                    return method;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Gets an accessible method (that is, one that can be invoked via\n     * reflection) by scanning through the superclasses. If no such method\n     * can be found, return {@code null}.\n     *\n     * @param cls Class to be checked\n     * @param methodName Method name of the method we wish to call\n     * @param parameterTypes The parameter type signatures\n     * @return the accessible method or {@code null} if not found\n     */\n    private static Method getAccessibleMethodFromSuperclass(final Class<?> cls,\n            final String methodName, final Class<?>... parameterTypes) {\n        Class<?> parentClass = cls.getSuperclass();\n        while (parentClass != null) {\n            if (ClassUtils.isPublic(parentClass)) {\n                return getMethodObject(parentClass, methodName, parameterTypes);\n            }\n            parentClass = parentClass.getSuperclass();\n        }\n        return null;\n    }\n\n    /**\n     * Gets a combination of {@link ClassUtils#getAllSuperclasses(Class)} and\n     * {@link ClassUtils#getAllInterfaces(Class)}, one from superclasses, one\n     * from interfaces, and so on in a breadth first way.\n     *\n     * @param cls  the class to look up, may be {@code null}\n     * @return the combined {@link List} of superclasses and interfaces in order\n     * going up from this one\n     *  {@code null} if null input\n     */\n    private static List<Class<?>> getAllSuperclassesAndInterfaces(final Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n\n        final List<Class<?>> allSuperClassesAndInterfaces = new ArrayList<>();\n        final List<Class<?>> allSuperclasses = ClassUtils.getAllSuperclasses(cls);\n        int superClassIndex = 0;\n        final List<Class<?>> allInterfaces = ClassUtils.getAllInterfaces(cls);\n        int interfaceIndex = 0;\n        while (interfaceIndex < allInterfaces.size() ||\n                superClassIndex < allSuperclasses.size()) {\n            final Class<?> acls;\n            if (interfaceIndex >= allInterfaces.size()) {\n                acls = allSuperclasses.get(superClassIndex++);\n            } else if (superClassIndex >= allSuperclasses.size() || !(superClassIndex < interfaceIndex)) {\n                acls = allInterfaces.get(interfaceIndex++);\n            } else {\n                acls = allSuperclasses.get(superClassIndex++);\n            }\n            allSuperClassesAndInterfaces.add(acls);\n        }\n        return allSuperClassesAndInterfaces;\n    }\n\n    /**\n     * Gets the annotation object with the given annotation type that is present on the given method\n     * or optionally on any equivalent method in super classes and interfaces. Returns null if the annotation\n     * type was not present.\n     *\n     * <p>Stops searching for an annotation once the first annotation of the specified type has been\n     * found. Additional annotations of the specified type will be silently ignored.</p>\n     * @param <A>\n     *            the annotation type\n     * @param method\n     *            the {@link Method} to query, may be null.\n     * @param annotationCls\n     *            the {@link Annotation} to check if is present on the method\n     * @param searchSupers\n     *            determines if a lookup in the entire inheritance hierarchy of the given class is performed\n     *            if the annotation was not directly present\n     * @param ignoreAccess\n     *            determines if underlying method has to be accessible\n     * @return the first matching annotation, or {@code null} if not found\n     * @throws NullPointerException if either the method or annotation class is {@code null}\n     * @since 3.6\n     */\n    public static <A extends Annotation> A getAnnotation(final Method method, final Class<A> annotationCls,\n                                                         final boolean searchSupers, final boolean ignoreAccess) {\n\n        Objects.requireNonNull(method, \"method\");\n        Objects.requireNonNull(annotationCls, \"annotationCls\");\n        if (!ignoreAccess && !MemberUtils.isAccessible(method)) {\n            return null;\n        }\n\n        A annotation = method.getAnnotation(annotationCls);\n\n        if (annotation == null && searchSupers) {\n            final Class<?> mcls = method.getDeclaringClass();\n            final List<Class<?>> classes = getAllSuperclassesAndInterfaces(mcls);\n            for (final Class<?> acls : classes) {\n                final Method equivalentMethod = ignoreAccess ? getMatchingMethod(acls, method.getName(), method.getParameterTypes())\n                        : getMatchingAccessibleMethod(acls, method.getName(), method.getParameterTypes());\n                if (equivalentMethod != null) {\n                    annotation = equivalentMethod.getAnnotation(annotationCls);\n                    if (annotation != null) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return annotation;\n    }\n\n    /**\n     * Gets an accessible method that matches the given name and has compatible parameters.\n     * Compatible parameters mean that every method parameter is assignable from\n     * the given parameters.\n     * In other words, it finds a method with the given name\n     * that will take the parameters given.\n     *\n     * <p>This method is used by\n     * {@link\n     * #invokeMethod(Object object, String methodName, Object[] args, Class[] parameterTypes)}.\n     * </p>\n     *\n     * <p>This method can match primitive parameter by passing in wrapper classes.\n     * For example, a {@link Boolean} will match a primitive {@code boolean}\n     * parameter.\n     * </p>\n     *\n     * @param cls find method in this class\n     * @param methodName find method with this name\n     * @param parameterTypes find method with most compatible parameters\n     * @return The accessible method\n     */\n    public static Method getMatchingAccessibleMethod(final Class<?> cls,\n        final String methodName, final Class<?>... parameterTypes) {\n        final Method candidate = getMethodObject(cls, methodName, parameterTypes);\n        if (candidate != null) {\n            return MemberUtils.setAccessibleWorkaround(candidate);\n        }\n        // search through all methods\n        final Method[] methods = cls.getMethods();\n        final List<Method> matchingMethods = Stream.of(methods)\n            .filter(method -> method.getName().equals(methodName) && MemberUtils.isMatchingMethod(method, parameterTypes)).collect(Collectors.toList());\n\n        // Sort methods by signature to force deterministic result\n        matchingMethods.sort(METHOD_BY_SIGNATURE);\n\n        Method bestMatch = null;\n        for (final Method method : matchingMethods) {\n            // get accessible version of method\n            final Method accessibleMethod = getAccessibleMethod(method);\n            if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareMethodFit(accessibleMethod, bestMatch, parameterTypes) < 0)) {\n                bestMatch = accessibleMethod;\n            }\n        }\n        if (bestMatch != null) {\n            MemberUtils.setAccessibleWorkaround(bestMatch);\n        }\n\n        if (bestMatch != null && bestMatch.isVarArgs() && bestMatch.getParameterTypes().length > 0 && parameterTypes.length > 0) {\n            final Class<?>[] methodParameterTypes = bestMatch.getParameterTypes();\n            final Class<?> methodParameterComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType();\n            final String methodParameterComponentTypeName = ClassUtils.primitiveToWrapper(methodParameterComponentType).getName();\n\n            final Class<?> lastParameterType = parameterTypes[parameterTypes.length - 1];\n            final String parameterTypeName = lastParameterType == null ? null : lastParameterType.getName();\n            final String parameterTypeSuperClassName = lastParameterType == null ? null : lastParameterType.getSuperclass().getName();\n\n            if (parameterTypeName != null && parameterTypeSuperClassName != null && !methodParameterComponentTypeName.equals(parameterTypeName)\n                && !methodParameterComponentTypeName.equals(parameterTypeSuperClassName)) {\n                return null;\n            }\n        }\n\n        return bestMatch;\n    }\n\n    /**\n     * Gets a method whether or not it's accessible. If no such method\n     * can be found, return {@code null}.\n     *\n     * @param cls The class that will be subjected to the method search\n     * @param methodName The method that we wish to call\n     * @param parameterTypes Argument class types\n     * @throws IllegalStateException if there is no unique result\n     * @throws NullPointerException if the class is {@code null}\n     * @return The method\n     *\n     * @since 3.5\n     */\n    public static Method getMatchingMethod(final Class<?> cls, final String methodName,\n            final Class<?>... parameterTypes) {\n        Objects.requireNonNull(cls, \"cls\");\n        Validate.notEmpty(methodName, \"methodName\");\n\n        final List<Method> methods = Stream.of(cls.getDeclaredMethods())\n                .filter(method -> method.getName().equals(methodName))\n                .collect(Collectors.toList());\n\n        ClassUtils.getAllSuperclasses(cls).stream()\n                .map(Class::getDeclaredMethods)\n                .flatMap(Stream::of)\n                .filter(method -> method.getName().equals(methodName))\n                .forEach(methods::add);\n\n        for (final Method method : methods) {\n            if (Arrays.deepEquals(method.getParameterTypes(), parameterTypes)) {\n                return method;\n            }\n        }\n\n        final TreeMap<Integer, List<Method>> candidates = new TreeMap<>();\n\n        methods.stream()\n                .filter(method -> ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true))\n                .forEach(method -> {\n                    final int distance = distance(parameterTypes, method.getParameterTypes());\n                    final List<Method> candidatesAtDistance = candidates.computeIfAbsent(distance, k -> new ArrayList<>());\n                    candidatesAtDistance.add(method);\n                });\n\n        if (candidates.isEmpty()) {\n            return null;\n        }\n\n        final List<Method> bestCandidates = candidates.values().iterator().next();\n        if (bestCandidates.size() == 1 || !Objects.equals(bestCandidates.get(0).getDeclaringClass(),\n                bestCandidates.get(1).getDeclaringClass())) {\n            return bestCandidates.get(0);\n        }\n\n        throw new IllegalStateException(\n                String.format(\"Found multiple candidates for method %s on class %s : %s\",\n                        methodName + Stream.of(parameterTypes).map(String::valueOf).collect(Collectors.joining(\",\", \"(\", \")\")),\n                        cls.getName(),\n                        bestCandidates.stream().map(Method::toString).collect(Collectors.joining(\",\", \"[\", \"]\")))\n        );\n    }\n\n    /**\n     * Gets a Method or null if a {@link Class#getMethod(String, Class...) documented} exception is thrown.\n     *\n     * @param cls Receiver for {@link Class#getMethod(String, Class...)}.\n     * @param name the name of the method\n     * @param parameterTypes the list of parameters\n     * @return a Method or null.\n     * @since 3.15.0\n     * @see Class#getMethod(String, Class...)\n     */\n    public static Method getMethodObject(final Class<?> cls, final String name, final Class<?>... parameterTypes) {\n        try {\n            return cls.getMethod(name, parameterTypes);\n        } catch (final NoSuchMethodException | SecurityException e) {\n            return null;\n        }\n    }\n\n    /**\n     * Gets all class level public methods of the given class that are annotated with the given annotation.\n     * @param cls\n     *            the {@link Class} to query\n     * @param annotationCls\n     *            the {@link Annotation} that must be present on a method to be matched\n     * @return a list of Methods (possibly empty).\n     * @throws NullPointerException\n     *            if the class or annotation are {@code null}\n     * @since 3.4\n     */\n    public static List<Method> getMethodsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls) {\n        return getMethodsListWithAnnotation(cls, annotationCls, false, false);\n    }\n\n    /**\n     * Gets all methods of the given class that are annotated with the given annotation.\n     *\n     * @param cls\n     *            the {@link Class} to query\n     * @param annotationCls\n     *            the {@link Annotation} that must be present on a method to be matched\n     * @param searchSupers\n     *            determines if a lookup in the entire inheritance hierarchy of the given class should be performed\n     * @param ignoreAccess\n     *            determines if non-public methods should be considered\n     * @return a list of Methods (possibly empty).\n     * @throws NullPointerException if either the class or annotation class is {@code null}\n     * @since 3.6\n     */\n    public static List<Method> getMethodsListWithAnnotation(final Class<?> cls,\n                                                            final Class<? extends Annotation> annotationCls,\n                                                            final boolean searchSupers, final boolean ignoreAccess) {\n\n        Objects.requireNonNull(cls, \"cls\");\n        Objects.requireNonNull(annotationCls, \"annotationCls\");\n        final List<Class<?>> classes = searchSupers ? getAllSuperclassesAndInterfaces(cls) : new ArrayList<>();\n        classes.add(0, cls);\n        final List<Method> annotatedMethods = new ArrayList<>();\n        classes.forEach(acls -> {\n            final Method[] methods = ignoreAccess ? acls.getDeclaredMethods() : acls.getMethods();\n            Stream.of(methods).filter(method -> method.isAnnotationPresent(annotationCls)).forEachOrdered(annotatedMethods::add);\n        });\n        return annotatedMethods;\n    }\n\n    /**\n     * Gets all class level public methods of the given class that are annotated with the given annotation.\n     *\n     * @param cls\n     *            the {@link Class} to query\n     * @param annotationCls\n     *            the {@link java.lang.annotation.Annotation} that must be present on a method to be matched\n     * @return an array of Methods (possibly empty).\n     * @throws NullPointerException if the class or annotation are {@code null}\n     * @since 3.4\n     */\n    public static Method[] getMethodsWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls) {\n        return getMethodsWithAnnotation(cls, annotationCls, false, false);\n    }\n\n    /**\n     * Gets all methods of the given class that are annotated with the given annotation.\n     *\n     * @param cls\n     *            the {@link Class} to query\n     * @param annotationCls\n     *            the {@link java.lang.annotation.Annotation} that must be present on a method to be matched\n     * @param searchSupers\n     *            determines if a lookup in the entire inheritance hierarchy of the given class should be performed\n     * @param ignoreAccess\n     *            determines if non-public methods should be considered\n     * @return an array of Methods (possibly empty).\n     * @throws NullPointerException if the class or annotation are {@code null}\n     * @since 3.6\n     */\n    public static Method[] getMethodsWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls,\n        final boolean searchSupers, final boolean ignoreAccess) {\n        return getMethodsListWithAnnotation(cls, annotationCls, searchSupers, ignoreAccess).toArray(ArrayUtils.EMPTY_METHOD_ARRAY);\n    }\n\n    /**\n     * Gets the hierarchy of overridden methods down to {@code result} respecting generics.\n     *\n     * @param method lowest to consider\n     * @param interfacesBehavior whether to search interfaces, {@code null} {@code implies} false\n     * @return Set&lt;Method&gt; in ascending order from sub- to superclass\n     * @throws NullPointerException if the specified method is {@code null}\n     * @since 3.2\n     */\n    public static Set<Method> getOverrideHierarchy(final Method method, final Interfaces interfacesBehavior) {\n        Objects.requireNonNull(method, \"method\");\n        final Set<Method> result = new LinkedHashSet<>();\n        result.add(method);\n\n        final Class<?>[] parameterTypes = method.getParameterTypes();\n\n        final Class<?> declaringClass = method.getDeclaringClass();\n\n        final Iterator<Class<?>> hierarchy = ClassUtils.hierarchy(declaringClass, interfacesBehavior).iterator();\n        //skip the declaring class :P\n        hierarchy.next();\n        hierarchyTraversal: while (hierarchy.hasNext()) {\n            final Class<?> c = hierarchy.next();\n            final Method m = getMatchingAccessibleMethod(c, method.getName(), parameterTypes);\n            if (m == null) {\n                continue;\n            }\n            if (Arrays.equals(m.getParameterTypes(), parameterTypes)) {\n                // matches without generics\n                result.add(m);\n                continue;\n            }\n            // necessary to get arguments every time in the case that we are including interfaces\n            final Map<TypeVariable<?>, Type> typeArguments = TypeUtils.getTypeArguments(declaringClass, m.getDeclaringClass());\n            for (int i = 0; i < parameterTypes.length; i++) {\n                final Type childType = TypeUtils.unrollVariables(typeArguments, method.getGenericParameterTypes()[i]);\n                final Type parentType = TypeUtils.unrollVariables(typeArguments, m.getGenericParameterTypes()[i]);\n                if (!TypeUtils.equals(childType, parentType)) {\n                    continue hierarchyTraversal;\n                }\n            }\n            result.add(m);\n        }\n        return result;\n    }\n\n    /**\n     * Gets an array of arguments in the canonical form, given an arguments array passed to a varargs method,\n     * for example an array with the declared number of parameters, and whose last parameter is an array of the varargs type.\n     *\n     * @param args the array of arguments passed to the varags method\n     * @param methodParameterTypes the declared array of method parameter types\n     * @return an array of the variadic arguments passed to the method\n     * @since 3.5\n     */\n    static Object[] getVarArgs(final Object[] args, final Class<?>[] methodParameterTypes) {\n        if (args.length == methodParameterTypes.length\n                && (args[args.length - 1] == null || args[args.length - 1].getClass().equals(methodParameterTypes[methodParameterTypes.length - 1]))) {\n            // The args array is already in the canonical form for the method.\n            return args;\n        }\n\n        // Construct a new array matching the method's declared parameter types.\n        // Copy the normal (non-varargs) parameters\n        final Object[] newArgs = ArrayUtils.arraycopy(args, 0, 0, methodParameterTypes.length - 1, () -> new Object[methodParameterTypes.length]);\n\n        // Construct a new array for the variadic parameters\n        final Class<?> varArgComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType();\n        final int varArgLength = args.length - methodParameterTypes.length + 1;\n\n        // Copy the variadic arguments into the varargs array.\n        Object varArgsArray = ArrayUtils.arraycopy(args, methodParameterTypes.length - 1, 0, varArgLength,\n                s -> Array.newInstance(ClassUtils.primitiveToWrapper(varArgComponentType), varArgLength));\n\n        if (varArgComponentType.isPrimitive()) {\n            // unbox from wrapper type to primitive type\n            varArgsArray = ArrayUtils.toPrimitive(varArgsArray);\n        }\n\n        // Store the varargs array in the last position of the array to return\n        newArgs[methodParameterTypes.length - 1] = varArgsArray;\n\n        // Return the canonical varargs array.\n        return newArgs;\n    }\n\n    /**\n     * Invokes a method whose parameter types match exactly the object\n     * types.\n     *\n     * <p>This uses reflection to invoke the method obtained from a call to\n     * {@link #getAccessibleMethod}(Class, String, Class[])}.</p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     *\n     * @since 3.4\n     */\n    public static Object invokeExactMethod(final Object object, final String methodName) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        return invokeExactMethod(object, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n    }\n\n    /**\n     * Invokes a method with no parameters.\n     *\n     * <p>This uses reflection to invoke the method obtained from a call to\n     * {@link #getAccessibleMethod}(Class, String, Class[])}.</p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     * @throws NullPointerException if the object or method name are {@code null}\n     */\n    public static Object invokeExactMethod(final Object object, final String methodName,\n            Object... args) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        return invokeExactMethod(object, methodName, args, ClassUtils.toClass(args));\n    }\n\n    /**\n     * Invokes a method whose parameter types match exactly the parameter\n     * types given.\n     *\n     * <p>This uses reflection to invoke the method obtained from a call to\n     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @param parameterTypes match these parameters - treat {@code null} as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     * @throws NullPointerException if the object or method name are {@code null}\n     */\n    public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes)\n        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n        Objects.requireNonNull(object, \"object\");\n        args = ArrayUtils.nullToEmpty(args);\n        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n        final Class<?> cls = object.getClass();\n        final Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n        if (method == null) {\n            throw new NoSuchMethodException(\"No such accessible method: \" + methodName + \"() on object: \" + cls.getName());\n        }\n        return method.invoke(object, args);\n    }\n\n    /**\n     * Invokes a {@code static} method whose parameter types match exactly the object\n     * types.\n     *\n     * <p>This uses reflection to invoke the method obtained from a call to\n     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * @param cls invoke static method on this class\n     * @param methodName get method with this name\n     * @param args use these arguments - treat {@code null} as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     */\n    public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName,\n            Object... args) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        return invokeExactStaticMethod(cls, methodName, args, ClassUtils.toClass(args));\n    }\n\n    /**\n     * Invokes a {@code static} method whose parameter types match exactly the parameter\n     * types given.\n     *\n     * <p>This uses reflection to invoke the method obtained from a call to\n     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * @param cls invoke static method on this class\n     * @param methodName get method with this name\n     * @param args use these arguments - treat {@code null} as empty array\n     * @param parameterTypes match these parameters - treat {@code null} as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     */\n    public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName,\n            Object[] args, Class<?>[] parameterTypes)\n            throws NoSuchMethodException, IllegalAccessException,\n            InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n        final Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n        if (method == null) {\n            throw new NoSuchMethodException(\"No such accessible method: \"\n                    + methodName + \"() on class: \" + cls.getName());\n        }\n        return method.invoke(null, args);\n    }\n\n    /**\n     * Invokes a named method without parameters.\n     *\n     * <p>This is a convenient wrapper for\n     * {@link #invokeMethod(Object object, boolean forceAccess, String methodName, Object[] args, Class[] parameterTypes)}.\n     * </p>\n     *\n     * @param object invoke method on this object\n     * @param forceAccess force access to invoke method even if it's not accessible\n     * @param methodName get method with this name\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     *\n     * @since 3.5\n     */\n    public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName)\n            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n        return invokeMethod(object, forceAccess, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n    }\n\n    /**\n     * Invokes a named method whose parameter type matches the object type.\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} object\n     * would match a {@code boolean} primitive.</p>\n     *\n     * <p>This is a convenient wrapper for\n     * {@link #invokeMethod(Object object, boolean forceAccess, String methodName, Object[] args, Class[] parameterTypes)}.\n     * </p>\n     *\n     * @param object invoke method on this object\n     * @param forceAccess force access to invoke method even if it's not accessible\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     * @throws NullPointerException if the object or method name are {@code null}\n     * @since 3.5\n     */\n    public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName,\n            Object... args) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        return invokeMethod(object, forceAccess, methodName, args, ClassUtils.toClass(args));\n    }\n\n    /**\n     * Invokes a named method whose parameter type matches the object type.\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} object\n     * would match a {@code boolean} primitive.</p>\n     *\n     * @param object invoke method on this object\n     * @param forceAccess force access to invoke method even if it's not accessible\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @param parameterTypes match these parameters - treat null as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     * @throws NullPointerException if the object or method name are {@code null}\n     * @since 3.5\n     */\n    public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName, Object[] args, Class<?>[] parameterTypes)\n        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n        Objects.requireNonNull(object, \"object\");\n        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n        args = ArrayUtils.nullToEmpty(args);\n\n        final String messagePrefix;\n        final Method method;\n\n        final Class<? extends Object> cls = object.getClass();\n        if (forceAccess) {\n            messagePrefix = \"No such method: \";\n            method = getMatchingMethod(cls, methodName, parameterTypes);\n            if (method != null && !method.isAccessible()) {\n                method.setAccessible(true);\n            }\n        } else {\n            messagePrefix = \"No such accessible method: \";\n            method = getMatchingAccessibleMethod(cls, methodName, parameterTypes);\n        }\n\n        if (method == null) {\n            throw new NoSuchMethodException(messagePrefix + methodName + \"() on object: \" + cls.getName());\n        }\n        args = toVarArgs(method, args);\n\n        return method.invoke(object, args);\n    }\n\n    /**\n     * Invokes a named method without parameters.\n     *\n     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * <p>This is a convenient wrapper for\n     * {@link #invokeMethod(Object object, String methodName, Object[] args, Class[] parameterTypes)}.\n     * </p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     *\n     *  @since 3.4\n     */\n    public static Object invokeMethod(final Object object, final String methodName) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        return invokeMethod(object, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n    }\n\n    /**\n     * Invokes a named method whose parameter type matches the object type.\n     *\n     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} object\n     * would match a {@code boolean} primitive.</p>\n     *\n     * <p>This is a convenient wrapper for\n     * {@link #invokeMethod(Object object, String methodName, Object[] args, Class[] parameterTypes)}.\n     * </p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     * @throws NullPointerException if the object or method name are {@code null}\n     */\n    public static Object invokeMethod(final Object object, final String methodName,\n            Object... args) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        return invokeMethod(object, methodName, args, ClassUtils.toClass(args));\n    }\n\n    /**\n     * Invokes a named method whose parameter type matches the object type.\n     *\n     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} object\n     * would match a {@code boolean} primitive.</p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @param parameterTypes match these parameters - treat null as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     */\n    public static Object invokeMethod(final Object object, final String methodName,\n            final Object[] args, final Class<?>[] parameterTypes)\n            throws NoSuchMethodException, IllegalAccessException,\n            InvocationTargetException {\n        return invokeMethod(object, false, methodName, args, parameterTypes);\n    }\n\n    /**\n     * Invokes a named {@code static} method whose parameter type matches the object type.\n     *\n     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} class\n     * would match a {@code boolean} primitive.</p>\n     *\n     * <p>This is a convenient wrapper for\n     * {@link #invokeStaticMethod(Class, String, Object[], Class[])}.\n     * </p>\n     *\n     * @param cls invoke static method on this class\n     * @param methodName get method with this name\n     * @param args use these arguments - treat {@code null} as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     */\n    public static Object invokeStaticMethod(final Class<?> cls, final String methodName,\n            Object... args) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        return invokeStaticMethod(cls, methodName, args, ClassUtils.toClass(args));\n    }\n\n    /**\n     * Invokes a named {@code static} method whose parameter type matches the object type.\n     *\n     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} class\n     * would match a {@code boolean} primitive.</p>\n     *\n     * @param cls invoke static method on this class\n     * @param methodName get method with this name\n     * @param args use these arguments - treat {@code null} as empty array\n     * @param parameterTypes match these parameters - treat {@code null} as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     */\n    public static Object invokeStaticMethod(final Class<?> cls, final String methodName,\n            Object[] args, Class<?>[] parameterTypes)\n            throws NoSuchMethodException, IllegalAccessException,\n            InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n        final Method method = getMatchingAccessibleMethod(cls, methodName,\n                parameterTypes);\n        if (method == null) {\n            throw new NoSuchMethodException(\"No such accessible method: \"\n                    + methodName + \"() on class: \" + cls.getName());\n        }\n        args = toVarArgs(method, args);\n        return method.invoke(null, args);\n    }\n\n    private static Object[] toVarArgs(final Method method, Object[] args) {\n        if (method.isVarArgs()) {\n            final Class<?>[] methodParameterTypes = method.getParameterTypes();\n            args = getVarArgs(args, methodParameterTypes);\n        }\n        return args;\n    }\n\n    /**\n     * {@link MethodUtils} instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as\n     * {@code MethodUtils.getAccessibleMethod(method)}.\n     *\n     * <p>This constructor is {@code public} to permit tools that require a JavaBean\n     * instance to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public MethodUtils() {\n        // empty\n    }\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Gets a Method or null if a {@link Class#getMethod(String, Class...) documented} exception is thrown.\n     *\n     * @param cls Receiver for {@link Class#getMethod(String, Class...)}.\n     * @param name the name of the method\n     * @param parameterTypes the list of parameters\n     * @return a Method or null.\n     * @since 3.15.0\n     * @see Class#getMethod(String, Class...)\n     */\n    public static Method getMethodObject(final Class<?> cls, final String name, final Class<?>... parameterTypes) {\n        try {\n            return cls.getMethod(name, parameterTypes);\n        } catch (final NoSuchMethodException | SecurityException e) {\n            return null;\n        }\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * Gets an accessible method (that is, one that can be invoked via\n     * reflection) by scanning through the superclasses. If no such method\n     * can be found, return {@code null}.\n     *\n     * @param cls Class to be checked\n     * @param methodName Method name of the method we wish to call\n     * @param parameterTypes The parameter type signatures\n     * @return the accessible method or {@code null} if not found\n     */\n    private static Method getAccessibleMethodFromSuperclass(final Class<?> cls,\n            final String methodName, final Class<?>... parameterTypes) {\n        Class<?> parentClass = cls.getSuperclass();\n        while (parentClass != null) {\n            if (ClassUtils.isPublic(parentClass)) {\n                return getMethodObject(parentClass, methodName, parameterTypes);\n            }\n            parentClass = parentClass.getSuperclass();\n        }\n        return null;\n    }\n/**\n     * Gets a Method or null if a {@link Class#getMethod(String, Class...) documented} exception is thrown.\n     *\n     * @param cls Receiver for {@link Class#getMethod(String, Class...)}.\n     * @param name the name of the method\n     * @param parameterTypes the list of parameters\n     * @return a Method or null.\n     * @since 3.15.0\n     * @see Class#getMethod(String, Class...)\n     */\n    public static Method getMethodObject(final Class<?> cls, final String name, final Class<?>... parameterTypes) {\n        try {\n            return cls.getMethod(name, parameterTypes);\n        } catch (final NoSuchMethodException | SecurityException e) {\n            return null;\n        }\n    }",
        "diffSourceCode": "-  191:                 if (method != null) {\n-  192:                     return method;\n-  193:                 }\n-  194:             }\n-  195:         }\n-  196:         return null;\n-  197:     }\n-  198: \n-  199:     /**\n-  200:      * Gets an accessible method (that is, one that can be invoked via\n-  201:      * reflection) by scanning through the superclasses. If no such method\n-  202:      * can be found, return {@code null}.\n-  203:      *\n-  204:      * @param cls Class to be checked\n-  205:      * @param methodName Method name of the method we wish to call\n-  206:      * @param parameterTypes The parameter type signatures\n-  207:      * @return the accessible method or {@code null} if not found\n-  208:      */\n-  209:     private static Method getAccessibleMethodFromSuperclass(final Class<?> cls,\n-  210:             final String methodName, final Class<?>... parameterTypes) {\n-  211:         Class<?> parentClass = cls.getSuperclass();\n-  212:         while (parentClass != null) {\n-  213:             if (ClassUtils.isPublic(parentClass)) {\n-  214:                 try {\n-  215:                     return parentClass.getMethod(methodName, parameterTypes);\n-  216:                 } catch (final NoSuchMethodException e) {\n-  217:                     return null;\n-  218:                 }\n-  219:             }\n-  220:             parentClass = parentClass.getSuperclass();\n-  221:         }\n-  222:         return null;\n-  223:     }\n-  427:         if (bestCandidates.size() == 1 || !Objects.equals(bestCandidates.get(0).getDeclaringClass(),\n-  428:                 bestCandidates.get(1).getDeclaringClass())) {\n-  429:             return bestCandidates.get(0);\n-  430:         }\n-  431: \n-  432:         throw new IllegalStateException(\n-  433:                 String.format(\"Found multiple candidates for method %s on class %s : %s\",\n-  434:                         methodName + Stream.of(parameterTypes).map(String::valueOf).collect(Collectors.joining(\",\", \"(\", \")\")),\n-  435:                         cls.getName(),\n-  436:                         bestCandidates.stream().map(Method::toString).collect(Collectors.joining(\",\", \"[\", \"]\")))\n-  437:         );\n-  438:     }\n-  439: \n-  440:     /**\n-  441:      * Gets all class level public methods of the given class that are annotated with the given annotation.\n-  442:      * @param cls\n-  443:      *            the {@link Class} to query\n+  191:     /**\n+  192:      * Gets an accessible method (that is, one that can be invoked via\n+  193:      * reflection) by scanning through the superclasses. If no such method\n+  194:      * can be found, return {@code null}.\n+  195:      *\n+  196:      * @param cls Class to be checked\n+  197:      * @param methodName Method name of the method we wish to call\n+  198:      * @param parameterTypes The parameter type signatures\n+  199:      * @return the accessible method or {@code null} if not found\n+  200:      */\n+  201:     private static Method getAccessibleMethodFromSuperclass(final Class<?> cls,\n+  202:             final String methodName, final Class<?>... parameterTypes) {\n+  203:         Class<?> parentClass = cls.getSuperclass();\n+  204:         while (parentClass != null) {\n+  205:             if (ClassUtils.isPublic(parentClass)) {\n+  206:                 return getMethodObject(parentClass, methodName, parameterTypes);\n+  207:             }\n+  208:             parentClass = parentClass.getSuperclass();\n+  209:         }\n+  210:         return null;\n+  211:     }\n+  212: \n+  213:     /**\n+  214:      * Gets a combination of {@link ClassUtils#getAllSuperclasses(Class)} and\n+  215:      * {@link ClassUtils#getAllInterfaces(Class)}, one from superclasses, one\n+  216:      * from interfaces, and so on in a breadth first way.\n+  217:      *\n+  218:      * @param cls  the class to look up, may be {@code null}\n+  219:      * @return the combined {@link List} of superclasses and interfaces in order\n+  220:      * going up from this one\n+  221:      *  {@code null} if null input\n+  222:      */\n+  223:     private static List<Class<?>> getAllSuperclassesAndInterfaces(final Class<?> cls) {\n+  427:     /**\n+  428:      * Gets a Method or null if a {@link Class#getMethod(String, Class...) documented} exception is thrown.\n+  429:      *\n+  430:      * @param cls Receiver for {@link Class#getMethod(String, Class...)}.\n+  431:      * @param name the name of the method\n+  432:      * @param parameterTypes the list of parameters\n+  433:      * @return a Method or null.\n+  434:      * @since 3.15.0\n+  435:      * @see Class#getMethod(String, Class...)\n+  436:      */\n+  437:     public static Method getMethodObject(final Class<?> cls, final String name, final Class<?>... parameterTypes) {\n+  438:         try {\n+  439:             return cls.getMethod(name, parameterTypes);\n+  440:         } catch (final NoSuchMethodException | SecurityException e) {\n+  441:             return null;\n+  442:         }\n+  443:     }\n",
        "uniqueId": "c290aebffa83b382a24d74117755904017f82b7c_199_223_427_443_191_211",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 11,
                "covered": 11
            },
            "BRANCH": {
                "missed": 2,
                "covered": 2
            },
            "LINE": {
                "missed": 3,
                "covered": 5
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Gets an accessible method (that is, one that can be invoked via\n * reflection) with given name and parameters. If no such method\n * can be found, return {@code null}.\n * This is just a convenience wrapper for\n * {@link #getAccessibleMethod(Method)}.\n *\n * @param cls get method from this class\n * @param methodName get method with this name\n * @param parameterTypes with these parameters types\n * @return The accessible method\n */\npublic static Method getAccessibleMethod(final Class<?> cls, final String methodName,\n        final Class<?>... parameterTypes) {\n    try {\n        return getAccessibleMethod(cls.getMethod(methodName, parameterTypes));\n    } catch (final NoSuchMethodException e) {\n        return null;\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Gets an accessible method (that is, one that can be invoked via\n     * reflection) by scanning through the superclasses. If no such method\n     * can be found, return {@code null}.\n     *\n     * @param cls Class to be checked\n     * @param methodName Method name of the method we wish to call\n     * @param parameterTypes The parameter type signatures\n     * @return the accessible method or {@code null} if not found\n     */\n    private static Method getAccessibleMethodFromSuperclass(final Class<?> cls,\n            final String methodName, final Class<?>... parameterTypes) {\n        Class<?> parentClass = cls.getSuperclass();\n        while (parentClass != null) {\n            if (ClassUtils.isPublic(parentClass)) {\n                try {\n                    return parentClass.getMethod(methodName, parameterTypes);\n                } catch (final NoSuchMethodException e) {\n                    return null;\n                }\n            }\n            parentClass = parentClass.getSuperclass();\n        }\n        return null;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.reflect;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.ClassUtils;\nimport org.apache.commons.lang3.ClassUtils.Interfaces;\nimport org.apache.commons.lang3.Validate;\n\n/**\n * Utility reflection methods focused on {@link Method}s, originally from Commons BeanUtils.\n * Differences from the BeanUtils version may be noted, especially where similar functionality\n * already existed within Lang.\n *\n * <h2>Known Limitations</h2>\n * <h3>Accessing Public Methods In A Default Access Superclass</h3>\n * <p>There is an issue when invoking {@code public} methods contained in a default access superclass on JREs prior to 1.4.\n * Reflection locates these methods fine and correctly assigns them as {@code public}.\n * However, an {@link IllegalAccessException} is thrown if the method is invoked.</p>\n *\n * <p>{@link MethodUtils} contains a workaround for this situation.\n * It will attempt to call {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} on this method.\n * If this call succeeds, then the method can be invoked as normal.\n * This call will only succeed when the application has sufficient security privileges.\n * If this call fails then the method may fail.</p>\n *\n * @since 2.5\n */\npublic class MethodUtils {\n\n    private static final Comparator<Method> METHOD_BY_SIGNATURE = Comparator.comparing(Method::toString);\n\n    /**\n     * Returns the aggregate number of inheritance hops between assignable argument class types.  Returns -1\n     * if the arguments aren't assignable.  Fills a specific purpose for getMatchingMethod and is not generalized.\n     *\n     * @param fromClassArray the Class array to calculate the distance from.\n     * @param toClassArray the Class array to calculate the distance to.\n     * @return the aggregate number of inheritance hops between assignable argument class types.\n     */\n    private static int distance(final Class<?>[] fromClassArray, final Class<?>[] toClassArray) {\n        int answer = 0;\n\n        if (!ClassUtils.isAssignable(fromClassArray, toClassArray, true)) {\n            return -1;\n        }\n        for (int offset = 0; offset < fromClassArray.length; offset++) {\n            // Note InheritanceUtils.distance() uses different scoring system.\n            final Class<?> aClass = fromClassArray[offset];\n            final Class<?> toClass = toClassArray[offset];\n            if (aClass == null || aClass.equals(toClass)) {\n                continue;\n            }\n            if (ClassUtils.isAssignable(aClass, toClass, true)\n                    && !ClassUtils.isAssignable(aClass, toClass, false)) {\n                answer++;\n            } else {\n                answer += 2;\n            }\n        }\n\n        return answer;\n    }\n\n    /**\n     * Gets an accessible method (that is, one that can be invoked via\n     * reflection) with given name and parameters. If no such method\n     * can be found, return {@code null}.\n     * This is just a convenience wrapper for\n     * {@link #getAccessibleMethod(Method)}.\n     *\n     * @param cls get method from this class\n     * @param methodName get method with this name\n     * @param parameterTypes with these parameters types\n     * @return The accessible method\n     */\n    public static Method getAccessibleMethod(final Class<?> cls, final String methodName,\n        final Class<?>... parameterTypes) {\n        try {\n            return getAccessibleMethod(cls.getMethod(methodName, parameterTypes));\n        } catch (final NoSuchMethodException e) {\n            return null;\n        }\n    }\n\n    /**\n     * Gets an accessible method (that is, one that can be invoked via\n     * reflection) that implements the specified Method. If no such method\n     * can be found, return {@code null}.\n     *\n     * @param method The method that we wish to call\n     * @return The accessible method\n     */\n    public static Method getAccessibleMethod(Method method) {\n        if (!MemberUtils.isAccessible(method)) {\n            return null;\n        }\n        // If the declaring class is public, we are done\n        final Class<?> cls = method.getDeclaringClass();\n        if (ClassUtils.isPublic(cls)) {\n            return method;\n        }\n        final String methodName = method.getName();\n        final Class<?>[] parameterTypes = method.getParameterTypes();\n\n        // Check the implemented interfaces and subinterfaces\n        method = getAccessibleMethodFromInterfaceNest(cls, methodName,\n                parameterTypes);\n\n        // Check the superclass chain\n        if (method == null) {\n            method = getAccessibleMethodFromSuperclass(cls, methodName,\n                    parameterTypes);\n        }\n        return method;\n    }\n\n    /**\n     * Gets an accessible method (that is, one that can be invoked via\n     * reflection) that implements the specified method, by scanning through\n     * all implemented interfaces and subinterfaces. If no such method\n     * can be found, return {@code null}.\n     *\n     * <p>There isn't any good reason why this method must be {@code private}.\n     * It is because there doesn't seem any reason why other classes should\n     * call this rather than the higher level methods.</p>\n     *\n     * @param cls Parent class for the interfaces to be checked\n     * @param methodName Method name of the method we wish to call\n     * @param parameterTypes The parameter type signatures\n     * @return the accessible method or {@code null} if not found\n     */\n    private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls,\n            final String methodName, final Class<?>... parameterTypes) {\n        // Search up the superclass chain\n        for (; cls != null; cls = cls.getSuperclass()) {\n\n            // Check the implemented interfaces of the parent class\n            final Class<?>[] interfaces = cls.getInterfaces();\n            for (final Class<?> anInterface : interfaces) {\n                // Is this interface public?\n                if (!ClassUtils.isPublic(anInterface)) {\n                    continue;\n                }\n                // Does the method exist on this interface?\n                try {\n                    return anInterface.getDeclaredMethod(methodName,\n                            parameterTypes);\n                } catch (final NoSuchMethodException ignored) {\n                    /*\n                     * Swallow, if no method is found after the loop then this\n                     * method returns null.\n                     */\n                }\n                // Recursively check our parent interfaces\n                final Method method = getAccessibleMethodFromInterfaceNest(anInterface,\n                        methodName, parameterTypes);\n                if (method != null) {\n                    return method;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Gets an accessible method (that is, one that can be invoked via\n     * reflection) by scanning through the superclasses. If no such method\n     * can be found, return {@code null}.\n     *\n     * @param cls Class to be checked\n     * @param methodName Method name of the method we wish to call\n     * @param parameterTypes The parameter type signatures\n     * @return the accessible method or {@code null} if not found\n     */\n    private static Method getAccessibleMethodFromSuperclass(final Class<?> cls,\n            final String methodName, final Class<?>... parameterTypes) {\n        Class<?> parentClass = cls.getSuperclass();\n        while (parentClass != null) {\n            if (ClassUtils.isPublic(parentClass)) {\n                try {\n                    return parentClass.getMethod(methodName, parameterTypes);\n                } catch (final NoSuchMethodException e) {\n                    return null;\n                }\n            }\n            parentClass = parentClass.getSuperclass();\n        }\n        return null;\n    }\n\n    /**\n     * Gets a combination of {@link ClassUtils#getAllSuperclasses(Class)} and\n     * {@link ClassUtils#getAllInterfaces(Class)}, one from superclasses, one\n     * from interfaces, and so on in a breadth first way.\n     *\n     * @param cls  the class to look up, may be {@code null}\n     * @return the combined {@link List} of superclasses and interfaces in order\n     * going up from this one\n     *  {@code null} if null input\n     */\n    private static List<Class<?>> getAllSuperclassesAndInterfaces(final Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n\n        final List<Class<?>> allSuperClassesAndInterfaces = new ArrayList<>();\n        final List<Class<?>> allSuperclasses = ClassUtils.getAllSuperclasses(cls);\n        int superClassIndex = 0;\n        final List<Class<?>> allInterfaces = ClassUtils.getAllInterfaces(cls);\n        int interfaceIndex = 0;\n        while (interfaceIndex < allInterfaces.size() ||\n                superClassIndex < allSuperclasses.size()) {\n            final Class<?> acls;\n            if (interfaceIndex >= allInterfaces.size()) {\n                acls = allSuperclasses.get(superClassIndex++);\n            } else if (superClassIndex >= allSuperclasses.size() || !(superClassIndex < interfaceIndex)) {\n                acls = allInterfaces.get(interfaceIndex++);\n            } else {\n                acls = allSuperclasses.get(superClassIndex++);\n            }\n            allSuperClassesAndInterfaces.add(acls);\n        }\n        return allSuperClassesAndInterfaces;\n    }\n\n    /**\n     * Gets the annotation object with the given annotation type that is present on the given method\n     * or optionally on any equivalent method in super classes and interfaces. Returns null if the annotation\n     * type was not present.\n     *\n     * <p>Stops searching for an annotation once the first annotation of the specified type has been\n     * found. Additional annotations of the specified type will be silently ignored.</p>\n     * @param <A>\n     *            the annotation type\n     * @param method\n     *            the {@link Method} to query\n     * @param annotationCls\n     *            the {@link Annotation} to check if is present on the method\n     * @param searchSupers\n     *            determines if a lookup in the entire inheritance hierarchy of the given class is performed\n     *            if the annotation was not directly present\n     * @param ignoreAccess\n     *            determines if underlying method has to be accessible\n     * @return the first matching annotation, or {@code null} if not found\n     * @throws NullPointerException if either the method or annotation class is {@code null}\n     * @since 3.6\n     */\n    public static <A extends Annotation> A getAnnotation(final Method method, final Class<A> annotationCls,\n                                                         final boolean searchSupers, final boolean ignoreAccess) {\n\n        Objects.requireNonNull(method, \"method\");\n        Objects.requireNonNull(annotationCls, \"annotationCls\");\n        if (!ignoreAccess && !MemberUtils.isAccessible(method)) {\n            return null;\n        }\n\n        A annotation = method.getAnnotation(annotationCls);\n\n        if (annotation == null && searchSupers) {\n            final Class<?> mcls = method.getDeclaringClass();\n            final List<Class<?>> classes = getAllSuperclassesAndInterfaces(mcls);\n            for (final Class<?> acls : classes) {\n                final Method equivalentMethod = ignoreAccess ? getMatchingMethod(acls, method.getName(), method.getParameterTypes())\n                        : getMatchingAccessibleMethod(acls, method.getName(), method.getParameterTypes());\n                if (equivalentMethod != null) {\n                    annotation = equivalentMethod.getAnnotation(annotationCls);\n                    if (annotation != null) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return annotation;\n    }\n\n    /**\n     * Gets an accessible method that matches the given name and has compatible parameters.\n     * Compatible parameters mean that every method parameter is assignable from\n     * the given parameters.\n     * In other words, it finds a method with the given name\n     * that will take the parameters given.\n     *\n     * <p>This method is used by\n     * {@link\n     * #invokeMethod(Object object, String methodName, Object[] args, Class[] parameterTypes)}.\n     * </p>\n     *\n     * <p>This method can match primitive parameter by passing in wrapper classes.\n     * For example, a {@link Boolean} will match a primitive {@code boolean}\n     * parameter.\n     * </p>\n     *\n     * @param cls find method in this class\n     * @param methodName find method with this name\n     * @param parameterTypes find method with most compatible parameters\n     * @return The accessible method\n     */\n    public static Method getMatchingAccessibleMethod(final Class<?> cls,\n        final String methodName, final Class<?>... parameterTypes) {\n        try {\n            return MemberUtils.setAccessibleWorkaround(cls.getMethod(methodName, parameterTypes));\n        } catch (final NoSuchMethodException ignored) {\n            // Swallow the exception\n        }\n        // search through all methods\n        final Method[] methods = cls.getMethods();\n        final List<Method> matchingMethods = Stream.of(methods)\n            .filter(method -> method.getName().equals(methodName) && MemberUtils.isMatchingMethod(method, parameterTypes)).collect(Collectors.toList());\n\n        // Sort methods by signature to force deterministic result\n        matchingMethods.sort(METHOD_BY_SIGNATURE);\n\n        Method bestMatch = null;\n        for (final Method method : matchingMethods) {\n            // get accessible version of method\n            final Method accessibleMethod = getAccessibleMethod(method);\n            if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareMethodFit(accessibleMethod, bestMatch, parameterTypes) < 0)) {\n                bestMatch = accessibleMethod;\n            }\n        }\n        if (bestMatch != null) {\n            MemberUtils.setAccessibleWorkaround(bestMatch);\n        }\n\n        if (bestMatch != null && bestMatch.isVarArgs() && bestMatch.getParameterTypes().length > 0 && parameterTypes.length > 0) {\n            final Class<?>[] methodParameterTypes = bestMatch.getParameterTypes();\n            final Class<?> methodParameterComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType();\n            final String methodParameterComponentTypeName = ClassUtils.primitiveToWrapper(methodParameterComponentType).getName();\n\n            final Class<?> lastParameterType = parameterTypes[parameterTypes.length - 1];\n            final String parameterTypeName = lastParameterType == null ? null : lastParameterType.getName();\n            final String parameterTypeSuperClassName = lastParameterType == null ? null : lastParameterType.getSuperclass().getName();\n\n            if (parameterTypeName != null && parameterTypeSuperClassName != null && !methodParameterComponentTypeName.equals(parameterTypeName)\n                && !methodParameterComponentTypeName.equals(parameterTypeSuperClassName)) {\n                return null;\n            }\n        }\n\n        return bestMatch;\n    }\n\n    /**\n     * Gets a method whether or not it's accessible. If no such method\n     * can be found, return {@code null}.\n     *\n     * @param cls The class that will be subjected to the method search\n     * @param methodName The method that we wish to call\n     * @param parameterTypes Argument class types\n     * @throws IllegalStateException if there is no unique result\n     * @throws NullPointerException if the class is {@code null}\n     * @return The method\n     *\n     * @since 3.5\n     */\n    public static Method getMatchingMethod(final Class<?> cls, final String methodName,\n            final Class<?>... parameterTypes) {\n        Objects.requireNonNull(cls, \"cls\");\n        Validate.notEmpty(methodName, \"methodName\");\n\n        final List<Method> methods = Stream.of(cls.getDeclaredMethods())\n                .filter(method -> method.getName().equals(methodName))\n                .collect(Collectors.toList());\n\n        ClassUtils.getAllSuperclasses(cls).stream()\n                .map(Class::getDeclaredMethods)\n                .flatMap(Stream::of)\n                .filter(method -> method.getName().equals(methodName))\n                .forEach(methods::add);\n\n        for (final Method method : methods) {\n            if (Arrays.deepEquals(method.getParameterTypes(), parameterTypes)) {\n                return method;\n            }\n        }\n\n        final TreeMap<Integer, List<Method>> candidates = new TreeMap<>();\n\n        methods.stream()\n                .filter(method -> ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true))\n                .forEach(method -> {\n                    final int distance = distance(parameterTypes, method.getParameterTypes());\n                    final List<Method> candidatesAtDistance = candidates.computeIfAbsent(distance, k -> new ArrayList<>());\n                    candidatesAtDistance.add(method);\n                });\n\n        if (candidates.isEmpty()) {\n            return null;\n        }\n\n        final List<Method> bestCandidates = candidates.values().iterator().next();\n        if (bestCandidates.size() == 1 || !Objects.equals(bestCandidates.get(0).getDeclaringClass(),\n                bestCandidates.get(1).getDeclaringClass())) {\n            return bestCandidates.get(0);\n        }\n\n        throw new IllegalStateException(\n                String.format(\"Found multiple candidates for method %s on class %s : %s\",\n                        methodName + Stream.of(parameterTypes).map(String::valueOf).collect(Collectors.joining(\",\", \"(\", \")\")),\n                        cls.getName(),\n                        bestCandidates.stream().map(Method::toString).collect(Collectors.joining(\",\", \"[\", \"]\")))\n        );\n    }\n\n    /**\n     * Gets all class level public methods of the given class that are annotated with the given annotation.\n     * @param cls\n     *            the {@link Class} to query\n     * @param annotationCls\n     *            the {@link Annotation} that must be present on a method to be matched\n     * @return a list of Methods (possibly empty).\n     * @throws NullPointerException\n     *            if the class or annotation are {@code null}\n     * @since 3.4\n     */\n    public static List<Method> getMethodsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls) {\n        return getMethodsListWithAnnotation(cls, annotationCls, false, false);\n    }\n\n    /**\n     * Gets all methods of the given class that are annotated with the given annotation.\n     *\n     * @param cls\n     *            the {@link Class} to query\n     * @param annotationCls\n     *            the {@link Annotation} that must be present on a method to be matched\n     * @param searchSupers\n     *            determines if a lookup in the entire inheritance hierarchy of the given class should be performed\n     * @param ignoreAccess\n     *            determines if non-public methods should be considered\n     * @return a list of Methods (possibly empty).\n     * @throws NullPointerException if either the class or annotation class is {@code null}\n     * @since 3.6\n     */\n    public static List<Method> getMethodsListWithAnnotation(final Class<?> cls,\n                                                            final Class<? extends Annotation> annotationCls,\n                                                            final boolean searchSupers, final boolean ignoreAccess) {\n\n        Objects.requireNonNull(cls, \"cls\");\n        Objects.requireNonNull(annotationCls, \"annotationCls\");\n        final List<Class<?>> classes = searchSupers ? getAllSuperclassesAndInterfaces(cls) : new ArrayList<>();\n        classes.add(0, cls);\n        final List<Method> annotatedMethods = new ArrayList<>();\n        classes.forEach(acls -> {\n            final Method[] methods = ignoreAccess ? acls.getDeclaredMethods() : acls.getMethods();\n            Stream.of(methods).filter(method -> method.isAnnotationPresent(annotationCls)).forEachOrdered(annotatedMethods::add);\n        });\n        return annotatedMethods;\n    }\n\n    /**\n     * Gets all class level public methods of the given class that are annotated with the given annotation.\n     *\n     * @param cls\n     *            the {@link Class} to query\n     * @param annotationCls\n     *            the {@link java.lang.annotation.Annotation} that must be present on a method to be matched\n     * @return an array of Methods (possibly empty).\n     * @throws NullPointerException if the class or annotation are {@code null}\n     * @since 3.4\n     */\n    public static Method[] getMethodsWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls) {\n        return getMethodsWithAnnotation(cls, annotationCls, false, false);\n    }\n\n    /**\n     * Gets all methods of the given class that are annotated with the given annotation.\n     *\n     * @param cls\n     *            the {@link Class} to query\n     * @param annotationCls\n     *            the {@link java.lang.annotation.Annotation} that must be present on a method to be matched\n     * @param searchSupers\n     *            determines if a lookup in the entire inheritance hierarchy of the given class should be performed\n     * @param ignoreAccess\n     *            determines if non-public methods should be considered\n     * @return an array of Methods (possibly empty).\n     * @throws NullPointerException if the class or annotation are {@code null}\n     * @since 3.6\n     */\n    public static Method[] getMethodsWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls,\n        final boolean searchSupers, final boolean ignoreAccess) {\n        return getMethodsListWithAnnotation(cls, annotationCls, searchSupers, ignoreAccess).toArray(ArrayUtils.EMPTY_METHOD_ARRAY);\n    }\n\n    /**\n     * Gets the hierarchy of overridden methods down to {@code result} respecting generics.\n     *\n     * @param method lowest to consider\n     * @param interfacesBehavior whether to search interfaces, {@code null} {@code implies} false\n     * @return Set&lt;Method&gt; in ascending order from sub- to superclass\n     * @throws NullPointerException if the specified method is {@code null}\n     * @since 3.2\n     */\n    public static Set<Method> getOverrideHierarchy(final Method method, final Interfaces interfacesBehavior) {\n        Objects.requireNonNull(method, \"method\");\n        final Set<Method> result = new LinkedHashSet<>();\n        result.add(method);\n\n        final Class<?>[] parameterTypes = method.getParameterTypes();\n\n        final Class<?> declaringClass = method.getDeclaringClass();\n\n        final Iterator<Class<?>> hierarchy = ClassUtils.hierarchy(declaringClass, interfacesBehavior).iterator();\n        //skip the declaring class :P\n        hierarchy.next();\n        hierarchyTraversal: while (hierarchy.hasNext()) {\n            final Class<?> c = hierarchy.next();\n            final Method m = getMatchingAccessibleMethod(c, method.getName(), parameterTypes);\n            if (m == null) {\n                continue;\n            }\n            if (Arrays.equals(m.getParameterTypes(), parameterTypes)) {\n                // matches without generics\n                result.add(m);\n                continue;\n            }\n            // necessary to get arguments every time in the case that we are including interfaces\n            final Map<TypeVariable<?>, Type> typeArguments = TypeUtils.getTypeArguments(declaringClass, m.getDeclaringClass());\n            for (int i = 0; i < parameterTypes.length; i++) {\n                final Type childType = TypeUtils.unrollVariables(typeArguments, method.getGenericParameterTypes()[i]);\n                final Type parentType = TypeUtils.unrollVariables(typeArguments, m.getGenericParameterTypes()[i]);\n                if (!TypeUtils.equals(childType, parentType)) {\n                    continue hierarchyTraversal;\n                }\n            }\n            result.add(m);\n        }\n        return result;\n    }\n\n    /**\n     * Gets an array of arguments in the canonical form, given an arguments array passed to a varargs method,\n     * for example an array with the declared number of parameters, and whose last parameter is an array of the varargs type.\n     *\n     * @param args the array of arguments passed to the varags method\n     * @param methodParameterTypes the declared array of method parameter types\n     * @return an array of the variadic arguments passed to the method\n     * @since 3.5\n     */\n    static Object[] getVarArgs(final Object[] args, final Class<?>[] methodParameterTypes) {\n        if (args.length == methodParameterTypes.length\n                && (args[args.length - 1] == null || args[args.length - 1].getClass().equals(methodParameterTypes[methodParameterTypes.length - 1]))) {\n            // The args array is already in the canonical form for the method.\n            return args;\n        }\n\n        // Construct a new array matching the method's declared parameter types.\n        // Copy the normal (non-varargs) parameters\n        final Object[] newArgs = ArrayUtils.arraycopy(args, 0, 0, methodParameterTypes.length - 1, () -> new Object[methodParameterTypes.length]);\n\n        // Construct a new array for the variadic parameters\n        final Class<?> varArgComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType();\n        final int varArgLength = args.length - methodParameterTypes.length + 1;\n\n        // Copy the variadic arguments into the varargs array.\n        Object varArgsArray = ArrayUtils.arraycopy(args, methodParameterTypes.length - 1, 0, varArgLength,\n                s -> Array.newInstance(ClassUtils.primitiveToWrapper(varArgComponentType), varArgLength));\n\n        if (varArgComponentType.isPrimitive()) {\n            // unbox from wrapper type to primitive type\n            varArgsArray = ArrayUtils.toPrimitive(varArgsArray);\n        }\n\n        // Store the varargs array in the last position of the array to return\n        newArgs[methodParameterTypes.length - 1] = varArgsArray;\n\n        // Return the canonical varargs array.\n        return newArgs;\n    }\n\n    /**\n     * Invokes a method whose parameter types match exactly the object\n     * types.\n     *\n     * <p>This uses reflection to invoke the method obtained from a call to\n     * {@link #getAccessibleMethod}(Class, String, Class[])}.</p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     *\n     * @since 3.4\n     */\n    public static Object invokeExactMethod(final Object object, final String methodName) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        return invokeExactMethod(object, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n    }\n\n    /**\n     * Invokes a method with no parameters.\n     *\n     * <p>This uses reflection to invoke the method obtained from a call to\n     * {@link #getAccessibleMethod}(Class, String, Class[])}.</p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     * @throws NullPointerException if the object or method name are {@code null}\n     */\n    public static Object invokeExactMethod(final Object object, final String methodName,\n            Object... args) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        return invokeExactMethod(object, methodName, args, ClassUtils.toClass(args));\n    }\n\n    /**\n     * Invokes a method whose parameter types match exactly the parameter\n     * types given.\n     *\n     * <p>This uses reflection to invoke the method obtained from a call to\n     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @param parameterTypes match these parameters - treat {@code null} as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     * @throws NullPointerException if the object or method name are {@code null}\n     */\n    public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes)\n        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n        Objects.requireNonNull(object, \"object\");\n        args = ArrayUtils.nullToEmpty(args);\n        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n        final Class<?> cls = object.getClass();\n        final Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n        if (method == null) {\n            throw new NoSuchMethodException(\"No such accessible method: \" + methodName + \"() on object: \" + cls.getName());\n        }\n        return method.invoke(object, args);\n    }\n\n    /**\n     * Invokes a {@code static} method whose parameter types match exactly the object\n     * types.\n     *\n     * <p>This uses reflection to invoke the method obtained from a call to\n     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * @param cls invoke static method on this class\n     * @param methodName get method with this name\n     * @param args use these arguments - treat {@code null} as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     */\n    public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName,\n            Object... args) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        return invokeExactStaticMethod(cls, methodName, args, ClassUtils.toClass(args));\n    }\n\n    /**\n     * Invokes a {@code static} method whose parameter types match exactly the parameter\n     * types given.\n     *\n     * <p>This uses reflection to invoke the method obtained from a call to\n     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * @param cls invoke static method on this class\n     * @param methodName get method with this name\n     * @param args use these arguments - treat {@code null} as empty array\n     * @param parameterTypes match these parameters - treat {@code null} as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     */\n    public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName,\n            Object[] args, Class<?>[] parameterTypes)\n            throws NoSuchMethodException, IllegalAccessException,\n            InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n        final Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n        if (method == null) {\n            throw new NoSuchMethodException(\"No such accessible method: \"\n                    + methodName + \"() on class: \" + cls.getName());\n        }\n        return method.invoke(null, args);\n    }\n\n    /**\n     * Invokes a named method without parameters.\n     *\n     * <p>This is a convenient wrapper for\n     * {@link #invokeMethod(Object object, boolean forceAccess, String methodName, Object[] args, Class[] parameterTypes)}.\n     * </p>\n     *\n     * @param object invoke method on this object\n     * @param forceAccess force access to invoke method even if it's not accessible\n     * @param methodName get method with this name\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     *\n     * @since 3.5\n     */\n    public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName)\n            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n        return invokeMethod(object, forceAccess, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n    }\n\n    /**\n     * Invokes a named method whose parameter type matches the object type.\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} object\n     * would match a {@code boolean} primitive.</p>\n     *\n     * <p>This is a convenient wrapper for\n     * {@link #invokeMethod(Object object, boolean forceAccess, String methodName, Object[] args, Class[] parameterTypes)}.\n     * </p>\n     *\n     * @param object invoke method on this object\n     * @param forceAccess force access to invoke method even if it's not accessible\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     * @throws NullPointerException if the object or method name are {@code null}\n     * @since 3.5\n     */\n    public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName,\n            Object... args) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        return invokeMethod(object, forceAccess, methodName, args, ClassUtils.toClass(args));\n    }\n\n    /**\n     * Invokes a named method whose parameter type matches the object type.\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} object\n     * would match a {@code boolean} primitive.</p>\n     *\n     * @param object invoke method on this object\n     * @param forceAccess force access to invoke method even if it's not accessible\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @param parameterTypes match these parameters - treat null as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     * @throws NullPointerException if the object or method name are {@code null}\n     * @since 3.5\n     */\n    public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName, Object[] args, Class<?>[] parameterTypes)\n        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n        Objects.requireNonNull(object, \"object\");\n        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n        args = ArrayUtils.nullToEmpty(args);\n\n        final String messagePrefix;\n        final Method method;\n\n        final Class<? extends Object> cls = object.getClass();\n        if (forceAccess) {\n            messagePrefix = \"No such method: \";\n            method = getMatchingMethod(cls, methodName, parameterTypes);\n            if (method != null && !method.isAccessible()) {\n                method.setAccessible(true);\n            }\n        } else {\n            messagePrefix = \"No such accessible method: \";\n            method = getMatchingAccessibleMethod(cls, methodName, parameterTypes);\n        }\n\n        if (method == null) {\n            throw new NoSuchMethodException(messagePrefix + methodName + \"() on object: \" + cls.getName());\n        }\n        args = toVarArgs(method, args);\n\n        return method.invoke(object, args);\n    }\n\n    /**\n     * Invokes a named method without parameters.\n     *\n     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * <p>This is a convenient wrapper for\n     * {@link #invokeMethod(Object object, String methodName, Object[] args, Class[] parameterTypes)}.\n     * </p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     *\n     *  @since 3.4\n     */\n    public static Object invokeMethod(final Object object, final String methodName) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        return invokeMethod(object, methodName, ArrayUtils.EMPTY_OBJECT_ARRAY, null);\n    }\n\n    /**\n     * Invokes a named method whose parameter type matches the object type.\n     *\n     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} object\n     * would match a {@code boolean} primitive.</p>\n     *\n     * <p>This is a convenient wrapper for\n     * {@link #invokeMethod(Object object, String methodName, Object[] args, Class[] parameterTypes)}.\n     * </p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     * @throws NullPointerException if the object or method name are {@code null}\n     */\n    public static Object invokeMethod(final Object object, final String methodName,\n            Object... args) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        return invokeMethod(object, methodName, args, ClassUtils.toClass(args));\n    }\n\n    /**\n     * Invokes a named method whose parameter type matches the object type.\n     *\n     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} object\n     * would match a {@code boolean} primitive.</p>\n     *\n     * @param object invoke method on this object\n     * @param methodName get method with this name\n     * @param args use these arguments - treat null as empty array\n     * @param parameterTypes match these parameters - treat null as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n     * @throws IllegalAccessException if the requested method is not accessible via reflection\n     */\n    public static Object invokeMethod(final Object object, final String methodName,\n            final Object[] args, final Class<?>[] parameterTypes)\n            throws NoSuchMethodException, IllegalAccessException,\n            InvocationTargetException {\n        return invokeMethod(object, false, methodName, args, parameterTypes);\n    }\n\n    /**\n     * Invokes a named {@code static} method whose parameter type matches the object type.\n     *\n     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} class\n     * would match a {@code boolean} primitive.</p>\n     *\n     * <p>This is a convenient wrapper for\n     * {@link #invokeStaticMethod(Class, String, Object[], Class[])}.\n     * </p>\n     *\n     * @param cls invoke static method on this class\n     * @param methodName get method with this name\n     * @param args use these arguments - treat {@code null} as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     */\n    public static Object invokeStaticMethod(final Class<?> cls, final String methodName,\n            Object... args) throws NoSuchMethodException,\n            IllegalAccessException, InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        return invokeStaticMethod(cls, methodName, args, ClassUtils.toClass(args));\n    }\n\n    /**\n     * Invokes a named {@code static} method whose parameter type matches the object type.\n     *\n     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n     *\n     * <p>This method supports calls to methods taking primitive parameters\n     * via passing in wrapping classes. So, for example, a {@link Boolean} class\n     * would match a {@code boolean} primitive.</p>\n     *\n     * @param cls invoke static method on this class\n     * @param methodName get method with this name\n     * @param args use these arguments - treat {@code null} as empty array\n     * @param parameterTypes match these parameters - treat {@code null} as empty array\n     * @return The value returned by the invoked method\n     *\n     * @throws NoSuchMethodException if there is no such accessible method\n     * @throws InvocationTargetException wraps an exception thrown by the\n     *  method invoked\n     * @throws IllegalAccessException if the requested method is not accessible\n     *  via reflection\n     */\n    public static Object invokeStaticMethod(final Class<?> cls, final String methodName,\n            Object[] args, Class<?>[] parameterTypes)\n            throws NoSuchMethodException, IllegalAccessException,\n            InvocationTargetException {\n        args = ArrayUtils.nullToEmpty(args);\n        parameterTypes = ArrayUtils.nullToEmpty(parameterTypes);\n        final Method method = getMatchingAccessibleMethod(cls, methodName,\n                parameterTypes);\n        if (method == null) {\n            throw new NoSuchMethodException(\"No such accessible method: \"\n                    + methodName + \"() on class: \" + cls.getName());\n        }\n        args = toVarArgs(method, args);\n        return method.invoke(null, args);\n    }\n\n    private static Object[] toVarArgs(final Method method, Object[] args) {\n        if (method.isVarArgs()) {\n            final Class<?>[] methodParameterTypes = method.getParameterTypes();\n            args = getVarArgs(args, methodParameterTypes);\n        }\n        return args;\n    }\n\n    /**\n     * {@link MethodUtils} instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as\n     * {@code MethodUtils.getAccessibleMethod(method)}.\n     *\n     * <p>This constructor is {@code public} to permit tools that require a JavaBean\n     * instance to operate.</p>\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public MethodUtils() {\n        // empty\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate streamOf(value T) : Stream<T> extracted from public failableStream(value T) : FailableStream<T> in class org.apache.commons.lang3.stream.Streams",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/stream/Streams.java",
                "startLine": 582,
                "endLine": 592,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/stream/Streams.java",
                "startLine": 582,
                "endLine": 592,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/stream/Streams.java",
                "startLine": 843,
                "endLine": 845,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Shorthand for {@code Streams.failableStream(value == null ? Stream.empty() : Stream.of(value))}.\n     *\n     * @param <T> the type of stream elements.\n     * @param value the single element of the new stream, may be {@code null}.\n     * @return the new FailableStream on {@code value} or an empty stream.\n     * @since 3.15.0\n     */\n    public static <T> FailableStream<T> failableStream(final T value) {\n        return failableStream(value == null ? Stream.empty() : Stream.of(value));\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/stream/Streams.java",
        "isPureRefactoring": true,
        "commitId": "64736630706adf9e2cbb482fbfcbdc81a9dc02f7",
        "packageNameBefore": "org.apache.commons.lang3.stream",
        "classNameBefore": "org.apache.commons.lang3.stream.Streams",
        "methodNameBefore": "org.apache.commons.lang3.stream.Streams#failableStream",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.stream.Streams#of\n methodBody: public static <T> Stream<T> of(final T... values) {\nreturn values == null ? Stream.empty() : Stream.of(values);\n}\nmethodSignature: org.apache.commons.lang3.stream.Streams#failableStream\n methodBody: public static <T> FailableStream<T> failableStream(final T... values) {\nreturn failableStream(of(values));\n}",
        "classSignatureBefore": "public class Streams ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.stream.Streams#failableStream"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.stream.Streams"
        ],
        "classSignatureBeforeSet": [
            "public class Streams "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "",
                "description": "Argument replaced with return expression - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.stream;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.Spliterators.AbstractSpliterator;\nimport java.util.function.BiConsumer;\nimport java.util.function.BinaryOperator;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.function.Failable;\nimport org.apache.commons.lang3.function.FailableConsumer;\nimport org.apache.commons.lang3.function.FailableFunction;\nimport org.apache.commons.lang3.function.FailablePredicate;\n\n/**\n * Provides utility functions, and classes for working with the {@link java.util.stream} package, or more generally,\n * with Java 8 lambdas. More specifically, it attempts to address the fact that lambdas are supposed not to throw\n * Exceptions, at least not checked Exceptions, AKA instances of {@link Exception}. This enforces the use of constructs\n * like:\n *\n * <pre>\n * {@code\n * Consumer<java.lang.reflect.Method> consumer = m -> {\n *     try {\n *         m.invoke(o, args);\n *     } catch (Throwable t) {\n *         throw Failable.rethrow(t);\n *     }\n * };\n * stream.forEach(consumer);\n * }\n * </pre>\n * <p>\n * Using a {@link FailableStream}, this can be rewritten as follows:\n * </p>\n *\n * <pre>\n * {@code\n * Streams.failable(stream).forEach((m) -> m.invoke(o, args));\n * }\n * </pre>\n *\n * Obviously, the second version is much more concise and the spirit of Lambda expressions is met better than in the\n * first version.\n *\n * @see Stream\n * @see Failable\n * @since 3.11\n */\npublic class Streams {\n\n    /**\n     * A Collector type for arrays.\n     *\n     * @param <E> The array type.\n     */\n    public static class ArrayCollector<E> implements Collector<E, List<E>, E[]> {\n        private static final Set<Characteristics> characteristics = Collections.emptySet();\n        private final Class<E> elementType;\n\n        /**\n         * Constructs a new instance for the given element type.\n         *\n         * @param elementType The element type.\n         */\n        public ArrayCollector(final Class<E> elementType) {\n            this.elementType = Objects.requireNonNull(elementType, \"elementType\");\n        }\n\n        @Override\n        public BiConsumer<List<E>, E> accumulator() {\n            return List::add;\n        }\n\n        @Override\n        public Set<Characteristics> characteristics() {\n            return characteristics;\n        }\n\n        @Override\n        public BinaryOperator<List<E>> combiner() {\n            return (left, right) -> {\n                left.addAll(right);\n                return left;\n            };\n        }\n\n        @Override\n        public Function<List<E>, E[]> finisher() {\n            return list -> list.toArray(ArrayUtils.newInstance(elementType, list.size()));\n        }\n\n        @Override\n        public Supplier<List<E>> supplier() {\n            return ArrayList::new;\n        }\n    }\n\n    /**\n     * Helps implement {@link Streams#of(Enumeration)}.\n     *\n     * @param <T> The element type.\n     */\n    private static final class EnumerationSpliterator<T> extends AbstractSpliterator<T> {\n\n        private final Enumeration<T> enumeration;\n\n        /**\n         * Creates a spliterator reporting the given estimated size and additionalCharacteristics.\n         *\n         * @param estimatedSize the estimated size of this spliterator if known, otherwise {@code Long.MAX_VALUE}.\n         * @param additionalCharacteristics properties of this spliterator's source or elements. If {@code SIZED} is reported then this spliterator will\n         *        additionally report {@code SUBSIZED}.\n         * @param enumeration The Enumeration to wrap.\n         */\n        protected EnumerationSpliterator(final long estimatedSize, final int additionalCharacteristics, final Enumeration<T> enumeration) {\n            super(estimatedSize, additionalCharacteristics);\n            this.enumeration = Objects.requireNonNull(enumeration, \"enumeration\");\n        }\n\n        @Override\n        public void forEachRemaining(final Consumer<? super T> action) {\n            while (enumeration.hasMoreElements()) {\n                next(action);\n            }\n        }\n\n        private boolean next(final Consumer<? super T> action) {\n            action.accept(enumeration.nextElement());\n            return true;\n\n        }\n\n        @Override\n        public boolean tryAdvance(final Consumer<? super T> action) {\n            return enumeration.hasMoreElements() && next(action);\n        }\n    }\n\n    /**\n     * A reduced, and simplified version of a {@link Stream} with failable method signatures.\n     *\n     * @param <T> The streams element type.\n     */\n    public static class FailableStream<T> {\n\n        private Stream<T> stream;\n        private boolean terminated;\n\n        /**\n         * Constructs a new instance with the given {@code stream}.\n         *\n         * @param stream The stream.\n         */\n        public FailableStream(final Stream<T> stream) {\n            this.stream = stream;\n        }\n\n        /**\n         * Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all\n         * elements if not necessary for determining the result. If the stream is empty then {@code true} is returned and the\n         * predicate is not evaluated.\n         *\n         * <p>\n         * This is a short-circuiting terminal operation.\n         * </p>\n         *\n         * Note This method evaluates the <em>universal quantification</em> of the predicate over the elements of the stream\n         * (for all x P(x)). If the stream is empty, the quantification is said to be <em>vacuously satisfied</em> and is always\n         * {@code true} (regardless of P(x)).\n         *\n         * @param predicate A non-interfering, stateless predicate to apply to elements of this stream\n         * @return {@code true} If either all elements of the stream match the provided predicate or the stream is empty,\n         *         otherwise {@code false}.\n         */\n        public boolean allMatch(final FailablePredicate<T, ?> predicate) {\n            assertNotTerminated();\n            return stream().allMatch(Failable.asPredicate(predicate));\n        }\n\n        /**\n         * Returns whether any elements of this stream match the provided predicate. May not evaluate the predicate on all\n         * elements if not necessary for determining the result. If the stream is empty then {@code false} is returned and the\n         * predicate is not evaluated.\n         *\n         * <p>\n         * This is a short-circuiting terminal operation.\n         * </p>\n         *\n         * Note This method evaluates the <em>existential quantification</em> of the predicate over the elements of the stream\n         * (for some x P(x)).\n         *\n         * @param predicate A non-interfering, stateless predicate to apply to elements of this stream\n         * @return {@code true} if any elements of the stream match the provided predicate, otherwise {@code false}\n         */\n        public boolean anyMatch(final FailablePredicate<T, ?> predicate) {\n            assertNotTerminated();\n            return stream().anyMatch(Failable.asPredicate(predicate));\n        }\n\n        /**\n         * Throws IllegalStateException if this stream is already terminated.\n         *\n         * @throws IllegalStateException if this stream is already terminated.\n         */\n        protected void assertNotTerminated() {\n            if (terminated) {\n                throw new IllegalStateException(\"This stream is already terminated.\");\n            }\n        }\n\n        /**\n         * Performs a mutable reduction operation on the elements of this stream using a {@link Collector}. A {@link Collector}\n         * encapsulates the functions used as arguments to {@link #collect(Supplier, BiConsumer, BiConsumer)}, allowing for\n         * reuse of collection strategies and composition of collect operations such as multiple-level grouping or partitioning.\n         *\n         * <p>\n         * If the underlying stream is parallel, and the {@link Collector} is concurrent, and either the stream is unordered or\n         * the collector is unordered, then a concurrent reduction will be performed (see {@link Collector} for details on\n         * concurrent reduction.)\n         * </p>\n         *\n         * <p>\n         * This is a terminal operation.\n         * </p>\n         *\n         * <p>\n         * When executed in parallel, multiple intermediate results may be instantiated, populated, and merged so as to maintain\n         * isolation of mutable data structures. Therefore, even when executed in parallel with non-thread-safe data structures\n         * (such as {@link ArrayList}), no additional synchronization is needed for a parallel reduction.\n         * </p>\n         *\n         * Note The following will accumulate strings into an ArrayList:\n         *\n         * <pre>\n         * {@code\n         *     List<String> asList = stringStream.collect(Collectors.toList());\n         * }\n         * </pre>\n         *\n         * <p>\n         * The following will classify {@code Person} objects by city:\n         * </p>\n         *\n         * <pre>\n         * {@code\n         *     Map<String, List<Person>> peopleByCity = personStream.collect(Collectors.groupingBy(Person::getCity));\n         * }\n         * </pre>\n         *\n         * <p>\n         * The following will classify {@code Person} objects by state and city, cascading two {@link Collector}s together:\n         * </p>\n         *\n         * <pre>\n         * {@code\n         *     Map<String, Map<String, List<Person>>> peopleByStateAndCity = personStream\n         *         .collect(Collectors.groupingBy(Person::getState, Collectors.groupingBy(Person::getCity)));\n         * }\n         * </pre>\n         *\n         * @param <R> the type of the result\n         * @param <A> the intermediate accumulation type of the {@link Collector}\n         * @param collector the {@link Collector} describing the reduction\n         * @return the result of the reduction\n         * @see #collect(Supplier, BiConsumer, BiConsumer)\n         * @see Collectors\n         */\n        public <A, R> R collect(final Collector<? super T, A, R> collector) {\n            makeTerminated();\n            return stream().collect(collector);\n        }\n\n        /**\n         * Performs a mutable reduction operation on the elements of this FailableStream. A mutable reduction is one in which\n         * the reduced value is a mutable result container, such as an {@link ArrayList}, and elements are incorporated by\n         * updating the state of the result rather than by replacing the result. This produces a result equivalent to:\n         *\n         * <pre>\n         * {@code\n         *     R result = supplier.get();\n         *     for (T element : this stream)\n         *         accumulator.accept(result, element);\n         *     return result;\n         * }\n         * </pre>\n         *\n         * <p>\n         * Like {@link #reduce(Object, BinaryOperator)}, {@code collect} operations can be parallelized without requiring\n         * additional synchronization.\n         * </p>\n         *\n         * <p>\n         * This is a terminal operation.\n         * </p>\n         *\n         * Note There are many existing classes in the JDK whose signatures are well-suited for use with method references as\n         * arguments to {@code collect()}. For example, the following will accumulate strings into an {@link ArrayList}:\n         *\n         * <pre>\n         * {@code\n         *     List<String> asList = stringStream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);\n         * }\n         * </pre>\n         *\n         * <p>\n         * The following will take a stream of strings and concatenates them into a single string:\n         * </p>\n         *\n         * <pre>\n         * {@code\n         *     String concat = stringStream.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();\n         * }\n         * </pre>\n         *\n         * @param <R> type of the result\n         * @param <A> Type of the accumulator.\n         * @param supplier a function that creates a new result container. For a parallel execution, this function may be called\n         *        multiple times and must return a fresh value each time.\n         * @param accumulator An associative, non-interfering, stateless function for incorporating an additional element into a\n         *        result\n         * @param combiner An associative, non-interfering, stateless function for combining two values, which must be\n         *        compatible with the accumulator function\n         * @return The result of the reduction\n         */\n        public <A, R> R collect(final Supplier<R> supplier, final BiConsumer<R, ? super T> accumulator, final BiConsumer<R, R> combiner) {\n            makeTerminated();\n            return stream().collect(supplier, accumulator, combiner);\n        }\n\n        /**\n         * Returns a FailableStream consisting of the elements of this stream that match the given FailablePredicate.\n         *\n         * <p>\n         * This is an intermediate operation.\n         * </p>\n         *\n         * @param predicate a non-interfering, stateless predicate to apply to each element to determine if it should be\n         *        included.\n         * @return the new stream\n         */\n        public FailableStream<T> filter(final FailablePredicate<T, ?> predicate) {\n            assertNotTerminated();\n            stream = stream.filter(Failable.asPredicate(predicate));\n            return this;\n        }\n\n        /**\n         * Performs an action for each element of this stream.\n         *\n         * <p>\n         * This is a terminal operation.\n         * </p>\n         *\n         * <p>\n         * The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines, this operation does\n         * <em>not</em> guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of\n         * parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library\n         * chooses. If the action accesses shared state, it is responsible for providing the required synchronization.\n         * </p>\n         *\n         * @param action a non-interfering action to perform on the elements\n         */\n        public void forEach(final FailableConsumer<T, ?> action) {\n            makeTerminated();\n            stream().forEach(Failable.asConsumer(action));\n        }\n\n        /**\n         * Marks this stream as terminated.\n         *\n         * @throws IllegalStateException if this stream is already terminated.\n         */\n        protected void makeTerminated() {\n            assertNotTerminated();\n            terminated = true;\n        }\n\n        /**\n         * Returns a stream consisting of the results of applying the given function to the elements of this stream.\n         *\n         * <p>\n         * This is an intermediate operation.\n         * </p>\n         *\n         * @param <R> The element type of the new stream\n         * @param mapper A non-interfering, stateless function to apply to each element\n         * @return the new stream\n         */\n        public <R> FailableStream<R> map(final FailableFunction<T, R, ?> mapper) {\n            assertNotTerminated();\n            return new FailableStream<>(stream.map(Failable.asFunction(mapper)));\n        }\n\n        /**\n         * Performs a reduction on the elements of this stream, using the provided identity value and an associative\n         * accumulation function, and returns the reduced value. This is equivalent to:\n         *\n         * <pre>\n         * {@code\n         *     T result = identity;\n         *     for (T element : this stream)\n         *         result = accumulator.apply(result, element)\n         *     return result;\n         * }\n         * </pre>\n         *\n         * but is not constrained to execute sequentially.\n         *\n         * <p>\n         * The {@code identity} value must be an identity for the accumulator function. This means that for all {@code t},\n         * {@code accumulator.apply(identity, t)} is equal to {@code t}. The {@code accumulator} function must be an associative\n         * function.\n         * </p>\n         *\n         * <p>\n         * This is a terminal operation.\n         * </p>\n         *\n         * Note Sum, min, max, average, and string concatenation are all special cases of reduction. Summing a stream of numbers\n         * can be expressed as:\n         *\n         * <pre>\n         * {@code\n         *     Integer sum = integers.reduce(0, (a, b) -> a + b);\n         * }\n         * </pre>\n         *\n         * or:\n         *\n         * <pre>\n         * {@code\n         *     Integer sum = integers.reduce(0, Integer::sum);\n         * }\n         * </pre>\n         *\n         * <p>\n         * While this may seem a more roundabout way to perform an aggregation compared to simply mutating a running total in a\n         * loop, reduction operations parallelize more gracefully, without needing additional synchronization and with greatly\n         * reduced risk of data races.\n         * </p>\n         *\n         * @param identity the identity value for the accumulating function\n         * @param accumulator an associative, non-interfering, stateless function for combining two values\n         * @return the result of the reduction\n         */\n        public T reduce(final T identity, final BinaryOperator<T> accumulator) {\n            makeTerminated();\n            return stream().reduce(identity, accumulator);\n        }\n\n        /**\n         * Converts the FailableStream into an equivalent stream.\n         *\n         * @return A stream, which will return the same elements, which this FailableStream would return.\n         */\n        public Stream<T> stream() {\n            return stream;\n        }\n    }\n\n    /**\n     * Converts the given {@link Collection} into a {@link FailableStream}. This is basically a simplified, reduced version\n     * of the {@link Stream} class, with the same underlying element stream, except that failable objects, like\n     * {@link FailablePredicate}, {@link FailableFunction}, or {@link FailableConsumer} may be applied, instead of\n     * {@link Predicate}, {@link Function}, or {@link Consumer}. The idea is to rewrite a code snippet like this:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final Function<O, String> mapper = (o) -> {\n     *     try {\n     *         return (String) m.invoke(o);\n     *     } catch (Throwable t) {\n     *         throw Failable.rethrow(t);\n     *     }\n     * };\n     * final List<String> strList = list.stream().map(mapper).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * as follows:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final List<String> strList = Failable.stream(list.stream()).map((o) -> (String) m.invoke(o)).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * While the second version may not be <em>quite</em> as efficient (because it depends on the creation of additional,\n     * intermediate objects, of type FailableStream), it is much more concise, and readable, and meets the spirit of Lambdas\n     * better than the first version.\n     *\n     * @param <T> The streams element type.\n     * @param stream The stream, which is being converted.\n     * @return The {@link FailableStream}, which has been created by converting the stream.\n     * @since 3.13.0\n     */\n    public static <T> FailableStream<T> failableStream(final Collection<T> stream) {\n        return failableStream(of(stream));\n    }\n\n    /**\n     * Converts the given {@link Stream stream} into a {@link FailableStream}. This is basically a simplified, reduced\n     * version of the {@link Stream} class, with the same underlying element stream, except that failable objects, like\n     * {@link FailablePredicate}, {@link FailableFunction}, or {@link FailableConsumer} may be applied, instead of\n     * {@link Predicate}, {@link Function}, or {@link Consumer}. The idea is to rewrite a code snippet like this:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final Function<O, String> mapper = (o) -> {\n     *     try {\n     *         return (String) m.invoke(o);\n     *     } catch (Throwable t) {\n     *         throw Failable.rethrow(t);\n     *     }\n     * };\n     * final List<String> strList = list.stream().map(mapper).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * as follows:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final List<String> strList = Failable.stream(list.stream()).map((o) -> (String) m.invoke(o)).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * While the second version may not be <em>quite</em> as efficient (because it depends on the creation of additional,\n     * intermediate objects, of type FailableStream), it is much more concise, and readable, and meets the spirit of Lambdas\n     * better than the first version.\n     *\n     * @param <T> The streams element type.\n     * @param stream The stream, which is being converted.\n     * @return The {@link FailableStream}, which has been created by converting the stream.\n     * @since 3.13.0\n     */\n    public static <T> FailableStream<T> failableStream(final Stream<T> stream) {\n        return new FailableStream<>(stream);\n    }\n\n    /**\n     * Shorthand for {@code Streams.failableStream(value == null ? Stream.empty() : Stream.of(value))}.\n     *\n     * @param <T> the type of stream elements.\n     * @param value the single element of the new stream, may be {@code null}.\n     * @return the new FailableStream on {@code value} or an empty stream.\n     * @since 3.15.0\n     */\n    public static <T> FailableStream<T> failableStream(final T value) {\n        return failableStream(value == null ? Stream.empty() : Stream.of(value));\n    }\n\n    /**\n     * Shorthand for {@code Streams.failableStream(Streams.of(arrayValues))}.\n     *\n     * @param <T> the type of stream elements.\n     * @param values the elements of the new stream, may be {@code null}.\n     * @return the new FailableStream on {@code values} or an empty stream.\n     * @since 3.14.0\n     */\n    @SafeVarargs // Creating a stream from an array is safe\n    public static <T> FailableStream<T> failableStream(final T... values) {\n        return failableStream(of(values));\n    }\n\n    /**\n     * Streams only instances of the give Class in a collection.\n     * <p>\n     * This method shorthand for:\n     * </p>\n     * <pre>\n     * {@code (Stream<E>) Streams.toStream(collection).filter(collection, SomeClass.class::isInstance);}\n     * </pre>\n     *\n     * @param <E> the type of elements in the collection we want to stream.\n     * @param clazz the type of elements in the collection we want to stream.\n     * @param collection the collection to stream or null.\n     * @return A non-null stream that only provides instances we want.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> instancesOf(final Class<? super E> clazz, final Collection<? super E> collection) {\n        return instancesOf(clazz, of(collection));\n    }\n\n    @SuppressWarnings(\"unchecked\") // After the isInstance check, we still need to type-cast.\n    private static <E> Stream<E> instancesOf(final Class<? super E> clazz, final Stream<?> stream) {\n        return (Stream<E>) of(stream).filter(clazz::isInstance);\n    }\n\n    /**\n     * Streams the non-null elements of a collection.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param collection the collection to stream or null.\n     * @return A non-null stream that filters out null elements.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> nonNull(final Collection<E> collection) {\n        return of(collection).filter(Objects::nonNull);\n    }\n\n    /**\n     * Streams the non-null elements of an array.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param array the array to stream or null.\n     * @return A non-null stream that filters out null elements.\n     * @since 3.13.0\n     */\n    @SafeVarargs\n    public static <E> Stream<E> nonNull(final E... array) {\n        return nonNull(of(array));\n    }\n\n    /**\n     * Streams the non-null elements of a stream.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param stream the stream to stream or null.\n     * @return A non-null stream that filters out null elements.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> nonNull(final Stream<E> stream) {\n        return of(stream).filter(Objects::nonNull);\n    }\n\n    /**\n     * Delegates to {@link Collection#stream()} or returns {@link Stream#empty()} if the collection is null.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param collection the collection to stream or null.\n     * @return {@link Collection#stream()} or {@link Stream#empty()} if the collection is null.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> of(final Collection<E> collection) {\n        return collection == null ? Stream.empty() : collection.stream();\n    }\n\n    /**\n     * Streams the elements of the given enumeration in order.\n     *\n     * @param <E> The enumeration element type.\n     * @param enumeration The enumeration to stream.\n     * @return a new stream.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> of(final Enumeration<E> enumeration) {\n        return StreamSupport.stream(new EnumerationSpliterator<>(Long.MAX_VALUE, Spliterator.ORDERED, enumeration), false);\n    }\n\n    /**\n     * Creates a stream on the given Iterable.\n     *\n     * @param <E> the type of elements in the Iterable.\n     * @param iterable the Iterable to stream or null.\n     * @return a new Stream or {@link Stream#empty()} if the Iterable is null.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> of(final Iterable<E> iterable) {\n        return iterable == null ? Stream.empty() : StreamSupport.stream(iterable.spliterator(), false);\n    }\n\n    /**\n     * Creates a stream on the given Iterator.\n     *\n     * @param <E> the type of elements in the Iterator.\n     * @param iterator the Iterator to stream or null.\n     * @return a new Stream or {@link Stream#empty()} if the Iterator is null.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> of(final Iterator<E> iterator) {\n        return iterator == null ? Stream.empty() : StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, Spliterator.ORDERED), false);\n    }\n\n    /**\n     * Returns the stream or {@link Stream#empty()} if the stream is null.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param stream the stream to stream or null.\n     * @return the stream or {@link Stream#empty()} if the stream is null.\n     * @since 3.13.0\n     */\n    private static <E> Stream<E> of(final Stream<E> stream) {\n        return stream == null ? Stream.empty() : stream;\n    }\n\n    /**\n     * Null-safe version of {@link Stream#of(Object[])}.\n     *\n     * @param <T> the type of stream elements.\n     * @param values the elements of the new stream, may be {@code null}.\n     * @return the new stream on {@code values} or {@link Stream#empty()}.\n     * @since 3.13.0\n     */\n    @SafeVarargs // Creating a stream from an array is safe\n    public static <T> Stream<T> of(final T... values) {\n        return values == null ? Stream.empty() : Stream.of(values);\n    }\n\n    /**\n     * Converts the given {@link Collection} into a {@link FailableStream}. This is basically a simplified, reduced version\n     * of the {@link Stream} class, with the same underlying element stream, except that failable objects, like\n     * {@link FailablePredicate}, {@link FailableFunction}, or {@link FailableConsumer} may be applied, instead of\n     * {@link Predicate}, {@link Function}, or {@link Consumer}. The idea is to rewrite a code snippet like this:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final Function<O, String> mapper = (o) -> {\n     *     try {\n     *         return (String) m.invoke(o);\n     *     } catch (Throwable t) {\n     *         throw Failable.rethrow(t);\n     *     }\n     * };\n     * final List<String> strList = list.stream().map(mapper).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * as follows:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final List<String> strList = Failable.stream(list.stream()).map((o) -> (String) m.invoke(o)).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * While the second version may not be <em>quite</em> as efficient (because it depends on the creation of additional,\n     * intermediate objects, of type FailableStream), it is much more concise, and readable, and meets the spirit of Lambdas\n     * better than the first version.\n     *\n     * @param <E> The streams element type.\n     * @param collection The stream, which is being converted.\n     * @return The {@link FailableStream}, which has been created by converting the stream.\n     * @deprecated Use {@link #failableStream(Collection)}.\n     */\n    @Deprecated\n    public static <E> FailableStream<E> stream(final Collection<E> collection) {\n        return failableStream(collection);\n    }\n\n    /**\n     * Converts the given {@link Stream stream} into a {@link FailableStream}. This is basically a simplified, reduced\n     * version of the {@link Stream} class, with the same underlying element stream, except that failable objects, like\n     * {@link FailablePredicate}, {@link FailableFunction}, or {@link FailableConsumer} may be applied, instead of\n     * {@link Predicate}, {@link Function}, or {@link Consumer}. The idea is to rewrite a code snippet like this:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final Function<O, String> mapper = (o) -> {\n     *     try {\n     *         return (String) m.invoke(o);\n     *     } catch (Throwable t) {\n     *         throw Failable.rethrow(t);\n     *     }\n     * };\n     * final List<String> strList = list.stream().map(mapper).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * as follows:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final List<String> strList = Failable.stream(list.stream()).map((o) -> (String) m.invoke(o)).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * While the second version may not be <em>quite</em> as efficient (because it depends on the creation of additional,\n     * intermediate objects, of type FailableStream), it is much more concise, and readable, and meets the spirit of Lambdas\n     * better than the first version.\n     *\n     * @param <T> The streams element type.\n     * @param stream The stream, which is being converted.\n     * @return The {@link FailableStream}, which has been created by converting the stream.\n     * @deprecated Use {@link #failableStream(Stream)}.\n     */\n    @Deprecated\n    public static <T> FailableStream<T> stream(final Stream<T> stream) {\n        return failableStream(stream);\n    }\n\n    /**\n     * Returns a {@link Collector} that accumulates the input elements into a new array.\n     *\n     * @param pElementType Type of an element in the array.\n     * @param <T> the type of the input elements\n     * @return a {@link Collector} which collects all the input elements into an array, in encounter order\n     */\n    public static <T> Collector<T, ?, T[]> toArray(final Class<T> pElementType) {\n        return new ArrayCollector<>(pElementType);\n    }\n\n    /**\n     * Make private in 4.0.\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public Streams() {\n        // empty\n    }\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/stream/Streams.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.stream;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.Spliterators.AbstractSpliterator;\nimport java.util.function.BiConsumer;\nimport java.util.function.BinaryOperator;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.function.Failable;\nimport org.apache.commons.lang3.function.FailableConsumer;\nimport org.apache.commons.lang3.function.FailableFunction;\nimport org.apache.commons.lang3.function.FailablePredicate;\n\n/**\n * Provides utility functions, and classes for working with the {@link java.util.stream} package, or more generally,\n * with Java 8 lambdas. More specifically, it attempts to address the fact that lambdas are supposed not to throw\n * Exceptions, at least not checked Exceptions, AKA instances of {@link Exception}. This enforces the use of constructs\n * like:\n *\n * <pre>\n * {@code\n * Consumer<java.lang.reflect.Method> consumer = m -> {\n *     try {\n *         m.invoke(o, args);\n *     } catch (Throwable t) {\n *         throw Failable.rethrow(t);\n *     }\n * };\n * stream.forEach(consumer);\n * }\n * </pre>\n * <p>\n * Using a {@link FailableStream}, this can be rewritten as follows:\n * </p>\n *\n * <pre>\n * {@code\n * Streams.failable(stream).forEach((m) -> m.invoke(o, args));\n * }\n * </pre>\n *\n * Obviously, the second version is much more concise and the spirit of Lambda expressions is met better than in the\n * first version.\n *\n * @see Stream\n * @see Failable\n * @since 3.11\n */\npublic class Streams {\n\n    /**\n     * A Collector type for arrays.\n     *\n     * @param <E> The array type.\n     */\n    public static class ArrayCollector<E> implements Collector<E, List<E>, E[]> {\n        private static final Set<Characteristics> characteristics = Collections.emptySet();\n        private final Class<E> elementType;\n\n        /**\n         * Constructs a new instance for the given element type.\n         *\n         * @param elementType The element type.\n         */\n        public ArrayCollector(final Class<E> elementType) {\n            this.elementType = Objects.requireNonNull(elementType, \"elementType\");\n        }\n\n        @Override\n        public BiConsumer<List<E>, E> accumulator() {\n            return List::add;\n        }\n\n        @Override\n        public Set<Characteristics> characteristics() {\n            return characteristics;\n        }\n\n        @Override\n        public BinaryOperator<List<E>> combiner() {\n            return (left, right) -> {\n                left.addAll(right);\n                return left;\n            };\n        }\n\n        @Override\n        public Function<List<E>, E[]> finisher() {\n            return list -> list.toArray(ArrayUtils.newInstance(elementType, list.size()));\n        }\n\n        @Override\n        public Supplier<List<E>> supplier() {\n            return ArrayList::new;\n        }\n    }\n\n    /**\n     * Helps implement {@link Streams#of(Enumeration)}.\n     *\n     * @param <T> The element type.\n     */\n    private static final class EnumerationSpliterator<T> extends AbstractSpliterator<T> {\n\n        private final Enumeration<T> enumeration;\n\n        /**\n         * Creates a spliterator reporting the given estimated size and additionalCharacteristics.\n         *\n         * @param estimatedSize the estimated size of this spliterator if known, otherwise {@code Long.MAX_VALUE}.\n         * @param additionalCharacteristics properties of this spliterator's source or elements. If {@code SIZED} is reported then this spliterator will\n         *        additionally report {@code SUBSIZED}.\n         * @param enumeration The Enumeration to wrap.\n         */\n        protected EnumerationSpliterator(final long estimatedSize, final int additionalCharacteristics, final Enumeration<T> enumeration) {\n            super(estimatedSize, additionalCharacteristics);\n            this.enumeration = Objects.requireNonNull(enumeration, \"enumeration\");\n        }\n\n        @Override\n        public void forEachRemaining(final Consumer<? super T> action) {\n            while (enumeration.hasMoreElements()) {\n                next(action);\n            }\n        }\n\n        private boolean next(final Consumer<? super T> action) {\n            action.accept(enumeration.nextElement());\n            return true;\n\n        }\n\n        @Override\n        public boolean tryAdvance(final Consumer<? super T> action) {\n            return enumeration.hasMoreElements() && next(action);\n        }\n    }\n\n    /**\n     * A reduced, and simplified version of a {@link Stream} with failable method signatures.\n     *\n     * @param <T> The streams element type.\n     */\n    public static class FailableStream<T> {\n\n        private Stream<T> stream;\n        private boolean terminated;\n\n        /**\n         * Constructs a new instance with the given {@code stream}.\n         *\n         * @param stream The stream.\n         */\n        public FailableStream(final Stream<T> stream) {\n            this.stream = stream;\n        }\n\n        /**\n         * Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all\n         * elements if not necessary for determining the result. If the stream is empty then {@code true} is returned and the\n         * predicate is not evaluated.\n         *\n         * <p>\n         * This is a short-circuiting terminal operation.\n         * </p>\n         *\n         * Note This method evaluates the <em>universal quantification</em> of the predicate over the elements of the stream\n         * (for all x P(x)). If the stream is empty, the quantification is said to be <em>vacuously satisfied</em> and is always\n         * {@code true} (regardless of P(x)).\n         *\n         * @param predicate A non-interfering, stateless predicate to apply to elements of this stream\n         * @return {@code true} If either all elements of the stream match the provided predicate or the stream is empty,\n         *         otherwise {@code false}.\n         */\n        public boolean allMatch(final FailablePredicate<T, ?> predicate) {\n            assertNotTerminated();\n            return stream().allMatch(Failable.asPredicate(predicate));\n        }\n\n        /**\n         * Returns whether any elements of this stream match the provided predicate. May not evaluate the predicate on all\n         * elements if not necessary for determining the result. If the stream is empty then {@code false} is returned and the\n         * predicate is not evaluated.\n         *\n         * <p>\n         * This is a short-circuiting terminal operation.\n         * </p>\n         *\n         * Note This method evaluates the <em>existential quantification</em> of the predicate over the elements of the stream\n         * (for some x P(x)).\n         *\n         * @param predicate A non-interfering, stateless predicate to apply to elements of this stream\n         * @return {@code true} if any elements of the stream match the provided predicate, otherwise {@code false}\n         */\n        public boolean anyMatch(final FailablePredicate<T, ?> predicate) {\n            assertNotTerminated();\n            return stream().anyMatch(Failable.asPredicate(predicate));\n        }\n\n        /**\n         * Throws IllegalStateException if this stream is already terminated.\n         *\n         * @throws IllegalStateException if this stream is already terminated.\n         */\n        protected void assertNotTerminated() {\n            if (terminated) {\n                throw new IllegalStateException(\"This stream is already terminated.\");\n            }\n        }\n\n        /**\n         * Performs a mutable reduction operation on the elements of this stream using a {@link Collector}. A {@link Collector}\n         * encapsulates the functions used as arguments to {@link #collect(Supplier, BiConsumer, BiConsumer)}, allowing for\n         * reuse of collection strategies and composition of collect operations such as multiple-level grouping or partitioning.\n         *\n         * <p>\n         * If the underlying stream is parallel, and the {@link Collector} is concurrent, and either the stream is unordered or\n         * the collector is unordered, then a concurrent reduction will be performed (see {@link Collector} for details on\n         * concurrent reduction.)\n         * </p>\n         *\n         * <p>\n         * This is a terminal operation.\n         * </p>\n         *\n         * <p>\n         * When executed in parallel, multiple intermediate results may be instantiated, populated, and merged so as to maintain\n         * isolation of mutable data structures. Therefore, even when executed in parallel with non-thread-safe data structures\n         * (such as {@link ArrayList}), no additional synchronization is needed for a parallel reduction.\n         * </p>\n         *\n         * Note The following will accumulate strings into an ArrayList:\n         *\n         * <pre>\n         * {@code\n         *     List<String> asList = stringStream.collect(Collectors.toList());\n         * }\n         * </pre>\n         *\n         * <p>\n         * The following will classify {@code Person} objects by city:\n         * </p>\n         *\n         * <pre>\n         * {@code\n         *     Map<String, List<Person>> peopleByCity = personStream.collect(Collectors.groupingBy(Person::getCity));\n         * }\n         * </pre>\n         *\n         * <p>\n         * The following will classify {@code Person} objects by state and city, cascading two {@link Collector}s together:\n         * </p>\n         *\n         * <pre>\n         * {@code\n         *     Map<String, Map<String, List<Person>>> peopleByStateAndCity = personStream\n         *         .collect(Collectors.groupingBy(Person::getState, Collectors.groupingBy(Person::getCity)));\n         * }\n         * </pre>\n         *\n         * @param <R> the type of the result\n         * @param <A> the intermediate accumulation type of the {@link Collector}\n         * @param collector the {@link Collector} describing the reduction\n         * @return the result of the reduction\n         * @see #collect(Supplier, BiConsumer, BiConsumer)\n         * @see Collectors\n         */\n        public <A, R> R collect(final Collector<? super T, A, R> collector) {\n            makeTerminated();\n            return stream().collect(collector);\n        }\n\n        /**\n         * Performs a mutable reduction operation on the elements of this FailableStream. A mutable reduction is one in which\n         * the reduced value is a mutable result container, such as an {@link ArrayList}, and elements are incorporated by\n         * updating the state of the result rather than by replacing the result. This produces a result equivalent to:\n         *\n         * <pre>\n         * {@code\n         *     R result = supplier.get();\n         *     for (T element : this stream)\n         *         accumulator.accept(result, element);\n         *     return result;\n         * }\n         * </pre>\n         *\n         * <p>\n         * Like {@link #reduce(Object, BinaryOperator)}, {@code collect} operations can be parallelized without requiring\n         * additional synchronization.\n         * </p>\n         *\n         * <p>\n         * This is a terminal operation.\n         * </p>\n         *\n         * Note There are many existing classes in the JDK whose signatures are well-suited for use with method references as\n         * arguments to {@code collect()}. For example, the following will accumulate strings into an {@link ArrayList}:\n         *\n         * <pre>\n         * {@code\n         *     List<String> asList = stringStream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);\n         * }\n         * </pre>\n         *\n         * <p>\n         * The following will take a stream of strings and concatenates them into a single string:\n         * </p>\n         *\n         * <pre>\n         * {@code\n         *     String concat = stringStream.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();\n         * }\n         * </pre>\n         *\n         * @param <R> type of the result\n         * @param <A> Type of the accumulator.\n         * @param supplier a function that creates a new result container. For a parallel execution, this function may be called\n         *        multiple times and must return a fresh value each time.\n         * @param accumulator An associative, non-interfering, stateless function for incorporating an additional element into a\n         *        result\n         * @param combiner An associative, non-interfering, stateless function for combining two values, which must be\n         *        compatible with the accumulator function\n         * @return The result of the reduction\n         */\n        public <A, R> R collect(final Supplier<R> supplier, final BiConsumer<R, ? super T> accumulator, final BiConsumer<R, R> combiner) {\n            makeTerminated();\n            return stream().collect(supplier, accumulator, combiner);\n        }\n\n        /**\n         * Returns a FailableStream consisting of the elements of this stream that match the given FailablePredicate.\n         *\n         * <p>\n         * This is an intermediate operation.\n         * </p>\n         *\n         * @param predicate a non-interfering, stateless predicate to apply to each element to determine if it should be\n         *        included.\n         * @return the new stream\n         */\n        public FailableStream<T> filter(final FailablePredicate<T, ?> predicate) {\n            assertNotTerminated();\n            stream = stream.filter(Failable.asPredicate(predicate));\n            return this;\n        }\n\n        /**\n         * Performs an action for each element of this stream.\n         *\n         * <p>\n         * This is a terminal operation.\n         * </p>\n         *\n         * <p>\n         * The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines, this operation does\n         * <em>not</em> guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of\n         * parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library\n         * chooses. If the action accesses shared state, it is responsible for providing the required synchronization.\n         * </p>\n         *\n         * @param action a non-interfering action to perform on the elements\n         */\n        public void forEach(final FailableConsumer<T, ?> action) {\n            makeTerminated();\n            stream().forEach(Failable.asConsumer(action));\n        }\n\n        /**\n         * Marks this stream as terminated.\n         *\n         * @throws IllegalStateException if this stream is already terminated.\n         */\n        protected void makeTerminated() {\n            assertNotTerminated();\n            terminated = true;\n        }\n\n        /**\n         * Returns a stream consisting of the results of applying the given function to the elements of this stream.\n         *\n         * <p>\n         * This is an intermediate operation.\n         * </p>\n         *\n         * @param <R> The element type of the new stream\n         * @param mapper A non-interfering, stateless function to apply to each element\n         * @return the new stream\n         */\n        public <R> FailableStream<R> map(final FailableFunction<T, R, ?> mapper) {\n            assertNotTerminated();\n            return new FailableStream<>(stream.map(Failable.asFunction(mapper)));\n        }\n\n        /**\n         * Performs a reduction on the elements of this stream, using the provided identity value and an associative\n         * accumulation function, and returns the reduced value. This is equivalent to:\n         *\n         * <pre>\n         * {@code\n         *     T result = identity;\n         *     for (T element : this stream)\n         *         result = accumulator.apply(result, element)\n         *     return result;\n         * }\n         * </pre>\n         *\n         * but is not constrained to execute sequentially.\n         *\n         * <p>\n         * The {@code identity} value must be an identity for the accumulator function. This means that for all {@code t},\n         * {@code accumulator.apply(identity, t)} is equal to {@code t}. The {@code accumulator} function must be an associative\n         * function.\n         * </p>\n         *\n         * <p>\n         * This is a terminal operation.\n         * </p>\n         *\n         * Note Sum, min, max, average, and string concatenation are all special cases of reduction. Summing a stream of numbers\n         * can be expressed as:\n         *\n         * <pre>\n         * {@code\n         *     Integer sum = integers.reduce(0, (a, b) -> a + b);\n         * }\n         * </pre>\n         *\n         * or:\n         *\n         * <pre>\n         * {@code\n         *     Integer sum = integers.reduce(0, Integer::sum);\n         * }\n         * </pre>\n         *\n         * <p>\n         * While this may seem a more roundabout way to perform an aggregation compared to simply mutating a running total in a\n         * loop, reduction operations parallelize more gracefully, without needing additional synchronization and with greatly\n         * reduced risk of data races.\n         * </p>\n         *\n         * @param identity the identity value for the accumulating function\n         * @param accumulator an associative, non-interfering, stateless function for combining two values\n         * @return the result of the reduction\n         */\n        public T reduce(final T identity, final BinaryOperator<T> accumulator) {\n            makeTerminated();\n            return stream().reduce(identity, accumulator);\n        }\n\n        /**\n         * Converts the FailableStream into an equivalent stream.\n         *\n         * @return A stream, which will return the same elements, which this FailableStream would return.\n         */\n        public Stream<T> stream() {\n            return stream;\n        }\n    }\n\n    /**\n     * Converts the given {@link Collection} into a {@link FailableStream}. This is basically a simplified, reduced version\n     * of the {@link Stream} class, with the same underlying element stream, except that failable objects, like\n     * {@link FailablePredicate}, {@link FailableFunction}, or {@link FailableConsumer} may be applied, instead of\n     * {@link Predicate}, {@link Function}, or {@link Consumer}. The idea is to rewrite a code snippet like this:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final Function<O, String> mapper = (o) -> {\n     *     try {\n     *         return (String) m.invoke(o);\n     *     } catch (Throwable t) {\n     *         throw Failable.rethrow(t);\n     *     }\n     * };\n     * final List<String> strList = list.stream().map(mapper).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * as follows:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final List<String> strList = Failable.stream(list.stream()).map((o) -> (String) m.invoke(o)).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * While the second version may not be <em>quite</em> as efficient (because it depends on the creation of additional,\n     * intermediate objects, of type FailableStream), it is much more concise, and readable, and meets the spirit of Lambdas\n     * better than the first version.\n     *\n     * @param <T> The streams element type.\n     * @param stream The stream, which is being converted.\n     * @return The {@link FailableStream}, which has been created by converting the stream.\n     * @since 3.13.0\n     */\n    public static <T> FailableStream<T> failableStream(final Collection<T> stream) {\n        return failableStream(of(stream));\n    }\n\n    /**\n     * Converts the given {@link Stream stream} into a {@link FailableStream}. This is basically a simplified, reduced\n     * version of the {@link Stream} class, with the same underlying element stream, except that failable objects, like\n     * {@link FailablePredicate}, {@link FailableFunction}, or {@link FailableConsumer} may be applied, instead of\n     * {@link Predicate}, {@link Function}, or {@link Consumer}. The idea is to rewrite a code snippet like this:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final Function<O, String> mapper = (o) -> {\n     *     try {\n     *         return (String) m.invoke(o);\n     *     } catch (Throwable t) {\n     *         throw Failable.rethrow(t);\n     *     }\n     * };\n     * final List<String> strList = list.stream().map(mapper).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * as follows:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final List<String> strList = Failable.stream(list.stream()).map((o) -> (String) m.invoke(o)).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * While the second version may not be <em>quite</em> as efficient (because it depends on the creation of additional,\n     * intermediate objects, of type FailableStream), it is much more concise, and readable, and meets the spirit of Lambdas\n     * better than the first version.\n     *\n     * @param <T> The streams element type.\n     * @param stream The stream, which is being converted.\n     * @return The {@link FailableStream}, which has been created by converting the stream.\n     * @since 3.13.0\n     */\n    public static <T> FailableStream<T> failableStream(final Stream<T> stream) {\n        return new FailableStream<>(stream);\n    }\n\n    /**\n     * Shorthand for {@code Streams.failableStream(value == null ? Stream.empty() : Stream.of(value))}.\n     *\n     * @param <T> the type of stream elements.\n     * @param value the single element of the new stream, may be {@code null}.\n     * @return the new FailableStream on {@code value} or an empty stream.\n     * @since 3.15.0\n     */\n    public static <T> FailableStream<T> failableStream(final T value) {\n        return failableStream(streamOf(value));\n    }\n\n    /**\n     * Shorthand for {@code Streams.failableStream(Streams.of(arrayValues))}.\n     *\n     * @param <T> the type of stream elements.\n     * @param values the elements of the new stream, may be {@code null}.\n     * @return the new FailableStream on {@code values} or an empty stream.\n     * @since 3.14.0\n     */\n    @SafeVarargs // Creating a stream from an array is safe\n    public static <T> FailableStream<T> failableStream(final T... values) {\n        return failableStream(of(values));\n    }\n\n    /**\n     * Streams only instances of the give Class in a collection.\n     * <p>\n     * This method shorthand for:\n     * </p>\n     * <pre>\n     * {@code (Stream<E>) Streams.toStream(collection).filter(collection, SomeClass.class::isInstance);}\n     * </pre>\n     *\n     * @param <E> the type of elements in the collection we want to stream.\n     * @param clazz the type of elements in the collection we want to stream.\n     * @param collection the collection to stream or null.\n     * @return A non-null stream that only provides instances we want.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> instancesOf(final Class<? super E> clazz, final Collection<? super E> collection) {\n        return instancesOf(clazz, of(collection));\n    }\n\n    @SuppressWarnings(\"unchecked\") // After the isInstance check, we still need to type-cast.\n    private static <E> Stream<E> instancesOf(final Class<? super E> clazz, final Stream<?> stream) {\n        return (Stream<E>) of(stream).filter(clazz::isInstance);\n    }\n\n    /**\n     * Streams the non-null elements of a collection.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param collection the collection to stream or null.\n     * @return A non-null stream that filters out null elements.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> nonNull(final Collection<E> collection) {\n        return of(collection).filter(Objects::nonNull);\n    }\n\n    /**\n     * Streams the non-null element.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param array the element to stream or null.\n     * @return A non-null stream that filters out a null element.\n     * @since 3.15.0\n     */\n    public static <E> Stream<E> nonNull(final E array) {\n        return nonNull(streamOf(array));\n    }\n\n    /**\n     * Streams the non-null elements of an array.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param array the array to stream or null.\n     * @return A non-null stream that filters out null elements.\n     * @since 3.13.0\n     */\n    @SafeVarargs\n    public static <E> Stream<E> nonNull(final E... array) {\n        return nonNull(of(array));\n    }\n\n    /**\n     * Streams the non-null elements of a stream.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param stream the stream to stream or null.\n     * @return A non-null stream that filters out null elements.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> nonNull(final Stream<E> stream) {\n        return of(stream).filter(Objects::nonNull);\n    }\n\n    /**\n     * Delegates to {@link Collection#stream()} or returns {@link Stream#empty()} if the collection is null.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param collection the collection to stream or null.\n     * @return {@link Collection#stream()} or {@link Stream#empty()} if the collection is null.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> of(final Collection<E> collection) {\n        return collection == null ? Stream.empty() : collection.stream();\n    }\n\n    /**\n     * Streams the elements of the given enumeration in order.\n     *\n     * @param <E> The enumeration element type.\n     * @param enumeration The enumeration to stream.\n     * @return a new stream.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> of(final Enumeration<E> enumeration) {\n        return StreamSupport.stream(new EnumerationSpliterator<>(Long.MAX_VALUE, Spliterator.ORDERED, enumeration), false);\n    }\n\n    /**\n     * Creates a stream on the given Iterable.\n     *\n     * @param <E> the type of elements in the Iterable.\n     * @param iterable the Iterable to stream or null.\n     * @return a new Stream or {@link Stream#empty()} if the Iterable is null.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> of(final Iterable<E> iterable) {\n        return iterable == null ? Stream.empty() : StreamSupport.stream(iterable.spliterator(), false);\n    }\n\n    /**\n     * Creates a stream on the given Iterator.\n     *\n     * @param <E> the type of elements in the Iterator.\n     * @param iterator the Iterator to stream or null.\n     * @return a new Stream or {@link Stream#empty()} if the Iterator is null.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> of(final Iterator<E> iterator) {\n        return iterator == null ? Stream.empty() : StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, Spliterator.ORDERED), false);\n    }\n\n    /**\n     * Returns the stream or {@link Stream#empty()} if the stream is null.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param stream the stream to stream or null.\n     * @return the stream or {@link Stream#empty()} if the stream is null.\n     * @since 3.13.0\n     */\n    private static <E> Stream<E> of(final Stream<E> stream) {\n        return stream == null ? Stream.empty() : stream;\n    }\n\n    /**\n     * Null-safe version of {@link Stream#of(Object[])}.\n     *\n     * @param <T> the type of stream elements.\n     * @param values the elements of the new stream, may be {@code null}.\n     * @return the new stream on {@code values} or {@link Stream#empty()}.\n     * @since 3.13.0\n     */\n    @SafeVarargs // Creating a stream from an array is safe\n    public static <T> Stream<T> of(final T... values) {\n        return values == null ? Stream.empty() : Stream.of(values);\n    }\n\n    /**\n     * Converts the given {@link Collection} into a {@link FailableStream}. This is basically a simplified, reduced version\n     * of the {@link Stream} class, with the same underlying element stream, except that failable objects, like\n     * {@link FailablePredicate}, {@link FailableFunction}, or {@link FailableConsumer} may be applied, instead of\n     * {@link Predicate}, {@link Function}, or {@link Consumer}. The idea is to rewrite a code snippet like this:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final Function<O, String> mapper = (o) -> {\n     *     try {\n     *         return (String) m.invoke(o);\n     *     } catch (Throwable t) {\n     *         throw Failable.rethrow(t);\n     *     }\n     * };\n     * final List<String> strList = list.stream().map(mapper).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * as follows:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final List<String> strList = Failable.stream(list.stream()).map((o) -> (String) m.invoke(o)).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * While the second version may not be <em>quite</em> as efficient (because it depends on the creation of additional,\n     * intermediate objects, of type FailableStream), it is much more concise, and readable, and meets the spirit of Lambdas\n     * better than the first version.\n     *\n     * @param <E> The streams element type.\n     * @param collection The stream, which is being converted.\n     * @return The {@link FailableStream}, which has been created by converting the stream.\n     * @deprecated Use {@link #failableStream(Collection)}.\n     */\n    @Deprecated\n    public static <E> FailableStream<E> stream(final Collection<E> collection) {\n        return failableStream(collection);\n    }\n\n    /**\n     * Converts the given {@link Stream stream} into a {@link FailableStream}. This is basically a simplified, reduced\n     * version of the {@link Stream} class, with the same underlying element stream, except that failable objects, like\n     * {@link FailablePredicate}, {@link FailableFunction}, or {@link FailableConsumer} may be applied, instead of\n     * {@link Predicate}, {@link Function}, or {@link Consumer}. The idea is to rewrite a code snippet like this:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final Function<O, String> mapper = (o) -> {\n     *     try {\n     *         return (String) m.invoke(o);\n     *     } catch (Throwable t) {\n     *         throw Failable.rethrow(t);\n     *     }\n     * };\n     * final List<String> strList = list.stream().map(mapper).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * as follows:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final List<String> strList = Failable.stream(list.stream()).map((o) -> (String) m.invoke(o)).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * While the second version may not be <em>quite</em> as efficient (because it depends on the creation of additional,\n     * intermediate objects, of type FailableStream), it is much more concise, and readable, and meets the spirit of Lambdas\n     * better than the first version.\n     *\n     * @param <T> The streams element type.\n     * @param stream The stream, which is being converted.\n     * @return The {@link FailableStream}, which has been created by converting the stream.\n     * @deprecated Use {@link #failableStream(Stream)}.\n     */\n    @Deprecated\n    public static <T> FailableStream<T> stream(final Stream<T> stream) {\n        return failableStream(stream);\n    }\n\n    private static <T> Stream<T> streamOf(final T value) {\n        return value == null ? Stream.empty() : Stream.of(value);\n    }\n\n    /**\n     * Returns a {@link Collector} that accumulates the input elements into a new array.\n     *\n     * @param pElementType Type of an element in the array.\n     * @param <T> the type of the input elements\n     * @return a {@link Collector} which collects all the input elements into an array, in encounter order\n     */\n    public static <T> Collector<T, ?, T[]> toArray(final Class<T> pElementType) {\n        return new ArrayCollector<>(pElementType);\n    }\n\n    /**\n     * Make private in 4.0.\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public Streams() {\n        // empty\n    }\n}\n",
        "diffSourceCodeSet": [
            "private static <T> Stream<T> streamOf(final T value) {\n        return value == null ? Stream.empty() : Stream.of(value);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.stream.Streams#of\n methodBody: public static <T> Stream<T> of(final T... values) {\nreturn values == null ? Stream.empty() : Stream.of(values);\n}",
            "methodSignature: org.apache.commons.lang3.stream.Streams#failableStream\n methodBody: public static <T> FailableStream<T> failableStream(final T... values) {\nreturn failableStream(of(values));\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Shorthand for {@code Streams.failableStream(value == null ? Stream.empty() : Stream.of(value))}.\n     *\n     * @param <T> the type of stream elements.\n     * @param value the single element of the new stream, may be {@code null}.\n     * @return the new FailableStream on {@code value} or an empty stream.\n     * @since 3.15.0\n     */\n    public static <T> FailableStream<T> failableStream(final T value) {\n        return failableStream(streamOf(value));\n    }\nprivate static <T> Stream<T> streamOf(final T value) {\n        return value == null ? Stream.empty() : Stream.of(value);\n    }",
        "diffSourceCode": "   582:     /**\n   583:      * Shorthand for {@code Streams.failableStream(value == null ? Stream.empty() : Stream.of(value))}.\n   584:      *\n   585:      * @param <T> the type of stream elements.\n   586:      * @param value the single element of the new stream, may be {@code null}.\n   587:      * @return the new FailableStream on {@code value} or an empty stream.\n   588:      * @since 3.15.0\n   589:      */\n   590:     public static <T> FailableStream<T> failableStream(final T value) {\n-  591:         return failableStream(value == null ? Stream.empty() : Stream.of(value));\n+  591:         return failableStream(streamOf(value));\n   592:     }\n-  843:      * Make private in 4.0.\n-  844:      *\n-  845:      * @deprecated TODO Make private in 4.0.\n+  843:     private static <T> Stream<T> streamOf(final T value) {\n+  844:         return value == null ? Stream.empty() : Stream.of(value);\n+  845:     }\n",
        "uniqueId": "64736630706adf9e2cbb482fbfcbdc81a9dc02f7_582_592_843_845_582_592",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Converts the given collection into a FailableStream.\n *\n * @param <E> The element type of the stream.\n * @param collection The collection to convert.\n * @return A FailableStream representing the elements of the collection.\n * @since 3.13.0\n */\npublic static <E> FailableStream<E> failableStream(final Collection<E> collection) {\n    return failableStream(of(collection));\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Shorthand for {@code Streams.failableStream(value == null ? Stream.empty() : Stream.of(value))}.\n     *\n     * @param <T> the type of stream elements.\n     * @param value the single element of the new stream, may be {@code null}.\n     * @return the new FailableStream on {@code value} or an empty stream.\n     * @since 3.15.0\n     */\n    public static <T> FailableStream<T> failableStream(final T value) {\n        return failableStream(value == null ? Stream.empty() : Stream.of(value));\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.stream;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.Spliterators.AbstractSpliterator;\nimport java.util.function.BiConsumer;\nimport java.util.function.BinaryOperator;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.function.Failable;\nimport org.apache.commons.lang3.function.FailableConsumer;\nimport org.apache.commons.lang3.function.FailableFunction;\nimport org.apache.commons.lang3.function.FailablePredicate;\n\n/**\n * Provides utility functions, and classes for working with the {@link java.util.stream} package, or more generally,\n * with Java 8 lambdas. More specifically, it attempts to address the fact that lambdas are supposed not to throw\n * Exceptions, at least not checked Exceptions, AKA instances of {@link Exception}. This enforces the use of constructs\n * like:\n *\n * <pre>\n * {@code\n * Consumer<java.lang.reflect.Method> consumer = m -> {\n *     try {\n *         m.invoke(o, args);\n *     } catch (Throwable t) {\n *         throw Failable.rethrow(t);\n *     }\n * };\n * stream.forEach(consumer);\n * }\n * </pre>\n * <p>\n * Using a {@link FailableStream}, this can be rewritten as follows:\n * </p>\n *\n * <pre>\n * {@code\n * Streams.failable(stream).forEach((m) -> m.invoke(o, args));\n * }\n * </pre>\n *\n * Obviously, the second version is much more concise and the spirit of Lambda expressions is met better than in the\n * first version.\n *\n * @see Stream\n * @see Failable\n * @since 3.11\n */\npublic class Streams {\n\n    /**\n     * A Collector type for arrays.\n     *\n     * @param <E> The array type.\n     */\n    public static class ArrayCollector<E> implements Collector<E, List<E>, E[]> {\n        private static final Set<Characteristics> characteristics = Collections.emptySet();\n        private final Class<E> elementType;\n\n        /**\n         * Constructs a new instance for the given element type.\n         *\n         * @param elementType The element type.\n         */\n        public ArrayCollector(final Class<E> elementType) {\n            this.elementType = Objects.requireNonNull(elementType, \"elementType\");\n        }\n\n        @Override\n        public BiConsumer<List<E>, E> accumulator() {\n            return List::add;\n        }\n\n        @Override\n        public Set<Characteristics> characteristics() {\n            return characteristics;\n        }\n\n        @Override\n        public BinaryOperator<List<E>> combiner() {\n            return (left, right) -> {\n                left.addAll(right);\n                return left;\n            };\n        }\n\n        @Override\n        public Function<List<E>, E[]> finisher() {\n            return list -> list.toArray(ArrayUtils.newInstance(elementType, list.size()));\n        }\n\n        @Override\n        public Supplier<List<E>> supplier() {\n            return ArrayList::new;\n        }\n    }\n\n    /**\n     * Helps implement {@link Streams#of(Enumeration)}.\n     *\n     * @param <T> The element type.\n     */\n    private static final class EnumerationSpliterator<T> extends AbstractSpliterator<T> {\n\n        private final Enumeration<T> enumeration;\n\n        /**\n         * Creates a spliterator reporting the given estimated size and additionalCharacteristics.\n         *\n         * @param estimatedSize the estimated size of this spliterator if known, otherwise {@code Long.MAX_VALUE}.\n         * @param additionalCharacteristics properties of this spliterator's source or elements. If {@code SIZED} is reported then this spliterator will\n         *        additionally report {@code SUBSIZED}.\n         * @param enumeration The Enumeration to wrap.\n         */\n        protected EnumerationSpliterator(final long estimatedSize, final int additionalCharacteristics, final Enumeration<T> enumeration) {\n            super(estimatedSize, additionalCharacteristics);\n            this.enumeration = Objects.requireNonNull(enumeration, \"enumeration\");\n        }\n\n        @Override\n        public void forEachRemaining(final Consumer<? super T> action) {\n            while (enumeration.hasMoreElements()) {\n                next(action);\n            }\n        }\n\n        private boolean next(final Consumer<? super T> action) {\n            action.accept(enumeration.nextElement());\n            return true;\n\n        }\n\n        @Override\n        public boolean tryAdvance(final Consumer<? super T> action) {\n            return enumeration.hasMoreElements() && next(action);\n        }\n    }\n\n    /**\n     * A reduced, and simplified version of a {@link Stream} with failable method signatures.\n     *\n     * @param <T> The streams element type.\n     */\n    public static class FailableStream<T> {\n\n        private Stream<T> stream;\n        private boolean terminated;\n\n        /**\n         * Constructs a new instance with the given {@code stream}.\n         *\n         * @param stream The stream.\n         */\n        public FailableStream(final Stream<T> stream) {\n            this.stream = stream;\n        }\n\n        /**\n         * Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all\n         * elements if not necessary for determining the result. If the stream is empty then {@code true} is returned and the\n         * predicate is not evaluated.\n         *\n         * <p>\n         * This is a short-circuiting terminal operation.\n         * </p>\n         *\n         * Note This method evaluates the <em>universal quantification</em> of the predicate over the elements of the stream\n         * (for all x P(x)). If the stream is empty, the quantification is said to be <em>vacuously satisfied</em> and is always\n         * {@code true} (regardless of P(x)).\n         *\n         * @param predicate A non-interfering, stateless predicate to apply to elements of this stream\n         * @return {@code true} If either all elements of the stream match the provided predicate or the stream is empty,\n         *         otherwise {@code false}.\n         */\n        public boolean allMatch(final FailablePredicate<T, ?> predicate) {\n            assertNotTerminated();\n            return stream().allMatch(Failable.asPredicate(predicate));\n        }\n\n        /**\n         * Returns whether any elements of this stream match the provided predicate. May not evaluate the predicate on all\n         * elements if not necessary for determining the result. If the stream is empty then {@code false} is returned and the\n         * predicate is not evaluated.\n         *\n         * <p>\n         * This is a short-circuiting terminal operation.\n         * </p>\n         *\n         * Note This method evaluates the <em>existential quantification</em> of the predicate over the elements of the stream\n         * (for some x P(x)).\n         *\n         * @param predicate A non-interfering, stateless predicate to apply to elements of this stream\n         * @return {@code true} if any elements of the stream match the provided predicate, otherwise {@code false}\n         */\n        public boolean anyMatch(final FailablePredicate<T, ?> predicate) {\n            assertNotTerminated();\n            return stream().anyMatch(Failable.asPredicate(predicate));\n        }\n\n        /**\n         * Throws IllegalStateException if this stream is already terminated.\n         *\n         * @throws IllegalStateException if this stream is already terminated.\n         */\n        protected void assertNotTerminated() {\n            if (terminated) {\n                throw new IllegalStateException(\"This stream is already terminated.\");\n            }\n        }\n\n        /**\n         * Performs a mutable reduction operation on the elements of this stream using a {@link Collector}. A {@link Collector}\n         * encapsulates the functions used as arguments to {@link #collect(Supplier, BiConsumer, BiConsumer)}, allowing for\n         * reuse of collection strategies and composition of collect operations such as multiple-level grouping or partitioning.\n         *\n         * <p>\n         * If the underlying stream is parallel, and the {@link Collector} is concurrent, and either the stream is unordered or\n         * the collector is unordered, then a concurrent reduction will be performed (see {@link Collector} for details on\n         * concurrent reduction.)\n         * </p>\n         *\n         * <p>\n         * This is a terminal operation.\n         * </p>\n         *\n         * <p>\n         * When executed in parallel, multiple intermediate results may be instantiated, populated, and merged so as to maintain\n         * isolation of mutable data structures. Therefore, even when executed in parallel with non-thread-safe data structures\n         * (such as {@link ArrayList}), no additional synchronization is needed for a parallel reduction.\n         * </p>\n         *\n         * Note The following will accumulate strings into an ArrayList:\n         *\n         * <pre>\n         * {@code\n         *     List<String> asList = stringStream.collect(Collectors.toList());\n         * }\n         * </pre>\n         *\n         * <p>\n         * The following will classify {@code Person} objects by city:\n         * </p>\n         *\n         * <pre>\n         * {@code\n         *     Map<String, List<Person>> peopleByCity = personStream.collect(Collectors.groupingBy(Person::getCity));\n         * }\n         * </pre>\n         *\n         * <p>\n         * The following will classify {@code Person} objects by state and city, cascading two {@link Collector}s together:\n         * </p>\n         *\n         * <pre>\n         * {@code\n         *     Map<String, Map<String, List<Person>>> peopleByStateAndCity = personStream\n         *         .collect(Collectors.groupingBy(Person::getState, Collectors.groupingBy(Person::getCity)));\n         * }\n         * </pre>\n         *\n         * @param <R> the type of the result\n         * @param <A> the intermediate accumulation type of the {@link Collector}\n         * @param collector the {@link Collector} describing the reduction\n         * @return the result of the reduction\n         * @see #collect(Supplier, BiConsumer, BiConsumer)\n         * @see Collectors\n         */\n        public <A, R> R collect(final Collector<? super T, A, R> collector) {\n            makeTerminated();\n            return stream().collect(collector);\n        }\n\n        /**\n         * Performs a mutable reduction operation on the elements of this FailableStream. A mutable reduction is one in which\n         * the reduced value is a mutable result container, such as an {@link ArrayList}, and elements are incorporated by\n         * updating the state of the result rather than by replacing the result. This produces a result equivalent to:\n         *\n         * <pre>\n         * {@code\n         *     R result = supplier.get();\n         *     for (T element : this stream)\n         *         accumulator.accept(result, element);\n         *     return result;\n         * }\n         * </pre>\n         *\n         * <p>\n         * Like {@link #reduce(Object, BinaryOperator)}, {@code collect} operations can be parallelized without requiring\n         * additional synchronization.\n         * </p>\n         *\n         * <p>\n         * This is a terminal operation.\n         * </p>\n         *\n         * Note There are many existing classes in the JDK whose signatures are well-suited for use with method references as\n         * arguments to {@code collect()}. For example, the following will accumulate strings into an {@link ArrayList}:\n         *\n         * <pre>\n         * {@code\n         *     List<String> asList = stringStream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);\n         * }\n         * </pre>\n         *\n         * <p>\n         * The following will take a stream of strings and concatenates them into a single string:\n         * </p>\n         *\n         * <pre>\n         * {@code\n         *     String concat = stringStream.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();\n         * }\n         * </pre>\n         *\n         * @param <R> type of the result\n         * @param <A> Type of the accumulator.\n         * @param supplier a function that creates a new result container. For a parallel execution, this function may be called\n         *        multiple times and must return a fresh value each time.\n         * @param accumulator An associative, non-interfering, stateless function for incorporating an additional element into a\n         *        result\n         * @param combiner An associative, non-interfering, stateless function for combining two values, which must be\n         *        compatible with the accumulator function\n         * @return The result of the reduction\n         */\n        public <A, R> R collect(final Supplier<R> supplier, final BiConsumer<R, ? super T> accumulator, final BiConsumer<R, R> combiner) {\n            makeTerminated();\n            return stream().collect(supplier, accumulator, combiner);\n        }\n\n        /**\n         * Returns a FailableStream consisting of the elements of this stream that match the given FailablePredicate.\n         *\n         * <p>\n         * This is an intermediate operation.\n         * </p>\n         *\n         * @param predicate a non-interfering, stateless predicate to apply to each element to determine if it should be\n         *        included.\n         * @return the new stream\n         */\n        public FailableStream<T> filter(final FailablePredicate<T, ?> predicate) {\n            assertNotTerminated();\n            stream = stream.filter(Failable.asPredicate(predicate));\n            return this;\n        }\n\n        /**\n         * Performs an action for each element of this stream.\n         *\n         * <p>\n         * This is a terminal operation.\n         * </p>\n         *\n         * <p>\n         * The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines, this operation does\n         * <em>not</em> guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of\n         * parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library\n         * chooses. If the action accesses shared state, it is responsible for providing the required synchronization.\n         * </p>\n         *\n         * @param action a non-interfering action to perform on the elements\n         */\n        public void forEach(final FailableConsumer<T, ?> action) {\n            makeTerminated();\n            stream().forEach(Failable.asConsumer(action));\n        }\n\n        /**\n         * Marks this stream as terminated.\n         *\n         * @throws IllegalStateException if this stream is already terminated.\n         */\n        protected void makeTerminated() {\n            assertNotTerminated();\n            terminated = true;\n        }\n\n        /**\n         * Returns a stream consisting of the results of applying the given function to the elements of this stream.\n         *\n         * <p>\n         * This is an intermediate operation.\n         * </p>\n         *\n         * @param <R> The element type of the new stream\n         * @param mapper A non-interfering, stateless function to apply to each element\n         * @return the new stream\n         */\n        public <R> FailableStream<R> map(final FailableFunction<T, R, ?> mapper) {\n            assertNotTerminated();\n            return new FailableStream<>(stream.map(Failable.asFunction(mapper)));\n        }\n\n        /**\n         * Performs a reduction on the elements of this stream, using the provided identity value and an associative\n         * accumulation function, and returns the reduced value. This is equivalent to:\n         *\n         * <pre>\n         * {@code\n         *     T result = identity;\n         *     for (T element : this stream)\n         *         result = accumulator.apply(result, element)\n         *     return result;\n         * }\n         * </pre>\n         *\n         * but is not constrained to execute sequentially.\n         *\n         * <p>\n         * The {@code identity} value must be an identity for the accumulator function. This means that for all {@code t},\n         * {@code accumulator.apply(identity, t)} is equal to {@code t}. The {@code accumulator} function must be an associative\n         * function.\n         * </p>\n         *\n         * <p>\n         * This is a terminal operation.\n         * </p>\n         *\n         * Note Sum, min, max, average, and string concatenation are all special cases of reduction. Summing a stream of numbers\n         * can be expressed as:\n         *\n         * <pre>\n         * {@code\n         *     Integer sum = integers.reduce(0, (a, b) -> a + b);\n         * }\n         * </pre>\n         *\n         * or:\n         *\n         * <pre>\n         * {@code\n         *     Integer sum = integers.reduce(0, Integer::sum);\n         * }\n         * </pre>\n         *\n         * <p>\n         * While this may seem a more roundabout way to perform an aggregation compared to simply mutating a running total in a\n         * loop, reduction operations parallelize more gracefully, without needing additional synchronization and with greatly\n         * reduced risk of data races.\n         * </p>\n         *\n         * @param identity the identity value for the accumulating function\n         * @param accumulator an associative, non-interfering, stateless function for combining two values\n         * @return the result of the reduction\n         */\n        public T reduce(final T identity, final BinaryOperator<T> accumulator) {\n            makeTerminated();\n            return stream().reduce(identity, accumulator);\n        }\n\n        /**\n         * Converts the FailableStream into an equivalent stream.\n         *\n         * @return A stream, which will return the same elements, which this FailableStream would return.\n         */\n        public Stream<T> stream() {\n            return stream;\n        }\n    }\n\n    /**\n     * Converts the given {@link Collection} into a {@link FailableStream}. This is basically a simplified, reduced version\n     * of the {@link Stream} class, with the same underlying element stream, except that failable objects, like\n     * {@link FailablePredicate}, {@link FailableFunction}, or {@link FailableConsumer} may be applied, instead of\n     * {@link Predicate}, {@link Function}, or {@link Consumer}. The idea is to rewrite a code snippet like this:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final Function<O, String> mapper = (o) -> {\n     *     try {\n     *         return (String) m.invoke(o);\n     *     } catch (Throwable t) {\n     *         throw Failable.rethrow(t);\n     *     }\n     * };\n     * final List<String> strList = list.stream().map(mapper).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * as follows:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final List<String> strList = Failable.stream(list.stream()).map((o) -> (String) m.invoke(o)).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * While the second version may not be <em>quite</em> as efficient (because it depends on the creation of additional,\n     * intermediate objects, of type FailableStream), it is much more concise, and readable, and meets the spirit of Lambdas\n     * better than the first version.\n     *\n     * @param <T> The streams element type.\n     * @param stream The stream, which is being converted.\n     * @return The {@link FailableStream}, which has been created by converting the stream.\n     * @since 3.13.0\n     */\n    public static <T> FailableStream<T> failableStream(final Collection<T> stream) {\n        return failableStream(of(stream));\n    }\n\n    /**\n     * Converts the given {@link Stream stream} into a {@link FailableStream}. This is basically a simplified, reduced\n     * version of the {@link Stream} class, with the same underlying element stream, except that failable objects, like\n     * {@link FailablePredicate}, {@link FailableFunction}, or {@link FailableConsumer} may be applied, instead of\n     * {@link Predicate}, {@link Function}, or {@link Consumer}. The idea is to rewrite a code snippet like this:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final Function<O, String> mapper = (o) -> {\n     *     try {\n     *         return (String) m.invoke(o);\n     *     } catch (Throwable t) {\n     *         throw Failable.rethrow(t);\n     *     }\n     * };\n     * final List<String> strList = list.stream().map(mapper).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * as follows:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final List<String> strList = Failable.stream(list.stream()).map((o) -> (String) m.invoke(o)).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * While the second version may not be <em>quite</em> as efficient (because it depends on the creation of additional,\n     * intermediate objects, of type FailableStream), it is much more concise, and readable, and meets the spirit of Lambdas\n     * better than the first version.\n     *\n     * @param <T> The streams element type.\n     * @param stream The stream, which is being converted.\n     * @return The {@link FailableStream}, which has been created by converting the stream.\n     * @since 3.13.0\n     */\n    public static <T> FailableStream<T> failableStream(final Stream<T> stream) {\n        return new FailableStream<>(stream);\n    }\n\n    /**\n     * Shorthand for {@code Streams.failableStream(value == null ? Stream.empty() : Stream.of(value))}.\n     *\n     * @param <T> the type of stream elements.\n     * @param value the single element of the new stream, may be {@code null}.\n     * @return the new FailableStream on {@code value} or an empty stream.\n     * @since 3.15.0\n     */\n    public static <T> FailableStream<T> failableStream(final T value) {\n        return failableStream(value == null ? Stream.empty() : Stream.of(value));\n    }\n\n    /**\n     * Shorthand for {@code Streams.failableStream(Streams.of(arrayValues))}.\n     *\n     * @param <T> the type of stream elements.\n     * @param values the elements of the new stream, may be {@code null}.\n     * @return the new FailableStream on {@code values} or an empty stream.\n     * @since 3.14.0\n     */\n    @SafeVarargs // Creating a stream from an array is safe\n    public static <T> FailableStream<T> failableStream(final T... values) {\n        return failableStream(of(values));\n    }\n\n    /**\n     * Streams only instances of the give Class in a collection.\n     * <p>\n     * This method shorthand for:\n     * </p>\n     * <pre>\n     * {@code (Stream<E>) Streams.toStream(collection).filter(collection, SomeClass.class::isInstance);}\n     * </pre>\n     *\n     * @param <E> the type of elements in the collection we want to stream.\n     * @param clazz the type of elements in the collection we want to stream.\n     * @param collection the collection to stream or null.\n     * @return A non-null stream that only provides instances we want.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> instancesOf(final Class<? super E> clazz, final Collection<? super E> collection) {\n        return instancesOf(clazz, of(collection));\n    }\n\n    @SuppressWarnings(\"unchecked\") // After the isInstance check, we still need to type-cast.\n    private static <E> Stream<E> instancesOf(final Class<? super E> clazz, final Stream<?> stream) {\n        return (Stream<E>) of(stream).filter(clazz::isInstance);\n    }\n\n    /**\n     * Streams the non-null elements of a collection.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param collection the collection to stream or null.\n     * @return A non-null stream that filters out null elements.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> nonNull(final Collection<E> collection) {\n        return of(collection).filter(Objects::nonNull);\n    }\n\n    /**\n     * Streams the non-null elements of an array.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param array the array to stream or null.\n     * @return A non-null stream that filters out null elements.\n     * @since 3.13.0\n     */\n    @SafeVarargs\n    public static <E> Stream<E> nonNull(final E... array) {\n        return nonNull(of(array));\n    }\n\n    /**\n     * Streams the non-null elements of a stream.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param stream the stream to stream or null.\n     * @return A non-null stream that filters out null elements.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> nonNull(final Stream<E> stream) {\n        return of(stream).filter(Objects::nonNull);\n    }\n\n    /**\n     * Delegates to {@link Collection#stream()} or returns {@link Stream#empty()} if the collection is null.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param collection the collection to stream or null.\n     * @return {@link Collection#stream()} or {@link Stream#empty()} if the collection is null.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> of(final Collection<E> collection) {\n        return collection == null ? Stream.empty() : collection.stream();\n    }\n\n    /**\n     * Streams the elements of the given enumeration in order.\n     *\n     * @param <E> The enumeration element type.\n     * @param enumeration The enumeration to stream.\n     * @return a new stream.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> of(final Enumeration<E> enumeration) {\n        return StreamSupport.stream(new EnumerationSpliterator<>(Long.MAX_VALUE, Spliterator.ORDERED, enumeration), false);\n    }\n\n    /**\n     * Creates a stream on the given Iterable.\n     *\n     * @param <E> the type of elements in the Iterable.\n     * @param iterable the Iterable to stream or null.\n     * @return a new Stream or {@link Stream#empty()} if the Iterable is null.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> of(final Iterable<E> iterable) {\n        return iterable == null ? Stream.empty() : StreamSupport.stream(iterable.spliterator(), false);\n    }\n\n    /**\n     * Creates a stream on the given Iterator.\n     *\n     * @param <E> the type of elements in the Iterator.\n     * @param iterator the Iterator to stream or null.\n     * @return a new Stream or {@link Stream#empty()} if the Iterator is null.\n     * @since 3.13.0\n     */\n    public static <E> Stream<E> of(final Iterator<E> iterator) {\n        return iterator == null ? Stream.empty() : StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, Spliterator.ORDERED), false);\n    }\n\n    /**\n     * Returns the stream or {@link Stream#empty()} if the stream is null.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param stream the stream to stream or null.\n     * @return the stream or {@link Stream#empty()} if the stream is null.\n     * @since 3.13.0\n     */\n    private static <E> Stream<E> of(final Stream<E> stream) {\n        return stream == null ? Stream.empty() : stream;\n    }\n\n    /**\n     * Null-safe version of {@link Stream#of(Object[])}.\n     *\n     * @param <T> the type of stream elements.\n     * @param values the elements of the new stream, may be {@code null}.\n     * @return the new stream on {@code values} or {@link Stream#empty()}.\n     * @since 3.13.0\n     */\n    @SafeVarargs // Creating a stream from an array is safe\n    public static <T> Stream<T> of(final T... values) {\n        return values == null ? Stream.empty() : Stream.of(values);\n    }\n\n    /**\n     * Converts the given {@link Collection} into a {@link FailableStream}. This is basically a simplified, reduced version\n     * of the {@link Stream} class, with the same underlying element stream, except that failable objects, like\n     * {@link FailablePredicate}, {@link FailableFunction}, or {@link FailableConsumer} may be applied, instead of\n     * {@link Predicate}, {@link Function}, or {@link Consumer}. The idea is to rewrite a code snippet like this:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final Function<O, String> mapper = (o) -> {\n     *     try {\n     *         return (String) m.invoke(o);\n     *     } catch (Throwable t) {\n     *         throw Failable.rethrow(t);\n     *     }\n     * };\n     * final List<String> strList = list.stream().map(mapper).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * as follows:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final List<String> strList = Failable.stream(list.stream()).map((o) -> (String) m.invoke(o)).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * While the second version may not be <em>quite</em> as efficient (because it depends on the creation of additional,\n     * intermediate objects, of type FailableStream), it is much more concise, and readable, and meets the spirit of Lambdas\n     * better than the first version.\n     *\n     * @param <E> The streams element type.\n     * @param collection The stream, which is being converted.\n     * @return The {@link FailableStream}, which has been created by converting the stream.\n     * @deprecated Use {@link #failableStream(Collection)}.\n     */\n    @Deprecated\n    public static <E> FailableStream<E> stream(final Collection<E> collection) {\n        return failableStream(collection);\n    }\n\n    /**\n     * Converts the given {@link Stream stream} into a {@link FailableStream}. This is basically a simplified, reduced\n     * version of the {@link Stream} class, with the same underlying element stream, except that failable objects, like\n     * {@link FailablePredicate}, {@link FailableFunction}, or {@link FailableConsumer} may be applied, instead of\n     * {@link Predicate}, {@link Function}, or {@link Consumer}. The idea is to rewrite a code snippet like this:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final Function<O, String> mapper = (o) -> {\n     *     try {\n     *         return (String) m.invoke(o);\n     *     } catch (Throwable t) {\n     *         throw Failable.rethrow(t);\n     *     }\n     * };\n     * final List<String> strList = list.stream().map(mapper).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * as follows:\n     *\n     * <pre>\n     * {@code\n     * final List<O> list;\n     * final Method m;\n     * final List<String> strList = Failable.stream(list.stream()).map((o) -> (String) m.invoke(o)).collect(Collectors.toList());\n     * }\n     * </pre>\n     *\n     * While the second version may not be <em>quite</em> as efficient (because it depends on the creation of additional,\n     * intermediate objects, of type FailableStream), it is much more concise, and readable, and meets the spirit of Lambdas\n     * better than the first version.\n     *\n     * @param <T> The streams element type.\n     * @param stream The stream, which is being converted.\n     * @return The {@link FailableStream}, which has been created by converting the stream.\n     * @deprecated Use {@link #failableStream(Stream)}.\n     */\n    @Deprecated\n    public static <T> FailableStream<T> stream(final Stream<T> stream) {\n        return failableStream(stream);\n    }\n\n    /**\n     * Returns a {@link Collector} that accumulates the input elements into a new array.\n     *\n     * @param pElementType Type of an element in the array.\n     * @param <T> the type of the input elements\n     * @return a {@link Collector} which collects all the input elements into an array, in encounter order\n     */\n    public static <T> Collector<T, ?, T[]> toArray(final Class<T> pElementType) {\n        return new ArrayCollector<>(pElementType);\n    }\n\n    /**\n     * Make private in 4.0.\n     *\n     * @deprecated TODO Make private in 4.0.\n     */\n    @Deprecated\n    public Streams() {\n        // empty\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Inline Method",
        "description": "Inline Method\tpackage validateNullToStringStyleRegistry() : void inlined to public after() : void in class org.apache.commons.lang3.AbstractLangTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/AbstractLangTest.java",
                "startLine": 29,
                "endLine": 35,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/AbstractLangTest.java",
                "startLine": 29,
                "endLine": 35,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/AbstractLangTest.java",
                "startLine": 37,
                "endLine": 39,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "void validateNullToStringStyleRegistry() {\n        assertNull(ToStringStyle.getRegistry(), \"Expected null, actual: \" + ToStringStyle.getRegistry());\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/AbstractLangTest.java",
        "isPureRefactoring": true,
        "commitId": "bddf9a30941a266476ef88903f634c8d26c0a14f",
        "packageNameBefore": "org.apache.commons.lang3",
        "classNameBefore": "org.apache.commons.lang3.AbstractLangTest",
        "methodNameBefore": "org.apache.commons.lang3.AbstractLangTest#validateNullToStringStyleRegistry",
        "classSignatureBefore": "public class AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.AbstractLangTest#validateNullToStringStyleRegistry"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.AbstractLangTest"
        ],
        "classSignatureBeforeSet": [
            "public class AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport org.apache.commons.lang3.builder.ToStringStyle;\nimport org.junit.jupiter.api.AfterEach;\n\n/**\n * All tests subclass this test.\n */\npublic class AbstractLangTest {\n\n    /**\n     * All tests should leave the {@link ToStringStyle} registry empty.\n     */\n    @AfterEach\n    public void after() {\n        validateNullToStringStyleRegistry();\n    }\n\n    void validateNullToStringStyleRegistry() {\n        assertNull(ToStringStyle.getRegistry(), \"Expected null, actual: \" + ToStringStyle.getRegistry());\n    }\n\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/AbstractLangTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport org.apache.commons.lang3.builder.ToStringStyle;\nimport org.junit.jupiter.api.AfterEach;\n\n/**\n * All tests subclass this test.\n */\npublic class AbstractLangTest {\n\n    /**\n     * All tests should leave the {@link ToStringStyle} registry empty.\n     */\n    @AfterEach\n    public void after() {\n        assertNull(ToStringStyle.getRegistry(), \"Expected null, actual: \" + ToStringStyle.getRegistry());\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * All tests should leave the {@link ToStringStyle} registry empty.\n     */\n    @AfterEach\n    public void after() {\n        assertNull(ToStringStyle.getRegistry(), \"Expected null, actual: \" + ToStringStyle.getRegistry());\n    }",
        "diffSourceCode": "    29:     /**\n    30:      * All tests should leave the {@link ToStringStyle} registry empty.\n    31:      */\n    32:     @AfterEach\n    33:     public void after() {\n-   34:         validateNullToStringStyleRegistry();\n+   34:         assertNull(ToStringStyle.getRegistry(), \"Expected null, actual: \" + ToStringStyle.getRegistry());\n    35:     }\n-   37:     void validateNullToStringStyleRegistry() {\n-   38:         assertNull(ToStringStyle.getRegistry(), \"Expected null, actual: \" + ToStringStyle.getRegistry());\n-   39:     }\n+   37: }\n",
        "uniqueId": "bddf9a30941a266476ef88903f634c8d26c0a14f_29_35__29_35_37_39",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": true,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport org.apache.commons.lang3.builder.ToStringStyle;\nimport org.junit.jupiter.api.AfterEach;\n\n/**\n * All tests subclass this test.\n */\npublic class AbstractLangTest {\n\n    /**\n     * All tests should leave the {@link ToStringStyle} registry empty.\n     */\n    @AfterEach\n    public void after() {\n        assertNull(ToStringStyle.getRegistry(), \"Expected null, actual: \" + ToStringStyle.getRegistry());\n    }\n\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nvoid validateNullToStringStyleRegistry() {\n        assertNull(ToStringStyle.getRegistry(), \"Expected null, actual: \" + ToStringStyle.getRegistry());\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport org.apache.commons.lang3.builder.ToStringStyle;\nimport org.junit.jupiter.api.AfterEach;\n\n/**\n * All tests subclass this test.\n */\npublic class AbstractLangTest {\n\n    /**\n     * All tests should leave the {@link ToStringStyle} registry empty.\n     */\n    @AfterEach\n    public void after() {\n        validateNullToStringStyleRegistry();\n    }\n\n    void validateNullToStringStyleRegistry() {\n        assertNull(ToStringStyle.getRegistry(), \"Expected null, actual: \" + ToStringStyle.getRegistry());\n    }\n\n}\n\nRefactoring Operation:\nInline Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\nrefactored_class_code\n##########################\n\n\n",
        "toolAfterCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport org.apache.commons.lang3.builder.ToStringStyle;\nimport org.junit.jupiter.api.AfterEach;\n\n/**\n * All tests subclass this test.\n */\npublic class AbstractLangTest {\n\n    /**\n     * All tests should leave the {@link ToStringStyle} registry empty.\n     */\n    @AfterEach\n    public void after() {\n        assertNull(ToStringStyle.getRegistry(), \"Expected null, actual: \" + ToStringStyle.getRegistry());\n    }\n\n}",
        "codebleu": 0.25,
        "ngram_match_score": 0,
        "syntax_match_score": 0.0,
        "weighted_ngram_match_score": 0,
        "dataflow_match_score": 0
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate toExcludeFieldNames(excludeFieldNames String[]) : String[] extracted from public setExcludeFieldNames(excludeFieldNamesParam String...) : ReflectionDiffBuilder<T> in class org.apache.commons.lang3.builder.ReflectionDiffBuilder",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/builder/ReflectionDiffBuilder.java",
                "startLine": 163,
                "endLine": 179,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/builder/ReflectionDiffBuilder.java",
                "startLine": 235,
                "endLine": 247,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/builder/ReflectionDiffBuilder.java",
                "startLine": 133,
                "endLine": 139,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Sets the field names to exclude.\n     *\n     * @param excludeFieldNamesParam\n     *            The field names to exclude from the diff or {@code null}.\n     * @return {@code this}\n     * @since 3.13.0\n     */\n    public ReflectionDiffBuilder<T> setExcludeFieldNames(final String... excludeFieldNamesParam) {\n        if (excludeFieldNamesParam == null) {\n            this.excludeFieldNames = ArrayUtils.EMPTY_STRING_ARRAY;\n        } else {\n            // clone and remove nulls\n            this.excludeFieldNames = ArraySorter.sort(ReflectionToStringBuilder.toNoNullStringArray(excludeFieldNamesParam));\n        }\n        return this;\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/builder/ReflectionDiffBuilder.java",
        "isPureRefactoring": true,
        "commitId": "4949adec480ddccdee4f7d09231e85e84fec00a1",
        "packageNameBefore": "org.apache.commons.lang3.builder",
        "classNameBefore": "org.apache.commons.lang3.builder.ReflectionDiffBuilder",
        "methodNameBefore": "org.apache.commons.lang3.builder.ReflectionDiffBuilder#setExcludeFieldNames",
        "classSignatureBefore": "public class ReflectionDiffBuilder<T> implements Builder<DiffResult<T>> ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.builder.ReflectionDiffBuilder#setExcludeFieldNames"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.builder.ReflectionDiffBuilder"
        ],
        "classSignatureBeforeSet": [
            "public class ReflectionDiffBuilder<T> implements Builder<DiffResult<T>> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Variable-",
                "description": "Rename Variable on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.builder;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\n\nimport org.apache.commons.lang3.ArraySorter;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.ClassUtils;\nimport org.apache.commons.lang3.reflect.FieldUtils;\n\n/**\n * Assists in implementing {@link Diffable#diff(Object)} methods.\n *\n * <p>\n * All non-static, non-transient fields (including inherited fields)\n * of the objects to diff are discovered using reflection and compared\n * for differences.\n * </p>\n *\n * <p>\n * To use this class, write code as follows:\n * </p>\n *\n * <pre>\n * public class Person implements Diffable&lt;Person&gt; {\n *   String name;\n *   int age;\n *   boolean smoker;\n *   ...\n *\n *   public DiffResult diff(Person obj) {\n *     // No need for null check, as NullPointerException correct if obj is null\n *     return new ReflectionDiffBuilder(this, obj, ToStringStyle.SHORT_PREFIX_STYLE)\n *       .build();\n *   }\n * }\n * </pre>\n *\n * <p>\n * The {@link ToStringStyle} passed to the constructor is embedded in the\n * returned {@link DiffResult} and influences the style of the\n * {@code DiffResult.toString()} method. This style choice can be overridden by\n * calling {@link DiffResult#toString(ToStringStyle)}.\n * </p>\n * <p>\n * See {@link DiffBuilder} for a non-reflection based version of this class.\n * </p>\n * @param <T>\n *            type of the left and right object to diff.\n * @see Diffable\n * @see Diff\n * @see DiffResult\n * @see ToStringStyle\n * @see DiffBuilder\n * @since 3.6\n */\npublic class ReflectionDiffBuilder<T> implements Builder<DiffResult<T>> {\n\n    private final T left;\n    private final T right;\n    private final DiffBuilder<T> diffBuilder;\n\n    /**\n     * Field names to exclude from output. Intended for fields like {@code \"password\"} or {@code \"lastModificationDate\"}.\n     *\n     * @since 3.13.0\n     */\n    private String[] excludeFieldNames;\n\n    /**\n     * Constructs a builder for the specified objects with the specified style.\n     *\n     * <p>\n     * If {@code lhs == rhs} or {@code lhs.equals(rhs)} then the builder will\n     * not evaluate any calls to {@code append(...)} and will return an empty\n     * {@link DiffResult} when {@link #build()} is executed.\n     * </p>\n     * @param lhs\n     *            {@code this} object\n     * @param rhs\n     *            the object to diff against\n     * @param style\n     *            the style will use when outputting the objects, {@code null}\n     *            uses the default\n     * @throws IllegalArgumentException\n     *             if {@code lhs} or {@code rhs} is {@code null}\n     */\n    public ReflectionDiffBuilder(final T lhs, final T rhs, final ToStringStyle style) {\n        this.left = lhs;\n        this.right = rhs;\n        this.diffBuilder = DiffBuilder.<T>builder().setLeft(lhs).setRight(rhs).setStyle(style).build();\n    }\n\n    private boolean accept(final Field field) {\n        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n            return false;\n        }\n        if (Modifier.isTransient(field.getModifiers())) {\n            return false;\n        }\n        if (Modifier.isStatic(field.getModifiers())) {\n            return false;\n        }\n        if (this.excludeFieldNames != null\n                && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\n            // Reject fields from the getExcludeFieldNames list.\n            return false;\n        }\n        return !field.isAnnotationPresent(DiffExclude.class);\n    }\n\n    private void appendFields(final Class<?> clazz) {\n        for (final Field field : FieldUtils.getAllFields(clazz)) {\n            if (accept(field)) {\n                try {\n                    diffBuilder.append(field.getName(), FieldUtils.readField(field, left, true), FieldUtils.readField(field, right, true));\n                } catch (final IllegalAccessException e) {\n                    // this can't happen. Would get a Security exception instead\n                    // throw a runtime exception in case the impossible happens.\n                    throw new IllegalArgumentException(\"Unexpected IllegalAccessException: \" + e.getMessage(), e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public DiffResult<T> build() {\n        if (left.equals(right)) {\n            return diffBuilder.build();\n        }\n\n        appendFields(left.getClass());\n        return diffBuilder.build();\n    }\n\n    /**\n     * Gets the field names that should be excluded from the diff.\n     *\n     * @return Returns the excludeFieldNames.\n     * @since 3.13.0\n     */\n    public String[] getExcludeFieldNames() {\n        return this.excludeFieldNames.clone();\n    }\n\n    /**\n     * Sets the field names to exclude.\n     *\n     * @param excludeFieldNamesParam\n     *            The field names to exclude from the diff or {@code null}.\n     * @return {@code this}\n     * @since 3.13.0\n     */\n    public ReflectionDiffBuilder<T> setExcludeFieldNames(final String... excludeFieldNamesParam) {\n        if (excludeFieldNamesParam == null) {\n            this.excludeFieldNames = ArrayUtils.EMPTY_STRING_ARRAY;\n        } else {\n            // clone and remove nulls\n            this.excludeFieldNames = ArraySorter.sort(ReflectionToStringBuilder.toNoNullStringArray(excludeFieldNamesParam));\n        }\n        return this;\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/builder/ReflectionDiffBuilder.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.builder;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\n\nimport org.apache.commons.lang3.ArraySorter;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.ClassUtils;\nimport org.apache.commons.lang3.reflect.FieldUtils;\n\n/**\n * Assists in implementing {@link Diffable#diff(Object)} methods.\n *\n * <p>\n * All non-static, non-transient fields (including inherited fields) of the objects to diff are discovered using reflection and compared for differences.\n * </p>\n *\n * <p>\n * To use this class, write code as follows:\n * </p>\n *\n * <pre>{@code\n * public class Person implements Diffable&lt;Person&gt; {\n *   String name;\n *   int age;\n *   boolean smoker;\n *   ...\n *\n *   public DiffResult diff(Person obj) {\n *     // No need for null check, as NullPointerException correct if obj is null\n *     return new ReflectionDiffBuilder.<Person>builder()\n *       .setDiffBuilder(DiffBuilder.<Person>builder()\n *           .setLeft(this)\n *           .setRight(obj)\n *           .setStyle(ToStringStyle.SHORT_PREFIX_STYLE)\n *           .build())\n *       .setExcludeFieldNames(\"userName\", \"password\")\n *       .build();\n *   }\n * }\n * }</pre>\n *\n * <p>\n * The {@link ToStringStyle} passed to the constructor is embedded in the returned {@link DiffResult} and influences the style of the\n * {@code DiffResult.toString()} method. This style choice can be overridden by calling {@link DiffResult#toString(ToStringStyle)}.\n * </p>\n * <p>\n * See {@link DiffBuilder} for a non-reflection based version of this class.\n * </p>\n *\n * @param <T> type of the left and right object to diff.\n * @see Diffable\n * @see Diff\n * @see DiffResult\n * @see ToStringStyle\n * @see DiffBuilder\n * @since 3.6\n */\npublic class ReflectionDiffBuilder<T> implements Builder<DiffResult<T>> {\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param <T> type of the left and right object.\n     * @since 3.15.0\n     */\n    public static final class Builder<T> {\n\n        private String[] excludeFieldNames = ArrayUtils.EMPTY_STRING_ARRAY;\n        private DiffBuilder<T> diffBuilder;\n\n        /**\n         * Builds a new configured {@link ReflectionDiffBuilder}.\n         *\n         * @return a new configured {@link ReflectionDiffBuilder}.\n         */\n        public ReflectionDiffBuilder<T> build() {\n            return new ReflectionDiffBuilder<>(diffBuilder, excludeFieldNames);\n        }\n\n        /**\n         * Sets the DiffBuilder.\n         *\n         * @param diffBuilder the DiffBuilder.\n         * @return this.\n         */\n        public Builder<T> setDiffBuilder(final DiffBuilder<T> diffBuilder) {\n            this.diffBuilder = diffBuilder;\n            return this;\n        }\n\n        /**\n         * Sets field names to exclude from output. Intended for fields like {@code \"password\"} or {@code \"lastModificationDate\"}.\n         *\n         * @param excludeFieldNames field names to exclude.\n         * @return this.\n         */\n        public Builder<T> setExcludeFieldNames(final String... excludeFieldNames) {\n            this.excludeFieldNames = toExcludeFieldNames(excludeFieldNames);\n            return this;\n        }\n\n    }\n\n    /**\n     * Constructs a new {@link Builder}.\n     *\n     * @param <T> type of the left and right object.\n     * @return a new {@link Builder}.\n     * @since 3.15.0\n     */\n    public static <T> Builder<T> builder() {\n        return new Builder<>();\n    }\n\n    private static String[] toExcludeFieldNames(final String[] excludeFieldNames) {\n        if (excludeFieldNames == null) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        // clone and remove nulls\n        return ArraySorter.sort(ReflectionToStringBuilder.toNoNullStringArray(excludeFieldNames));\n    }\n\n    private final DiffBuilder<T> diffBuilder;\n\n    /**\n     * Field names to exclude from output. Intended for fields like {@code \"password\"} or {@code \"lastModificationDate\"}.\n     */\n    private String[] excludeFieldNames;\n\n    private ReflectionDiffBuilder(final DiffBuilder<T> diffBuilder, final String[] excludeFieldNames) {\n        this.diffBuilder = diffBuilder;\n        this.excludeFieldNames = excludeFieldNames;\n    }\n\n    /**\n     * Constructs a builder for the specified objects with the specified style.\n     *\n     * <p>\n     * If {@code left == right} or {@code left.equals(right)} then the builder will not evaluate any calls to {@code append(...)} and will return an empty\n     * {@link DiffResult} when {@link #build()} is executed.\n     * </p>\n     *\n     * @param left  {@code this} object.\n     * @param right the object to diff against.\n     * @param style the style will use when outputting the objects, {@code null} uses the default\n     * @throws IllegalArgumentException if {@code left} or {@code right} is {@code null}.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public ReflectionDiffBuilder(final T left, final T right, final ToStringStyle style) {\n        this(DiffBuilder.<T>builder().setLeft(left).setRight(right).setStyle(style).build(), null);\n    }\n\n    private boolean accept(final Field field) {\n        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n            return false;\n        }\n        if (Modifier.isTransient(field.getModifiers())) {\n            return false;\n        }\n        if (Modifier.isStatic(field.getModifiers())) {\n            return false;\n        }\n        if (this.excludeFieldNames != null && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\n            // Reject fields from the getExcludeFieldNames list.\n            return false;\n        }\n        return !field.isAnnotationPresent(DiffExclude.class);\n    }\n\n    private void appendFields(final Class<?> clazz) {\n        for (final Field field : FieldUtils.getAllFields(clazz)) {\n            if (accept(field)) {\n                try {\n                    diffBuilder.append(field.getName(), readField(field, getLeft()), readField(field, getRight()));\n                } catch (final IllegalAccessException e) {\n                    // this can't happen. Would get a Security exception instead\n                    // throw a runtime exception in case the impossible happens.\n                    throw new IllegalArgumentException(\"Unexpected IllegalAccessException: \" + e.getMessage(), e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public DiffResult<T> build() {\n        if (getLeft().equals(getRight())) {\n            return diffBuilder.build();\n        }\n\n        appendFields(getLeft().getClass());\n        return diffBuilder.build();\n    }\n\n    /**\n     * Gets the field names that should be excluded from the diff.\n     *\n     * @return Returns the excludeFieldNames.\n     * @since 3.13.0\n     */\n    public String[] getExcludeFieldNames() {\n        return this.excludeFieldNames.clone();\n    }\n\n    private T getLeft() {\n        return diffBuilder.getLeft();\n    }\n\n    private T getRight() {\n        return diffBuilder.getRight();\n    }\n\n    private Object readField(final Field field, final Object target) throws IllegalAccessException {\n        return FieldUtils.readField(field, target, true);\n    }\n\n    /**\n     * Sets the field names to exclude.\n     *\n     * @param excludeFieldNames The field names to exclude from the diff or {@code null}.\n     * @return {@code this}\n     * @since 3.13.0\n     * @deprecated Use {@link Builder#setExcludeFieldNames(String[])}.\n     */\n    @Deprecated\n    public ReflectionDiffBuilder<T> setExcludeFieldNames(final String... excludeFieldNames) {\n        this.excludeFieldNames = toExcludeFieldNames(excludeFieldNames);\n        return this;\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "private static String[] toExcludeFieldNames(final String[] excludeFieldNames) {\n        if (excludeFieldNames == null) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        // clone and remove nulls\n        return ArraySorter.sort(ReflectionToStringBuilder.toNoNullStringArray(excludeFieldNames));\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * Sets the field names to exclude.\n     *\n     * @param excludeFieldNames The field names to exclude from the diff or {@code null}.\n     * @return {@code this}\n     * @since 3.13.0\n     * @deprecated Use {@link Builder#setExcludeFieldNames(String[])}.\n     */\n    @Deprecated\n    public ReflectionDiffBuilder<T> setExcludeFieldNames(final String... excludeFieldNames) {\n        this.excludeFieldNames = toExcludeFieldNames(excludeFieldNames);\n        return this;\n    }\nprivate static String[] toExcludeFieldNames(final String[] excludeFieldNames) {\n        if (excludeFieldNames == null) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        // clone and remove nulls\n        return ArraySorter.sort(ReflectionToStringBuilder.toNoNullStringArray(excludeFieldNames));\n    }",
        "diffSourceCode": "-  133:                     diffBuilder.append(field.getName(), FieldUtils.readField(field, left, true), FieldUtils.readField(field, right, true));\n-  134:                 } catch (final IllegalAccessException e) {\n-  135:                     // this can't happen. Would get a Security exception instead\n-  136:                     // throw a runtime exception in case the impossible happens.\n-  137:                     throw new IllegalArgumentException(\"Unexpected IllegalAccessException: \" + e.getMessage(), e);\n-  138:                 }\n-  139:             }\n-  163:     /**\n-  164:      * Sets the field names to exclude.\n-  165:      *\n-  166:      * @param excludeFieldNamesParam\n-  167:      *            The field names to exclude from the diff or {@code null}.\n-  168:      * @return {@code this}\n-  169:      * @since 3.13.0\n-  170:      */\n-  171:     public ReflectionDiffBuilder<T> setExcludeFieldNames(final String... excludeFieldNamesParam) {\n-  172:         if (excludeFieldNamesParam == null) {\n-  173:             this.excludeFieldNames = ArrayUtils.EMPTY_STRING_ARRAY;\n-  174:         } else {\n-  175:             // clone and remove nulls\n-  176:             this.excludeFieldNames = ArraySorter.sort(ReflectionToStringBuilder.toNoNullStringArray(excludeFieldNamesParam));\n-  177:         }\n-  178:         return this;\n-  179:     }\n+  133:     private static String[] toExcludeFieldNames(final String[] excludeFieldNames) {\n+  134:         if (excludeFieldNames == null) {\n+  135:             return ArrayUtils.EMPTY_STRING_ARRAY;\n+  136:         }\n+  137:         // clone and remove nulls\n+  138:         return ArraySorter.sort(ReflectionToStringBuilder.toNoNullStringArray(excludeFieldNames));\n+  139:     }\n+  163:      * @param style the style will use when outputting the objects, {@code null} uses the default\n+  164:      * @throws IllegalArgumentException if {@code left} or {@code right} is {@code null}.\n+  165:      * @deprecated Use {@link Builder}.\n+  166:      */\n+  167:     @Deprecated\n+  168:     public ReflectionDiffBuilder(final T left, final T right, final ToStringStyle style) {\n+  169:         this(DiffBuilder.<T>builder().setLeft(left).setRight(right).setStyle(style).build(), null);\n+  170:     }\n+  171: \n+  172:     private boolean accept(final Field field) {\n+  173:         if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n+  174:             return false;\n+  175:         }\n+  176:         if (Modifier.isTransient(field.getModifiers())) {\n+  177:             return false;\n+  178:         }\n+  179:         if (Modifier.isStatic(field.getModifiers())) {\n+  235:     /**\n+  236:      * Sets the field names to exclude.\n+  237:      *\n+  238:      * @param excludeFieldNames The field names to exclude from the diff or {@code null}.\n+  239:      * @return {@code this}\n+  240:      * @since 3.13.0\n+  241:      * @deprecated Use {@link Builder#setExcludeFieldNames(String[])}.\n+  242:      */\n+  243:     @Deprecated\n+  244:     public ReflectionDiffBuilder<T> setExcludeFieldNames(final String... excludeFieldNames) {\n+  245:         this.excludeFieldNames = toExcludeFieldNames(excludeFieldNames);\n+  246:         return this;\n+  247:     }\n",
        "uniqueId": "4949adec480ddccdee4f7d09231e85e84fec00a1_163_179_133_139_235_247",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 14
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Initializes the excludeFieldNames array based on the input parameter.\n *\n * @param excludeFieldNamesParam\n *            The field names to exclude from the diff or {@code null}.\n */\nprivate void initializeExcludeFieldNames(final String... excludeFieldNamesParam) {\n    if (excludeFieldNamesParam == null) {\n        this.excludeFieldNames = ArrayUtils.EMPTY_STRING_ARRAY;\n    } else {\n        // clone and remove nulls\n        this.excludeFieldNames = ArraySorter.sort(ReflectionToStringBuilder.toNoNullStringArray(excludeFieldNamesParam));\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Sets the field names to exclude.\n     *\n     * @param excludeFieldNamesParam\n     *            The field names to exclude from the diff or {@code null}.\n     * @return {@code this}\n     * @since 3.13.0\n     */\n    public ReflectionDiffBuilder<T> setExcludeFieldNames(final String... excludeFieldNamesParam) {\n        if (excludeFieldNamesParam == null) {\n            this.excludeFieldNames = ArrayUtils.EMPTY_STRING_ARRAY;\n        } else {\n            // clone and remove nulls\n            this.excludeFieldNames = ArraySorter.sort(ReflectionToStringBuilder.toNoNullStringArray(excludeFieldNamesParam));\n        }\n        return this;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.builder;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\n\nimport org.apache.commons.lang3.ArraySorter;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.ClassUtils;\nimport org.apache.commons.lang3.reflect.FieldUtils;\n\n/**\n * Assists in implementing {@link Diffable#diff(Object)} methods.\n *\n * <p>\n * All non-static, non-transient fields (including inherited fields)\n * of the objects to diff are discovered using reflection and compared\n * for differences.\n * </p>\n *\n * <p>\n * To use this class, write code as follows:\n * </p>\n *\n * <pre>\n * public class Person implements Diffable&lt;Person&gt; {\n *   String name;\n *   int age;\n *   boolean smoker;\n *   ...\n *\n *   public DiffResult diff(Person obj) {\n *     // No need for null check, as NullPointerException correct if obj is null\n *     return new ReflectionDiffBuilder(this, obj, ToStringStyle.SHORT_PREFIX_STYLE)\n *       .build();\n *   }\n * }\n * </pre>\n *\n * <p>\n * The {@link ToStringStyle} passed to the constructor is embedded in the\n * returned {@link DiffResult} and influences the style of the\n * {@code DiffResult.toString()} method. This style choice can be overridden by\n * calling {@link DiffResult#toString(ToStringStyle)}.\n * </p>\n * <p>\n * See {@link DiffBuilder} for a non-reflection based version of this class.\n * </p>\n * @param <T>\n *            type of the left and right object to diff.\n * @see Diffable\n * @see Diff\n * @see DiffResult\n * @see ToStringStyle\n * @see DiffBuilder\n * @since 3.6\n */\npublic class ReflectionDiffBuilder<T> implements Builder<DiffResult<T>> {\n\n    private final T left;\n    private final T right;\n    private final DiffBuilder<T> diffBuilder;\n\n    /**\n     * Field names to exclude from output. Intended for fields like {@code \"password\"} or {@code \"lastModificationDate\"}.\n     *\n     * @since 3.13.0\n     */\n    private String[] excludeFieldNames;\n\n    /**\n     * Constructs a builder for the specified objects with the specified style.\n     *\n     * <p>\n     * If {@code lhs == rhs} or {@code lhs.equals(rhs)} then the builder will\n     * not evaluate any calls to {@code append(...)} and will return an empty\n     * {@link DiffResult} when {@link #build()} is executed.\n     * </p>\n     * @param lhs\n     *            {@code this} object\n     * @param rhs\n     *            the object to diff against\n     * @param style\n     *            the style will use when outputting the objects, {@code null}\n     *            uses the default\n     * @throws IllegalArgumentException\n     *             if {@code lhs} or {@code rhs} is {@code null}\n     */\n    public ReflectionDiffBuilder(final T lhs, final T rhs, final ToStringStyle style) {\n        this.left = lhs;\n        this.right = rhs;\n        this.diffBuilder = DiffBuilder.<T>builder().setLeft(lhs).setRight(rhs).setStyle(style).build();\n    }\n\n    private boolean accept(final Field field) {\n        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n            return false;\n        }\n        if (Modifier.isTransient(field.getModifiers())) {\n            return false;\n        }\n        if (Modifier.isStatic(field.getModifiers())) {\n            return false;\n        }\n        if (this.excludeFieldNames != null\n                && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\n            // Reject fields from the getExcludeFieldNames list.\n            return false;\n        }\n        return !field.isAnnotationPresent(DiffExclude.class);\n    }\n\n    private void appendFields(final Class<?> clazz) {\n        for (final Field field : FieldUtils.getAllFields(clazz)) {\n            if (accept(field)) {\n                try {\n                    diffBuilder.append(field.getName(), FieldUtils.readField(field, left, true), FieldUtils.readField(field, right, true));\n                } catch (final IllegalAccessException e) {\n                    // this can't happen. Would get a Security exception instead\n                    // throw a runtime exception in case the impossible happens.\n                    throw new IllegalArgumentException(\"Unexpected IllegalAccessException: \" + e.getMessage(), e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public DiffResult<T> build() {\n        if (left.equals(right)) {\n            return diffBuilder.build();\n        }\n\n        appendFields(left.getClass());\n        return diffBuilder.build();\n    }\n\n    /**\n     * Gets the field names that should be excluded from the diff.\n     *\n     * @return Returns the excludeFieldNames.\n     * @since 3.13.0\n     */\n    public String[] getExcludeFieldNames() {\n        return this.excludeFieldNames.clone();\n    }\n\n    /**\n     * Sets the field names to exclude.\n     *\n     * @param excludeFieldNamesParam\n     *            The field names to exclude from the diff or {@code null}.\n     * @return {@code this}\n     * @since 3.13.0\n     */\n    public ReflectionDiffBuilder<T> setExcludeFieldNames(final String... excludeFieldNamesParam) {\n        if (excludeFieldNamesParam == null) {\n            this.excludeFieldNames = ArrayUtils.EMPTY_STRING_ARRAY;\n        } else {\n            // clone and remove nulls\n            this.excludeFieldNames = ArraySorter.sort(ReflectionToStringBuilder.toNoNullStringArray(excludeFieldNamesParam));\n        }\n        return this;\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate nanosToMillis(nanos long) : long extracted from public getTime() : long in class org.apache.commons.lang3.time.StopWatch",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/time/StopWatch.java",
                "startLine": 367,
                "endLine": 379,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/time/StopWatch.java",
                "startLine": 367,
                "endLine": 379,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/time/StopWatch.java",
                "startLine": 431,
                "endLine": 439,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Gets the time on the stopwatch.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop.\n     * </p>\n     *\n     * @return the time in milliseconds\n     */\n    public long getTime() {\n        return getNanoTime() / NANO_2_MILLIS;\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/time/StopWatch.java",
        "isPureRefactoring": true,
        "commitId": "426ebb13ee04af4f7d7efcb6338e86b3a4ccca98",
        "packageNameBefore": "org.apache.commons.lang3.time",
        "classNameBefore": "org.apache.commons.lang3.time.StopWatch",
        "methodNameBefore": "org.apache.commons.lang3.time.StopWatch#getTime",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.time.StopWatch#getNanoTime\n methodBody: public long getNanoTime() {\nif(this.runningState == State.STOPPED || this.runningState == State.SUSPENDED){return this.stopTimeNanos - this.startTimeNanos;\n}if(this.runningState == State.UNSTARTED){return 0;\n}if(this.runningState == State.RUNNING){return System.nanoTime() - this.startTimeNanos;\n}throw new IllegalStateException(\"Illegal running state has occurred.\");\n}",
        "classSignatureBefore": "public class StopWatch ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.time.StopWatch#getTime"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.time.StopWatch"
        ],
        "classSignatureBeforeSet": [
            "public class StopWatch "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All the mappings are matched! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.lang3.time;\n\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * {@link StopWatch} provides a convenient API for timings.\n *\n * <p>\n * To start the watch, call {@link #start()} or {@link StopWatch#createStarted()}. At this point you can:\n * </p>\n * <ul>\n * <li>{@link #split()} the watch to get the time whilst the watch continues in the background. {@link #unsplit()} will\n * remove the effect of the split. At this point, these three options are available again.</li>\n * <li>{@link #suspend()} the watch to pause it. {@link #resume()} allows the watch to continue. Any time between the\n * suspend and resume will not be counted in the total. At this point, these three options are available again.</li>\n * <li>{@link #stop()} the watch to complete the timing session.</li>\n * </ul>\n *\n * <p>\n * It is intended that the output methods {@link #toString()} and {@link #getTime()} should only be called after stop,\n * split or suspend, however a suitable result will be returned at other points.\n * </p>\n *\n * <p>\n * NOTE: As from v2.1, the methods protect against inappropriate calls. Thus you cannot now call stop before start,\n * resume before suspend or unsplit before split.\n * </p>\n *\n * <p>\n * 1. split(), suspend(), or stop() cannot be invoked twice<br>\n * 2. unsplit() may only be called if the watch has been split()<br>\n * 3. resume() may only be called if the watch has been suspend()<br>\n * 4. start() cannot be called twice without calling reset()\n * </p>\n *\n * <p>This class is not thread-safe</p>\n *\n * @since 2.0\n */\npublic class StopWatch {\n\n    /**\n     * Enumeration type which indicates the split status of stopwatch.\n     */\n    private enum SplitState {\n        SPLIT,\n        UNSPLIT\n    }\n\n    /**\n     * Enumeration type which indicates the status of stopwatch.\n     */\n    private enum State {\n\n        RUNNING {\n            @Override\n            boolean isStarted() {\n                return true;\n            }\n            @Override\n            boolean isStopped() {\n                return false;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        },\n        STOPPED {\n            @Override\n            boolean isStarted() {\n                return false;\n            }\n            @Override\n            boolean isStopped() {\n                return true;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        },\n        SUSPENDED {\n            @Override\n            boolean isStarted() {\n                return true;\n            }\n            @Override\n            boolean isStopped() {\n                return false;\n            }\n            @Override\n            boolean isSuspended() {\n                return true;\n            }\n        },\n        UNSTARTED {\n            @Override\n            boolean isStarted() {\n                return false;\n            }\n            @Override\n            boolean isStopped() {\n                return true;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        };\n\n        /**\n         * Returns whether the StopWatch is started. A suspended StopWatch is also started watch.\n         *\n         * @return boolean If the StopWatch is started.\n         */\n        abstract boolean isStarted();\n\n        /**\n         * Returns whether the StopWatch is stopped. The stopwatch which's not yet started and explicitly stopped stopwatch is\n         * considered as stopped.\n         *\n         * @return boolean If the StopWatch is stopped.\n         */\n        abstract boolean isStopped();\n\n        /**\n         * Returns whether the StopWatch is suspended.\n         *\n         * @return boolean\n         *             If the StopWatch is suspended.\n         */\n        abstract boolean isSuspended();\n    }\n\n    private static final long NANO_2_MILLIS = 1000000L;\n\n    /**\n     * Creates a stopwatch for convenience.\n     *\n     * @return StopWatch a stopwatch.\n     *\n     * @since 3.10\n     */\n    public static StopWatch create() {\n        return new StopWatch();\n    }\n\n    /**\n     * Creates a started stopwatch for convenience.\n     *\n     * @return StopWatch a stopwatch that's already been started.\n     *\n     * @since 3.5\n     */\n    public static StopWatch createStarted() {\n        final StopWatch sw = new StopWatch();\n        sw.start();\n        return sw;\n    }\n\n    /**\n     * A message for string presentation.\n     *\n     * @since 3.10\n     */\n    private final String message;\n\n    /**\n     * The current running state of the StopWatch.\n     */\n    private State runningState = State.UNSTARTED;\n\n    /**\n     * Whether the stopwatch has a split time recorded.\n     */\n    private SplitState splitState = SplitState.UNSPLIT;\n\n    /**\n     * The start time in nanoseconds.\n     */\n    private long startTimeNanos;\n\n    /**\n     * The start time in milliseconds - nanoTime is only for elapsed time so we\n     * need to also store the currentTimeMillis to maintain the old\n     * getStartTime API.\n     */\n    private long startTimeMillis;\n\n    /**\n     * The end time in milliseconds - nanoTime is only for elapsed time so we\n     * need to also store the currentTimeMillis to maintain the old\n     * getStartTime API.\n     */\n    private long stopTimeMillis;\n\n    /**\n     * The stop time in nanoseconds.\n     */\n    private long stopTimeNanos;\n\n    /**\n     * Constructor.\n     *\n     */\n    public StopWatch() {\n        this(null);\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param message A message for string presentation.\n     * @since 3.10\n     */\n    public StopWatch(final String message) {\n        this.message = message;\n    }\n\n    /**\n     * Returns the split time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     *\n     * @return the split time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     * @since 3.10\n     */\n    public String formatSplitTime() {\n        return DurationFormatUtils.formatDurationHMS(getSplitTime());\n    }\n\n    /**\n     * Returns the time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     *\n     * @return the time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     * @since 3.10\n     */\n    public String formatTime() {\n        return DurationFormatUtils.formatDurationHMS(getTime());\n    }\n\n    /**\n     * Gets the message for string presentation.\n     *\n     * @return the message for string presentation.\n     * @since 3.10\n     */\n    public String getMessage() {\n        return message;\n    }\n\n    /**\n     * Gets the <em>elapsed</em> time in nanoseconds.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop.\n     * </p>\n     *\n     * @return the <em>elapsed</em> time in nanoseconds.\n     * @see System#nanoTime()\n     * @since 3.0\n     */\n    public long getNanoTime() {\n        if (this.runningState == State.STOPPED || this.runningState == State.SUSPENDED) {\n            return this.stopTimeNanos - this.startTimeNanos;\n        }\n        if (this.runningState == State.UNSTARTED) {\n            return 0;\n        }\n        if (this.runningState == State.RUNNING) {\n            return System.nanoTime() - this.startTimeNanos;\n        }\n        throw new IllegalStateException(\"Illegal running state has occurred.\");\n    }\n\n    /**\n     * Gets the split time in nanoseconds.\n     *\n     * <p>\n     * This is the time between start and latest split.\n     * </p>\n     *\n     * @return the split time in nanoseconds\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not yet been split.\n     * @since 3.0\n     */\n    public long getSplitNanoTime() {\n        if (this.splitState != SplitState.SPLIT) {\n            throw new IllegalStateException(\"Stopwatch must be split to get the split time.\");\n        }\n        return this.stopTimeNanos - this.startTimeNanos;\n    }\n\n    /**\n     * Gets the split time on the stopwatch.\n     *\n     * <p>\n     * This is the time between start and latest split.\n     * </p>\n     *\n     * @return the split time in milliseconds\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not yet been split.\n     * @since 2.1\n     */\n    public long getSplitTime() {\n        return getSplitNanoTime() / NANO_2_MILLIS;\n    }\n\n    /**\n     * Gets the time this stopwatch was started in milliseconds, between the current time and midnight, January 1, 1970\n     * UTC.\n     *\n     * @return the time this stopwatch was started in milliseconds, between the current time and midnight, January 1,\n     *         1970 UTC.\n     * @throws IllegalStateException if this StopWatch has not been started\n     * @since 2.4\n     */\n    public long getStartTime() {\n        if (this.runningState == State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch has not been started\");\n        }\n        // System.nanoTime is for elapsed time\n        return this.startTimeMillis;\n    }\n\n    /**\n     * Gets the time this stopwatch was stopped in milliseconds, between the current time and midnight, January 1, 1970\n     * UTC.\n     *\n     * @return the time this stopwatch was started in milliseconds, between the current time and midnight, January 1,\n     *         1970 UTC.\n     * @throws IllegalStateException if this StopWatch has not been started\n     * @since 3.12.0\n     */\n    public long getStopTime() {\n        if (this.runningState == State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch has not been started\");\n        }\n        // System.nanoTime is for elapsed time\n        return this.stopTimeMillis;\n    }\n\n    /**\n     * Gets the time on the stopwatch.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop.\n     * </p>\n     *\n     * @return the time in milliseconds\n     */\n    public long getTime() {\n        return getNanoTime() / NANO_2_MILLIS;\n    }\n\n    /**\n     * Gets the time in the specified TimeUnit.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop. The resulting time will be expressed in the desired TimeUnit with any remainder rounded down.\n     * For example, if the specified unit is {@code TimeUnit.HOURS} and the stopwatch time is 59 minutes, then the\n     * result returned will be {@code 0}.\n     * </p>\n     *\n     * @param timeUnit the unit of time, not null\n     * @return the time in the specified TimeUnit, rounded down\n     * @since 3.5\n     */\n    public long getTime(final TimeUnit timeUnit) {\n        return timeUnit.convert(getNanoTime(), TimeUnit.NANOSECONDS);\n    }\n\n    /**\n     * Returns whether the StopWatch is started. A suspended StopWatch is also started watch.\n     *\n     * @return boolean If the StopWatch is started.\n     * @since 3.2\n     */\n    public boolean isStarted() {\n        return runningState.isStarted();\n    }\n\n    /**\n     * Returns whether StopWatch is stopped. The stopwatch which's not yet started and explicitly stopped stopwatch is considered\n     * as stopped.\n     *\n     * @return boolean If the StopWatch is stopped.\n     * @since 3.2\n     */\n    public boolean isStopped() {\n        return runningState.isStopped();\n    }\n\n    /**\n     * Returns whether the StopWatch is suspended.\n     *\n     * @return boolean\n     *             If the StopWatch is suspended.\n     * @since 3.2\n     */\n    public boolean isSuspended() {\n        return runningState.isSuspended();\n    }\n\n    /**\n     * Resets the stopwatch. Stops it if need be.\n     *\n     * <p>\n     * This method clears the internal values to allow the object to be reused.\n     * </p>\n     */\n    public void reset() {\n        this.runningState = State.UNSTARTED;\n        this.splitState = SplitState.UNSPLIT;\n    }\n\n    /**\n     * Resumes the stopwatch after a suspend.\n     *\n     * <p>\n     * This method resumes the watch after it was suspended. The watch will not include time between the suspend and\n     * resume calls in the total time.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not been suspended.\n     */\n    public void resume() {\n        if (this.runningState != State.SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume. \");\n        }\n        this.startTimeNanos += System.nanoTime() - this.stopTimeNanos;\n        this.runningState = State.RUNNING;\n    }\n\n    /**\n     * Splits the time.\n     *\n     * <p>\n     * This method sets the stop time of the watch to allow a time to be extracted. The start time is unaffected,\n     * enabling {@link #unsplit()} to continue the timing from the original start point.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not running.\n     */\n    public void split() {\n        if (this.runningState != State.RUNNING) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        this.stopTimeNanos = System.nanoTime();\n        this.splitState = SplitState.SPLIT;\n    }\n\n    /**\n     * Starts the stopwatch.\n     *\n     * <p>\n     * This method starts a new timing session, clearing any previous values.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is already running.\n     */\n    public void start() {\n        if (this.runningState == State.STOPPED) {\n            throw new IllegalStateException(\"Stopwatch must be reset before being restarted. \");\n        }\n        if (this.runningState != State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch already started. \");\n        }\n        this.startTimeNanos = System.nanoTime();\n        this.startTimeMillis = System.currentTimeMillis();\n        this.runningState = State.RUNNING;\n    }\n\n    /**\n     * Stops the stopwatch.\n     *\n     * <p>\n     * This method ends a new timing session, allowing the time to be retrieved.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not running.\n     */\n    public void stop() {\n        if (this.runningState != State.RUNNING && this.runningState != State.SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        if (this.runningState == State.RUNNING) {\n            this.stopTimeNanos = System.nanoTime();\n            this.stopTimeMillis = System.currentTimeMillis();\n        }\n        this.runningState = State.STOPPED;\n    }\n\n    /**\n     * Suspends the stopwatch for later resumption.\n     *\n     * <p>\n     * This method suspends the watch until it is resumed. The watch will not include time between the suspend and\n     * resume calls in the total time.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if (this.runningState != State.RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n        }\n        this.stopTimeNanos = System.nanoTime();\n        this.stopTimeMillis = System.currentTimeMillis();\n        this.runningState = State.SUSPENDED;\n    }\n\n    /**\n     * Gets a summary of the split time that the stopwatch recorded as a string.\n     *\n     * <p>\n     * The format used is ISO 8601-like, [<i>message</i> ]<i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n     * </p>\n     *\n     * @return the split time as a String\n     * @since 2.1\n     * @since 3.10 Returns the prefix {@code \"message \"} if the message is set.\n     */\n    public String toSplitString() {\n        final String msgStr = Objects.toString(message, StringUtils.EMPTY);\n        final String formattedTime = formatSplitTime();\n        return msgStr.isEmpty() ? formattedTime : msgStr + StringUtils.SPACE + formattedTime;\n    }\n\n    /**\n     * Gets a summary of the time that the stopwatch recorded as a string.\n     *\n     * <p>\n     * The format used is ISO 8601-like, [<i>message</i> ]<i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n     * </p>\n     *\n     * @return the time as a String\n     * @since 3.10 Returns the prefix {@code \"message \"} if the message is set.\n     */\n    @Override\n    public String toString() {\n        final String msgStr = Objects.toString(message, StringUtils.EMPTY);\n        final String formattedTime = formatTime();\n        return msgStr.isEmpty() ? formattedTime : msgStr + StringUtils.SPACE + formattedTime;\n    }\n\n    /**\n     * Removes a split.\n     *\n     * <p>\n     * This method clears the stop time. The start time is unaffected, enabling timing from the original start point to\n     * continue.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not been split.\n     */\n    public void unsplit() {\n        if (this.splitState != SplitState.SPLIT) {\n            throw new IllegalStateException(\"Stopwatch has not been split. \");\n        }\n        this.splitState = SplitState.UNSPLIT;\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/time/StopWatch.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.lang3.time;\n\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * {@link StopWatch} provides a convenient API for timings.\n *\n * <p>\n * To start the watch, call {@link #start()} or {@link StopWatch#createStarted()}. At this point you can:\n * </p>\n * <ul>\n * <li>{@link #split()} the watch to get the time whilst the watch continues in the background. {@link #unsplit()} will\n * remove the effect of the split. At this point, these three options are available again.</li>\n * <li>{@link #suspend()} the watch to pause it. {@link #resume()} allows the watch to continue. Any time between the\n * suspend and resume will not be counted in the total. At this point, these three options are available again.</li>\n * <li>{@link #stop()} the watch to complete the timing session.</li>\n * </ul>\n *\n * <p>\n * It is intended that the output methods {@link #toString()} and {@link #getTime()} should only be called after stop,\n * split or suspend, however a suitable result will be returned at other points.\n * </p>\n *\n * <p>\n * NOTE: As from v2.1, the methods protect against inappropriate calls. Thus you cannot now call stop before start,\n * resume before suspend or unsplit before split.\n * </p>\n *\n * <ol>\n * <li>{@link #split()}, {@link #suspend()}, or {@link #stop()} cannot be invoked twice</li>\n * <li>{@link #unsplit()} may only be called if the watch has been {@link #split()}</li>\n * <li>{@link #resume()} may only be called if the watch has been {@link #suspend()}</li>\n * <li>{@link #start()} cannot be called twice without calling {@link #reset()}</li>\n * </ol>\n *\n * <p>This class is not thread-safe</p>\n *\n * @since 2.0\n */\npublic class StopWatch {\n\n    /**\n     * Enumeration type which indicates the split status of stopwatch.\n     */\n    private enum SplitState {\n        SPLIT,\n        UNSPLIT\n    }\n\n    /**\n     * Enumeration type which indicates the status of stopwatch.\n     */\n    private enum State {\n\n        RUNNING {\n            @Override\n            boolean isStarted() {\n                return true;\n            }\n            @Override\n            boolean isStopped() {\n                return false;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        },\n        STOPPED {\n            @Override\n            boolean isStarted() {\n                return false;\n            }\n            @Override\n            boolean isStopped() {\n                return true;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        },\n        SUSPENDED {\n            @Override\n            boolean isStarted() {\n                return true;\n            }\n            @Override\n            boolean isStopped() {\n                return false;\n            }\n            @Override\n            boolean isSuspended() {\n                return true;\n            }\n        },\n        UNSTARTED {\n            @Override\n            boolean isStarted() {\n                return false;\n            }\n            @Override\n            boolean isStopped() {\n                return true;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        };\n\n        /**\n         * Returns whether the StopWatch is started. A suspended StopWatch is also started watch.\n         *\n         * @return boolean If the StopWatch is started.\n         */\n        abstract boolean isStarted();\n\n        /**\n         * Returns whether the StopWatch is stopped. The stopwatch which's not yet started and explicitly stopped stopwatch is\n         * considered as stopped.\n         *\n         * @return boolean If the StopWatch is stopped.\n         */\n        abstract boolean isStopped();\n\n        /**\n         * Returns whether the StopWatch is suspended.\n         *\n         * @return boolean\n         *             If the StopWatch is suspended.\n         */\n        abstract boolean isSuspended();\n    }\n\n    private static final long NANO_2_MILLIS = 1000000L;\n\n    /**\n     * Creates a stopwatch for convenience.\n     *\n     * @return StopWatch a stopwatch.\n     *\n     * @since 3.10\n     */\n    public static StopWatch create() {\n        return new StopWatch();\n    }\n\n    /**\n     * Creates a started stopwatch for convenience.\n     *\n     * @return StopWatch a stopwatch that's already been started.\n     *\n     * @since 3.5\n     */\n    public static StopWatch createStarted() {\n        final StopWatch sw = new StopWatch();\n        sw.start();\n        return sw;\n    }\n\n    /**\n     * A message for string presentation.\n     *\n     * @since 3.10\n     */\n    private final String message;\n\n    /**\n     * The current running state of the StopWatch.\n     */\n    private State runningState = State.UNSTARTED;\n\n    /**\n     * Whether the stopwatch has a split time recorded.\n     */\n    private SplitState splitState = SplitState.UNSPLIT;\n\n    /**\n     * The start time in nanoseconds.\n     */\n    private long startTimeNanos;\n\n    /**\n     * The start time in milliseconds - nanoTime is only for elapsed time so we\n     * need to also store the currentTimeMillis to maintain the old\n     * getStartTime API.\n     */\n    private long startTimeMillis;\n\n    /**\n     * The end time in milliseconds - nanoTime is only for elapsed time so we\n     * need to also store the currentTimeMillis to maintain the old\n     * getStartTime API.\n     */\n    private long stopTimeMillis;\n\n    /**\n     * The stop time in nanoseconds.\n     */\n    private long stopTimeNanos;\n\n    /**\n     * Constructor.\n     *\n     */\n    public StopWatch() {\n        this(null);\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param message A message for string presentation.\n     * @since 3.10\n     */\n    public StopWatch(final String message) {\n        this.message = message;\n    }\n\n    /**\n     * Returns the split time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     *\n     * @return the split time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     * @since 3.10\n     */\n    public String formatSplitTime() {\n        return DurationFormatUtils.formatDurationHMS(getSplitTime());\n    }\n\n    /**\n     * Returns the time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     *\n     * @return the time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     * @since 3.10\n     */\n    public String formatTime() {\n        return DurationFormatUtils.formatDurationHMS(getTime());\n    }\n\n    /**\n     * Gets the message for string presentation.\n     *\n     * @return the message for string presentation.\n     * @since 3.10\n     */\n    public String getMessage() {\n        return message;\n    }\n\n    /**\n     * Gets the <em>elapsed</em> time in nanoseconds.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop.\n     * </p>\n     *\n     * @return the <em>elapsed</em> time in nanoseconds.\n     * @see System#nanoTime()\n     * @since 3.0\n     */\n    public long getNanoTime() {\n        if (this.runningState == State.STOPPED || this.runningState == State.SUSPENDED) {\n            return this.stopTimeNanos - this.startTimeNanos;\n        }\n        if (this.runningState == State.UNSTARTED) {\n            return 0;\n        }\n        if (this.runningState == State.RUNNING) {\n            return System.nanoTime() - this.startTimeNanos;\n        }\n        throw new IllegalStateException(\"Illegal running state has occurred.\");\n    }\n\n    /**\n     * Gets the split time in nanoseconds.\n     *\n     * <p>\n     * This is the time between start and latest split.\n     * </p>\n     *\n     * @return the split time in nanoseconds\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not yet been split.\n     * @since 3.0\n     */\n    public long getSplitNanoTime() {\n        if (this.splitState != SplitState.SPLIT) {\n            throw new IllegalStateException(\"Stopwatch must be split to get the split time.\");\n        }\n        return this.stopTimeNanos - this.startTimeNanos;\n    }\n\n    /**\n     * Gets the split time on the stopwatch.\n     *\n     * <p>\n     * This is the time between start and latest split.\n     * </p>\n     *\n     * @return the split time in milliseconds\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not yet been split.\n     * @since 2.1\n     */\n    public long getSplitTime() {\n        return nanosToMillis(getSplitNanoTime());\n    }\n\n    /**\n     * Gets the time this stopwatch was started in milliseconds, between the current time and midnight, January 1, 1970\n     * UTC.\n     *\n     * @return the time this stopwatch was started in milliseconds, between the current time and midnight, January 1,\n     *         1970 UTC.\n     * @throws IllegalStateException if this StopWatch has not been started\n     * @since 2.4\n     */\n    public long getStartTime() {\n        if (this.runningState == State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch has not been started\");\n        }\n        // System.nanoTime is for elapsed time\n        return this.startTimeMillis;\n    }\n\n    /**\n     * Gets the time this stopwatch was stopped in milliseconds, between the current time and midnight, January 1, 1970\n     * UTC.\n     *\n     * @return the time this stopwatch was started in milliseconds, between the current time and midnight, January 1,\n     *         1970 UTC.\n     * @throws IllegalStateException if this StopWatch has not been started\n     * @since 3.12.0\n     */\n    public long getStopTime() {\n        if (this.runningState == State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch has not been started\");\n        }\n        // System.nanoTime is for elapsed time\n        return this.stopTimeMillis;\n    }\n\n    /**\n     * Gets the time on the stopwatch.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop.\n     * </p>\n     *\n     * @return the time in milliseconds\n     */\n    public long getTime() {\n        return nanosToMillis(getNanoTime());\n    }\n\n    /**\n     * Gets the time in the specified TimeUnit.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop. The resulting time will be expressed in the desired TimeUnit with any remainder rounded down.\n     * For example, if the specified unit is {@code TimeUnit.HOURS} and the stopwatch time is 59 minutes, then the\n     * result returned will be {@code 0}.\n     * </p>\n     *\n     * @param timeUnit the unit of time, not null\n     * @return the time in the specified TimeUnit, rounded down\n     * @since 3.5\n     */\n    public long getTime(final TimeUnit timeUnit) {\n        return timeUnit.convert(getNanoTime(), TimeUnit.NANOSECONDS);\n    }\n\n    /**\n     * Returns whether the StopWatch is started. A suspended StopWatch is also started watch.\n     *\n     * @return boolean If the StopWatch is started.\n     * @since 3.2\n     */\n    public boolean isStarted() {\n        return runningState.isStarted();\n    }\n\n    /**\n     * Returns whether StopWatch is stopped. The stopwatch which's not yet started and explicitly stopped stopwatch is considered\n     * as stopped.\n     *\n     * @return boolean If the StopWatch is stopped.\n     * @since 3.2\n     */\n    public boolean isStopped() {\n        return runningState.isStopped();\n    }\n\n    /**\n     * Returns whether the StopWatch is suspended.\n     *\n     * @return boolean\n     *             If the StopWatch is suspended.\n     * @since 3.2\n     */\n    public boolean isSuspended() {\n        return runningState.isSuspended();\n    }\n\n    /**\n     * Converts nanoseconds to milliseconds.\n     *\n     * @param nanos nanoseconds to convert.\n     * @return milliseconds conversion result.\n     */\n    private long nanosToMillis(long nanos) {\n        return nanos / NANO_2_MILLIS;\n    }\n\n    /**\n     * Resets the stopwatch. Stops it if need be.\n     *\n     * <p>\n     * This method clears the internal values to allow the object to be reused.\n     * </p>\n     */\n    public void reset() {\n        this.runningState = State.UNSTARTED;\n        this.splitState = SplitState.UNSPLIT;\n    }\n\n    /**\n     * Resumes the stopwatch after a suspend.\n     *\n     * <p>\n     * This method resumes the watch after it was suspended. The watch will not include time between the suspend and\n     * resume calls in the total time.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not been suspended.\n     */\n    public void resume() {\n        if (this.runningState != State.SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume. \");\n        }\n        this.startTimeNanos += System.nanoTime() - this.stopTimeNanos;\n        this.runningState = State.RUNNING;\n    }\n\n    /**\n     * Splits the time.\n     *\n     * <p>\n     * This method sets the stop time of the watch to allow a time to be extracted. The start time is unaffected,\n     * enabling {@link #unsplit()} to continue the timing from the original start point.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not running.\n     */\n    public void split() {\n        if (this.runningState != State.RUNNING) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        this.stopTimeNanos = System.nanoTime();\n        this.splitState = SplitState.SPLIT;\n    }\n\n    /**\n     * Starts the stopwatch.\n     *\n     * <p>\n     * This method starts a new timing session, clearing any previous values.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is already running.\n     */\n    public void start() {\n        if (this.runningState == State.STOPPED) {\n            throw new IllegalStateException(\"Stopwatch must be reset before being restarted. \");\n        }\n        if (this.runningState != State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch already started. \");\n        }\n        this.startTimeNanos = System.nanoTime();\n        this.startTimeMillis = System.currentTimeMillis();\n        this.runningState = State.RUNNING;\n    }\n\n    /**\n     * Stops the stopwatch.\n     *\n     * <p>\n     * This method ends a new timing session, allowing the time to be retrieved.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not running.\n     */\n    public void stop() {\n        if (this.runningState != State.RUNNING && this.runningState != State.SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        if (this.runningState == State.RUNNING) {\n            this.stopTimeNanos = System.nanoTime();\n            this.stopTimeMillis = System.currentTimeMillis();\n        }\n        this.runningState = State.STOPPED;\n    }\n\n    /**\n     * Suspends the stopwatch for later resumption.\n     *\n     * <p>\n     * This method suspends the watch until it is resumed. The watch will not include time between the suspend and\n     * resume calls in the total time.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if (this.runningState != State.RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n        }\n        this.stopTimeNanos = System.nanoTime();\n        this.stopTimeMillis = System.currentTimeMillis();\n        this.runningState = State.SUSPENDED;\n    }\n\n    /**\n     * Gets a summary of the split time that the stopwatch recorded as a string.\n     *\n     * <p>\n     * The format used is ISO 8601-like, [<i>message</i> ]<i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n     * </p>\n     *\n     * @return the split time as a String\n     * @since 2.1\n     * @since 3.10 Returns the prefix {@code \"message \"} if the message is set.\n     */\n    public String toSplitString() {\n        final String msgStr = Objects.toString(message, StringUtils.EMPTY);\n        final String formattedTime = formatSplitTime();\n        return msgStr.isEmpty() ? formattedTime : msgStr + StringUtils.SPACE + formattedTime;\n    }\n\n    /**\n     * Gets a summary of the time that the stopwatch recorded as a string.\n     *\n     * <p>\n     * The format used is ISO 8601-like, [<i>message</i> ]<i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n     * </p>\n     *\n     * @return the time as a String\n     * @since 3.10 Returns the prefix {@code \"message \"} if the message is set.\n     */\n    @Override\n    public String toString() {\n        final String msgStr = Objects.toString(message, StringUtils.EMPTY);\n        final String formattedTime = formatTime();\n        return msgStr.isEmpty() ? formattedTime : msgStr + StringUtils.SPACE + formattedTime;\n    }\n\n    /**\n     * Removes a split.\n     *\n     * <p>\n     * This method clears the stop time. The start time is unaffected, enabling timing from the original start point to\n     * continue.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not been split.\n     */\n    public void unsplit() {\n        if (this.splitState != SplitState.SPLIT) {\n            throw new IllegalStateException(\"Stopwatch has not been split. \");\n        }\n        this.splitState = SplitState.UNSPLIT;\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Converts nanoseconds to milliseconds.\n     *\n     * @param nanos nanoseconds to convert.\n     * @return milliseconds conversion result.\n     */\n    private long nanosToMillis(long nanos) {\n        return nanos / NANO_2_MILLIS;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.time.StopWatch#getNanoTime\n methodBody: public long getNanoTime() {\nif(this.runningState == State.STOPPED || this.runningState == State.SUSPENDED){return this.stopTimeNanos - this.startTimeNanos;\n}if(this.runningState == State.UNSTARTED){return 0;\n}if(this.runningState == State.RUNNING){return System.nanoTime() - this.startTimeNanos;\n}throw new IllegalStateException(\"Illegal running state has occurred.\");\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Gets the time on the stopwatch.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop.\n     * </p>\n     *\n     * @return the time in milliseconds\n     */\n    public long getTime() {\n        return nanosToMillis(getNanoTime());\n    }\n/**\n     * Converts nanoseconds to milliseconds.\n     *\n     * @param nanos nanoseconds to convert.\n     * @return milliseconds conversion result.\n     */\n    private long nanosToMillis(long nanos) {\n        return nanos / NANO_2_MILLIS;\n    }",
        "diffSourceCode": "   367:     /**\n   368:      * Gets the time on the stopwatch.\n   369:      *\n   370:      * <p>\n   371:      * This is either the time between the start and the moment this method is called, or the amount of time between\n   372:      * start and stop.\n   373:      * </p>\n   374:      *\n   375:      * @return the time in milliseconds\n   376:      */\n   377:     public long getTime() {\n-  378:         return getNanoTime() / NANO_2_MILLIS;\n+  378:         return nanosToMillis(getNanoTime());\n   379:     }\n   431:     /**\n-  432:      * Resets the stopwatch. Stops it if need be.\n+  432:      * Converts nanoseconds to milliseconds.\n   433:      *\n-  434:      * <p>\n-  435:      * This method clears the internal values to allow the object to be reused.\n-  436:      * </p>\n-  437:      */\n-  438:     public void reset() {\n-  439:         this.runningState = State.UNSTARTED;\n+  434:      * @param nanos nanoseconds to convert.\n+  435:      * @return milliseconds conversion result.\n+  436:      */\n+  437:     private long nanosToMillis(long nanos) {\n+  438:         return nanos / NANO_2_MILLIS;\n+  439:     }\n",
        "uniqueId": "426ebb13ee04af4f7d7efcb6338e86b3a4ccca98_367_379_431_439_367_379",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 6
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n/**\n * Gets the time in milliseconds.\n *\n * @return the time in milliseconds\n */\npublic long getTime() {\n    return getNanoTime() / NANO_2_MILLIS;\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Gets the time on the stopwatch.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop.\n     * </p>\n     *\n     * @return the time in milliseconds\n     */\n    public long getTime() {\n        return getNanoTime() / NANO_2_MILLIS;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.lang3.time;\n\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * {@link StopWatch} provides a convenient API for timings.\n *\n * <p>\n * To start the watch, call {@link #start()} or {@link StopWatch#createStarted()}. At this point you can:\n * </p>\n * <ul>\n * <li>{@link #split()} the watch to get the time whilst the watch continues in the background. {@link #unsplit()} will\n * remove the effect of the split. At this point, these three options are available again.</li>\n * <li>{@link #suspend()} the watch to pause it. {@link #resume()} allows the watch to continue. Any time between the\n * suspend and resume will not be counted in the total. At this point, these three options are available again.</li>\n * <li>{@link #stop()} the watch to complete the timing session.</li>\n * </ul>\n *\n * <p>\n * It is intended that the output methods {@link #toString()} and {@link #getTime()} should only be called after stop,\n * split or suspend, however a suitable result will be returned at other points.\n * </p>\n *\n * <p>\n * NOTE: As from v2.1, the methods protect against inappropriate calls. Thus you cannot now call stop before start,\n * resume before suspend or unsplit before split.\n * </p>\n *\n * <p>\n * 1. split(), suspend(), or stop() cannot be invoked twice<br>\n * 2. unsplit() may only be called if the watch has been split()<br>\n * 3. resume() may only be called if the watch has been suspend()<br>\n * 4. start() cannot be called twice without calling reset()\n * </p>\n *\n * <p>This class is not thread-safe</p>\n *\n * @since 2.0\n */\npublic class StopWatch {\n\n    /**\n     * Enumeration type which indicates the split status of stopwatch.\n     */\n    private enum SplitState {\n        SPLIT,\n        UNSPLIT\n    }\n\n    /**\n     * Enumeration type which indicates the status of stopwatch.\n     */\n    private enum State {\n\n        RUNNING {\n            @Override\n            boolean isStarted() {\n                return true;\n            }\n            @Override\n            boolean isStopped() {\n                return false;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        },\n        STOPPED {\n            @Override\n            boolean isStarted() {\n                return false;\n            }\n            @Override\n            boolean isStopped() {\n                return true;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        },\n        SUSPENDED {\n            @Override\n            boolean isStarted() {\n                return true;\n            }\n            @Override\n            boolean isStopped() {\n                return false;\n            }\n            @Override\n            boolean isSuspended() {\n                return true;\n            }\n        },\n        UNSTARTED {\n            @Override\n            boolean isStarted() {\n                return false;\n            }\n            @Override\n            boolean isStopped() {\n                return true;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        };\n\n        /**\n         * Returns whether the StopWatch is started. A suspended StopWatch is also started watch.\n         *\n         * @return boolean If the StopWatch is started.\n         */\n        abstract boolean isStarted();\n\n        /**\n         * Returns whether the StopWatch is stopped. The stopwatch which's not yet started and explicitly stopped stopwatch is\n         * considered as stopped.\n         *\n         * @return boolean If the StopWatch is stopped.\n         */\n        abstract boolean isStopped();\n\n        /**\n         * Returns whether the StopWatch is suspended.\n         *\n         * @return boolean\n         *             If the StopWatch is suspended.\n         */\n        abstract boolean isSuspended();\n    }\n\n    private static final long NANO_2_MILLIS = 1000000L;\n\n    /**\n     * Creates a stopwatch for convenience.\n     *\n     * @return StopWatch a stopwatch.\n     *\n     * @since 3.10\n     */\n    public static StopWatch create() {\n        return new StopWatch();\n    }\n\n    /**\n     * Creates a started stopwatch for convenience.\n     *\n     * @return StopWatch a stopwatch that's already been started.\n     *\n     * @since 3.5\n     */\n    public static StopWatch createStarted() {\n        final StopWatch sw = new StopWatch();\n        sw.start();\n        return sw;\n    }\n\n    /**\n     * A message for string presentation.\n     *\n     * @since 3.10\n     */\n    private final String message;\n\n    /**\n     * The current running state of the StopWatch.\n     */\n    private State runningState = State.UNSTARTED;\n\n    /**\n     * Whether the stopwatch has a split time recorded.\n     */\n    private SplitState splitState = SplitState.UNSPLIT;\n\n    /**\n     * The start time in nanoseconds.\n     */\n    private long startTimeNanos;\n\n    /**\n     * The start time in milliseconds - nanoTime is only for elapsed time so we\n     * need to also store the currentTimeMillis to maintain the old\n     * getStartTime API.\n     */\n    private long startTimeMillis;\n\n    /**\n     * The end time in milliseconds - nanoTime is only for elapsed time so we\n     * need to also store the currentTimeMillis to maintain the old\n     * getStartTime API.\n     */\n    private long stopTimeMillis;\n\n    /**\n     * The stop time in nanoseconds.\n     */\n    private long stopTimeNanos;\n\n    /**\n     * Constructor.\n     *\n     */\n    public StopWatch() {\n        this(null);\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param message A message for string presentation.\n     * @since 3.10\n     */\n    public StopWatch(final String message) {\n        this.message = message;\n    }\n\n    /**\n     * Returns the split time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     *\n     * @return the split time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     * @since 3.10\n     */\n    public String formatSplitTime() {\n        return DurationFormatUtils.formatDurationHMS(getSplitTime());\n    }\n\n    /**\n     * Returns the time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     *\n     * @return the time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     * @since 3.10\n     */\n    public String formatTime() {\n        return DurationFormatUtils.formatDurationHMS(getTime());\n    }\n\n    /**\n     * Gets the message for string presentation.\n     *\n     * @return the message for string presentation.\n     * @since 3.10\n     */\n    public String getMessage() {\n        return message;\n    }\n\n    /**\n     * Gets the <em>elapsed</em> time in nanoseconds.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop.\n     * </p>\n     *\n     * @return the <em>elapsed</em> time in nanoseconds.\n     * @see System#nanoTime()\n     * @since 3.0\n     */\n    public long getNanoTime() {\n        if (this.runningState == State.STOPPED || this.runningState == State.SUSPENDED) {\n            return this.stopTimeNanos - this.startTimeNanos;\n        }\n        if (this.runningState == State.UNSTARTED) {\n            return 0;\n        }\n        if (this.runningState == State.RUNNING) {\n            return System.nanoTime() - this.startTimeNanos;\n        }\n        throw new IllegalStateException(\"Illegal running state has occurred.\");\n    }\n\n    /**\n     * Gets the split time in nanoseconds.\n     *\n     * <p>\n     * This is the time between start and latest split.\n     * </p>\n     *\n     * @return the split time in nanoseconds\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not yet been split.\n     * @since 3.0\n     */\n    public long getSplitNanoTime() {\n        if (this.splitState != SplitState.SPLIT) {\n            throw new IllegalStateException(\"Stopwatch must be split to get the split time.\");\n        }\n        return this.stopTimeNanos - this.startTimeNanos;\n    }\n\n    /**\n     * Gets the split time on the stopwatch.\n     *\n     * <p>\n     * This is the time between start and latest split.\n     * </p>\n     *\n     * @return the split time in milliseconds\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not yet been split.\n     * @since 2.1\n     */\n    public long getSplitTime() {\n        return getSplitNanoTime() / NANO_2_MILLIS;\n    }\n\n    /**\n     * Gets the time this stopwatch was started in milliseconds, between the current time and midnight, January 1, 1970\n     * UTC.\n     *\n     * @return the time this stopwatch was started in milliseconds, between the current time and midnight, January 1,\n     *         1970 UTC.\n     * @throws IllegalStateException if this StopWatch has not been started\n     * @since 2.4\n     */\n    public long getStartTime() {\n        if (this.runningState == State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch has not been started\");\n        }\n        // System.nanoTime is for elapsed time\n        return this.startTimeMillis;\n    }\n\n    /**\n     * Gets the time this stopwatch was stopped in milliseconds, between the current time and midnight, January 1, 1970\n     * UTC.\n     *\n     * @return the time this stopwatch was started in milliseconds, between the current time and midnight, January 1,\n     *         1970 UTC.\n     * @throws IllegalStateException if this StopWatch has not been started\n     * @since 3.12.0\n     */\n    public long getStopTime() {\n        if (this.runningState == State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch has not been started\");\n        }\n        // System.nanoTime is for elapsed time\n        return this.stopTimeMillis;\n    }\n\n    /**\n     * Gets the time on the stopwatch.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop.\n     * </p>\n     *\n     * @return the time in milliseconds\n     */\n    public long getTime() {\n        return getNanoTime() / NANO_2_MILLIS;\n    }\n\n    /**\n     * Gets the time in the specified TimeUnit.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop. The resulting time will be expressed in the desired TimeUnit with any remainder rounded down.\n     * For example, if the specified unit is {@code TimeUnit.HOURS} and the stopwatch time is 59 minutes, then the\n     * result returned will be {@code 0}.\n     * </p>\n     *\n     * @param timeUnit the unit of time, not null\n     * @return the time in the specified TimeUnit, rounded down\n     * @since 3.5\n     */\n    public long getTime(final TimeUnit timeUnit) {\n        return timeUnit.convert(getNanoTime(), TimeUnit.NANOSECONDS);\n    }\n\n    /**\n     * Returns whether the StopWatch is started. A suspended StopWatch is also started watch.\n     *\n     * @return boolean If the StopWatch is started.\n     * @since 3.2\n     */\n    public boolean isStarted() {\n        return runningState.isStarted();\n    }\n\n    /**\n     * Returns whether StopWatch is stopped. The stopwatch which's not yet started and explicitly stopped stopwatch is considered\n     * as stopped.\n     *\n     * @return boolean If the StopWatch is stopped.\n     * @since 3.2\n     */\n    public boolean isStopped() {\n        return runningState.isStopped();\n    }\n\n    /**\n     * Returns whether the StopWatch is suspended.\n     *\n     * @return boolean\n     *             If the StopWatch is suspended.\n     * @since 3.2\n     */\n    public boolean isSuspended() {\n        return runningState.isSuspended();\n    }\n\n    /**\n     * Resets the stopwatch. Stops it if need be.\n     *\n     * <p>\n     * This method clears the internal values to allow the object to be reused.\n     * </p>\n     */\n    public void reset() {\n        this.runningState = State.UNSTARTED;\n        this.splitState = SplitState.UNSPLIT;\n    }\n\n    /**\n     * Resumes the stopwatch after a suspend.\n     *\n     * <p>\n     * This method resumes the watch after it was suspended. The watch will not include time between the suspend and\n     * resume calls in the total time.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not been suspended.\n     */\n    public void resume() {\n        if (this.runningState != State.SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume. \");\n        }\n        this.startTimeNanos += System.nanoTime() - this.stopTimeNanos;\n        this.runningState = State.RUNNING;\n    }\n\n    /**\n     * Splits the time.\n     *\n     * <p>\n     * This method sets the stop time of the watch to allow a time to be extracted. The start time is unaffected,\n     * enabling {@link #unsplit()} to continue the timing from the original start point.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not running.\n     */\n    public void split() {\n        if (this.runningState != State.RUNNING) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        this.stopTimeNanos = System.nanoTime();\n        this.splitState = SplitState.SPLIT;\n    }\n\n    /**\n     * Starts the stopwatch.\n     *\n     * <p>\n     * This method starts a new timing session, clearing any previous values.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is already running.\n     */\n    public void start() {\n        if (this.runningState == State.STOPPED) {\n            throw new IllegalStateException(\"Stopwatch must be reset before being restarted. \");\n        }\n        if (this.runningState != State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch already started. \");\n        }\n        this.startTimeNanos = System.nanoTime();\n        this.startTimeMillis = System.currentTimeMillis();\n        this.runningState = State.RUNNING;\n    }\n\n    /**\n     * Stops the stopwatch.\n     *\n     * <p>\n     * This method ends a new timing session, allowing the time to be retrieved.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not running.\n     */\n    public void stop() {\n        if (this.runningState != State.RUNNING && this.runningState != State.SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        if (this.runningState == State.RUNNING) {\n            this.stopTimeNanos = System.nanoTime();\n            this.stopTimeMillis = System.currentTimeMillis();\n        }\n        this.runningState = State.STOPPED;\n    }\n\n    /**\n     * Suspends the stopwatch for later resumption.\n     *\n     * <p>\n     * This method suspends the watch until it is resumed. The watch will not include time between the suspend and\n     * resume calls in the total time.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if (this.runningState != State.RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n        }\n        this.stopTimeNanos = System.nanoTime();\n        this.stopTimeMillis = System.currentTimeMillis();\n        this.runningState = State.SUSPENDED;\n    }\n\n    /**\n     * Gets a summary of the split time that the stopwatch recorded as a string.\n     *\n     * <p>\n     * The format used is ISO 8601-like, [<i>message</i> ]<i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n     * </p>\n     *\n     * @return the split time as a String\n     * @since 2.1\n     * @since 3.10 Returns the prefix {@code \"message \"} if the message is set.\n     */\n    public String toSplitString() {\n        final String msgStr = Objects.toString(message, StringUtils.EMPTY);\n        final String formattedTime = formatSplitTime();\n        return msgStr.isEmpty() ? formattedTime : msgStr + StringUtils.SPACE + formattedTime;\n    }\n\n    /**\n     * Gets a summary of the time that the stopwatch recorded as a string.\n     *\n     * <p>\n     * The format used is ISO 8601-like, [<i>message</i> ]<i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n     * </p>\n     *\n     * @return the time as a String\n     * @since 3.10 Returns the prefix {@code \"message \"} if the message is set.\n     */\n    @Override\n    public String toString() {\n        final String msgStr = Objects.toString(message, StringUtils.EMPTY);\n        final String formattedTime = formatTime();\n        return msgStr.isEmpty() ? formattedTime : msgStr + StringUtils.SPACE + formattedTime;\n    }\n\n    /**\n     * Removes a split.\n     *\n     * <p>\n     * This method clears the stop time. The start time is unaffected, enabling timing from the original start point to\n     * continue.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not been split.\n     */\n    public void unsplit() {\n        if (this.splitState != SplitState.SPLIT) {\n            throw new IllegalStateException(\"Stopwatch has not been split. \");\n        }\n        this.splitState = SplitState.UNSPLIT;\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate nanosToMillis(nanos long) : long extracted from public getSplitTime() : long in class org.apache.commons.lang3.time.StopWatch",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/apache/commons/lang3/time/StopWatch.java",
                "startLine": 316,
                "endLine": 331,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/time/StopWatch.java",
                "startLine": 316,
                "endLine": 331,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/apache/commons/lang3/time/StopWatch.java",
                "startLine": 431,
                "endLine": 439,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Gets the split time on the stopwatch.\n     *\n     * <p>\n     * This is the time between start and latest split.\n     * </p>\n     *\n     * @return the split time in milliseconds\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not yet been split.\n     * @since 2.1\n     */\n    public long getSplitTime() {\n        return getSplitNanoTime() / NANO_2_MILLIS;\n    }",
        "filePathBefore": "src/main/java/org/apache/commons/lang3/time/StopWatch.java",
        "isPureRefactoring": true,
        "commitId": "426ebb13ee04af4f7d7efcb6338e86b3a4ccca98",
        "packageNameBefore": "org.apache.commons.lang3.time",
        "classNameBefore": "org.apache.commons.lang3.time.StopWatch",
        "methodNameBefore": "org.apache.commons.lang3.time.StopWatch#getSplitTime",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.time.StopWatch#getSplitNanoTime\n methodBody: public long getSplitNanoTime() {\nif(this.splitState != SplitState.SPLIT){throw new IllegalStateException(\"Stopwatch must be split to get the split time.\");\n}return this.stopTimeNanos - this.startTimeNanos;\n}",
        "classSignatureBefore": "public class StopWatch ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.time.StopWatch#getSplitTime"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.time.StopWatch"
        ],
        "classSignatureBeforeSet": [
            "public class StopWatch "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All the mappings are matched! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.lang3.time;\n\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * {@link StopWatch} provides a convenient API for timings.\n *\n * <p>\n * To start the watch, call {@link #start()} or {@link StopWatch#createStarted()}. At this point you can:\n * </p>\n * <ul>\n * <li>{@link #split()} the watch to get the time whilst the watch continues in the background. {@link #unsplit()} will\n * remove the effect of the split. At this point, these three options are available again.</li>\n * <li>{@link #suspend()} the watch to pause it. {@link #resume()} allows the watch to continue. Any time between the\n * suspend and resume will not be counted in the total. At this point, these three options are available again.</li>\n * <li>{@link #stop()} the watch to complete the timing session.</li>\n * </ul>\n *\n * <p>\n * It is intended that the output methods {@link #toString()} and {@link #getTime()} should only be called after stop,\n * split or suspend, however a suitable result will be returned at other points.\n * </p>\n *\n * <p>\n * NOTE: As from v2.1, the methods protect against inappropriate calls. Thus you cannot now call stop before start,\n * resume before suspend or unsplit before split.\n * </p>\n *\n * <p>\n * 1. split(), suspend(), or stop() cannot be invoked twice<br>\n * 2. unsplit() may only be called if the watch has been split()<br>\n * 3. resume() may only be called if the watch has been suspend()<br>\n * 4. start() cannot be called twice without calling reset()\n * </p>\n *\n * <p>This class is not thread-safe</p>\n *\n * @since 2.0\n */\npublic class StopWatch {\n\n    /**\n     * Enumeration type which indicates the split status of stopwatch.\n     */\n    private enum SplitState {\n        SPLIT,\n        UNSPLIT\n    }\n\n    /**\n     * Enumeration type which indicates the status of stopwatch.\n     */\n    private enum State {\n\n        RUNNING {\n            @Override\n            boolean isStarted() {\n                return true;\n            }\n            @Override\n            boolean isStopped() {\n                return false;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        },\n        STOPPED {\n            @Override\n            boolean isStarted() {\n                return false;\n            }\n            @Override\n            boolean isStopped() {\n                return true;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        },\n        SUSPENDED {\n            @Override\n            boolean isStarted() {\n                return true;\n            }\n            @Override\n            boolean isStopped() {\n                return false;\n            }\n            @Override\n            boolean isSuspended() {\n                return true;\n            }\n        },\n        UNSTARTED {\n            @Override\n            boolean isStarted() {\n                return false;\n            }\n            @Override\n            boolean isStopped() {\n                return true;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        };\n\n        /**\n         * Returns whether the StopWatch is started. A suspended StopWatch is also started watch.\n         *\n         * @return boolean If the StopWatch is started.\n         */\n        abstract boolean isStarted();\n\n        /**\n         * Returns whether the StopWatch is stopped. The stopwatch which's not yet started and explicitly stopped stopwatch is\n         * considered as stopped.\n         *\n         * @return boolean If the StopWatch is stopped.\n         */\n        abstract boolean isStopped();\n\n        /**\n         * Returns whether the StopWatch is suspended.\n         *\n         * @return boolean\n         *             If the StopWatch is suspended.\n         */\n        abstract boolean isSuspended();\n    }\n\n    private static final long NANO_2_MILLIS = 1000000L;\n\n    /**\n     * Creates a stopwatch for convenience.\n     *\n     * @return StopWatch a stopwatch.\n     *\n     * @since 3.10\n     */\n    public static StopWatch create() {\n        return new StopWatch();\n    }\n\n    /**\n     * Creates a started stopwatch for convenience.\n     *\n     * @return StopWatch a stopwatch that's already been started.\n     *\n     * @since 3.5\n     */\n    public static StopWatch createStarted() {\n        final StopWatch sw = new StopWatch();\n        sw.start();\n        return sw;\n    }\n\n    /**\n     * A message for string presentation.\n     *\n     * @since 3.10\n     */\n    private final String message;\n\n    /**\n     * The current running state of the StopWatch.\n     */\n    private State runningState = State.UNSTARTED;\n\n    /**\n     * Whether the stopwatch has a split time recorded.\n     */\n    private SplitState splitState = SplitState.UNSPLIT;\n\n    /**\n     * The start time in nanoseconds.\n     */\n    private long startTimeNanos;\n\n    /**\n     * The start time in milliseconds - nanoTime is only for elapsed time so we\n     * need to also store the currentTimeMillis to maintain the old\n     * getStartTime API.\n     */\n    private long startTimeMillis;\n\n    /**\n     * The end time in milliseconds - nanoTime is only for elapsed time so we\n     * need to also store the currentTimeMillis to maintain the old\n     * getStartTime API.\n     */\n    private long stopTimeMillis;\n\n    /**\n     * The stop time in nanoseconds.\n     */\n    private long stopTimeNanos;\n\n    /**\n     * Constructor.\n     *\n     */\n    public StopWatch() {\n        this(null);\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param message A message for string presentation.\n     * @since 3.10\n     */\n    public StopWatch(final String message) {\n        this.message = message;\n    }\n\n    /**\n     * Returns the split time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     *\n     * @return the split time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     * @since 3.10\n     */\n    public String formatSplitTime() {\n        return DurationFormatUtils.formatDurationHMS(getSplitTime());\n    }\n\n    /**\n     * Returns the time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     *\n     * @return the time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     * @since 3.10\n     */\n    public String formatTime() {\n        return DurationFormatUtils.formatDurationHMS(getTime());\n    }\n\n    /**\n     * Gets the message for string presentation.\n     *\n     * @return the message for string presentation.\n     * @since 3.10\n     */\n    public String getMessage() {\n        return message;\n    }\n\n    /**\n     * Gets the <em>elapsed</em> time in nanoseconds.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop.\n     * </p>\n     *\n     * @return the <em>elapsed</em> time in nanoseconds.\n     * @see System#nanoTime()\n     * @since 3.0\n     */\n    public long getNanoTime() {\n        if (this.runningState == State.STOPPED || this.runningState == State.SUSPENDED) {\n            return this.stopTimeNanos - this.startTimeNanos;\n        }\n        if (this.runningState == State.UNSTARTED) {\n            return 0;\n        }\n        if (this.runningState == State.RUNNING) {\n            return System.nanoTime() - this.startTimeNanos;\n        }\n        throw new IllegalStateException(\"Illegal running state has occurred.\");\n    }\n\n    /**\n     * Gets the split time in nanoseconds.\n     *\n     * <p>\n     * This is the time between start and latest split.\n     * </p>\n     *\n     * @return the split time in nanoseconds\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not yet been split.\n     * @since 3.0\n     */\n    public long getSplitNanoTime() {\n        if (this.splitState != SplitState.SPLIT) {\n            throw new IllegalStateException(\"Stopwatch must be split to get the split time.\");\n        }\n        return this.stopTimeNanos - this.startTimeNanos;\n    }\n\n    /**\n     * Gets the split time on the stopwatch.\n     *\n     * <p>\n     * This is the time between start and latest split.\n     * </p>\n     *\n     * @return the split time in milliseconds\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not yet been split.\n     * @since 2.1\n     */\n    public long getSplitTime() {\n        return getSplitNanoTime() / NANO_2_MILLIS;\n    }\n\n    /**\n     * Gets the time this stopwatch was started in milliseconds, between the current time and midnight, January 1, 1970\n     * UTC.\n     *\n     * @return the time this stopwatch was started in milliseconds, between the current time and midnight, January 1,\n     *         1970 UTC.\n     * @throws IllegalStateException if this StopWatch has not been started\n     * @since 2.4\n     */\n    public long getStartTime() {\n        if (this.runningState == State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch has not been started\");\n        }\n        // System.nanoTime is for elapsed time\n        return this.startTimeMillis;\n    }\n\n    /**\n     * Gets the time this stopwatch was stopped in milliseconds, between the current time and midnight, January 1, 1970\n     * UTC.\n     *\n     * @return the time this stopwatch was started in milliseconds, between the current time and midnight, January 1,\n     *         1970 UTC.\n     * @throws IllegalStateException if this StopWatch has not been started\n     * @since 3.12.0\n     */\n    public long getStopTime() {\n        if (this.runningState == State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch has not been started\");\n        }\n        // System.nanoTime is for elapsed time\n        return this.stopTimeMillis;\n    }\n\n    /**\n     * Gets the time on the stopwatch.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop.\n     * </p>\n     *\n     * @return the time in milliseconds\n     */\n    public long getTime() {\n        return getNanoTime() / NANO_2_MILLIS;\n    }\n\n    /**\n     * Gets the time in the specified TimeUnit.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop. The resulting time will be expressed in the desired TimeUnit with any remainder rounded down.\n     * For example, if the specified unit is {@code TimeUnit.HOURS} and the stopwatch time is 59 minutes, then the\n     * result returned will be {@code 0}.\n     * </p>\n     *\n     * @param timeUnit the unit of time, not null\n     * @return the time in the specified TimeUnit, rounded down\n     * @since 3.5\n     */\n    public long getTime(final TimeUnit timeUnit) {\n        return timeUnit.convert(getNanoTime(), TimeUnit.NANOSECONDS);\n    }\n\n    /**\n     * Returns whether the StopWatch is started. A suspended StopWatch is also started watch.\n     *\n     * @return boolean If the StopWatch is started.\n     * @since 3.2\n     */\n    public boolean isStarted() {\n        return runningState.isStarted();\n    }\n\n    /**\n     * Returns whether StopWatch is stopped. The stopwatch which's not yet started and explicitly stopped stopwatch is considered\n     * as stopped.\n     *\n     * @return boolean If the StopWatch is stopped.\n     * @since 3.2\n     */\n    public boolean isStopped() {\n        return runningState.isStopped();\n    }\n\n    /**\n     * Returns whether the StopWatch is suspended.\n     *\n     * @return boolean\n     *             If the StopWatch is suspended.\n     * @since 3.2\n     */\n    public boolean isSuspended() {\n        return runningState.isSuspended();\n    }\n\n    /**\n     * Resets the stopwatch. Stops it if need be.\n     *\n     * <p>\n     * This method clears the internal values to allow the object to be reused.\n     * </p>\n     */\n    public void reset() {\n        this.runningState = State.UNSTARTED;\n        this.splitState = SplitState.UNSPLIT;\n    }\n\n    /**\n     * Resumes the stopwatch after a suspend.\n     *\n     * <p>\n     * This method resumes the watch after it was suspended. The watch will not include time between the suspend and\n     * resume calls in the total time.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not been suspended.\n     */\n    public void resume() {\n        if (this.runningState != State.SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume. \");\n        }\n        this.startTimeNanos += System.nanoTime() - this.stopTimeNanos;\n        this.runningState = State.RUNNING;\n    }\n\n    /**\n     * Splits the time.\n     *\n     * <p>\n     * This method sets the stop time of the watch to allow a time to be extracted. The start time is unaffected,\n     * enabling {@link #unsplit()} to continue the timing from the original start point.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not running.\n     */\n    public void split() {\n        if (this.runningState != State.RUNNING) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        this.stopTimeNanos = System.nanoTime();\n        this.splitState = SplitState.SPLIT;\n    }\n\n    /**\n     * Starts the stopwatch.\n     *\n     * <p>\n     * This method starts a new timing session, clearing any previous values.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is already running.\n     */\n    public void start() {\n        if (this.runningState == State.STOPPED) {\n            throw new IllegalStateException(\"Stopwatch must be reset before being restarted. \");\n        }\n        if (this.runningState != State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch already started. \");\n        }\n        this.startTimeNanos = System.nanoTime();\n        this.startTimeMillis = System.currentTimeMillis();\n        this.runningState = State.RUNNING;\n    }\n\n    /**\n     * Stops the stopwatch.\n     *\n     * <p>\n     * This method ends a new timing session, allowing the time to be retrieved.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not running.\n     */\n    public void stop() {\n        if (this.runningState != State.RUNNING && this.runningState != State.SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        if (this.runningState == State.RUNNING) {\n            this.stopTimeNanos = System.nanoTime();\n            this.stopTimeMillis = System.currentTimeMillis();\n        }\n        this.runningState = State.STOPPED;\n    }\n\n    /**\n     * Suspends the stopwatch for later resumption.\n     *\n     * <p>\n     * This method suspends the watch until it is resumed. The watch will not include time between the suspend and\n     * resume calls in the total time.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if (this.runningState != State.RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n        }\n        this.stopTimeNanos = System.nanoTime();\n        this.stopTimeMillis = System.currentTimeMillis();\n        this.runningState = State.SUSPENDED;\n    }\n\n    /**\n     * Gets a summary of the split time that the stopwatch recorded as a string.\n     *\n     * <p>\n     * The format used is ISO 8601-like, [<i>message</i> ]<i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n     * </p>\n     *\n     * @return the split time as a String\n     * @since 2.1\n     * @since 3.10 Returns the prefix {@code \"message \"} if the message is set.\n     */\n    public String toSplitString() {\n        final String msgStr = Objects.toString(message, StringUtils.EMPTY);\n        final String formattedTime = formatSplitTime();\n        return msgStr.isEmpty() ? formattedTime : msgStr + StringUtils.SPACE + formattedTime;\n    }\n\n    /**\n     * Gets a summary of the time that the stopwatch recorded as a string.\n     *\n     * <p>\n     * The format used is ISO 8601-like, [<i>message</i> ]<i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n     * </p>\n     *\n     * @return the time as a String\n     * @since 3.10 Returns the prefix {@code \"message \"} if the message is set.\n     */\n    @Override\n    public String toString() {\n        final String msgStr = Objects.toString(message, StringUtils.EMPTY);\n        final String formattedTime = formatTime();\n        return msgStr.isEmpty() ? formattedTime : msgStr + StringUtils.SPACE + formattedTime;\n    }\n\n    /**\n     * Removes a split.\n     *\n     * <p>\n     * This method clears the stop time. The start time is unaffected, enabling timing from the original start point to\n     * continue.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not been split.\n     */\n    public void unsplit() {\n        if (this.splitState != SplitState.SPLIT) {\n            throw new IllegalStateException(\"Stopwatch has not been split. \");\n        }\n        this.splitState = SplitState.UNSPLIT;\n    }\n\n}\n",
        "filePathAfter": "src/main/java/org/apache/commons/lang3/time/StopWatch.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.lang3.time;\n\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * {@link StopWatch} provides a convenient API for timings.\n *\n * <p>\n * To start the watch, call {@link #start()} or {@link StopWatch#createStarted()}. At this point you can:\n * </p>\n * <ul>\n * <li>{@link #split()} the watch to get the time whilst the watch continues in the background. {@link #unsplit()} will\n * remove the effect of the split. At this point, these three options are available again.</li>\n * <li>{@link #suspend()} the watch to pause it. {@link #resume()} allows the watch to continue. Any time between the\n * suspend and resume will not be counted in the total. At this point, these three options are available again.</li>\n * <li>{@link #stop()} the watch to complete the timing session.</li>\n * </ul>\n *\n * <p>\n * It is intended that the output methods {@link #toString()} and {@link #getTime()} should only be called after stop,\n * split or suspend, however a suitable result will be returned at other points.\n * </p>\n *\n * <p>\n * NOTE: As from v2.1, the methods protect against inappropriate calls. Thus you cannot now call stop before start,\n * resume before suspend or unsplit before split.\n * </p>\n *\n * <ol>\n * <li>{@link #split()}, {@link #suspend()}, or {@link #stop()} cannot be invoked twice</li>\n * <li>{@link #unsplit()} may only be called if the watch has been {@link #split()}</li>\n * <li>{@link #resume()} may only be called if the watch has been {@link #suspend()}</li>\n * <li>{@link #start()} cannot be called twice without calling {@link #reset()}</li>\n * </ol>\n *\n * <p>This class is not thread-safe</p>\n *\n * @since 2.0\n */\npublic class StopWatch {\n\n    /**\n     * Enumeration type which indicates the split status of stopwatch.\n     */\n    private enum SplitState {\n        SPLIT,\n        UNSPLIT\n    }\n\n    /**\n     * Enumeration type which indicates the status of stopwatch.\n     */\n    private enum State {\n\n        RUNNING {\n            @Override\n            boolean isStarted() {\n                return true;\n            }\n            @Override\n            boolean isStopped() {\n                return false;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        },\n        STOPPED {\n            @Override\n            boolean isStarted() {\n                return false;\n            }\n            @Override\n            boolean isStopped() {\n                return true;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        },\n        SUSPENDED {\n            @Override\n            boolean isStarted() {\n                return true;\n            }\n            @Override\n            boolean isStopped() {\n                return false;\n            }\n            @Override\n            boolean isSuspended() {\n                return true;\n            }\n        },\n        UNSTARTED {\n            @Override\n            boolean isStarted() {\n                return false;\n            }\n            @Override\n            boolean isStopped() {\n                return true;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        };\n\n        /**\n         * Returns whether the StopWatch is started. A suspended StopWatch is also started watch.\n         *\n         * @return boolean If the StopWatch is started.\n         */\n        abstract boolean isStarted();\n\n        /**\n         * Returns whether the StopWatch is stopped. The stopwatch which's not yet started and explicitly stopped stopwatch is\n         * considered as stopped.\n         *\n         * @return boolean If the StopWatch is stopped.\n         */\n        abstract boolean isStopped();\n\n        /**\n         * Returns whether the StopWatch is suspended.\n         *\n         * @return boolean\n         *             If the StopWatch is suspended.\n         */\n        abstract boolean isSuspended();\n    }\n\n    private static final long NANO_2_MILLIS = 1000000L;\n\n    /**\n     * Creates a stopwatch for convenience.\n     *\n     * @return StopWatch a stopwatch.\n     *\n     * @since 3.10\n     */\n    public static StopWatch create() {\n        return new StopWatch();\n    }\n\n    /**\n     * Creates a started stopwatch for convenience.\n     *\n     * @return StopWatch a stopwatch that's already been started.\n     *\n     * @since 3.5\n     */\n    public static StopWatch createStarted() {\n        final StopWatch sw = new StopWatch();\n        sw.start();\n        return sw;\n    }\n\n    /**\n     * A message for string presentation.\n     *\n     * @since 3.10\n     */\n    private final String message;\n\n    /**\n     * The current running state of the StopWatch.\n     */\n    private State runningState = State.UNSTARTED;\n\n    /**\n     * Whether the stopwatch has a split time recorded.\n     */\n    private SplitState splitState = SplitState.UNSPLIT;\n\n    /**\n     * The start time in nanoseconds.\n     */\n    private long startTimeNanos;\n\n    /**\n     * The start time in milliseconds - nanoTime is only for elapsed time so we\n     * need to also store the currentTimeMillis to maintain the old\n     * getStartTime API.\n     */\n    private long startTimeMillis;\n\n    /**\n     * The end time in milliseconds - nanoTime is only for elapsed time so we\n     * need to also store the currentTimeMillis to maintain the old\n     * getStartTime API.\n     */\n    private long stopTimeMillis;\n\n    /**\n     * The stop time in nanoseconds.\n     */\n    private long stopTimeNanos;\n\n    /**\n     * Constructor.\n     *\n     */\n    public StopWatch() {\n        this(null);\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param message A message for string presentation.\n     * @since 3.10\n     */\n    public StopWatch(final String message) {\n        this.message = message;\n    }\n\n    /**\n     * Returns the split time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     *\n     * @return the split time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     * @since 3.10\n     */\n    public String formatSplitTime() {\n        return DurationFormatUtils.formatDurationHMS(getSplitTime());\n    }\n\n    /**\n     * Returns the time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     *\n     * @return the time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     * @since 3.10\n     */\n    public String formatTime() {\n        return DurationFormatUtils.formatDurationHMS(getTime());\n    }\n\n    /**\n     * Gets the message for string presentation.\n     *\n     * @return the message for string presentation.\n     * @since 3.10\n     */\n    public String getMessage() {\n        return message;\n    }\n\n    /**\n     * Gets the <em>elapsed</em> time in nanoseconds.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop.\n     * </p>\n     *\n     * @return the <em>elapsed</em> time in nanoseconds.\n     * @see System#nanoTime()\n     * @since 3.0\n     */\n    public long getNanoTime() {\n        if (this.runningState == State.STOPPED || this.runningState == State.SUSPENDED) {\n            return this.stopTimeNanos - this.startTimeNanos;\n        }\n        if (this.runningState == State.UNSTARTED) {\n            return 0;\n        }\n        if (this.runningState == State.RUNNING) {\n            return System.nanoTime() - this.startTimeNanos;\n        }\n        throw new IllegalStateException(\"Illegal running state has occurred.\");\n    }\n\n    /**\n     * Gets the split time in nanoseconds.\n     *\n     * <p>\n     * This is the time between start and latest split.\n     * </p>\n     *\n     * @return the split time in nanoseconds\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not yet been split.\n     * @since 3.0\n     */\n    public long getSplitNanoTime() {\n        if (this.splitState != SplitState.SPLIT) {\n            throw new IllegalStateException(\"Stopwatch must be split to get the split time.\");\n        }\n        return this.stopTimeNanos - this.startTimeNanos;\n    }\n\n    /**\n     * Gets the split time on the stopwatch.\n     *\n     * <p>\n     * This is the time between start and latest split.\n     * </p>\n     *\n     * @return the split time in milliseconds\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not yet been split.\n     * @since 2.1\n     */\n    public long getSplitTime() {\n        return nanosToMillis(getSplitNanoTime());\n    }\n\n    /**\n     * Gets the time this stopwatch was started in milliseconds, between the current time and midnight, January 1, 1970\n     * UTC.\n     *\n     * @return the time this stopwatch was started in milliseconds, between the current time and midnight, January 1,\n     *         1970 UTC.\n     * @throws IllegalStateException if this StopWatch has not been started\n     * @since 2.4\n     */\n    public long getStartTime() {\n        if (this.runningState == State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch has not been started\");\n        }\n        // System.nanoTime is for elapsed time\n        return this.startTimeMillis;\n    }\n\n    /**\n     * Gets the time this stopwatch was stopped in milliseconds, between the current time and midnight, January 1, 1970\n     * UTC.\n     *\n     * @return the time this stopwatch was started in milliseconds, between the current time and midnight, January 1,\n     *         1970 UTC.\n     * @throws IllegalStateException if this StopWatch has not been started\n     * @since 3.12.0\n     */\n    public long getStopTime() {\n        if (this.runningState == State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch has not been started\");\n        }\n        // System.nanoTime is for elapsed time\n        return this.stopTimeMillis;\n    }\n\n    /**\n     * Gets the time on the stopwatch.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop.\n     * </p>\n     *\n     * @return the time in milliseconds\n     */\n    public long getTime() {\n        return nanosToMillis(getNanoTime());\n    }\n\n    /**\n     * Gets the time in the specified TimeUnit.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop. The resulting time will be expressed in the desired TimeUnit with any remainder rounded down.\n     * For example, if the specified unit is {@code TimeUnit.HOURS} and the stopwatch time is 59 minutes, then the\n     * result returned will be {@code 0}.\n     * </p>\n     *\n     * @param timeUnit the unit of time, not null\n     * @return the time in the specified TimeUnit, rounded down\n     * @since 3.5\n     */\n    public long getTime(final TimeUnit timeUnit) {\n        return timeUnit.convert(getNanoTime(), TimeUnit.NANOSECONDS);\n    }\n\n    /**\n     * Returns whether the StopWatch is started. A suspended StopWatch is also started watch.\n     *\n     * @return boolean If the StopWatch is started.\n     * @since 3.2\n     */\n    public boolean isStarted() {\n        return runningState.isStarted();\n    }\n\n    /**\n     * Returns whether StopWatch is stopped. The stopwatch which's not yet started and explicitly stopped stopwatch is considered\n     * as stopped.\n     *\n     * @return boolean If the StopWatch is stopped.\n     * @since 3.2\n     */\n    public boolean isStopped() {\n        return runningState.isStopped();\n    }\n\n    /**\n     * Returns whether the StopWatch is suspended.\n     *\n     * @return boolean\n     *             If the StopWatch is suspended.\n     * @since 3.2\n     */\n    public boolean isSuspended() {\n        return runningState.isSuspended();\n    }\n\n    /**\n     * Converts nanoseconds to milliseconds.\n     *\n     * @param nanos nanoseconds to convert.\n     * @return milliseconds conversion result.\n     */\n    private long nanosToMillis(long nanos) {\n        return nanos / NANO_2_MILLIS;\n    }\n\n    /**\n     * Resets the stopwatch. Stops it if need be.\n     *\n     * <p>\n     * This method clears the internal values to allow the object to be reused.\n     * </p>\n     */\n    public void reset() {\n        this.runningState = State.UNSTARTED;\n        this.splitState = SplitState.UNSPLIT;\n    }\n\n    /**\n     * Resumes the stopwatch after a suspend.\n     *\n     * <p>\n     * This method resumes the watch after it was suspended. The watch will not include time between the suspend and\n     * resume calls in the total time.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not been suspended.\n     */\n    public void resume() {\n        if (this.runningState != State.SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume. \");\n        }\n        this.startTimeNanos += System.nanoTime() - this.stopTimeNanos;\n        this.runningState = State.RUNNING;\n    }\n\n    /**\n     * Splits the time.\n     *\n     * <p>\n     * This method sets the stop time of the watch to allow a time to be extracted. The start time is unaffected,\n     * enabling {@link #unsplit()} to continue the timing from the original start point.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not running.\n     */\n    public void split() {\n        if (this.runningState != State.RUNNING) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        this.stopTimeNanos = System.nanoTime();\n        this.splitState = SplitState.SPLIT;\n    }\n\n    /**\n     * Starts the stopwatch.\n     *\n     * <p>\n     * This method starts a new timing session, clearing any previous values.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is already running.\n     */\n    public void start() {\n        if (this.runningState == State.STOPPED) {\n            throw new IllegalStateException(\"Stopwatch must be reset before being restarted. \");\n        }\n        if (this.runningState != State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch already started. \");\n        }\n        this.startTimeNanos = System.nanoTime();\n        this.startTimeMillis = System.currentTimeMillis();\n        this.runningState = State.RUNNING;\n    }\n\n    /**\n     * Stops the stopwatch.\n     *\n     * <p>\n     * This method ends a new timing session, allowing the time to be retrieved.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not running.\n     */\n    public void stop() {\n        if (this.runningState != State.RUNNING && this.runningState != State.SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        if (this.runningState == State.RUNNING) {\n            this.stopTimeNanos = System.nanoTime();\n            this.stopTimeMillis = System.currentTimeMillis();\n        }\n        this.runningState = State.STOPPED;\n    }\n\n    /**\n     * Suspends the stopwatch for later resumption.\n     *\n     * <p>\n     * This method suspends the watch until it is resumed. The watch will not include time between the suspend and\n     * resume calls in the total time.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if (this.runningState != State.RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n        }\n        this.stopTimeNanos = System.nanoTime();\n        this.stopTimeMillis = System.currentTimeMillis();\n        this.runningState = State.SUSPENDED;\n    }\n\n    /**\n     * Gets a summary of the split time that the stopwatch recorded as a string.\n     *\n     * <p>\n     * The format used is ISO 8601-like, [<i>message</i> ]<i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n     * </p>\n     *\n     * @return the split time as a String\n     * @since 2.1\n     * @since 3.10 Returns the prefix {@code \"message \"} if the message is set.\n     */\n    public String toSplitString() {\n        final String msgStr = Objects.toString(message, StringUtils.EMPTY);\n        final String formattedTime = formatSplitTime();\n        return msgStr.isEmpty() ? formattedTime : msgStr + StringUtils.SPACE + formattedTime;\n    }\n\n    /**\n     * Gets a summary of the time that the stopwatch recorded as a string.\n     *\n     * <p>\n     * The format used is ISO 8601-like, [<i>message</i> ]<i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n     * </p>\n     *\n     * @return the time as a String\n     * @since 3.10 Returns the prefix {@code \"message \"} if the message is set.\n     */\n    @Override\n    public String toString() {\n        final String msgStr = Objects.toString(message, StringUtils.EMPTY);\n        final String formattedTime = formatTime();\n        return msgStr.isEmpty() ? formattedTime : msgStr + StringUtils.SPACE + formattedTime;\n    }\n\n    /**\n     * Removes a split.\n     *\n     * <p>\n     * This method clears the stop time. The start time is unaffected, enabling timing from the original start point to\n     * continue.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not been split.\n     */\n    public void unsplit() {\n        if (this.splitState != SplitState.SPLIT) {\n            throw new IllegalStateException(\"Stopwatch has not been split. \");\n        }\n        this.splitState = SplitState.UNSPLIT;\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Converts nanoseconds to milliseconds.\n     *\n     * @param nanos nanoseconds to convert.\n     * @return milliseconds conversion result.\n     */\n    private long nanosToMillis(long nanos) {\n        return nanos / NANO_2_MILLIS;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.time.StopWatch#getSplitNanoTime\n methodBody: public long getSplitNanoTime() {\nif(this.splitState != SplitState.SPLIT){throw new IllegalStateException(\"Stopwatch must be split to get the split time.\");\n}return this.stopTimeNanos - this.startTimeNanos;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Gets the split time on the stopwatch.\n     *\n     * <p>\n     * This is the time between start and latest split.\n     * </p>\n     *\n     * @return the split time in milliseconds\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not yet been split.\n     * @since 2.1\n     */\n    public long getSplitTime() {\n        return nanosToMillis(getSplitNanoTime());\n    }\n/**\n     * Converts nanoseconds to milliseconds.\n     *\n     * @param nanos nanoseconds to convert.\n     * @return milliseconds conversion result.\n     */\n    private long nanosToMillis(long nanos) {\n        return nanos / NANO_2_MILLIS;\n    }",
        "diffSourceCode": "   316:     /**\n   317:      * Gets the split time on the stopwatch.\n   318:      *\n   319:      * <p>\n   320:      * This is the time between start and latest split.\n   321:      * </p>\n   322:      *\n   323:      * @return the split time in milliseconds\n   324:      *\n   325:      * @throws IllegalStateException\n   326:      *             if the StopWatch has not yet been split.\n   327:      * @since 2.1\n   328:      */\n   329:     public long getSplitTime() {\n-  330:         return getSplitNanoTime() / NANO_2_MILLIS;\n+  330:         return nanosToMillis(getSplitNanoTime());\n   331:     }\n   431:     /**\n-  432:      * Resets the stopwatch. Stops it if need be.\n+  432:      * Converts nanoseconds to milliseconds.\n   433:      *\n-  434:      * <p>\n-  435:      * This method clears the internal values to allow the object to be reused.\n-  436:      * </p>\n-  437:      */\n-  438:     public void reset() {\n-  439:         this.runningState = State.UNSTARTED;\n+  434:      * @param nanos nanoseconds to convert.\n+  435:      * @return milliseconds conversion result.\n+  436:      */\n+  437:     private long nanosToMillis(long nanos) {\n+  438:         return nanos / NANO_2_MILLIS;\n+  439:     }\n",
        "uniqueId": "426ebb13ee04af4f7d7efcb6338e86b3a4ccca98_316_331_431_439_316_331",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": true,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n/**\n * Gets the split time on the stopwatch.\n *\n * <p>\n * This is the time between start and latest split.\n * </p>\n *\n * @return the split time in milliseconds\n *\n * @throws IllegalStateException\n *             if the StopWatch has not yet been split.\n * @since 2.1\n */\npublic long getSplitTime() {\n    return calculateSplitTime();\n}\n\n/**\n * Calculates the split time in milliseconds.\n *\n * @return the split time in milliseconds\n *\n * @throws IllegalStateException\n *             if the StopWatch has not yet been split.\n */\nprivate long calculateSplitTime() {\n    return getSplitNanoTime() / NANO_2_MILLIS;\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Gets the split time on the stopwatch.\n     *\n     * <p>\n     * This is the time between start and latest split.\n     * </p>\n     *\n     * @return the split time in milliseconds\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not yet been split.\n     * @since 2.1\n     */\n    public long getSplitTime() {\n        return getSplitNanoTime() / NANO_2_MILLIS;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.lang3.time;\n\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * {@link StopWatch} provides a convenient API for timings.\n *\n * <p>\n * To start the watch, call {@link #start()} or {@link StopWatch#createStarted()}. At this point you can:\n * </p>\n * <ul>\n * <li>{@link #split()} the watch to get the time whilst the watch continues in the background. {@link #unsplit()} will\n * remove the effect of the split. At this point, these three options are available again.</li>\n * <li>{@link #suspend()} the watch to pause it. {@link #resume()} allows the watch to continue. Any time between the\n * suspend and resume will not be counted in the total. At this point, these three options are available again.</li>\n * <li>{@link #stop()} the watch to complete the timing session.</li>\n * </ul>\n *\n * <p>\n * It is intended that the output methods {@link #toString()} and {@link #getTime()} should only be called after stop,\n * split or suspend, however a suitable result will be returned at other points.\n * </p>\n *\n * <p>\n * NOTE: As from v2.1, the methods protect against inappropriate calls. Thus you cannot now call stop before start,\n * resume before suspend or unsplit before split.\n * </p>\n *\n * <p>\n * 1. split(), suspend(), or stop() cannot be invoked twice<br>\n * 2. unsplit() may only be called if the watch has been split()<br>\n * 3. resume() may only be called if the watch has been suspend()<br>\n * 4. start() cannot be called twice without calling reset()\n * </p>\n *\n * <p>This class is not thread-safe</p>\n *\n * @since 2.0\n */\npublic class StopWatch {\n\n    /**\n     * Enumeration type which indicates the split status of stopwatch.\n     */\n    private enum SplitState {\n        SPLIT,\n        UNSPLIT\n    }\n\n    /**\n     * Enumeration type which indicates the status of stopwatch.\n     */\n    private enum State {\n\n        RUNNING {\n            @Override\n            boolean isStarted() {\n                return true;\n            }\n            @Override\n            boolean isStopped() {\n                return false;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        },\n        STOPPED {\n            @Override\n            boolean isStarted() {\n                return false;\n            }\n            @Override\n            boolean isStopped() {\n                return true;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        },\n        SUSPENDED {\n            @Override\n            boolean isStarted() {\n                return true;\n            }\n            @Override\n            boolean isStopped() {\n                return false;\n            }\n            @Override\n            boolean isSuspended() {\n                return true;\n            }\n        },\n        UNSTARTED {\n            @Override\n            boolean isStarted() {\n                return false;\n            }\n            @Override\n            boolean isStopped() {\n                return true;\n            }\n            @Override\n            boolean isSuspended() {\n                return false;\n            }\n        };\n\n        /**\n         * Returns whether the StopWatch is started. A suspended StopWatch is also started watch.\n         *\n         * @return boolean If the StopWatch is started.\n         */\n        abstract boolean isStarted();\n\n        /**\n         * Returns whether the StopWatch is stopped. The stopwatch which's not yet started and explicitly stopped stopwatch is\n         * considered as stopped.\n         *\n         * @return boolean If the StopWatch is stopped.\n         */\n        abstract boolean isStopped();\n\n        /**\n         * Returns whether the StopWatch is suspended.\n         *\n         * @return boolean\n         *             If the StopWatch is suspended.\n         */\n        abstract boolean isSuspended();\n    }\n\n    private static final long NANO_2_MILLIS = 1000000L;\n\n    /**\n     * Creates a stopwatch for convenience.\n     *\n     * @return StopWatch a stopwatch.\n     *\n     * @since 3.10\n     */\n    public static StopWatch create() {\n        return new StopWatch();\n    }\n\n    /**\n     * Creates a started stopwatch for convenience.\n     *\n     * @return StopWatch a stopwatch that's already been started.\n     *\n     * @since 3.5\n     */\n    public static StopWatch createStarted() {\n        final StopWatch sw = new StopWatch();\n        sw.start();\n        return sw;\n    }\n\n    /**\n     * A message for string presentation.\n     *\n     * @since 3.10\n     */\n    private final String message;\n\n    /**\n     * The current running state of the StopWatch.\n     */\n    private State runningState = State.UNSTARTED;\n\n    /**\n     * Whether the stopwatch has a split time recorded.\n     */\n    private SplitState splitState = SplitState.UNSPLIT;\n\n    /**\n     * The start time in nanoseconds.\n     */\n    private long startTimeNanos;\n\n    /**\n     * The start time in milliseconds - nanoTime is only for elapsed time so we\n     * need to also store the currentTimeMillis to maintain the old\n     * getStartTime API.\n     */\n    private long startTimeMillis;\n\n    /**\n     * The end time in milliseconds - nanoTime is only for elapsed time so we\n     * need to also store the currentTimeMillis to maintain the old\n     * getStartTime API.\n     */\n    private long stopTimeMillis;\n\n    /**\n     * The stop time in nanoseconds.\n     */\n    private long stopTimeNanos;\n\n    /**\n     * Constructor.\n     *\n     */\n    public StopWatch() {\n        this(null);\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param message A message for string presentation.\n     * @since 3.10\n     */\n    public StopWatch(final String message) {\n        this.message = message;\n    }\n\n    /**\n     * Returns the split time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     *\n     * @return the split time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     * @since 3.10\n     */\n    public String formatSplitTime() {\n        return DurationFormatUtils.formatDurationHMS(getSplitTime());\n    }\n\n    /**\n     * Returns the time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     *\n     * @return the time formatted by {@link DurationFormatUtils#formatDurationHMS}.\n     * @since 3.10\n     */\n    public String formatTime() {\n        return DurationFormatUtils.formatDurationHMS(getTime());\n    }\n\n    /**\n     * Gets the message for string presentation.\n     *\n     * @return the message for string presentation.\n     * @since 3.10\n     */\n    public String getMessage() {\n        return message;\n    }\n\n    /**\n     * Gets the <em>elapsed</em> time in nanoseconds.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop.\n     * </p>\n     *\n     * @return the <em>elapsed</em> time in nanoseconds.\n     * @see System#nanoTime()\n     * @since 3.0\n     */\n    public long getNanoTime() {\n        if (this.runningState == State.STOPPED || this.runningState == State.SUSPENDED) {\n            return this.stopTimeNanos - this.startTimeNanos;\n        }\n        if (this.runningState == State.UNSTARTED) {\n            return 0;\n        }\n        if (this.runningState == State.RUNNING) {\n            return System.nanoTime() - this.startTimeNanos;\n        }\n        throw new IllegalStateException(\"Illegal running state has occurred.\");\n    }\n\n    /**\n     * Gets the split time in nanoseconds.\n     *\n     * <p>\n     * This is the time between start and latest split.\n     * </p>\n     *\n     * @return the split time in nanoseconds\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not yet been split.\n     * @since 3.0\n     */\n    public long getSplitNanoTime() {\n        if (this.splitState != SplitState.SPLIT) {\n            throw new IllegalStateException(\"Stopwatch must be split to get the split time.\");\n        }\n        return this.stopTimeNanos - this.startTimeNanos;\n    }\n\n    /**\n     * Gets the split time on the stopwatch.\n     *\n     * <p>\n     * This is the time between start and latest split.\n     * </p>\n     *\n     * @return the split time in milliseconds\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not yet been split.\n     * @since 2.1\n     */\n    public long getSplitTime() {\n        return getSplitNanoTime() / NANO_2_MILLIS;\n    }\n\n    /**\n     * Gets the time this stopwatch was started in milliseconds, between the current time and midnight, January 1, 1970\n     * UTC.\n     *\n     * @return the time this stopwatch was started in milliseconds, between the current time and midnight, January 1,\n     *         1970 UTC.\n     * @throws IllegalStateException if this StopWatch has not been started\n     * @since 2.4\n     */\n    public long getStartTime() {\n        if (this.runningState == State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch has not been started\");\n        }\n        // System.nanoTime is for elapsed time\n        return this.startTimeMillis;\n    }\n\n    /**\n     * Gets the time this stopwatch was stopped in milliseconds, between the current time and midnight, January 1, 1970\n     * UTC.\n     *\n     * @return the time this stopwatch was started in milliseconds, between the current time and midnight, January 1,\n     *         1970 UTC.\n     * @throws IllegalStateException if this StopWatch has not been started\n     * @since 3.12.0\n     */\n    public long getStopTime() {\n        if (this.runningState == State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch has not been started\");\n        }\n        // System.nanoTime is for elapsed time\n        return this.stopTimeMillis;\n    }\n\n    /**\n     * Gets the time on the stopwatch.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop.\n     * </p>\n     *\n     * @return the time in milliseconds\n     */\n    public long getTime() {\n        return getNanoTime() / NANO_2_MILLIS;\n    }\n\n    /**\n     * Gets the time in the specified TimeUnit.\n     *\n     * <p>\n     * This is either the time between the start and the moment this method is called, or the amount of time between\n     * start and stop. The resulting time will be expressed in the desired TimeUnit with any remainder rounded down.\n     * For example, if the specified unit is {@code TimeUnit.HOURS} and the stopwatch time is 59 minutes, then the\n     * result returned will be {@code 0}.\n     * </p>\n     *\n     * @param timeUnit the unit of time, not null\n     * @return the time in the specified TimeUnit, rounded down\n     * @since 3.5\n     */\n    public long getTime(final TimeUnit timeUnit) {\n        return timeUnit.convert(getNanoTime(), TimeUnit.NANOSECONDS);\n    }\n\n    /**\n     * Returns whether the StopWatch is started. A suspended StopWatch is also started watch.\n     *\n     * @return boolean If the StopWatch is started.\n     * @since 3.2\n     */\n    public boolean isStarted() {\n        return runningState.isStarted();\n    }\n\n    /**\n     * Returns whether StopWatch is stopped. The stopwatch which's not yet started and explicitly stopped stopwatch is considered\n     * as stopped.\n     *\n     * @return boolean If the StopWatch is stopped.\n     * @since 3.2\n     */\n    public boolean isStopped() {\n        return runningState.isStopped();\n    }\n\n    /**\n     * Returns whether the StopWatch is suspended.\n     *\n     * @return boolean\n     *             If the StopWatch is suspended.\n     * @since 3.2\n     */\n    public boolean isSuspended() {\n        return runningState.isSuspended();\n    }\n\n    /**\n     * Resets the stopwatch. Stops it if need be.\n     *\n     * <p>\n     * This method clears the internal values to allow the object to be reused.\n     * </p>\n     */\n    public void reset() {\n        this.runningState = State.UNSTARTED;\n        this.splitState = SplitState.UNSPLIT;\n    }\n\n    /**\n     * Resumes the stopwatch after a suspend.\n     *\n     * <p>\n     * This method resumes the watch after it was suspended. The watch will not include time between the suspend and\n     * resume calls in the total time.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not been suspended.\n     */\n    public void resume() {\n        if (this.runningState != State.SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume. \");\n        }\n        this.startTimeNanos += System.nanoTime() - this.stopTimeNanos;\n        this.runningState = State.RUNNING;\n    }\n\n    /**\n     * Splits the time.\n     *\n     * <p>\n     * This method sets the stop time of the watch to allow a time to be extracted. The start time is unaffected,\n     * enabling {@link #unsplit()} to continue the timing from the original start point.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not running.\n     */\n    public void split() {\n        if (this.runningState != State.RUNNING) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        this.stopTimeNanos = System.nanoTime();\n        this.splitState = SplitState.SPLIT;\n    }\n\n    /**\n     * Starts the stopwatch.\n     *\n     * <p>\n     * This method starts a new timing session, clearing any previous values.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is already running.\n     */\n    public void start() {\n        if (this.runningState == State.STOPPED) {\n            throw new IllegalStateException(\"Stopwatch must be reset before being restarted. \");\n        }\n        if (this.runningState != State.UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch already started. \");\n        }\n        this.startTimeNanos = System.nanoTime();\n        this.startTimeMillis = System.currentTimeMillis();\n        this.runningState = State.RUNNING;\n    }\n\n    /**\n     * Stops the stopwatch.\n     *\n     * <p>\n     * This method ends a new timing session, allowing the time to be retrieved.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not running.\n     */\n    public void stop() {\n        if (this.runningState != State.RUNNING && this.runningState != State.SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        if (this.runningState == State.RUNNING) {\n            this.stopTimeNanos = System.nanoTime();\n            this.stopTimeMillis = System.currentTimeMillis();\n        }\n        this.runningState = State.STOPPED;\n    }\n\n    /**\n     * Suspends the stopwatch for later resumption.\n     *\n     * <p>\n     * This method suspends the watch until it is resumed. The watch will not include time between the suspend and\n     * resume calls in the total time.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if (this.runningState != State.RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n        }\n        this.stopTimeNanos = System.nanoTime();\n        this.stopTimeMillis = System.currentTimeMillis();\n        this.runningState = State.SUSPENDED;\n    }\n\n    /**\n     * Gets a summary of the split time that the stopwatch recorded as a string.\n     *\n     * <p>\n     * The format used is ISO 8601-like, [<i>message</i> ]<i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n     * </p>\n     *\n     * @return the split time as a String\n     * @since 2.1\n     * @since 3.10 Returns the prefix {@code \"message \"} if the message is set.\n     */\n    public String toSplitString() {\n        final String msgStr = Objects.toString(message, StringUtils.EMPTY);\n        final String formattedTime = formatSplitTime();\n        return msgStr.isEmpty() ? formattedTime : msgStr + StringUtils.SPACE + formattedTime;\n    }\n\n    /**\n     * Gets a summary of the time that the stopwatch recorded as a string.\n     *\n     * <p>\n     * The format used is ISO 8601-like, [<i>message</i> ]<i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n     * </p>\n     *\n     * @return the time as a String\n     * @since 3.10 Returns the prefix {@code \"message \"} if the message is set.\n     */\n    @Override\n    public String toString() {\n        final String msgStr = Objects.toString(message, StringUtils.EMPTY);\n        final String formattedTime = formatTime();\n        return msgStr.isEmpty() ? formattedTime : msgStr + StringUtils.SPACE + formattedTime;\n    }\n\n    /**\n     * Removes a split.\n     *\n     * <p>\n     * This method clears the stop time. The start time is unaffected, enabling timing from the original start point to\n     * continue.\n     * </p>\n     *\n     * @throws IllegalStateException\n     *             if the StopWatch has not been split.\n     */\n    public void unsplit() {\n        if (this.splitState != SplitState.SPLIT) {\n            throw new IllegalStateException(\"Stopwatch has not been split. \");\n        }\n        this.splitState = SplitState.UNSPLIT;\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": "/**\n * Gets the split time on the stopwatch.\n *\n * <p>\n * This is the time between start and latest split.\n * </p>\n *\n * @return the split time in milliseconds\n *\n * @throws IllegalStateException\n *             if the StopWatch has not yet been split.\n * @since 2.1\n */\npublic long getSplitTime() {\n    return calculateSplitTime();\n}\n\n/**\n * Calculates the split time in milliseconds.\n *\n * @return the split time in milliseconds\n *\n * @throws IllegalStateException\n *             if the StopWatch has not yet been split.\n */\nprivate long calculateSplitTime() {\n    return getSplitNanoTime() / NANO_2_MILLIS;\n}",
        "codebleu": 0.566022766963064,
        "ngram_match_score": 0.6394531287135242,
        "syntax_match_score": 0.4,
        "weighted_ngram_match_score": 0.7246379391387319,
        "dataflow_match_score": 0.5
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected createChildBackgroundInitializer() : AbstractChildBackgroundInitializer extracted from public testInitializeChildWithExecutor() : void in class org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 167,
                "endLine": 191,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 167,
                "endLine": 191,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 411,
                "endLine": 418,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n            final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#testInitializeChildWithExecutor",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkChild\n methodBody: private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\nfinal ChildBackgroundInitializer cinit=(ChildBackgroundInitializer)child;\nfinal Integer result=cinit.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,cinit.initializeCalls,\"Wrong number of executions\");\nif(expExec != null){assertEquals(expExec,cinit.currentExecutor,\"Wrong executor service\");\n}}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#getActiveExecutor\n methodBody: protected final synchronized ExecutorService getActiveExecutor() {\nreturn executor;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#addInitializer\n methodBody: public void addInitializer(final String name, final BackgroundInitializer<?> backgroundInitializer) {\nObjects.requireNonNull(name,\"name\");\nObjects.requireNonNull(backgroundInitializer,\"backgroundInitializer\");\nsynchronized(this){if(isStarted()){throw new IllegalStateException(\"addInitializer() must not be called after start()!\");\n}childInitializers.put(name,backgroundInitializer);\n}}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#setExternalExecutor\n methodBody: public final synchronized void setExternalExecutor(\n            final ExecutorService externalExecutor) {\nif(isStarted()){throw new IllegalStateException(\"Cannot set ExecutorService after start()!\");\n}this.externalExecutor=externalExecutor;\n}",
        "classSignatureBefore": "public class MultiBackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#testInitializeChildWithExecutor"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class MultiBackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    private MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    private static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n        final Integer result = cinit.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, new ChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    new ChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(Integer.valueOf(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n            final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            new ChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final ChildBackgroundInitializer childOne = new ChildBackgroundInitializer();\n        final ChildBackgroundInitializer childTwo = new ChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * A concrete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     */\n    private static final class ChildBackgroundInitializer extends\n            BackgroundInitializer<Integer> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            currentExecutor = getActiveExecutor();\n            initializeCalls++;\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            return Integer.valueOf(initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    protected MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    protected static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final AbstractChildBackgroundInitializer cinit = (AbstractChildBackgroundInitializer) child;\n        final Integer result = cinit.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, createChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    createChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(CloseableCounter.wrapInteger(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractChildBackgroundInitializer c1 = createChildBackgroundInitializer();\n            final AbstractChildBackgroundInitializer c2 = createChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, createChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, createChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            createChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final AbstractChildBackgroundInitializer childOne = createChildBackgroundInitializer();\n        final AbstractChildBackgroundInitializer childTwo = createChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }\n\n    /**\n     * A mostly complete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     *\n     * Subclasses will contain the initializer, either as an method implementation\n     * or by using a supplier.\n     */\n    protected static class AbstractChildBackgroundInitializer extends BackgroundInitializer<CloseableCounter> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            initializeCalls++;\n            currentExecutor = getActiveExecutor();\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodChildBackgroundInitializer extends AbstractChildBackgroundInitializer {\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** Has the close consumer successfully reached this object. */\n        volatile boolean closed;\n\n        public CloseableCounter increment() {\n            initializeCalls++;\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls;\n        }\n\n        public CloseableCounter setInitializeCalls(int i) {\n            initializeCalls = i;\n            return this;\n        }\n\n        public void close() {\n            closed = true;\n        }\n\n        public boolean isClosed() {\n            return closed;\n        }\n\n        @Override\n        public boolean equals(final Object other) {\n            if (other instanceof CloseableCounter) {\n                return initializeCalls == ((CloseableCounter) other).getInitializeCalls();\n            }\n            return false;\n        }\n\n        // A convenience for testing that a CloseableCounter typed as Object has a specific initializeCalls value\n        public static CloseableCounter wrapInteger(int i) {\n            return new CloseableCounter().setInitializeCalls(i);\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkChild\n methodBody: private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\nfinal ChildBackgroundInitializer cinit=(ChildBackgroundInitializer)child;\nfinal Integer result=cinit.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,cinit.initializeCalls,\"Wrong number of executions\");\nif(expExec != null){assertEquals(expExec,cinit.currentExecutor,\"Wrong executor service\");\n}}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#getActiveExecutor\n methodBody: protected final synchronized ExecutorService getActiveExecutor() {\nreturn executor;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#addInitializer\n methodBody: public void addInitializer(final String name, final BackgroundInitializer<?> backgroundInitializer) {\nObjects.requireNonNull(name,\"name\");\nObjects.requireNonNull(backgroundInitializer,\"backgroundInitializer\");\nsynchronized(this){if(isStarted()){throw new IllegalStateException(\"addInitializer() must not be called after start()!\");\n}childInitializers.put(name,backgroundInitializer);\n}}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#setExternalExecutor\n methodBody: public final synchronized void setExternalExecutor(\n            final ExecutorService externalExecutor) {\nif(isStarted()){throw new IllegalStateException(\"Cannot set ExecutorService after start()!\");\n}this.externalExecutor=externalExecutor;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractChildBackgroundInitializer c1 = createChildBackgroundInitializer();\n            final AbstractChildBackgroundInitializer c2 = createChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n/**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }",
        "diffSourceCode": "   167:     /**\n   168:      * Tests the behavior of initialize() if a child initializer has a specific\n   169:      * executor service. Then this service should not be overridden.\n   170:      *\n   171:      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n   172:      */\n   173:     @Test\n   174:     public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n   175:         final String initExec = \"childInitializerWithExecutor\";\n   176:         final ExecutorService exec = Executors.newSingleThreadExecutor();\n   177:         try {\n-  178:             final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n-  179:             final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n+  178:             final AbstractChildBackgroundInitializer c1 = createChildBackgroundInitializer();\n+  179:             final AbstractChildBackgroundInitializer c2 = createChildBackgroundInitializer();\n   180:             c2.setExternalExecutor(exec);\n   181:             initializer.addInitializer(CHILD_INIT, c1);\n   182:             initializer.addInitializer(initExec, c2);\n   183:             initializer.start();\n   184:             initializer.get();\n   185:             checkChild(c1, initializer.getActiveExecutor());\n   186:             checkChild(c2, exec);\n   187:         } finally {\n   188:             exec.shutdown();\n   189:             exec.awaitTermination(1, TimeUnit.SECONDS);\n   190:         }\n   191:     }\n   411:     /**\n-  412:      * A concrete implementation of {@code BackgroundInitializer} used for\n-  413:      * defining background tasks for {@code MultiBackgroundInitializer}.\n-  414:      */\n-  415:     private static final class ChildBackgroundInitializer extends\n-  416:             BackgroundInitializer<Integer> {\n-  417:         /** Stores the current executor service. */\n-  418:         volatile ExecutorService currentExecutor;\n+  412:      * An overrideable method to create concrete implementations of\n+  413:      * {@code BackgroundInitializer} used for defining background tasks\n+  414:      * for {@code MultiBackgroundInitializer}.\n+  415:      */\n+  416:     protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n+  417:         return new MethodChildBackgroundInitializer();\n+  418:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_167_191_411_418_167_191",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Helper method for testing the initialize() method. This method can\n * operate with both an external and a temporary executor service.\n *\n * @return the result object produced by the initializer\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\nprivate MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n        throws ConcurrentException {\n    final int count = 5;\n    for (int i = 0; i < count; i++) {\n        initializer.addInitializer(CHILD_INIT + i,\n                new ChildBackgroundInitializer());\n    }\n    initializer.start();\n    final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n            .get();\n    assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n    for (int i = 0; i < count; i++) {\n        final String key = CHILD_INIT + i;\n        assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n        assertEquals(Integer.valueOf(1), res.getResultObject(key), \"Wrong result object\");\n        assertFalse(res.isException(key), \"Exception flag\");\n        assertNull(res.getException(key), \"Got an exception\");\n        checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n    }\n    return res;\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n            final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    private MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    private static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n        final Integer result = cinit.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, new ChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    new ChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(Integer.valueOf(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n            final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            new ChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final ChildBackgroundInitializer childOne = new ChildBackgroundInitializer();\n        final ChildBackgroundInitializer childTwo = new ChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * A concrete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     */\n    private static final class ChildBackgroundInitializer extends\n            BackgroundInitializer<Integer> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            currentExecutor = getActiveExecutor();\n            initializeCalls++;\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            return Integer.valueOf(initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl() : AbstractBackgroundInitializerTestImpl extracted from public testIsInitialized() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 270,
                "endLine": 283,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 272,
                "endLine": 285,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 287,
                "endLine": 289,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testIsInitialized",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.AbstractConcurrentInitializer#isInitialized\n methodBody: protected abstract boolean isInitialized();\nmethodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nreturn object != NO_INIT;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#isInitialized\n methodBody: public synchronized boolean isInitialized() {\nif(future == null || !future.isDone()){return false;\n}tryfuture.get();\nreturn true;\ncatch(CancellationException|ExecutionException|InterruptedException e)return false;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest.BackgroundInitializerTestImpl#enableLatch\n methodBody: public void enableLatch() {\nwaitForLatch=true;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nif(childInitializers.isEmpty()){return false;\n}return childInitializers.values().stream().allMatch(BackgroundInitializer::isInitialized);\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#isStarted\n methodBody: public synchronized boolean isStarted() {\nreturn future != null;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest.ChildBackgroundInitializer#enableLatch\n methodBody: public void enableLatch() {\nwaitForLatch=true;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest.BackgroundInitializerTestImpl#releaseLatch\n methodBody: public void releaseLatch() {\nlatch.countDown();\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nreturn reference.get() != NO_INIT;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest.ChildBackgroundInitializer#releaseLatch\n methodBody: public void releaseLatch() {\nlatch.countDown();\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nreturn reference.get() != NO_INIT;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testIsInitialized"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.AbstractConcurrentInitializer#isInitialized\n methodBody: protected abstract boolean isInitialized();",
            "methodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nreturn object != NO_INIT;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#isInitialized\n methodBody: public synchronized boolean isInitialized() {\nif(future == null || !future.isDone()){return false;\n}tryfuture.get();\nreturn true;\ncatch(CancellationException|ExecutionException|InterruptedException e)return false;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest.BackgroundInitializerTestImpl#enableLatch\n methodBody: public void enableLatch() {\nwaitForLatch=true;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nif(childInitializers.isEmpty()){return false;\n}return childInitializers.values().stream().allMatch(BackgroundInitializer::isInitialized);\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#isStarted\n methodBody: public synchronized boolean isStarted() {\nreturn future != null;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest.ChildBackgroundInitializer#enableLatch\n methodBody: public void enableLatch() {\nwaitForLatch=true;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest.BackgroundInitializerTestImpl#releaseLatch\n methodBody: public void releaseLatch() {\nlatch.countDown();\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nreturn reference.get() != NO_INIT;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest.ChildBackgroundInitializer#releaseLatch\n methodBody: public void releaseLatch() {\nlatch.countDown();\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nreturn reference.get() != NO_INIT;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }",
        "diffSourceCode": "-  270:     /**\n-  271:      * Tests isInitialized() before and after the background task has finished.\n-  272:      */\n-  273:     @Test\n-  274:     public void testIsInitialized() throws ConcurrentException {\n-  275:         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-  276:         init.enableLatch();\n-  277:         init.start();\n-  278:         assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n-  279:         assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n-  280:         init.releaseLatch();\n-  281:         init.get(); //to ensure the initialize thread has completed.\n-  282:         assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n-  283:     }\n-  284: \n-  285:     /**\n-  287:      * some methods that simplify testing.\n-  288:      */\n-  289:     private static final class BackgroundInitializerTestImpl extends\n+  270:     }\n+  271: \n+  272:     /**\n+  273:      * Tests isInitialized() before and after the background task has finished.\n+  274:      */\n+  275:     @Test\n+  276:     public void testIsInitialized() throws ConcurrentException {\n+  277:         final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n+  278:         init.enableLatch();\n+  279:         init.start();\n+  280:         assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n+  281:         assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n+  282:         init.releaseLatch();\n+  283:         init.get(); //to ensure the initialize thread has completed.\n+  284:         assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n+  285:     }\n+  287:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n+  288:         return new MethodBackgroundInitializerTestImpl();\n+  289:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_270_283_287_289_272_285",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n/**\n * Checks if the background task has finished and the result is initialized.\n */\nprivate void checkIsInitialized(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n    assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n    assertFalse(init.isInitialized(), \"Initialized before releasing latch\");\n    init.releaseLatch();\n    init.get(); //to ensure the initialize thread has completed.\n    assertTrue(init.isInitialized(), \"Not initialized after releasing latch\");\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl() : AbstractBackgroundInitializerTestImpl extracted from public testIsStartedAfterGet() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 259,
                "endLine": 268,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 261,
                "endLine": 270,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 287,
                "endLine": 289,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testIsStartedAfterGet",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkInitialize\n methodBody: private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\nfinal int count=5;\nfor(int i=0; i < count; i++){initializer.addInitializer(CHILD_INIT + i,new ChildBackgroundInitializer());\n}initializer.start();\nfinal MultiBackgroundInitializer.MultiBackgroundInitializerResults res=initializer.get();\nassertEquals(count,res.initializerNames().size(),\"Wrong number of child initializers\");\nfor(int i=0; i < count; i++){final String key=CHILD_INIT + i;\nassertTrue(res.initializerNames().contains(key),\"Name not found: \" + key);\nassertEquals(Integer.valueOf(1),res.getResultObject(key),\"Wrong result object\");\nassertFalse(res.isException(key),\"Exception flag\");\nassertNull(res.getException(key),\"Got an exception\");\ncheckChild(res.getInitializer(key),initializer.getActiveExecutor());\n}return res;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#isStarted\n methodBody: public synchronized boolean isStarted() {\nreturn future != null;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest#checkInitialize\n methodBody: private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\nfinal Integer result=init.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,init.initializeCalls,\"Wrong number of invocations\");\nassertNotNull(init.getFuture(),\"No future\");\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testIsStartedAfterGet"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkInitialize\n methodBody: private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\nfinal int count=5;\nfor(int i=0; i < count; i++){initializer.addInitializer(CHILD_INIT + i,new ChildBackgroundInitializer());\n}initializer.start();\nfinal MultiBackgroundInitializer.MultiBackgroundInitializerResults res=initializer.get();\nassertEquals(count,res.initializerNames().size(),\"Wrong number of child initializers\");\nfor(int i=0; i < count; i++){final String key=CHILD_INIT + i;\nassertTrue(res.initializerNames().contains(key),\"Name not found: \" + key);\nassertEquals(Integer.valueOf(1),res.getResultObject(key),\"Wrong result object\");\nassertFalse(res.isException(key),\"Exception flag\");\nassertNull(res.getException(key),\"Got an exception\");\ncheckChild(res.getInitializer(key),initializer.getActiveExecutor());\n}return res;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#isStarted\n methodBody: public synchronized boolean isStarted() {\nreturn future != null;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest#checkInitialize\n methodBody: private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\nfinal Integer result=init.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,init.initializeCalls,\"Wrong number of invocations\");\nassertNotNull(init.getFuture(),\"No future\");\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }",
        "diffSourceCode": "-  259:     /**\n-  260:      * Tests isStarted() after the background task has finished.\n-  261:      */\n-  262:     @Test\n-  263:     public void testIsStartedAfterGet() throws ConcurrentException {\n-  264:         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-  265:         init.start();\n-  266:         checkInitialize(init);\n-  267:         assertTrue(init.isStarted(), \"Not started\");\n-  268:     }\n-  269: \n-  270:     /**\n-  287:      * some methods that simplify testing.\n-  288:      */\n-  289:     private static final class BackgroundInitializerTestImpl extends\n+  259:     }\n+  260: \n+  261:     /**\n+  262:      * Tests isStarted() after the background task has finished.\n+  263:      */\n+  264:     @Test\n+  265:     public void testIsStartedAfterGet() throws ConcurrentException {\n+  266:         final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n+  267:         init.start();\n+  268:         checkInitialize(init);\n+  269:         assertTrue(init.isStarted(), \"Not started\");\n+  270:     }\n+  287:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n+  288:         return new MethodBackgroundInitializerTestImpl();\n+  289:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_259_268_287_289_261_270",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Checks if the background task has finished initializing.\n *\n * @param init the initializer to test\n */\nprivate void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n    final Integer result = init.get();\n    assertEquals(1, result.intValue(), \"Wrong result\");\n    assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n    assertNotNull(init.getFuture(), \"No future\");\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl() : AbstractBackgroundInitializerTestImpl extracted from public testIsStartedTrue() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 249,
                "endLine": 257,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 251,
                "endLine": 259,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 287,
                "endLine": 289,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testIsStartedTrue",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#isStarted\n methodBody: public synchronized boolean isStarted() {\nreturn future != null;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testIsStartedTrue"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#isStarted\n methodBody: public synchronized boolean isStarted() {\nreturn future != null;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }",
        "diffSourceCode": "-  249:     /**\n-  250:      * Tests isStarted() after start().\n-  251:      */\n-  252:     @Test\n-  253:     public void testIsStartedTrue() {\n-  254:         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-  255:         init.start();\n-  256:         assertTrue(init.isStarted(), \"Not started\");\n-  257:     }\n-  258: \n-  259:     /**\n-  287:      * some methods that simplify testing.\n-  288:      */\n-  289:     private static final class BackgroundInitializerTestImpl extends\n+  249:     }\n+  250: \n+  251:     /**\n+  252:      * Tests isStarted() after start().\n+  253:      */\n+  254:     @Test\n+  255:     public void testIsStartedTrue() {\n+  256:         final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n+  257:         init.start();\n+  258:         assertTrue(init.isStarted(), \"Not started\");\n+  259:     }\n+  287:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n+  288:         return new MethodBackgroundInitializerTestImpl();\n+  289:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_249_257_287_289_251_259",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Helper method for checking whether the initialize() method was correctly\n * called. start() must already have been invoked.\n *\n * @param init the initializer to test\n */\nprivate void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n    final Integer result = init.get();\n    assertEquals(1, result.intValue(), \"Wrong result\");\n    assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n    assertNotNull(init.getFuture(), \"No future\");\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl() : AbstractBackgroundInitializerTestImpl extracted from public testIsStartedFalse() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 240,
                "endLine": 247,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 242,
                "endLine": 249,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 287,
                "endLine": 289,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testIsStartedFalse",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#isStarted\n methodBody: public synchronized boolean isStarted() {\nreturn future != null;\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testIsStartedFalse"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#isStarted\n methodBody: public synchronized boolean isStarted() {\nreturn future != null;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }",
        "diffSourceCode": "-  240:     /**\n-  241:      * Tests isStarted() before start() was called.\n-  242:      */\n-  243:     @Test\n-  244:     public void testIsStartedFalse() {\n-  245:         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-  246:         assertFalse(init.isStarted(), \"Already started\");\n-  247:     }\n-  248: \n-  249:     /**\n-  287:      * some methods that simplify testing.\n-  288:      */\n-  289:     private static final class BackgroundInitializerTestImpl extends\n+  240:     }\n+  241: \n+  242:     /**\n+  243:      * Tests isStarted() before start() was called.\n+  244:      */\n+  245:     @Test\n+  246:     public void testIsStartedFalse() {\n+  247:         final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n+  248:         assertFalse(init.isStarted(), \"Already started\");\n+  249:     }\n+  287:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n+  288:         return new MethodBackgroundInitializerTestImpl();\n+  289:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_240_247_287_289_242_249",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Helper method for checking whether the initialize() method was correctly\n * called. start() must already have been invoked.\n *\n * @param init the initializer to test\n */\nprivate void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n    final Integer result = init.get();\n    assertEquals(1, result.intValue(), \"Wrong result\");\n    assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n    assertNotNull(init.getFuture(), \"No future\");\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl(exec ExecutorService) : AbstractBackgroundInitializerTestImpl extracted from public testGetInterruptedException() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 203,
                "endLine": 238,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 205,
                "endLine": 240,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 291,
                "endLine": 293,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testGetInterruptedException",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testGetInterruptedException"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }",
        "diffSourceCode": "-  203:     /**\n-  204:      * Tests the get() method if waiting for the initialization is interrupted.\n-  205:      *\n-  206:      * @throws InterruptedException because we're making use of Java's concurrent API\n-  207:      */\n-  208:     @Test\n-  209:     public void testGetInterruptedException() throws InterruptedException {\n-  210:         final ExecutorService exec = Executors.newSingleThreadExecutor();\n-  211:         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n-  212:                 exec);\n-  213:         final CountDownLatch latch1 = new CountDownLatch(1);\n-  214:         init.shouldSleep = true;\n-  215:         init.start();\n-  216:         final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n-  217:         final Thread getThread = new Thread() {\n-  218:             @Override\n-  219:             public void run() {\n-  220:                 try {\n-  221:                     init.get();\n-  222:                 } catch (final ConcurrentException cex) {\n-  223:                     if (cex.getCause() instanceof InterruptedException) {\n-  224:                         iex.set((InterruptedException) cex.getCause());\n-  225:                     }\n-  226:                 } finally {\n-  227:                     assertTrue(isInterrupted(), \"Thread not interrupted\");\n-  228:                     latch1.countDown();\n-  229:                 }\n-  230:             }\n-  231:         };\n-  232:         getThread.start();\n-  233:         getThread.interrupt();\n-  234:         latch1.await();\n-  235:         exec.shutdownNow();\n-  236:         exec.awaitTermination(1, TimeUnit.SECONDS);\n-  237:         assertNotNull(iex.get(), \"No interrupted exception\");\n-  238:     }\n-  239: \n-  240:     /**\n-  291:         /** An exception to be thrown by initialize(). */\n-  292:         Exception ex;\n-  293: \n+  203:     }\n+  204: \n+  205:     /**\n+  206:      * Tests the get() method if waiting for the initialization is interrupted.\n+  207:      *\n+  208:      * @throws InterruptedException because we're making use of Java's concurrent API\n+  209:      */\n+  210:     @Test\n+  211:     public void testGetInterruptedException() throws InterruptedException {\n+  212:         final ExecutorService exec = Executors.newSingleThreadExecutor();\n+  213:         final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n+  214:                 exec);\n+  215:         final CountDownLatch latch1 = new CountDownLatch(1);\n+  216:         init.shouldSleep = true;\n+  217:         init.start();\n+  218:         final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n+  219:         final Thread getThread = new Thread() {\n+  220:             @Override\n+  221:             public void run() {\n+  222:                 try {\n+  223:                     init.get();\n+  224:                 } catch (final ConcurrentException cex) {\n+  225:                     if (cex.getCause() instanceof InterruptedException) {\n+  226:                         iex.set((InterruptedException) cex.getCause());\n+  227:                     }\n+  228:                 } finally {\n+  229:                     assertTrue(isInterrupted(), \"Thread not interrupted\");\n+  230:                     latch1.countDown();\n+  231:                 }\n+  232:             }\n+  233:         };\n+  234:         getThread.start();\n+  235:         getThread.interrupt();\n+  236:         latch1.await();\n+  237:         exec.shutdownNow();\n+  238:         exec.awaitTermination(1, TimeUnit.SECONDS);\n+  239:         assertNotNull(iex.get(), \"No interrupted exception\");\n+  240:     }\n+  291:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n+  292:         return new MethodBackgroundInitializerTestImpl(exec);\n+  293:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_203_238_291_293_205_240",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\nprivate void initializeBackgroundTask(BackgroundInitializerTestImpl init, AtomicReference<InterruptedException> iex, CountDownLatch latch1, ExecutorService exec) throws InterruptedException {\n    final Thread getThread = new Thread() {\n        @Override\n        public void run() {\n            try {\n                init.get();\n            } catch (final ConcurrentException cex) {\n                if (cex.getCause() instanceof InterruptedException) {\n                    iex.set((InterruptedException) cex.getCause());\n                }\n            } finally {\n                assertTrue(isInterrupted(), \"Thread not interrupted\");\n                latch1.countDown();\n            }\n        }\n    };\n    getThread.start();\n    getThread.interrupt();\n    latch1.await();\n    exec.shutdownNow();\n    exec.awaitTermination(1, TimeUnit.SECONDS);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl() : AbstractBackgroundInitializerTestImpl extracted from public testGetCheckedException() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 189,
                "endLine": 201,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 191,
                "endLine": 203,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 287,
                "endLine": 289,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testGetCheckedException",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testGetCheckedException"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }",
        "diffSourceCode": "-  189:     /**\n-  190:      * Tests the get() method if background processing causes a checked\n-  191:      * exception.\n-  192:      */\n-  193:     @Test\n-  194:     public void testGetCheckedException() {\n-  195:         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-  196:         final Exception ex = new Exception();\n-  197:         init.ex = ex;\n-  198:         init.start();\n-  199:         final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n-  200:         assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n-  201:     }\n-  202: \n-  203:     /**\n-  287:      * some methods that simplify testing.\n-  288:      */\n-  289:     private static final class BackgroundInitializerTestImpl extends\n+  189:     }\n+  190: \n+  191:     /**\n+  192:      * Tests the get() method if background processing causes a checked\n+  193:      * exception.\n+  194:      */\n+  195:     @Test\n+  196:     public void testGetCheckedException() {\n+  197:         final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n+  198:         final Exception ex = new Exception();\n+  199:         init.ex = ex;\n+  200:         init.start();\n+  201:         final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n+  202:         assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n+  203:     }\n+  287:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n+  288:         return new MethodBackgroundInitializerTestImpl();\n+  289:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_189_201_287_289_191_203",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n/**\n * Helper method for setting up and starting the background initializer.\n *\n * @param init the initializer to test\n * @param ex the exception to be thrown by initialize()\n */\nprivate void setupAndStartBackgroundInitializer(BackgroundInitializerTestImpl init, Exception ex) {\n    init.ex = ex;\n    init.start();\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl() : AbstractBackgroundInitializerTestImpl extracted from public testGetRuntimeException() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 175,
                "endLine": 187,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 177,
                "endLine": 189,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 287,
                "endLine": 289,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testGetRuntimeException",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testGetRuntimeException"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }",
        "diffSourceCode": "-  175:     /**\n-  176:      * Tests the get() method if background processing causes a runtime\n-  177:      * exception.\n-  178:      */\n-  179:     @Test\n-  180:     public void testGetRuntimeException() {\n-  181:         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-  182:         final RuntimeException rex = new RuntimeException();\n-  183:         init.ex = rex;\n-  184:         init.start();\n-  185:         final Exception ex = assertThrows(Exception.class, init::get);\n-  186:         assertEquals(rex, ex, \"Runtime exception not thrown\");\n-  187:     }\n-  188: \n-  189:     /**\n-  287:      * some methods that simplify testing.\n-  288:      */\n-  289:     private static final class BackgroundInitializerTestImpl extends\n+  175:     }\n+  176: \n+  177:     /**\n+  178:      * Tests the get() method if background processing causes a runtime\n+  179:      * exception.\n+  180:      */\n+  181:     @Test\n+  182:     public void testGetRuntimeException() {\n+  183:         final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n+  184:         final RuntimeException rex = new RuntimeException();\n+  185:         init.ex = rex;\n+  186:         init.start();\n+  187:         final Exception ex = assertThrows(Exception.class, init::get);\n+  188:         assertEquals(rex, ex, \"Runtime exception not thrown\");\n+  189:     }\n+  287:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n+  288:         return new MethodBackgroundInitializerTestImpl();\n+  289:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_175_187_287_289_177_189",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n/**\n * Helper method for testing the get() method after background processing causes a runtime exception.\n */\nprivate void testGetRuntimeException() {\n    final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n    final RuntimeException rex = new RuntimeException();\n    init.ex = rex;\n    init.start();\n    final Exception ex = assertThrows(Exception.class, init::get);\n    assertEquals(rex, ex, \"Runtime exception not thrown\");\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl() : AbstractBackgroundInitializerTestImpl extracted from public testGetBeforeStart() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 166,
                "endLine": 173,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 168,
                "endLine": 175,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 287,
                "endLine": 289,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testGetBeforeStart",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testGetBeforeStart"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }",
        "diffSourceCode": "-  166:     /**\n-  167:      * Tests calling get() before start(). This should cause an exception.\n-  168:      */\n-  169:     @Test\n-  170:     public void testGetBeforeStart() {\n-  171:         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-  172:         assertThrows(IllegalStateException.class, init::get);\n-  173:     }\n-  174: \n-  175:     /**\n-  287:      * some methods that simplify testing.\n-  288:      */\n-  289:     private static final class BackgroundInitializerTestImpl extends\n+  166:     }\n+  167: \n+  168:     /**\n+  169:      * Tests calling get() before start(). This should cause an exception.\n+  170:      */\n+  171:     @Test\n+  172:     public void testGetBeforeStart() {\n+  173:         final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n+  174:         assertThrows(IllegalStateException.class, init::get);\n+  175:     }\n+  287:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n+  288:         return new MethodBackgroundInitializerTestImpl();\n+  289:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_166_173_287_289_168_175",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Helper method for checking whether the initialize() method was correctly\n * called. start() must already have been invoked.\n *\n * @param init the initializer to test\n */\nprivate void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n    final Integer result = init.get();\n    assertEquals(1, result.intValue(), \"Wrong result\");\n    assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n    assertNotNull(init.getFuture(), \"No future\");\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getBackgroundInitializerTestImpl() : AbstractBackgroundInitializerTestImpl extracted from public testStartMultipleTimes() : void in class org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 152,
                "endLine": 164,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 154,
                "endLine": 166,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
                "startLine": 287,
                "endLine": 289,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testStartMultipleTimes",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkInitialize\n methodBody: private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\nfinal int count=5;\nfor(int i=0; i < count; i++){initializer.addInitializer(CHILD_INIT + i,new ChildBackgroundInitializer());\n}initializer.start();\nfinal MultiBackgroundInitializer.MultiBackgroundInitializerResults res=initializer.get();\nassertEquals(count,res.initializerNames().size(),\"Wrong number of child initializers\");\nfor(int i=0; i < count; i++){final String key=CHILD_INIT + i;\nassertTrue(res.initializerNames().contains(key),\"Name not found: \" + key);\nassertEquals(Integer.valueOf(1),res.getResultObject(key),\"Wrong result object\");\nassertFalse(res.isException(key),\"Exception flag\");\nassertNull(res.getException(key),\"Got an exception\");\ncheckChild(res.getInitializer(key),initializer.getActiveExecutor());\n}return res;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest#checkInitialize\n methodBody: private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\nfinal Integer result=init.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,init.initializeCalls,\"Wrong number of invocations\");\nassertNotNull(init.getFuture(),\"No future\");\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
        "classSignatureBefore": "public class BackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest#testStartMultipleTimes"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.BackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class BackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final AbstractBackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.getCloseableCounter().getInitializeCalls(), \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }\n\n    protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl(final ExecutorService exec) {\n        return new MethodBackgroundInitializerTestImpl(exec);\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    protected static class AbstractBackgroundInitializerTestImpl extends\n            BackgroundInitializer<CloseableCounter> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        AbstractBackgroundInitializerTestImpl() {\n        }\n\n        AbstractBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodBackgroundInitializerTestImpl extends AbstractBackgroundInitializerTestImpl {\n\n        MethodBackgroundInitializerTestImpl() {\n        }\n\n        MethodBackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        AtomicInteger initializeCalls = new AtomicInteger();\n\n        /** Has the close consumer successfully reached this object. */\n        AtomicBoolean closed = new AtomicBoolean();\n\n        public CloseableCounter increment() {\n            initializeCalls.incrementAndGet();\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls.get();\n        }\n\n        public void close() {\n            closed.set(true);\n        }\n\n        public boolean isClosed() {\n            return closed.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#checkInitialize\n methodBody: private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\nfinal int count=5;\nfor(int i=0; i < count; i++){initializer.addInitializer(CHILD_INIT + i,new ChildBackgroundInitializer());\n}initializer.start();\nfinal MultiBackgroundInitializer.MultiBackgroundInitializerResults res=initializer.get();\nassertEquals(count,res.initializerNames().size(),\"Wrong number of child initializers\");\nfor(int i=0; i < count; i++){final String key=CHILD_INIT + i;\nassertTrue(res.initializerNames().contains(key),\"Name not found: \" + key);\nassertEquals(Integer.valueOf(1),res.getResultObject(key),\"Wrong result object\");\nassertFalse(res.isException(key),\"Exception flag\");\nassertNull(res.getException(key),\"Got an exception\");\ncheckChild(res.getInitializer(key),initializer.getActiveExecutor());\n}return res;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest#checkInitialize\n methodBody: private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\nfinal Integer result=init.get();\nassertEquals(1,result.intValue(),\"Wrong result\");\nassertEquals(1,init.initializeCalls,\"Wrong number of invocations\");\nassertNotNull(init.getFuture(),\"No future\");\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\nprotected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n        return new MethodBackgroundInitializerTestImpl();\n    }",
        "diffSourceCode": "-  152:     /**\n-  153:      * Tests invoking start() multiple times. Only the first invocation should\n-  154:      * have an effect.\n-  155:      */\n-  156:     @Test\n-  157:     public void testStartMultipleTimes() throws ConcurrentException {\n-  158:         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-  159:         assertTrue(init.start(), \"Wrong result for start()\");\n-  160:         for (int i = 0; i < 10; i++) {\n-  161:             assertFalse(init.start(), \"Could start again\");\n-  162:         }\n-  163:         checkInitialize(init);\n-  164:     }\n-  165: \n-  166:     /**\n-  287:      * some methods that simplify testing.\n-  288:      */\n-  289:     private static final class BackgroundInitializerTestImpl extends\n+  152:     }\n+  153: \n+  154:     /**\n+  155:      * Tests invoking start() multiple times. Only the first invocation should\n+  156:      * have an effect.\n+  157:      */\n+  158:     @Test\n+  159:     public void testStartMultipleTimes() throws ConcurrentException {\n+  160:         final AbstractBackgroundInitializerTestImpl init = getBackgroundInitializerTestImpl();\n+  161:         assertTrue(init.start(), \"Wrong result for start()\");\n+  162:         for (int i = 0; i < 10; i++) {\n+  163:             assertFalse(init.start(), \"Could start again\");\n+  164:         }\n+  165:         checkInitialize(init);\n+  166:     }\n+  287:     protected AbstractBackgroundInitializerTestImpl getBackgroundInitializerTestImpl() {\n+  288:         return new MethodBackgroundInitializerTestImpl();\n+  289:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_152_164_287_289_154_166",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Helper method for checking whether the initialize() method was correctly\n * called. start() must already have been invoked.\n *\n * @param init the initializer to test\n */\nprivate void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n    final Integer result = init.get();\n    assertEquals(1, result.intValue(), \"Wrong result\");\n    assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n    assertNotNull(init.getFuture(), \"No future\");\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Duration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.apache.commons.lang3.ThreadUtils;\nimport org.junit.jupiter.api.Test;\n\npublic class BackgroundInitializerTest extends AbstractLangTest {\n    /**\n     * Helper method for checking whether the initialize() method was correctly\n     * called. start() must already have been invoked.\n     *\n     * @param init the initializer to test\n     */\n    private void checkInitialize(final BackgroundInitializerTestImpl init) throws ConcurrentException {\n        final Integer result = init.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, init.initializeCalls, \"Wrong number of invocations\");\n        assertNotNull(init.getFuture(), \"No future\");\n    }\n\n    /**\n     * Tests whether initialize() is invoked.\n     */\n    @Test\n    public void testInitialize() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n    }\n\n    /**\n     * Tries to obtain the executor before start(). It should not have been\n     * initialized yet.\n     */\n    @Test\n    public void testGetActiveExecutorBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertNull(init.getActiveExecutor(), \"Got an executor\");\n    }\n\n    /**\n     * Tests whether an external executor is correctly detected.\n     */\n    @Test\n    public void testGetActiveExecutorExternal() throws InterruptedException, ConcurrentException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                    exec);\n            init.start();\n            assertSame(exec, init.getActiveExecutor(), \"Wrong executor\");\n            checkInitialize(init);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests getActiveExecutor() for a temporary executor.\n     */\n    @Test\n    public void testGetActiveExecutorTemp() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertNotNull(init.getActiveExecutor(), \"No active executor\");\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests the execution of the background task if a temporary executor has to\n     * be created.\n     */\n    @Test\n    public void testInitializeTempExecutor() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result of start()\");\n        checkInitialize(init);\n        assertTrue(init.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests whether an external executor can be set using the\n     * setExternalExecutor() method.\n     */\n    @Test\n    public void testSetExternalExecutor() throws ConcurrentException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n            init.setExternalExecutor(exec);\n            assertEquals(exec, init.getExternalExecutor(), \"Wrong executor service\");\n            assertTrue(init.start(), \"Wrong result of start()\");\n            assertSame(exec, init.getActiveExecutor(), \"Wrong active executor\");\n            checkInitialize(init);\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n        }\n    }\n\n    /**\n     * Tests that setting an executor after start() causes an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException because the test implementation may throw it\n     */\n    @Test\n    public void testSetExternalExecutorAfterStart() throws ConcurrentException, InterruptedException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            assertThrows(IllegalStateException.class, () -> init.setExternalExecutor(exec));\n            init.get();\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests invoking start() multiple times. Only the first invocation should\n     * have an effect.\n     */\n    @Test\n    public void testStartMultipleTimes() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertTrue(init.start(), \"Wrong result for start()\");\n        for (int i = 0; i < 10; i++) {\n            assertFalse(init.start(), \"Could start again\");\n        }\n        checkInitialize(init);\n    }\n\n    /**\n     * Tests calling get() before start(). This should cause an exception.\n     */\n    @Test\n    public void testGetBeforeStart() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertThrows(IllegalStateException.class, init::get);\n    }\n\n    /**\n     * Tests the get() method if background processing causes a runtime\n     * exception.\n     */\n    @Test\n    public void testGetRuntimeException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final RuntimeException rex = new RuntimeException();\n        init.ex = rex;\n        init.start();\n        final Exception ex = assertThrows(Exception.class, init::get);\n        assertEquals(rex, ex, \"Runtime exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if background processing causes a checked\n     * exception.\n     */\n    @Test\n    public void testGetCheckedException() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        final Exception ex = new Exception();\n        init.ex = ex;\n        init.start();\n        final ConcurrentException cex = assertThrows(ConcurrentException.class, init::get);\n        assertEquals(ex, cex.getCause(), \"Exception not thrown\");\n    }\n\n    /**\n     * Tests the get() method if waiting for the initialization is interrupted.\n     *\n     * @throws InterruptedException because we're making use of Java's concurrent API\n     */\n    @Test\n    public void testGetInterruptedException() throws InterruptedException {\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                exec);\n        final CountDownLatch latch1 = new CountDownLatch(1);\n        init.shouldSleep = true;\n        init.start();\n        final AtomicReference<InterruptedException> iex = new AtomicReference<>();\n        final Thread getThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    init.get();\n                } catch (final ConcurrentException cex) {\n                    if (cex.getCause() instanceof InterruptedException) {\n                        iex.set((InterruptedException) cex.getCause());\n                    }\n                } finally {\n                    assertTrue(isInterrupted(), \"Thread not interrupted\");\n                    latch1.countDown();\n                }\n            }\n        };\n        getThread.start();\n        getThread.interrupt();\n        latch1.await();\n        exec.shutdownNow();\n        exec.awaitTermination(1, TimeUnit.SECONDS);\n        assertNotNull(iex.get(), \"No interrupted exception\");\n    }\n\n    /**\n     * Tests isStarted() before start() was called.\n     */\n    @Test\n    public void testIsStartedFalse() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        assertFalse(init.isStarted(), \"Already started\");\n    }\n\n    /**\n     * Tests isStarted() after start().\n     */\n    @Test\n    public void testIsStartedTrue() {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isStarted() after the background task has finished.\n     */\n    @Test\n    public void testIsStartedAfterGet() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.start();\n        checkInitialize(init);\n        assertTrue(init.isStarted(), \"Not started\");\n    }\n\n    /**\n     * Tests isInitialized() before and after the background task has finished.\n     */\n    @Test\n    public void testIsInitialized() throws ConcurrentException {\n        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n        init.enableLatch();\n        init.start();\n        assertTrue(init.isStarted(), \"Not started\"); //Started and Initialized should return opposite values\n        assertFalse(init.isInitialized(), \"Initalized before releasing latch\");\n        init.releaseLatch();\n        init.get(); //to ensure the initialize thread has completed.\n        assertTrue(init.isInitialized(), \"Not initalized after releasing latch\");\n    }\n\n    /**\n     * A concrete implementation of BackgroundInitializer. It also overloads\n     * some methods that simplify testing.\n     */\n    private static final class BackgroundInitializerTestImpl extends\n            BackgroundInitializer<Integer> {\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A flag whether the background task should sleep a while. */\n        boolean shouldSleep;\n\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        BackgroundInitializerTestImpl() {\n        }\n\n        BackgroundInitializerTestImpl(final ExecutorService exec) {\n            super(exec);\n        }\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception or sleeps a\n         * while.\n         *\n         * @throws Exception in case of an error\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            if (ex != null) {\n                throw ex;\n            }\n            if (shouldSleep) {\n                ThreadUtils.sleep(Duration.ofMinutes(1));\n            }\n            if (waitForLatch) {\n                latch.await();\n            }\n            return Integer.valueOf(++initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected createChildBackgroundInitializer() : AbstractChildBackgroundInitializer extracted from public testIsInitialized() : void in class org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 374,
                "endLine": 409,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 374,
                "endLine": 409,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 411,
                "endLine": 418,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final ChildBackgroundInitializer childOne = new ChildBackgroundInitializer();\n        final ChildBackgroundInitializer childTwo = new ChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#testIsInitialized",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.AbstractConcurrentInitializer#isInitialized\n methodBody: protected abstract boolean isInitialized();\nmethodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nreturn object != NO_INIT;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#isInitialized\n methodBody: public synchronized boolean isInitialized() {\nif(future == null || !future.isDone()){return false;\n}tryfuture.get();\nreturn true;\ncatch(CancellationException|ExecutionException|InterruptedException e)return false;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest.BackgroundInitializerTestImpl#enableLatch\n methodBody: public void enableLatch() {\nwaitForLatch=true;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nif(childInitializers.isEmpty()){return false;\n}return childInitializers.values().stream().allMatch(BackgroundInitializer::isInitialized);\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#isStarted\n methodBody: public synchronized boolean isStarted() {\nreturn future != null;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest.ChildBackgroundInitializer#enableLatch\n methodBody: public void enableLatch() {\nwaitForLatch=true;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest.BackgroundInitializerTestImpl#releaseLatch\n methodBody: public void releaseLatch() {\nlatch.countDown();\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#addInitializer\n methodBody: public void addInitializer(final String name, final BackgroundInitializer<?> backgroundInitializer) {\nObjects.requireNonNull(name,\"name\");\nObjects.requireNonNull(backgroundInitializer,\"backgroundInitializer\");\nsynchronized(this){if(isStarted()){throw new IllegalStateException(\"addInitializer() must not be called after start()!\");\n}childInitializers.put(name,backgroundInitializer);\n}}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nreturn reference.get() != NO_INIT;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest.ChildBackgroundInitializer#releaseLatch\n methodBody: public void releaseLatch() {\nlatch.countDown();\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nreturn reference.get() != NO_INIT;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
        "classSignatureBefore": "public class MultiBackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#testIsInitialized"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class MultiBackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    private MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    private static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n        final Integer result = cinit.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, new ChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    new ChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(Integer.valueOf(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n            final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            new ChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final ChildBackgroundInitializer childOne = new ChildBackgroundInitializer();\n        final ChildBackgroundInitializer childTwo = new ChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * A concrete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     */\n    private static final class ChildBackgroundInitializer extends\n            BackgroundInitializer<Integer> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            currentExecutor = getActiveExecutor();\n            initializeCalls++;\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            return Integer.valueOf(initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    protected MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    protected static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final AbstractChildBackgroundInitializer cinit = (AbstractChildBackgroundInitializer) child;\n        final Integer result = cinit.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, createChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    createChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(CloseableCounter.wrapInteger(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractChildBackgroundInitializer c1 = createChildBackgroundInitializer();\n            final AbstractChildBackgroundInitializer c2 = createChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, createChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, createChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            createChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final AbstractChildBackgroundInitializer childOne = createChildBackgroundInitializer();\n        final AbstractChildBackgroundInitializer childTwo = createChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }\n\n    /**\n     * A mostly complete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     *\n     * Subclasses will contain the initializer, either as an method implementation\n     * or by using a supplier.\n     */\n    protected static class AbstractChildBackgroundInitializer extends BackgroundInitializer<CloseableCounter> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            initializeCalls++;\n            currentExecutor = getActiveExecutor();\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodChildBackgroundInitializer extends AbstractChildBackgroundInitializer {\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** Has the close consumer successfully reached this object. */\n        volatile boolean closed;\n\n        public CloseableCounter increment() {\n            initializeCalls++;\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls;\n        }\n\n        public CloseableCounter setInitializeCalls(int i) {\n            initializeCalls = i;\n            return this;\n        }\n\n        public void close() {\n            closed = true;\n        }\n\n        public boolean isClosed() {\n            return closed;\n        }\n\n        @Override\n        public boolean equals(final Object other) {\n            if (other instanceof CloseableCounter) {\n                return initializeCalls == ((CloseableCounter) other).getInitializeCalls();\n            }\n            return false;\n        }\n\n        // A convenience for testing that a CloseableCounter typed as Object has a specific initializeCalls value\n        public static CloseableCounter wrapInteger(int i) {\n            return new CloseableCounter().setInitializeCalls(i);\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.AbstractConcurrentInitializer#isInitialized\n methodBody: protected abstract boolean isInitialized();",
            "methodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nreturn object != NO_INIT;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#isInitialized\n methodBody: public synchronized boolean isInitialized() {\nif(future == null || !future.isDone()){return false;\n}tryfuture.get();\nreturn true;\ncatch(CancellationException|ExecutionException|InterruptedException e)return false;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest.BackgroundInitializerTestImpl#enableLatch\n methodBody: public void enableLatch() {\nwaitForLatch=true;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nif(childInitializers.isEmpty()){return false;\n}return childInitializers.values().stream().allMatch(BackgroundInitializer::isInitialized);\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#isStarted\n methodBody: public synchronized boolean isStarted() {\nreturn future != null;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest.ChildBackgroundInitializer#enableLatch\n methodBody: public void enableLatch() {\nwaitForLatch=true;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializerTest.BackgroundInitializerTestImpl#releaseLatch\n methodBody: public void releaseLatch() {\nlatch.countDown();\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#addInitializer\n methodBody: public void addInitializer(final String name, final BackgroundInitializer<?> backgroundInitializer) {\nObjects.requireNonNull(name,\"name\");\nObjects.requireNonNull(backgroundInitializer,\"backgroundInitializer\");\nsynchronized(this){if(isStarted()){throw new IllegalStateException(\"addInitializer() must not be called after start()!\");\n}childInitializers.put(name,backgroundInitializer);\n}}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nreturn reference.get() != NO_INIT;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest.ChildBackgroundInitializer#releaseLatch\n methodBody: public void releaseLatch() {\nlatch.countDown();\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#isInitialized\n methodBody: public boolean isInitialized() {\nreturn reference.get() != NO_INIT;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final AbstractChildBackgroundInitializer childOne = createChildBackgroundInitializer();\n        final AbstractChildBackgroundInitializer childTwo = createChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n/**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }",
        "diffSourceCode": "   374:     @Test\n   375:     public void testIsInitialized()\n   376:             throws ConcurrentException, InterruptedException {\n-  377:         final ChildBackgroundInitializer childOne = new ChildBackgroundInitializer();\n-  378:         final ChildBackgroundInitializer childTwo = new ChildBackgroundInitializer();\n+  377:         final AbstractChildBackgroundInitializer childOne = createChildBackgroundInitializer();\n+  378:         final AbstractChildBackgroundInitializer childTwo = createChildBackgroundInitializer();\n   379: \n   380:         childOne.enableLatch();\n   381:         childTwo.enableLatch();\n   382: \n   383:         assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n   384: \n   385:         initializer.addInitializer(\"child one\", childOne);\n   386:         initializer.addInitializer(\"child two\", childTwo);\n   387:         initializer.start();\n   388: \n   389:         long startTime = System.currentTimeMillis();\n   390:         long waitTime = 3000;\n   391:         long endTime = startTime + waitTime;\n   392:         //wait for the children to start\n   393:         while (! childOne.isStarted() || ! childTwo.isStarted()) {\n   394:             if (System.currentTimeMillis() > endTime) {\n   395:                 fail(\"children never started\");\n   396:                 Thread.sleep(PERIOD_MILLIS);\n   397:             }\n   398:         }\n   399: \n   400:         assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n   401: \n   402:         childOne.releaseLatch();\n   403:         childOne.get(); //ensure this child finishes initializing\n   404:         assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n   405: \n   406:         childTwo.releaseLatch();\n   407:         childTwo.get(); //ensure this child finishes initializing\n   408:         assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n   409:     }\n   411:     /**\n-  412:      * A concrete implementation of {@code BackgroundInitializer} used for\n-  413:      * defining background tasks for {@code MultiBackgroundInitializer}.\n-  414:      */\n-  415:     private static final class ChildBackgroundInitializer extends\n-  416:             BackgroundInitializer<Integer> {\n-  417:         /** Stores the current executor service. */\n-  418:         volatile ExecutorService currentExecutor;\n+  412:      * An overrideable method to create concrete implementations of\n+  413:      * {@code BackgroundInitializer} used for defining background tasks\n+  414:      * for {@code MultiBackgroundInitializer}.\n+  415:      */\n+  416:     protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n+  417:         return new MethodChildBackgroundInitializer();\n+  418:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_374_409_411_418_374_409",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\nprivate void waitForChildrenToStart(ChildBackgroundInitializer childOne, ChildBackgroundInitializer childTwo) throws InterruptedException {\n    long startTime = System.currentTimeMillis();\n    long waitTime = 3000;\n    long endTime = startTime + waitTime;\n    //wait for the children to start\n    while (!childOne.isStarted() || !childTwo.isStarted()) {\n        if (System.currentTimeMillis() > endTime) {\n            fail(\"children never started\");\n            Thread.sleep(PERIOD_MILLIS);\n        }\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final ChildBackgroundInitializer childOne = new ChildBackgroundInitializer();\n        final ChildBackgroundInitializer childTwo = new ChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    private MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    private static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n        final Integer result = cinit.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, new ChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    new ChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(Integer.valueOf(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n            final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            new ChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final ChildBackgroundInitializer childOne = new ChildBackgroundInitializer();\n        final ChildBackgroundInitializer childTwo = new ChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * A concrete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     */\n    private static final class ChildBackgroundInitializer extends\n            BackgroundInitializer<Integer> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            currentExecutor = getActiveExecutor();\n            initializeCalls++;\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            return Integer.valueOf(initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected createChildBackgroundInitializer() : AbstractChildBackgroundInitializer extracted from public testInitializeResultsIsSuccessfulFalse() : void in class org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 323,
                "endLine": 339,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 323,
                "endLine": 339,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 411,
                "endLine": 418,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#testInitializeResultsIsSuccessfulFalse",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#addInitializer\n methodBody: public void addInitializer(final String name, final BackgroundInitializer<?> backgroundInitializer) {\nObjects.requireNonNull(name,\"name\");\nObjects.requireNonNull(backgroundInitializer,\"backgroundInitializer\");\nsynchronized(this){if(isStarted()){throw new IllegalStateException(\"addInitializer() must not be called after start()!\");\n}childInitializers.put(name,backgroundInitializer);\n}}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer.MultiBackgroundInitializerResults#isSuccessful\n methodBody: public boolean isSuccessful() {\nreturn exceptions.isEmpty();\n}",
        "classSignatureBefore": "public class MultiBackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#testInitializeResultsIsSuccessfulFalse"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class MultiBackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    private MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    private static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n        final Integer result = cinit.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, new ChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    new ChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(Integer.valueOf(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n            final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            new ChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final ChildBackgroundInitializer childOne = new ChildBackgroundInitializer();\n        final ChildBackgroundInitializer childTwo = new ChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * A concrete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     */\n    private static final class ChildBackgroundInitializer extends\n            BackgroundInitializer<Integer> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            currentExecutor = getActiveExecutor();\n            initializeCalls++;\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            return Integer.valueOf(initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    protected MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    protected static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final AbstractChildBackgroundInitializer cinit = (AbstractChildBackgroundInitializer) child;\n        final Integer result = cinit.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, createChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    createChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(CloseableCounter.wrapInteger(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractChildBackgroundInitializer c1 = createChildBackgroundInitializer();\n            final AbstractChildBackgroundInitializer c2 = createChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, createChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, createChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            createChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final AbstractChildBackgroundInitializer childOne = createChildBackgroundInitializer();\n        final AbstractChildBackgroundInitializer childTwo = createChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }\n\n    /**\n     * A mostly complete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     *\n     * Subclasses will contain the initializer, either as an method implementation\n     * or by using a supplier.\n     */\n    protected static class AbstractChildBackgroundInitializer extends BackgroundInitializer<CloseableCounter> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            initializeCalls++;\n            currentExecutor = getActiveExecutor();\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodChildBackgroundInitializer extends AbstractChildBackgroundInitializer {\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** Has the close consumer successfully reached this object. */\n        volatile boolean closed;\n\n        public CloseableCounter increment() {\n            initializeCalls++;\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls;\n        }\n\n        public CloseableCounter setInitializeCalls(int i) {\n            initializeCalls = i;\n            return this;\n        }\n\n        public void close() {\n            closed = true;\n        }\n\n        public boolean isClosed() {\n            return closed;\n        }\n\n        @Override\n        public boolean equals(final Object other) {\n            if (other instanceof CloseableCounter) {\n                return initializeCalls == ((CloseableCounter) other).getInitializeCalls();\n            }\n            return false;\n        }\n\n        // A convenience for testing that a CloseableCounter typed as Object has a specific initializeCalls value\n        public static CloseableCounter wrapInteger(int i) {\n            return new CloseableCounter().setInitializeCalls(i);\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#addInitializer\n methodBody: public void addInitializer(final String name, final BackgroundInitializer<?> backgroundInitializer) {\nObjects.requireNonNull(name,\"name\");\nObjects.requireNonNull(backgroundInitializer,\"backgroundInitializer\");\nsynchronized(this){if(isStarted()){throw new IllegalStateException(\"addInitializer() must not be called after start()!\");\n}childInitializers.put(name,backgroundInitializer);\n}}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer.MultiBackgroundInitializerResults#isSuccessful\n methodBody: public boolean isSuccessful() {\nreturn exceptions.isEmpty();\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n/**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }",
        "diffSourceCode": "   323:     /**\n   324:      * Tests the isSuccessful() method of the result object if at least one\n   325:      * child initializer has thrown an exception.\n   326:      *\n   327:      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n   328:      */\n   329:     @Test\n   330:     public void testInitializeResultsIsSuccessfulFalse()\n   331:             throws ConcurrentException {\n-  332:         final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n+  332:         final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n   333:         child.ex = new Exception();\n   334:         initializer.addInitializer(CHILD_INIT, child);\n   335:         initializer.start();\n   336:         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n   337:                 .get();\n   338:         assertFalse(res.isSuccessful(), \"Wrong success flag\");\n   339:     }\n   411:     /**\n-  412:      * A concrete implementation of {@code BackgroundInitializer} used for\n-  413:      * defining background tasks for {@code MultiBackgroundInitializer}.\n-  414:      */\n-  415:     private static final class ChildBackgroundInitializer extends\n-  416:             BackgroundInitializer<Integer> {\n-  417:         /** Stores the current executor service. */\n-  418:         volatile ExecutorService currentExecutor;\n+  412:      * An overrideable method to create concrete implementations of\n+  413:      * {@code BackgroundInitializer} used for defining background tasks\n+  414:      * for {@code MultiBackgroundInitializer}.\n+  415:      */\n+  416:     protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n+  417:         return new MethodChildBackgroundInitializer();\n+  418:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_323_339_411_418_323_339",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n/**\n * Helper method for setting up and initializing child background initializers.\n *\n * @param child the child background initializer to be added\n * @param expExec the expected executor service (null if the executor should not be checked)\n * @throws ConcurrentException if an error occurs\n */\nprivate void setupAndInitializeChild(BackgroundInitializer<?> child, ExecutorService expExec) throws ConcurrentException {\n    initializer.addInitializer(CHILD_INIT, child);\n    initializer.start();\n    MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get();\n    assertEquals(1, res.getResultObject(CHILD_INIT), \"Wrong result object\");\n    assertFalse(res.isException(CHILD_INIT), \"Exception flag\");\n    assertNull(res.getException(CHILD_INIT), \"Got an exception\");\n    checkChild(res.getInitializer(CHILD_INIT), expExec);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    private MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    private static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n        final Integer result = cinit.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, new ChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    new ChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(Integer.valueOf(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n            final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            new ChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final ChildBackgroundInitializer childOne = new ChildBackgroundInitializer();\n        final ChildBackgroundInitializer childTwo = new ChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * A concrete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     */\n    private static final class ChildBackgroundInitializer extends\n            BackgroundInitializer<Integer> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            currentExecutor = getActiveExecutor();\n            initializeCalls++;\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            return Integer.valueOf(initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected createChildBackgroundInitializer() : AbstractChildBackgroundInitializer extracted from public testInitializeResultsIsSuccessfulTrue() : void in class org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 306,
                "endLine": 321,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 306,
                "endLine": 321,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 411,
                "endLine": 418,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#testInitializeResultsIsSuccessfulTrue",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#addInitializer\n methodBody: public void addInitializer(final String name, final BackgroundInitializer<?> backgroundInitializer) {\nObjects.requireNonNull(name,\"name\");\nObjects.requireNonNull(backgroundInitializer,\"backgroundInitializer\");\nsynchronized(this){if(isStarted()){throw new IllegalStateException(\"addInitializer() must not be called after start()!\");\n}childInitializers.put(name,backgroundInitializer);\n}}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer.MultiBackgroundInitializerResults#isSuccessful\n methodBody: public boolean isSuccessful() {\nreturn exceptions.isEmpty();\n}",
        "classSignatureBefore": "public class MultiBackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#testInitializeResultsIsSuccessfulTrue"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class MultiBackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    private MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    private static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n        final Integer result = cinit.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, new ChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    new ChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(Integer.valueOf(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n            final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            new ChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final ChildBackgroundInitializer childOne = new ChildBackgroundInitializer();\n        final ChildBackgroundInitializer childTwo = new ChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * A concrete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     */\n    private static final class ChildBackgroundInitializer extends\n            BackgroundInitializer<Integer> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            currentExecutor = getActiveExecutor();\n            initializeCalls++;\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            return Integer.valueOf(initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    protected MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    protected static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final AbstractChildBackgroundInitializer cinit = (AbstractChildBackgroundInitializer) child;\n        final Integer result = cinit.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, createChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    createChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(CloseableCounter.wrapInteger(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractChildBackgroundInitializer c1 = createChildBackgroundInitializer();\n            final AbstractChildBackgroundInitializer c2 = createChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, createChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, createChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            createChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final AbstractChildBackgroundInitializer childOne = createChildBackgroundInitializer();\n        final AbstractChildBackgroundInitializer childTwo = createChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }\n\n    /**\n     * A mostly complete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     *\n     * Subclasses will contain the initializer, either as an method implementation\n     * or by using a supplier.\n     */\n    protected static class AbstractChildBackgroundInitializer extends BackgroundInitializer<CloseableCounter> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            initializeCalls++;\n            currentExecutor = getActiveExecutor();\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodChildBackgroundInitializer extends AbstractChildBackgroundInitializer {\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** Has the close consumer successfully reached this object. */\n        volatile boolean closed;\n\n        public CloseableCounter increment() {\n            initializeCalls++;\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls;\n        }\n\n        public CloseableCounter setInitializeCalls(int i) {\n            initializeCalls = i;\n            return this;\n        }\n\n        public void close() {\n            closed = true;\n        }\n\n        public boolean isClosed() {\n            return closed;\n        }\n\n        @Override\n        public boolean equals(final Object other) {\n            if (other instanceof CloseableCounter) {\n                return initializeCalls == ((CloseableCounter) other).getInitializeCalls();\n            }\n            return false;\n        }\n\n        // A convenience for testing that a CloseableCounter typed as Object has a specific initializeCalls value\n        public static CloseableCounter wrapInteger(int i) {\n            return new CloseableCounter().setInitializeCalls(i);\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#addInitializer\n methodBody: public void addInitializer(final String name, final BackgroundInitializer<?> backgroundInitializer) {\nObjects.requireNonNull(name,\"name\");\nObjects.requireNonNull(backgroundInitializer,\"backgroundInitializer\");\nsynchronized(this){if(isStarted()){throw new IllegalStateException(\"addInitializer() must not be called after start()!\");\n}childInitializers.put(name,backgroundInitializer);\n}}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer.MultiBackgroundInitializerResults#isSuccessful\n methodBody: public boolean isSuccessful() {\nreturn exceptions.isEmpty();\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n/**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }",
        "diffSourceCode": "   306:     /**\n   307:      * Tests the isSuccessful() method of the result object if no child\n   308:      * initializer has thrown an exception.\n   309:      *\n   310:      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n   311:      */\n   312:     @Test\n   313:     public void testInitializeResultsIsSuccessfulTrue()\n   314:             throws ConcurrentException {\n-  315:         final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n+  315:         final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n   316:         initializer.addInitializer(CHILD_INIT, child);\n   317:         initializer.start();\n   318:         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n   319:                 .get();\n   320:         assertTrue(res.isSuccessful(), \"Wrong success flag\");\n   321:     }\n   411:     /**\n-  412:      * A concrete implementation of {@code BackgroundInitializer} used for\n-  413:      * defining background tasks for {@code MultiBackgroundInitializer}.\n-  414:      */\n-  415:     private static final class ChildBackgroundInitializer extends\n-  416:             BackgroundInitializer<Integer> {\n-  417:         /** Stores the current executor service. */\n-  418:         volatile ExecutorService currentExecutor;\n+  412:      * An overrideable method to create concrete implementations of\n+  413:      * {@code BackgroundInitializer} used for defining background tasks\n+  414:      * for {@code MultiBackgroundInitializer}.\n+  415:      */\n+  416:     protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n+  417:         return new MethodChildBackgroundInitializer();\n+  418:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_306_321_411_418_306_321",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n/**\n * Helper method to add multiple child initializers and start the initializer.\n * This method checks the results and executor service of each child initializer.\n *\n * @return the result object produced by the initializer\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\nprivate MultiBackgroundInitializer.MultiBackgroundInitializerResults addAndStartChildInitializers() throws ConcurrentException {\n    final int count = 5;\n    for (int i = 0; i < count; i++) {\n        initializer.addInitializer(CHILD_INIT + i, new ChildBackgroundInitializer());\n    }\n    initializer.start();\n    final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get();\n    assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n    for (int i = 0; i < count; i++) {\n        final String key = CHILD_INIT + i;\n        assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n        assertEquals(Integer.valueOf(1), res.getResultObject(key), \"Wrong result object\");\n        assertFalse(res.isException(key), \"Exception flag\");\n        assertNull(res.getException(key), \"Got an exception\");\n        checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n    }\n    return res;\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    private MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    private static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n        final Integer result = cinit.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, new ChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    new ChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(Integer.valueOf(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n            final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            new ChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final ChildBackgroundInitializer childOne = new ChildBackgroundInitializer();\n        final ChildBackgroundInitializer childTwo = new ChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * A concrete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     */\n    private static final class ChildBackgroundInitializer extends\n            BackgroundInitializer<Integer> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            currentExecutor = getActiveExecutor();\n            initializeCalls++;\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            return Integer.valueOf(initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected createChildBackgroundInitializer() : AbstractChildBackgroundInitializer extracted from public testInitializeEx() : void in class org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 286,
                "endLine": 304,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 286,
                "endLine": 304,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 411,
                "endLine": 418,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#testInitializeEx",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer.MultiBackgroundInitializerResults#isException\n methodBody: public boolean isException(final String name) {\ncheckName(name);\nreturn exceptions.containsKey(name);\n}\nmethodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#addInitializer\n methodBody: public void addInitializer(final String name, final BackgroundInitializer<?> backgroundInitializer) {\nObjects.requireNonNull(name,\"name\");\nObjects.requireNonNull(backgroundInitializer,\"backgroundInitializer\");\nsynchronized(this){if(isStarted()){throw new IllegalStateException(\"addInitializer() must not be called after start()!\");\n}childInitializers.put(name,backgroundInitializer);\n}}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer.MultiBackgroundInitializerResults#getException\n methodBody: public ConcurrentException getException(final String name) {\ncheckName(name);\nreturn exceptions.get(name);\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer.MultiBackgroundInitializerResults#getResultObject\n methodBody: public Object getResultObject(final String name) {\ncheckName(name);\nreturn resultObjects.get(name);\n}",
        "classSignatureBefore": "public class MultiBackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#testInitializeEx"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class MultiBackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    private MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    private static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n        final Integer result = cinit.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, new ChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    new ChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(Integer.valueOf(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n            final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            new ChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final ChildBackgroundInitializer childOne = new ChildBackgroundInitializer();\n        final ChildBackgroundInitializer childTwo = new ChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * A concrete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     */\n    private static final class ChildBackgroundInitializer extends\n            BackgroundInitializer<Integer> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            currentExecutor = getActiveExecutor();\n            initializeCalls++;\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            return Integer.valueOf(initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    protected MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    protected static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final AbstractChildBackgroundInitializer cinit = (AbstractChildBackgroundInitializer) child;\n        final Integer result = cinit.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, createChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    createChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(CloseableCounter.wrapInteger(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractChildBackgroundInitializer c1 = createChildBackgroundInitializer();\n            final AbstractChildBackgroundInitializer c2 = createChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, createChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, createChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            createChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final AbstractChildBackgroundInitializer childOne = createChildBackgroundInitializer();\n        final AbstractChildBackgroundInitializer childTwo = createChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }\n\n    /**\n     * A mostly complete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     *\n     * Subclasses will contain the initializer, either as an method implementation\n     * or by using a supplier.\n     */\n    protected static class AbstractChildBackgroundInitializer extends BackgroundInitializer<CloseableCounter> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            initializeCalls++;\n            currentExecutor = getActiveExecutor();\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodChildBackgroundInitializer extends AbstractChildBackgroundInitializer {\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** Has the close consumer successfully reached this object. */\n        volatile boolean closed;\n\n        public CloseableCounter increment() {\n            initializeCalls++;\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls;\n        }\n\n        public CloseableCounter setInitializeCalls(int i) {\n            initializeCalls = i;\n            return this;\n        }\n\n        public void close() {\n            closed = true;\n        }\n\n        public boolean isClosed() {\n            return closed;\n        }\n\n        @Override\n        public boolean equals(final Object other) {\n            if (other instanceof CloseableCounter) {\n                return initializeCalls == ((CloseableCounter) other).getInitializeCalls();\n            }\n            return false;\n        }\n\n        // A convenience for testing that a CloseableCounter typed as Object has a specific initializeCalls value\n        public static CloseableCounter wrapInteger(int i) {\n            return new CloseableCounter().setInitializeCalls(i);\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer.MultiBackgroundInitializerResults#isException\n methodBody: public boolean isException(final String name) {\ncheckName(name);\nreturn exceptions.containsKey(name);\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#addInitializer\n methodBody: public void addInitializer(final String name, final BackgroundInitializer<?> backgroundInitializer) {\nObjects.requireNonNull(name,\"name\");\nObjects.requireNonNull(backgroundInitializer,\"backgroundInitializer\");\nsynchronized(this){if(isStarted()){throw new IllegalStateException(\"addInitializer() must not be called after start()!\");\n}childInitializers.put(name,backgroundInitializer);\n}}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer.MultiBackgroundInitializerResults#getException\n methodBody: public ConcurrentException getException(final String name) {\ncheckName(name);\nreturn exceptions.get(name);\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer.MultiBackgroundInitializerResults#getResultObject\n methodBody: public Object getResultObject(final String name) {\ncheckName(name);\nreturn resultObjects.get(name);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n/**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }",
        "diffSourceCode": "   286:     /**\n   287:      * Tests the behavior of the initializer if one of the child initializers\n   288:      * throws a checked exception.\n   289:      *\n   290:      * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n   291:      */\n   292:     @Test\n   293:     public void testInitializeEx() throws ConcurrentException {\n-  294:         final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n+  294:         final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n   295:         child.ex = new Exception();\n   296:         initializer.addInitializer(CHILD_INIT, child);\n   297:         initializer.start();\n   298:         final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n   299:                 .get();\n   300:         assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n   301:         assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n   302:         final ConcurrentException cex = res.getException(CHILD_INIT);\n   303:         assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n   304:     }\n   411:     /**\n-  412:      * A concrete implementation of {@code BackgroundInitializer} used for\n-  413:      * defining background tasks for {@code MultiBackgroundInitializer}.\n-  414:      */\n-  415:     private static final class ChildBackgroundInitializer extends\n-  416:             BackgroundInitializer<Integer> {\n-  417:         /** Stores the current executor service. */\n-  418:         volatile ExecutorService currentExecutor;\n+  412:      * An overrideable method to create concrete implementations of\n+  413:      * {@code BackgroundInitializer} used for defining background tasks\n+  414:      * for {@code MultiBackgroundInitializer}.\n+  415:      */\n+  416:     protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n+  417:         return new MethodChildBackgroundInitializer();\n+  418:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_286_304_411_418_286_304",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n/**\n * Helper method to add multiple child initializers and start the initializer.\n * This method checks the results and executor service for each child initializer.\n *\n * @return the result object produced by the initializer\n *\n * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n */\nprivate MultiBackgroundInitializer.MultiBackgroundInitializerResults addAndStartChildInitializers() throws ConcurrentException {\n    final int count = 5;\n    for (int i = 0; i < count; i++) {\n        initializer.addInitializer(CHILD_INIT + i, new ChildBackgroundInitializer());\n    }\n    initializer.start();\n    final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get();\n    assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n    for (int i = 0; i < count; i++) {\n        final String key = CHILD_INIT + i;\n        assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n        assertEquals(Integer.valueOf(1), res.getResultObject(key), \"Wrong result object\");\n        assertFalse(res.isException(key), \"Exception flag\");\n        assertNull(res.getException(key), \"Got an exception\");\n        checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n    }\n    return res;\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    private MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    private static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n        final Integer result = cinit.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, new ChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    new ChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(Integer.valueOf(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n            final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            new ChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final ChildBackgroundInitializer childOne = new ChildBackgroundInitializer();\n        final ChildBackgroundInitializer childTwo = new ChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * A concrete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     */\n    private static final class ChildBackgroundInitializer extends\n            BackgroundInitializer<Integer> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            currentExecutor = getActiveExecutor();\n            initializeCalls++;\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            return Integer.valueOf(initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected createChildBackgroundInitializer() : AbstractChildBackgroundInitializer extracted from public testInitializeRuntimeEx() : void in class org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest",
        "diffLocations": [
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 272,
                "endLine": 284,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 272,
                "endLine": 284,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
                "startLine": 411,
                "endLine": 418,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }",
        "filePathBefore": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
        "isPureRefactoring": true,
        "commitId": "5d146cd06965432812c11ea8a6b458b3d2f56f65",
        "packageNameBefore": "org.apache.commons.lang3.concurrent",
        "classNameBefore": "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest",
        "methodNameBefore": "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#testInitializeRuntimeEx",
        "invokedMethod": "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}\nmethodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#addInitializer\n methodBody: public void addInitializer(final String name, final BackgroundInitializer<?> backgroundInitializer) {\nObjects.requireNonNull(name,\"name\");\nObjects.requireNonNull(backgroundInitializer,\"backgroundInitializer\");\nsynchronized(this){if(isStarted()){throw new IllegalStateException(\"addInitializer() must not be called after start()!\");\n}childInitializers.put(name,backgroundInitializer);\n}}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}\nmethodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}",
        "classSignatureBefore": "public class MultiBackgroundInitializerTest extends AbstractLangTest ",
        "methodNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest#testInitializeRuntimeEx"
        ],
        "classNameBeforeSet": [
            "org.apache.commons.lang3.concurrent.MultiBackgroundInitializerTest"
        ],
        "classSignatureBeforeSet": [
            "public class MultiBackgroundInitializerTest extends AbstractLangTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    private MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    private static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n        final Integer result = cinit.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, new ChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    new ChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(Integer.valueOf(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n            final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            new ChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final ChildBackgroundInitializer childOne = new ChildBackgroundInitializer();\n        final ChildBackgroundInitializer childTwo = new ChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * A concrete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     */\n    private static final class ChildBackgroundInitializer extends\n            BackgroundInitializer<Integer> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            currentExecutor = getActiveExecutor();\n            initializeCalls++;\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            return Integer.valueOf(initializeCalls);\n        }\n    }\n}\n",
        "filePathAfter": "src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java",
        "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    protected MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    protected static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final AbstractChildBackgroundInitializer cinit = (AbstractChildBackgroundInitializer) child;\n        final Integer result = cinit.get().getInitializeCalls();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, createChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    createChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(CloseableCounter.wrapInteger(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final AbstractChildBackgroundInitializer c1 = createChildBackgroundInitializer();\n            final AbstractChildBackgroundInitializer c2 = createChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, createChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, createChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            createChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final AbstractChildBackgroundInitializer childOne = createChildBackgroundInitializer();\n        final AbstractChildBackgroundInitializer childTwo = createChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }\n\n    /**\n     * A mostly complete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     *\n     * Subclasses will contain the initializer, either as an method implementation\n     * or by using a supplier.\n     */\n    protected static class AbstractChildBackgroundInitializer extends BackgroundInitializer<CloseableCounter> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** An object containing the state we are testing */\n        CloseableCounter counter = new CloseableCounter();\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        public CloseableCounter getCloseableCounter() {\n            return counter;\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        protected CloseableCounter initializeInternal() throws Exception {\n            initializeCalls++;\n            currentExecutor = getActiveExecutor();\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            return counter.increment();\n        }\n    }\n\n    protected static class MethodChildBackgroundInitializer extends AbstractChildBackgroundInitializer {\n        @Override\n        protected CloseableCounter initialize() throws Exception {\n            return initializeInternal();\n        }\n    }\n\n    protected static class CloseableCounter {\n        /** The number of invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** Has the close consumer successfully reached this object. */\n        volatile boolean closed;\n\n        public CloseableCounter increment() {\n            initializeCalls++;\n            return this;\n        }\n\n        public int getInitializeCalls() {\n            return initializeCalls;\n        }\n\n        public CloseableCounter setInitializeCalls(int i) {\n            initializeCalls = i;\n            return this;\n        }\n\n        public void close() {\n            closed = true;\n        }\n\n        public boolean isClosed() {\n            return closed;\n        }\n\n        @Override\n        public boolean equals(final Object other) {\n            if (other instanceof CloseableCounter) {\n                return initializeCalls == ((CloseableCounter) other).getInitializeCalls();\n            }\n            return false;\n        }\n\n        // A convenience for testing that a CloseableCounter typed as Object has a specific initializeCalls value\n        public static CloseableCounter wrapInteger(int i) {\n            return new CloseableCounter().setInitializeCalls(i);\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=reference.get();\nif(result == getNoInit()){result=initialize();\nif(!reference.compareAndSet(getNoInit(),result)){result=reference.get();\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.AtomicSafeInitializer#get\n methodBody: public final T get() throws ConcurrentException {\nT result;\nwhile((result=reference.get()) == getNoInit()){if(factory.compareAndSet(null,this)){reference.set(initialize());\n}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.LazyInitializer#get\n methodBody: public T get() throws ConcurrentException {\nT result=object;\nif(result == NO_INIT){synchronized(this){result=object;\nif(result == NO_INIT){object=result=initialize();\n}}}return result;\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.MultiBackgroundInitializer#addInitializer\n methodBody: public void addInitializer(final String name, final BackgroundInitializer<?> backgroundInitializer) {\nObjects.requireNonNull(name,\"name\");\nObjects.requireNonNull(backgroundInitializer,\"backgroundInitializer\");\nsynchronized(this){if(isStarted()){throw new IllegalStateException(\"addInitializer() must not be called after start()!\");\n}childInitializers.put(name,backgroundInitializer);\n}}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#get\n methodBody: public T get() throws ConcurrentException {\ntryreturn getFuture().get();\ncatch(final ExecutionException execex)ConcurrentUtils.handleCause(execex);\nreturn null;\ncatch(final InterruptedException iex)Thread.currentThread().interrupt();\nthrow new ConcurrentException(iex);\n}",
            "methodSignature: org.apache.commons.lang3.concurrent.BackgroundInitializer#start\n methodBody: public synchronized boolean start() {\nif(!isStarted()){final ExecutorService tempExec;\nexecutor=getExternalExecutor();\nif(executor == null){executor=tempExec=createExecutor();\n}{tempExec=null;\n}future=executor.submit(createTask(tempExec));\nreturn true;\n}return false;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n/**\n     * An overrideable method to create concrete implementations of\n     * {@code BackgroundInitializer} used for defining background tasks\n     * for {@code MultiBackgroundInitializer}.\n     */\n    protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n        return new MethodChildBackgroundInitializer();\n    }",
        "diffSourceCode": "   272:     /**\n   273:      * Tests the behavior of the initializer if one of the child initializers\n   274:      * throws a runtime exception.\n   275:      */\n   276:     @Test\n   277:     public void testInitializeRuntimeEx() {\n-  278:         final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n+  278:         final AbstractChildBackgroundInitializer child = createChildBackgroundInitializer();\n   279:         child.ex = new RuntimeException();\n   280:         initializer.addInitializer(CHILD_INIT, child);\n   281:         initializer.start();\n   282:         final Exception ex = assertThrows(Exception.class, initializer::get);\n   283:         assertEquals(child.ex, ex, \"Wrong exception\");\n   284:     }\n   411:     /**\n-  412:      * A concrete implementation of {@code BackgroundInitializer} used for\n-  413:      * defining background tasks for {@code MultiBackgroundInitializer}.\n-  414:      */\n-  415:     private static final class ChildBackgroundInitializer extends\n-  416:             BackgroundInitializer<Integer> {\n-  417:         /** Stores the current executor service. */\n-  418:         volatile ExecutorService currentExecutor;\n+  412:      * An overrideable method to create concrete implementations of\n+  413:      * {@code BackgroundInitializer} used for defining background tasks\n+  414:      * for {@code MultiBackgroundInitializer}.\n+  415:      */\n+  416:     protected AbstractChildBackgroundInitializer createChildBackgroundInitializer() {\n+  417:         return new MethodChildBackgroundInitializer();\n+  418:     }\n",
        "uniqueId": "5d146cd06965432812c11ea8a6b458b3d2f56f65_272_284_411_418_272_284",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n/**\n * Helper method for setting up and initializing child initializers.\n *\n * @param child the child initializer to be added\n * @param expExec the expected executor service (null if the executor should not be checked)\n * @throws ConcurrentException if an error occurs\n */\nprivate void setupAndInitializeChild(BackgroundInitializer<?> child, ExecutorService expExec) throws ConcurrentException {\n    initializer.addInitializer(CHILD_INIT, child);\n    initializer.start();\n    MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer.get();\n    assertEquals(1, res.initializerNames().size(), \"Wrong number of child initializers\");\n    assertTrue(res.initializerNames().contains(CHILD_INIT), \"Name not found: \" + CHILD_INIT);\n    assertEquals(Integer.valueOf(1), res.getResultObject(CHILD_INIT), \"Wrong result object\");\n    assertFalse(res.isException(CHILD_INIT), \"Exception flag\");\n    assertNull(res.getException(CHILD_INIT), \"Got an exception\");\n    checkChild(res.getInitializer(CHILD_INIT), expExec);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.concurrent;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.lang3.AbstractLangTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@link MultiBackgroundInitializer}.\n */\npublic class MultiBackgroundInitializerTest extends AbstractLangTest {\n    /** Constant for the names of the child initializers. */\n    private static final String CHILD_INIT = \"childInitializer\";\n\n    /** The initializer to be tested. */\n    private MultiBackgroundInitializer initializer;\n\n    /** A short time to wait for background threads to run. */\n    private static final long PERIOD_MILLIS = 50;\n\n    @BeforeEach\n    public void setUp() {\n        initializer = new MultiBackgroundInitializer();\n    }\n\n    /**\n     * Tests whether a child initializer has been executed. Optionally the\n     * expected executor service can be checked, too.\n     *\n     * @param child the child initializer\n     * @param expExec the expected executor service (null if the executor should\n     * not be checked)\n     * @throws ConcurrentException if an error occurs\n     */\n    private void checkChild(final BackgroundInitializer<?> child,\n            final ExecutorService expExec) throws ConcurrentException {\n        final ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n        final Integer result = cinit.get();\n        assertEquals(1, result.intValue(), \"Wrong result\");\n        assertEquals(1, cinit.initializeCalls, \"Wrong number of executions\");\n        if (expExec != null) {\n            assertEquals(expExec, cinit.currentExecutor, \"Wrong executor service\");\n        }\n    }\n\n    /**\n     * Tests addInitializer() if a null name is passed in. This should cause an\n     * exception.\n     */\n    @Test\n    public void testAddInitializerNullName() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(null, new ChildBackgroundInitializer()));\n    }\n\n    /**\n     * Tests addInitializer() if a null initializer is passed in. This should\n     * cause an exception.\n     */\n    @Test\n    public void testAddInitializerNullInit() {\n        assertThrows(NullPointerException.class, () -> initializer.addInitializer(CHILD_INIT, null));\n    }\n\n    /**\n     * Tests the background processing if there are no child initializers.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNoChildren() throws ConcurrentException {\n        assertTrue(initializer.start(), \"Wrong result of start()\");\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.initializerNames().isEmpty(), \"Got child initializers\");\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Helper method for testing the initialize() method. This method can\n     * operate with both an external and a temporary executor service.\n     *\n     * @return the result object produced by the initializer\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n            throws ConcurrentException {\n        final int count = 5;\n        for (int i = 0; i < count; i++) {\n            initializer.addInitializer(CHILD_INIT + i,\n                    new ChildBackgroundInitializer());\n        }\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertEquals(count, res.initializerNames().size(), \"Wrong number of child initializers\");\n        for (int i = 0; i < count; i++) {\n            final String key = CHILD_INIT + i;\n            assertTrue(res.initializerNames().contains(key), \"Name not found: \" + key);\n            assertEquals(Integer.valueOf(1), res.getResultObject(key), \"Wrong result object\");\n            assertFalse(res.isException(key), \"Exception flag\");\n            assertNull(res.getException(key), \"Got an exception\");\n            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n        }\n        return res;\n    }\n\n    /**\n     * Tests background processing if a temporary executor is used.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeTempExec() throws ConcurrentException {\n        checkInitialize();\n        assertTrue(initializer.getActiveExecutor().isShutdown(), \"Executor not shutdown\");\n    }\n\n    /**\n     * Tests background processing if an external executor service is provided.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeExternalExec() throws ConcurrentException, InterruptedException {\n        final ExecutorService exec = Executors.newCachedThreadPool();\n        try {\n            initializer = new MultiBackgroundInitializer(exec);\n            checkInitialize();\n            assertEquals(exec, initializer.getActiveExecutor(), \"Wrong executor\");\n            assertFalse(exec.isShutdown(), \"Executor was shutdown\");\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tests the behavior of initialize() if a child initializer has a specific\n     * executor service. Then this service should not be overridden.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeChildWithExecutor() throws ConcurrentException, InterruptedException {\n        final String initExec = \"childInitializerWithExecutor\";\n        final ExecutorService exec = Executors.newSingleThreadExecutor();\n        try {\n            final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n            final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n            c2.setExternalExecutor(exec);\n            initializer.addInitializer(CHILD_INIT, c1);\n            initializer.addInitializer(initExec, c2);\n            initializer.start();\n            initializer.get();\n            checkChild(c1, initializer.getActiveExecutor());\n            checkChild(c2, exec);\n        } finally {\n            exec.shutdown();\n            exec.awaitTermination(1, TimeUnit.SECONDS);\n        }\n    }\n\n    /**\n     * Tries to add another child initializer after the start() method has been\n     * called. This should not be allowed.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testAddInitializerAfterStart() throws ConcurrentException {\n        initializer.start();\n        assertThrows(\n                IllegalStateException.class,\n                () -> initializer.addInitializer(CHILD_INIT, new ChildBackgroundInitializer()),\n                \"Could add initializer after start()!\");\n        initializer.get();\n    }\n\n    /**\n     * Tries to query an unknown child initializer from the results object. This\n     * should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetInitializerUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getInitializer(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the results of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getResultObject(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception of an unknown child initializer from the\n     * results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultGetExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.getException(\"unknown\"));\n    }\n\n    /**\n     * Tries to query the exception flag of an unknown child initializer from\n     * the results object. This should cause an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultIsExceptionUnknown() throws ConcurrentException {\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n        assertThrows(NoSuchElementException.class, () -> res.isException(\"unknown\"));\n    }\n\n    /**\n     * Tests that the set with the names of the initializers cannot be modified.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testResultInitializerNamesModify() throws ConcurrentException {\n        checkInitialize();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final Iterator<String> it = res.initializerNames().iterator();\n        it.next();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a runtime exception.\n     */\n    @Test\n    public void testInitializeRuntimeEx() {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new RuntimeException();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final Exception ex = assertThrows(Exception.class, initializer::get);\n        assertEquals(child.ex, ex, \"Wrong exception\");\n    }\n\n    /**\n     * Tests the behavior of the initializer if one of the child initializers\n     * throws a checked exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeEx() throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isException(CHILD_INIT), \"No exception flag\");\n        assertNull(res.getResultObject(CHILD_INIT), \"Got a results object\");\n        final ConcurrentException cex = res.getException(CHILD_INIT);\n        assertEquals(child.ex, cex.getCause(), \"Wrong cause\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if no child\n     * initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulTrue()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertTrue(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests the isSuccessful() method of the result object if at least one\n     * child initializer has thrown an exception.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeResultsIsSuccessfulFalse()\n            throws ConcurrentException {\n        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n        child.ex = new Exception();\n        initializer.addInitializer(CHILD_INIT, child);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        assertFalse(res.isSuccessful(), \"Wrong success flag\");\n    }\n\n    /**\n     * Tests whether MultiBackgroundInitializers can be combined in a nested\n     * way.\n     *\n     * @throws org.apache.commons.lang3.concurrent.ConcurrentException so we don't have to catch it\n     */\n    @Test\n    public void testInitializeNested() throws ConcurrentException {\n        final String nameMulti = \"multiChildInitializer\";\n        initializer\n                .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());\n        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n        final int count = 3;\n        for (int i = 0; i < count; i++) {\n            mi2\n                    .addInitializer(CHILD_INIT + i,\n                            new ChildBackgroundInitializer());\n        }\n        initializer.addInitializer(nameMulti, mi2);\n        initializer.start();\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                .get();\n        final ExecutorService exec = initializer.getActiveExecutor();\n        checkChild(res.getInitializer(CHILD_INIT), exec);\n        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                .getResultObject(nameMulti);\n        assertEquals(count, res2.initializerNames().size(), \"Wrong number of initializers\");\n        for (int i = 0; i < count; i++) {\n            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n        }\n        assertTrue(exec.isShutdown(), \"Executor not shutdown\");\n    }\n\n    @Test\n    public void testIsInitialized()\n            throws ConcurrentException, InterruptedException {\n        final ChildBackgroundInitializer childOne = new ChildBackgroundInitializer();\n        final ChildBackgroundInitializer childTwo = new ChildBackgroundInitializer();\n\n        childOne.enableLatch();\n        childTwo.enableLatch();\n\n        assertFalse(initializer.isInitialized(), \"Initalized without having anything to initalize\");\n\n        initializer.addInitializer(\"child one\", childOne);\n        initializer.addInitializer(\"child two\", childTwo);\n        initializer.start();\n\n        long startTime = System.currentTimeMillis();\n        long waitTime = 3000;\n        long endTime = startTime + waitTime;\n        //wait for the children to start\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n\n        assertFalse(initializer.isInitialized(), \"Initalized with two children running\");\n\n        childOne.releaseLatch();\n        childOne.get(); //ensure this child finishes initializing\n        assertFalse(initializer.isInitialized(), \"Initalized with one child running\");\n\n        childTwo.releaseLatch();\n        childTwo.get(); //ensure this child finishes initializing\n        assertTrue(initializer.isInitialized(), \"Not initalized with no children running\");\n    }\n\n    /**\n     * A concrete implementation of {@code BackgroundInitializer} used for\n     * defining background tasks for {@code MultiBackgroundInitializer}.\n     */\n    private static final class ChildBackgroundInitializer extends\n            BackgroundInitializer<Integer> {\n        /** Stores the current executor service. */\n        volatile ExecutorService currentExecutor;\n\n        /** A counter for the invocations of initialize(). */\n        volatile int initializeCalls;\n\n        /** An exception to be thrown by initialize(). */\n        Exception ex;\n\n        /** A latch tests can use to control when initialize completes. */\n        final CountDownLatch latch = new CountDownLatch(1);\n        boolean waitForLatch = false;\n\n        public void enableLatch() {\n            waitForLatch = true;\n        }\n\n        public void releaseLatch() {\n            latch.countDown();\n        }\n\n        /**\n         * Records this invocation. Optionally throws an exception.\n         */\n        @Override\n        protected Integer initialize() throws Exception {\n            currentExecutor = getActiveExecutor();\n            initializeCalls++;\n\n            if (ex != null) {\n                throw ex;\n            }\n\n            if (waitForLatch) {\n                latch.await();\n            }\n\n            return Integer.valueOf(initializeCalls);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n",
        "toolAfterCode": ""
    }
]