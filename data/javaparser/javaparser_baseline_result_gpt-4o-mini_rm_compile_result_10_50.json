[{"type": "Extract Method", "description": "Extract Method\tpackage provider(source String) : UnicodeEscapeProcessingProvider extracted from private read(source String) : String in class com.github.javaparser.UnicodeEscapeProcessingProviderTest", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java", "startLine": 123, "endLine": 140, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java", "startLine": 123, "endLine": 125, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java", "startLine": 127, "endLine": 131, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private String read(String source) throws IOException {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java", "isPureRefactoring": true, "commitId": "baf9003923057506e2518c688bc1e5d09d5052d6", "packageNameBefore": "com.github.javaparser", "classNameBefore": "com.github.javaparser.UnicodeEscapeProcessingProviderTest", "methodNameBefore": "com.github.javaparser.UnicodeEscapeProcessingProviderTest#read", "invokedMethod": "methodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#read\n methodBody: public int read(char[] buffer, final int offset, int len) throws IOException {\nint pos=offset;\nint stop=offset + len;\nwhile(pos < stop){int ch=nextOutputChar();\nif(ch < 0){if(pos == offset){return EOF;\n}{break;\n}}{buffer[pos++]=(char)ch;\n}}return pos - offset;\n}\nmethodSignature: com.github.javaparser.UnicodeEscapeProcessingProviderTest#read\n methodBody: private String read(String source) throws IOException {\nUnicodeEscapeProcessingProvider provider=new UnicodeEscapeProcessingProvider(10,new StringProvider(source));\nStringBuilder result=new StringBuilder();\nchar[] buffer=new char[10];\nwhile(true){int direct=provider.read(buffer,0,buffer.length);\nif(direct < 0){break;\n}result.append(buffer,0,direct);\n}provider.close();\nreturn result.toString();\n}\nmethodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#close\n methodBody: public void close() throws IOException {\n_input.close();\n}", "classSignatureBefore": "public class UnicodeEscapeProcessingProviderTest ", "methodNameBeforeSet": ["com.github.javaparser.UnicodeEscapeProcessingProviderTest#read"], "classNameBeforeSet": ["com.github.javaparser.UnicodeEscapeProcessingProviderTest"], "classSignatureBeforeSet": ["public class UnicodeEscapeProcessingProviderTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes", "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves", "mappingState": 2}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for {@link UnicodeEscapeProcessingProvider}.\n */\npublic class UnicodeEscapeProcessingProviderTest {\n\n\t@Test\n\tvoid testUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\u12aA98\")));\n\t}\n\n\t@Test\n\tvoid testEscapedUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\\\\\\\\u12aA98\", new String(read(\"13\\\\\\\\u12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testUnicodeEscapeWithMultipleUs() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\uuuuuu12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslash() throws IOException {\n\t\tassertEquals(\"foobar\\\\\", new String(read(\"foobar\\\\\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU() throws IOException {\n\t\tassertEquals(\"foobar\\\\u\", new String(read(\"foobar\\\\u\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashUs() throws IOException {\n\t\tassertEquals(\"foobar\\\\uuuuuu\", new String(read(\"foobar\\\\uuuuuu\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU1() throws IOException {\n\t\tassertEquals(\"foobar\\\\uA\", new String(read(\"foobar\\\\uA\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU2() throws IOException {\n\t\tassertEquals(\"foobar\\\\uAB\", new String(read(\"foobar\\\\uAB\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU3() throws IOException {\n\t\tassertEquals(\"foobar\\\\uABC\", new String(read(\"foobar\\\\uABC\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingUnicodeEscape() throws IOException {\n\t\tassertEquals(\"foobar\\uABCD\", new String(read(\"foobar\\\\uABCD\")));\n\t}\n\t\n\t@Test\n\tvoid testEmptyInput() throws IOException {\n\t\tassertEquals(\"\", new String(read(\"\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape0() throws IOException {\n\t\tassertEquals(\"13\\\\ux\", new String(read(\"13\\\\ux\")));\n\t}\n\t\n\t@Test\n\tvoid testBadUnicodeEscape1() throws IOException {\n\t\tassertEquals(\"13\\\\u1x\", new String(read(\"13\\\\u1x\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape2() throws IOException {\n\t\tassertEquals(\"13\\\\u1Ax\", new String(read(\"13\\\\u1Ax\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape3() throws IOException {\n\t\tassertEquals(\"13\\\\u1ABx\", new String(read(\"13\\\\u1ABx\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscapeMultipleUs() throws IOException {\n\t\tassertEquals(\"13\\\\uuuuuu1ABx\", new String(read(\"13\\\\uuuuuu1ABx\")));\n\t}\n\n\t@Test\n\tvoid testPushBackWithFullBuffer() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\", new String(read(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\")));\n\t}\n\t\n\t@Test\n\tvoid testPushBackWithBufferShift() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxx\", new String(read(\"12345678\\\\uuxx\")));\n\t}\n\t\n\tprivate String read(String source) throws IOException {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for {@link UnicodeEscapeProcessingProvider}.\n */\npublic class UnicodeEscapeProcessingProviderTest {\n\n\t@Test\n\tvoid testUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\u12aA98\")));\n\t}\n\n\t@Test\n\tvoid testEscapedUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\\\\\\\\u12aA98\", new String(read(\"13\\\\\\\\u12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testUnicodeEscapeWithMultipleUs() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\uuuuuu12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslash() throws IOException {\n\t\tassertEquals(\"foobar\\\\\", new String(read(\"foobar\\\\\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU() throws IOException {\n\t\tassertEquals(\"foobar\\\\u\", new String(read(\"foobar\\\\u\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashUs() throws IOException {\n\t\tassertEquals(\"foobar\\\\uuuuuu\", new String(read(\"foobar\\\\uuuuuu\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU1() throws IOException {\n\t\tassertEquals(\"foobar\\\\uA\", new String(read(\"foobar\\\\uA\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU2() throws IOException {\n\t\tassertEquals(\"foobar\\\\uAB\", new String(read(\"foobar\\\\uAB\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU3() throws IOException {\n\t\tassertEquals(\"foobar\\\\uABC\", new String(read(\"foobar\\\\uABC\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingUnicodeEscape() throws IOException {\n\t\tassertEquals(\"foobar\\uABCD\", new String(read(\"foobar\\\\uABCD\")));\n\t}\n\t\n\t@Test\n\tvoid testEmptyInput() throws IOException {\n\t\tassertEquals(\"\", new String(read(\"\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape0() throws IOException {\n\t\tassertEquals(\"13\\\\ux\", new String(read(\"13\\\\ux\")));\n\t}\n\t\n\t@Test\n\tvoid testBadUnicodeEscape1() throws IOException {\n\t\tassertEquals(\"13\\\\u1x\", new String(read(\"13\\\\u1x\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape2() throws IOException {\n\t\tassertEquals(\"13\\\\u1Ax\", new String(read(\"13\\\\u1Ax\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape3() throws IOException {\n\t\tassertEquals(\"13\\\\u1ABx\", new String(read(\"13\\\\u1ABx\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscapeMultipleUs() throws IOException {\n\t\tassertEquals(\"13\\\\uuuuuu1ABx\", new String(read(\"13\\\\uuuuuu1ABx\")));\n\t}\n\n\t@Test\n\tvoid testPushBackWithFullBuffer() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\", new String(read(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\")));\n\t}\n\t\n\t@Test\n\tvoid testPushBackWithBufferShift() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxx\", new String(read(\"12345678\\\\uuxx\")));\n\t}\n\t\n\tstatic String read(String source) throws IOException {\n\t\treturn process(provider(source));\n\t}\n\n\tstatic UnicodeEscapeProcessingProvider provider(String source) {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\treturn provider;\n\t}\n\n\tstatic String process(UnicodeEscapeProcessingProvider provider)\n\t\t\tthrows IOException {\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}\n}\n", "diffSourceCodeSet": ["static UnicodeEscapeProcessingProvider provider(String source) {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\treturn provider;\n\t}"], "invokedMethodSet": ["methodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#read\n methodBody: public int read(char[] buffer, final int offset, int len) throws IOException {\nint pos=offset;\nint stop=offset + len;\nwhile(pos < stop){int ch=nextOutputChar();\nif(ch < 0){if(pos == offset){return EOF;\n}{break;\n}}{buffer[pos++]=(char)ch;\n}}return pos - offset;\n}", "methodSignature: com.github.javaparser.UnicodeEscapeProcessingProviderTest#read\n methodBody: private String read(String source) throws IOException {\nUnicodeEscapeProcessingProvider provider=new UnicodeEscapeProcessingProvider(10,new StringProvider(source));\nStringBuilder result=new StringBuilder();\nchar[] buffer=new char[10];\nwhile(true){int direct=provider.read(buffer,0,buffer.length);\nif(direct < 0){break;\n}result.append(buffer,0,direct);\n}provider.close();\nreturn result.toString();\n}", "methodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#close\n methodBody: public void close() throws IOException {\n_input.close();\n}"], "sourceCodeAfterRefactoring": "static String read(String source) throws IOException {\n\t\treturn process(provider(source));\n\t}\nstatic UnicodeEscapeProcessingProvider provider(String source) {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\treturn provider;\n\t}", "diffSourceCode": "-  123: \tprivate String read(String source) throws IOException {\n-  124: \t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n-  125: \t\t\t\tnew StringProvider(source));\n-  126: \t\n-  127: \t\tStringBuilder result = new StringBuilder();\n-  128: \t\tchar[] buffer = new char[10];\n-  129: \t\twhile (true) {\n-  130: \t\t\tint direct = provider.read(buffer, 0, buffer.length);\n-  131: \t\t\tif (direct < 0) {\n-  132: \t\t\t\tbreak;\n-  133: \t\t\t}\n-  134: \t\t\tresult.append(buffer, 0, direct);\n-  135: \t\t}\n-  136: \t\t\n-  137: \t\tprovider.close();\n-  138: \t\n-  139: \t\treturn result.toString();\n-  140: \t}\n+  123: \tstatic String read(String source) throws IOException {\n+  124: \t\treturn process(provider(source));\n+  125: \t}\n+  126: \n+  127: \tstatic UnicodeEscapeProcessingProvider provider(String source) {\n+  128: \t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n+  129: \t\t\t\tnew StringProvider(source));\n+  130: \t\treturn provider;\n+  131: \t}\n+  132: \n+  133: \tstatic String process(UnicodeEscapeProcessingProvider provider)\n+  134: \t\t\tthrows IOException {\n+  135: \t\tStringBuilder result = new StringBuilder();\n+  136: \t\tchar[] buffer = new char[10];\n+  137: \t\twhile (true) {\n+  138: \t\t\tint direct = provider.read(buffer, 0, buffer.length);\n+  139: \t\t\tif (direct < 0) {\n+  140: \t\t\t\tbreak;\n", "uniqueId": "baf9003923057506e2518c688bc1e5d09d5052d6_123_140_127_131_123_125", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `read` method, we can extract the logic that reads from the `UnicodeEscapeProcessingProvider` into a separate method. This will make the code cleaner and allow for easier testing and modification of the reading logic in the future.\n\nHere\u2019s the refactored code:\n\n```java\nprivate String read(String source) throws IOException {\n    UnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n            new StringProvider(source));\n    \n    String result = readFromProvider(provider);\n    \n    provider.close();\n    \n    return result;\n}\n\nprivate String readFromProvider(UnicodeEscapeProcessingProvider provider) throws IOException {\n    StringBuilder result = new StringBuilder();\n    char[] buffer = new char[10];\n    while (true) {\n        int direct = provider.read(buffer, 0, buffer.length);\n        if (direct < 0) {\n            break;\n        }\n        result.append(buffer, 0, direct);\n    }\n    return result.toString();\n}\n```\n\nThe `readFromProvider` method encapsulates the logic for reading from the `UnicodeEscapeProcessingProvider`, making the `read` method cleaner and more focused on its primary responsibility. \n\nHere\u2019s the output in the required format:\n\n##########################\n```java\nprivate String read(String source) throws IOException {\n    UnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n            new StringProvider(source));\n    \n    String result = readFromProvider(provider);\n    \n    provider.close();\n    \n    return result;\n}\n\nprivate String readFromProvider(UnicodeEscapeProcessingProvider provider) throws IOException {\n    StringBuilder result = new StringBuilder();\n    char[] buffer = new char[10];\n    while (true) {\n        int direct = provider.read(buffer, 0, buffer.length);\n        if (direct < 0) {\n            break;\n        }\n        result.append(buffer, 0, direct);\n    }\n    return result.toString();\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate String read(String source) throws IOException {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}\n\nClass content:\n/*\n * Copyright (C) 2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for {@link UnicodeEscapeProcessingProvider}.\n */\npublic class UnicodeEscapeProcessingProviderTest {\n\n\t@Test\n\tvoid testUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\u12aA98\")));\n\t}\n\n\t@Test\n\tvoid testEscapedUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\\\\\\\\u12aA98\", new String(read(\"13\\\\\\\\u12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testUnicodeEscapeWithMultipleUs() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\uuuuuu12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslash() throws IOException {\n\t\tassertEquals(\"foobar\\\\\", new String(read(\"foobar\\\\\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU() throws IOException {\n\t\tassertEquals(\"foobar\\\\u\", new String(read(\"foobar\\\\u\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashUs() throws IOException {\n\t\tassertEquals(\"foobar\\\\uuuuuu\", new String(read(\"foobar\\\\uuuuuu\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU1() throws IOException {\n\t\tassertEquals(\"foobar\\\\uA\", new String(read(\"foobar\\\\uA\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU2() throws IOException {\n\t\tassertEquals(\"foobar\\\\uAB\", new String(read(\"foobar\\\\uAB\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU3() throws IOException {\n\t\tassertEquals(\"foobar\\\\uABC\", new String(read(\"foobar\\\\uABC\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingUnicodeEscape() throws IOException {\n\t\tassertEquals(\"foobar\\uABCD\", new String(read(\"foobar\\\\uABCD\")));\n\t}\n\t\n\t@Test\n\tvoid testEmptyInput() throws IOException {\n\t\tassertEquals(\"\", new String(read(\"\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape0() throws IOException {\n\t\tassertEquals(\"13\\\\ux\", new String(read(\"13\\\\ux\")));\n\t}\n\t\n\t@Test\n\tvoid testBadUnicodeEscape1() throws IOException {\n\t\tassertEquals(\"13\\\\u1x\", new String(read(\"13\\\\u1x\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape2() throws IOException {\n\t\tassertEquals(\"13\\\\u1Ax\", new String(read(\"13\\\\u1Ax\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape3() throws IOException {\n\t\tassertEquals(\"13\\\\u1ABx\", new String(read(\"13\\\\u1ABx\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscapeMultipleUs() throws IOException {\n\t\tassertEquals(\"13\\\\uuuuuu1ABx\", new String(read(\"13\\\\uuuuuu1ABx\")));\n\t}\n\n\t@Test\n\tvoid testPushBackWithFullBuffer() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\", new String(read(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\")));\n\t}\n\t\n\t@Test\n\tvoid testPushBackWithBufferShift() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxx\", new String(read(\"12345678\\\\uuxx\")));\n\t}\n\t\n\tprivate String read(String source) throws IOException {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic deserializeObject(reader JsonReader, delegates Map<String,Delegate>) : Node extracted from public deserializeObject(reader JsonReader) : Node in class com.github.javaparser.serialization.JavaParserJsonDeserializer", "diffLocations": [{"filePath": "javaparser-core-serialization/src/main/java/com/github/javaparser/serialization/JavaParserJsonDeserializer.java", "startLine": 48, "endLine": 52, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-serialization/src/main/java/com/github/javaparser/serialization/JavaParserJsonDeserializer.java", "startLine": 44, "endLine": 46, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-serialization/src/main/java/com/github/javaparser/serialization/JavaParserJsonDeserializer.java", "startLine": 48, "endLine": 52, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "public Node deserializeObject(JsonReader reader) {\n        Log.info(\"Deserializing JSON to Node.\");\n        JsonObject jsonObject = reader.readObject();\n        return deserializeObject(jsonObject);\n    }", "filePathBefore": "javaparser-core-serialization/src/main/java/com/github/javaparser/serialization/JavaParserJsonDeserializer.java", "isPureRefactoring": true, "commitId": "ef3ecbbbdebff45488e6017781f8caf59c2056fa", "packageNameBefore": "com.github.javaparser.serialization", "classNameBefore": "com.github.javaparser.serialization.JavaParserJsonDeserializer", "methodNameBefore": "com.github.javaparser.serialization.JavaParserJsonDeserializer#deserializeObject", "invokedMethod": "methodSignature: com.github.javaparser.serialization.JavaParserJsonDeserializer#deserializeObject\n methodBody: private Node deserializeObject(JsonObject nodeJson) {\ntryString serializedNodeType=nodeJson.getString(SERIALIZED_CLASS_KEY);\nBaseNodeMetaModel nodeMetaModel=getNodeMetaModel(Class.forName(serializedNodeType)).orElseThrow(() -> new IllegalStateException(\"Trying to deserialize an unknown node type: \" + serializedNodeType));\nMap<String,Object> parameters=new HashMap<>();\nfor(String name: nodeJson.keySet()){if(name.equals(SERIALIZED_CLASS_KEY)){continue;\n}PropertyMetaModel propertyMetaModel=nodeMetaModel.getAllPropertyMetaModels().stream().filter(mm -> mm.getName().equals(name)).findFirst().orElseThrow(() -> new IllegalStateException(\"Unknown property: \" + nodeMetaModel.getQualifiedClassName() + \".\" + name));\nif(propertyMetaModel.isNodeList()){JsonArray nodeListJson=nodeJson.getJsonArray(name);\nparameters.put(name,deserializeNodeList(nodeListJson));\n}if(propertyMetaModel.isEnumSet()){JsonArray enumSetJson=nodeJson.getJsonArray(name);\nparameters.put(name,deserializeEnumSet(enumSetJson));\n}if(propertyMetaModel.isNode()){parameters.put(name,deserializeObject(nodeJson.getJsonObject(name)));\n}{Class<?> type=propertyMetaModel.getType();\nif(type == String.class){parameters.put(name,nodeJson.getString(name));\n}if(type == boolean.class){parameters.put(name,Boolean.parseBoolean(nodeJson.getString(name)));\n}if(Enum.class.isAssignableFrom(type)){parameters.put(name,Enum.valueOf((Class<? extends Enum>)type,nodeJson.getString(name)));\n}{throw new IllegalStateException(\"Don't know how to convert: \" + type);\n}}}return nodeMetaModel.construct(parameters);\ncatch(ClassNotFoundException e)throw new RuntimeException(e);\n}", "classSignatureBefore": "public class JavaParserJsonDeserializer ", "methodNameBeforeSet": ["com.github.javaparser.serialization.JavaParserJsonDeserializer#deserializeObject"], "classNameBeforeSet": ["com.github.javaparser.serialization.JavaParserJsonDeserializer"], "classSignatureBeforeSet": ["public class JavaParserJsonDeserializer "], "purityCheckResultList": [{"isPure": true, "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Add Parameter-", "description": "Parametrization or Add Parameter on top of the extract method - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2018 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.serialization;\n\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.metamodel.BaseNodeMetaModel;\nimport com.github.javaparser.metamodel.PropertyMetaModel;\nimport com.github.javaparser.utils.Log;\n\nimport javax.json.JsonArray;\nimport javax.json.JsonObject;\nimport javax.json.JsonReader;\nimport javax.json.JsonString;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.ast.NodeList.toNodeList;\nimport static com.github.javaparser.metamodel.JavaParserMetaModel.getNodeMetaModel;\nimport static com.github.javaparser.serialization.JavaParserJsonSerializer.SERIALIZED_CLASS_KEY;\n\n/**\n * Deserializes the JSON file that was built by {@link JavaParserJsonSerializer}.\n */\npublic class JavaParserJsonDeserializer {\n\n    public Node deserializeObject(JsonReader reader) {\n        Log.info(\"Deserializing JSON to Node.\");\n        JsonObject jsonObject = reader.readObject();\n        return deserializeObject(jsonObject);\n    }\n\n    private Node deserializeObject(JsonObject nodeJson) {\n        try {\n            String serializedNodeType = nodeJson.getString(SERIALIZED_CLASS_KEY);\n            BaseNodeMetaModel nodeMetaModel = getNodeMetaModel(Class.forName(serializedNodeType))\n                    .orElseThrow(() -> new IllegalStateException(\"Trying to deserialize an unknown node type: \" + serializedNodeType));\n            Map<String, Object> parameters = new HashMap<>();\n            for (String name : nodeJson.keySet()) {\n                if (name.equals(SERIALIZED_CLASS_KEY)) {\n                    continue;\n                }\n\n                PropertyMetaModel propertyMetaModel = nodeMetaModel.getAllPropertyMetaModels().stream()\n                        .filter(mm -> mm.getName().equals(name))\n                        .findFirst().orElseThrow(() -> new IllegalStateException(\"Unknown property: \" + nodeMetaModel.getQualifiedClassName() + \".\" + name));\n\n                if (propertyMetaModel.isNodeList()) {\n                    JsonArray nodeListJson = nodeJson.getJsonArray(name);\n                    parameters.put(name, deserializeNodeList(nodeListJson));\n                } else if (propertyMetaModel.isEnumSet()) {\n                    JsonArray enumSetJson = nodeJson.getJsonArray(name);\n                    parameters.put(name, deserializeEnumSet(enumSetJson));\n                } else if (propertyMetaModel.isNode()) {\n                    parameters.put(name, deserializeObject(nodeJson.getJsonObject(name)));\n                } else {\n                    Class<?> type = propertyMetaModel.getType();\n                    if (type == String.class) {\n                        parameters.put(name, nodeJson.getString(name));\n                    } else if (type == boolean.class) {\n                        parameters.put(name, Boolean.parseBoolean(nodeJson.getString(name)));\n                    } else if (Enum.class.isAssignableFrom(type)) {\n                        parameters.put(name, Enum.valueOf((Class<? extends Enum>) type, nodeJson.getString(name)));\n                    } else {\n                        throw new IllegalStateException(\"Don't know how to convert: \" + type);\n                    }\n                }\n            }\n\n            return nodeMetaModel.construct(parameters);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private EnumSet<?> deserializeEnumSet(JsonArray enumSetJson) {\n        return enumSetJson.stream().map(v -> (JsonString) v).map(s -> Modifier.valueOf(s.getString())).collect(Collectors.toCollection(() -> EnumSet.noneOf(Modifier.class)));\n    }\n\n    private NodeList<?> deserializeNodeList(JsonArray nodeListJson) {\n        return nodeListJson.stream().map(nodeJson -> deserializeObject((JsonObject) nodeJson)).collect(toNodeList());\n    }\n}\n", "filePathAfter": "javaparser-core-serialization/src/main/java/com/github/javaparser/serialization/JavaParserJsonDeserializer.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2018 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.serialization;\n\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.metamodel.BaseNodeMetaModel;\nimport com.github.javaparser.metamodel.PropertyMetaModel;\nimport com.github.javaparser.utils.Log;\nimport com.github.javaparser.utils.Pair;\n\nimport javax.json.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.ast.NodeList.toNodeList;\nimport static com.github.javaparser.metamodel.JavaParserMetaModel.getNodeMetaModel;\nimport static com.github.javaparser.serialization.JavaParserJsonSerializer.SERIALIZED_CLASS_KEY;\n\n/**\n * Deserializes the JSON file that was built by {@link JavaParserJsonSerializer}.\n */\npublic class JavaParserJsonDeserializer {\n\n    public Node deserializeObject(JsonReader reader) {\n        return deserializeObject(reader, new HashMap<>());\n    }\n\n    public Node deserializeObject(JsonReader reader, Map<String, Delegate> delegates) {\n        Log.info(\"Deserializing JSON to Node.\");\n        JsonObject jsonObject = reader.readObject();\n        return deserializeObject(jsonObject, delegates);\n    }\n\n    private Node deserializeObject(JsonObject nodeJson, Map<String, Delegate> delegates) {\n        try {\n            String serializedNodeType = nodeJson.getString(SERIALIZED_CLASS_KEY);\n            BaseNodeMetaModel nodeMetaModel = getNodeMetaModel(Class.forName(serializedNodeType))\n                    .orElseThrow(() -> new IllegalStateException(\"Trying to deserialize an unknown node type: \" + serializedNodeType));\n            Map<String, Object> parameters = new HashMap<>();\n            List<Pair<String, JsonValue>> jsonValuesForDelegates = new LinkedList<>();\n            for (String name : nodeJson.keySet()) {\n                if (name.equals(SERIALIZED_CLASS_KEY)) {\n                    continue;\n                } else if (delegates.containsKey(name)) {\n                    jsonValuesForDelegates.add(\n                            new Pair<>(name, nodeJson.get(name))\n                    );\n                    continue;\n                }\n\n                PropertyMetaModel propertyMetaModel = nodeMetaModel.getAllPropertyMetaModels().stream()\n                        .filter(mm -> mm.getName().equals(name))\n                        .findFirst().orElseThrow(() -> new IllegalStateException(\"Unknown property: \" + nodeMetaModel.getQualifiedClassName() + \".\" + name));\n\n                if (propertyMetaModel.isNodeList()) {\n                    JsonArray nodeListJson = nodeJson.getJsonArray(name);\n                    parameters.put(name, deserializeNodeList(nodeListJson, delegates));\n                } else if (propertyMetaModel.isEnumSet()) {\n                    JsonArray enumSetJson = nodeJson.getJsonArray(name);\n                    parameters.put(name, deserializeEnumSet(enumSetJson));\n                } else if (propertyMetaModel.isNode()) {\n                    parameters.put(name, deserializeObject(nodeJson.getJsonObject(name), delegates));\n                } else {\n                    Class<?> type = propertyMetaModel.getType();\n                    if (type == String.class) {\n                        parameters.put(name, nodeJson.getString(name));\n                    } else if (type == boolean.class) {\n                        parameters.put(name, Boolean.parseBoolean(nodeJson.getString(name)));\n                    } else if (Enum.class.isAssignableFrom(type)) {\n                        parameters.put(name, Enum.valueOf((Class<? extends Enum>) type, nodeJson.getString(name)));\n                    } else {\n                        throw new IllegalStateException(\"Don't know how to convert: \" + type);\n                    }\n                }\n            }\n\n            Node node = nodeMetaModel.construct(parameters);\n            for (Pair<String, JsonValue> nameAndValue : jsonValuesForDelegates) {\n                delegates.get(nameAndValue.a).fromJson(nameAndValue.a, nameAndValue.b, node);\n            }\n\n            return node;\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private EnumSet<?> deserializeEnumSet(JsonArray enumSetJson) {\n        return enumSetJson.stream().map(v -> (JsonString) v).map(s -> Modifier.valueOf(s.getString())).collect(Collectors.toCollection(() -> EnumSet.noneOf(Modifier.class)));\n    }\n\n    private NodeList<?> deserializeNodeList(JsonArray nodeListJson, Map<String, Delegate> delegates) {\n        return nodeListJson.stream().map(nodeJson -> deserializeObject((JsonObject) nodeJson, delegates)).collect(toNodeList());\n    }\n\n    interface Delegate {\n        void fromJson(String propertyName, JsonValue jsonValue, Node node);\n    }\n}\n", "diffSourceCodeSet": ["public Node deserializeObject(JsonReader reader, Map<String, Delegate> delegates) {\n        Log.info(\"Deserializing JSON to Node.\");\n        JsonObject jsonObject = reader.readObject();\n        return deserializeObject(jsonObject, delegates);\n    }"], "invokedMethodSet": ["methodSignature: com.github.javaparser.serialization.JavaParserJsonDeserializer#deserializeObject\n methodBody: private Node deserializeObject(JsonObject nodeJson) {\ntryString serializedNodeType=nodeJson.getString(SERIALIZED_CLASS_KEY);\nBaseNodeMetaModel nodeMetaModel=getNodeMetaModel(Class.forName(serializedNodeType)).orElseThrow(() -> new IllegalStateException(\"Trying to deserialize an unknown node type: \" + serializedNodeType));\nMap<String,Object> parameters=new HashMap<>();\nfor(String name: nodeJson.keySet()){if(name.equals(SERIALIZED_CLASS_KEY)){continue;\n}PropertyMetaModel propertyMetaModel=nodeMetaModel.getAllPropertyMetaModels().stream().filter(mm -> mm.getName().equals(name)).findFirst().orElseThrow(() -> new IllegalStateException(\"Unknown property: \" + nodeMetaModel.getQualifiedClassName() + \".\" + name));\nif(propertyMetaModel.isNodeList()){JsonArray nodeListJson=nodeJson.getJsonArray(name);\nparameters.put(name,deserializeNodeList(nodeListJson));\n}if(propertyMetaModel.isEnumSet()){JsonArray enumSetJson=nodeJson.getJsonArray(name);\nparameters.put(name,deserializeEnumSet(enumSetJson));\n}if(propertyMetaModel.isNode()){parameters.put(name,deserializeObject(nodeJson.getJsonObject(name)));\n}{Class<?> type=propertyMetaModel.getType();\nif(type == String.class){parameters.put(name,nodeJson.getString(name));\n}if(type == boolean.class){parameters.put(name,Boolean.parseBoolean(nodeJson.getString(name)));\n}if(Enum.class.isAssignableFrom(type)){parameters.put(name,Enum.valueOf((Class<? extends Enum>)type,nodeJson.getString(name)));\n}{throw new IllegalStateException(\"Don't know how to convert: \" + type);\n}}}return nodeMetaModel.construct(parameters);\ncatch(ClassNotFoundException e)throw new RuntimeException(e);\n}"], "sourceCodeAfterRefactoring": "public Node deserializeObject(JsonReader reader) {\n        return deserializeObject(reader, new HashMap<>());\n    }\npublic Node deserializeObject(JsonReader reader, Map<String, Delegate> delegates) {\n        Log.info(\"Deserializing JSON to Node.\");\n        JsonObject jsonObject = reader.readObject();\n        return deserializeObject(jsonObject, delegates);\n    }", "diffSourceCode": "-   44:  * Deserializes the JSON file that was built by {@link JavaParserJsonSerializer}.\n-   45:  */\n-   46: public class JavaParserJsonDeserializer {\n-   48:     public Node deserializeObject(JsonReader reader) {\n+   44:     public Node deserializeObject(JsonReader reader) {\n+   45:         return deserializeObject(reader, new HashMap<>());\n+   46:     }\n+   48:     public Node deserializeObject(JsonReader reader, Map<String, Delegate> delegates) {\n    49:         Log.info(\"Deserializing JSON to Node.\");\n    50:         JsonObject jsonObject = reader.readObject();\n-   51:         return deserializeObject(jsonObject);\n+   51:         return deserializeObject(jsonObject, delegates);\n    52:     }\n", "uniqueId": "ef3ecbbbdebff45488e6017781f8caf59c2056fa_48_52_48_52_44_46", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 18, "covered": 134}, "BRANCH": {"missed": 1, "covered": 15}, "LINE": {"missed": 3, "covered": 27}, "COMPLEXITY": {"missed": 1, "covered": 8}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `deserializeObject(JsonReader reader)` method, we can extract the logging functionality into a separate method. This will make the main method cleaner and more focused on its primary task, which is deserializing the JSON object.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\npublic Node deserializeObject(JsonReader reader) {\n    logDeserialization();\n    JsonObject jsonObject = reader.readObject();\n    return deserializeObject(jsonObject);\n}\n\nprivate void logDeserialization() {\n    Log.info(\"Deserializing JSON to Node.\");\n}\n##########################\n```\n\nIn this refactoring, the logging functionality has been extracted into a new method called `logDeserialization()`. This enhances the clarity of the `deserializeObject(JsonReader reader)` method by separating concerns, making it easier to read and maintain.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\npublic Node deserializeObject(JsonReader reader) {\n        Log.info(\"Deserializing JSON to Node.\");\n        JsonObject jsonObject = reader.readObject();\n        return deserializeObject(jsonObject);\n    }\n\nClass content:\n/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2018 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.serialization;\n\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.metamodel.BaseNodeMetaModel;\nimport com.github.javaparser.metamodel.PropertyMetaModel;\nimport com.github.javaparser.utils.Log;\n\nimport javax.json.JsonArray;\nimport javax.json.JsonObject;\nimport javax.json.JsonReader;\nimport javax.json.JsonString;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.ast.NodeList.toNodeList;\nimport static com.github.javaparser.metamodel.JavaParserMetaModel.getNodeMetaModel;\nimport static com.github.javaparser.serialization.JavaParserJsonSerializer.SERIALIZED_CLASS_KEY;\n\n/**\n * Deserializes the JSON file that was built by {@link JavaParserJsonSerializer}.\n */\npublic class JavaParserJsonDeserializer {\n\n    public Node deserializeObject(JsonReader reader) {\n        Log.info(\"Deserializing JSON to Node.\");\n        JsonObject jsonObject = reader.readObject();\n        return deserializeObject(jsonObject);\n    }\n\n    private Node deserializeObject(JsonObject nodeJson) {\n        try {\n            String serializedNodeType = nodeJson.getString(SERIALIZED_CLASS_KEY);\n            BaseNodeMetaModel nodeMetaModel = getNodeMetaModel(Class.forName(serializedNodeType))\n                    .orElseThrow(() -> new IllegalStateException(\"Trying to deserialize an unknown node type: \" + serializedNodeType));\n            Map<String, Object> parameters = new HashMap<>();\n            for (String name : nodeJson.keySet()) {\n                if (name.equals(SERIALIZED_CLASS_KEY)) {\n                    continue;\n                }\n\n                PropertyMetaModel propertyMetaModel = nodeMetaModel.getAllPropertyMetaModels().stream()\n                        .filter(mm -> mm.getName().equals(name))\n                        .findFirst().orElseThrow(() -> new IllegalStateException(\"Unknown property: \" + nodeMetaModel.getQualifiedClassName() + \".\" + name));\n\n                if (propertyMetaModel.isNodeList()) {\n                    JsonArray nodeListJson = nodeJson.getJsonArray(name);\n                    parameters.put(name, deserializeNodeList(nodeListJson));\n                } else if (propertyMetaModel.isEnumSet()) {\n                    JsonArray enumSetJson = nodeJson.getJsonArray(name);\n                    parameters.put(name, deserializeEnumSet(enumSetJson));\n                } else if (propertyMetaModel.isNode()) {\n                    parameters.put(name, deserializeObject(nodeJson.getJsonObject(name)));\n                } else {\n                    Class<?> type = propertyMetaModel.getType();\n                    if (type == String.class) {\n                        parameters.put(name, nodeJson.getString(name));\n                    } else if (type == boolean.class) {\n                        parameters.put(name, Boolean.parseBoolean(nodeJson.getString(name)));\n                    } else if (Enum.class.isAssignableFrom(type)) {\n                        parameters.put(name, Enum.valueOf((Class<? extends Enum>) type, nodeJson.getString(name)));\n                    } else {\n                        throw new IllegalStateException(\"Don't know how to convert: \" + type);\n                    }\n                }\n            }\n\n            return nodeMetaModel.construct(parameters);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private EnumSet<?> deserializeEnumSet(JsonArray enumSetJson) {\n        return enumSetJson.stream().map(v -> (JsonString) v).map(s -> Modifier.valueOf(s.getString())).collect(Collectors.toCollection(() -> EnumSet.noneOf(Modifier.class)));\n    }\n\n    private NodeList<?> deserializeNodeList(JsonArray nodeListJson) {\n        return nodeListJson.stream().map(nodeJson -> deserializeObject((JsonObject) nodeJson)).collect(toNodeList());\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic assertProblems(result List<Problem>, expectedArg String...) : void extracted from public assertProblems(result ParseResult<?>, expectedArg String...) : void in class com.github.javaparser.utils.TestUtils", "diffLocations": [{"filePath": "javaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java", "startLine": 129, "endLine": 134, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java", "startLine": 126, "endLine": 128, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java", "startLine": 130, "endLine": 135, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        Set<String> actual = result.getProblems().stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>();\n        expected.addAll(Arrays.asList(expectedArg));\n        assertCollections(expected, actual);\n    }", "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java", "isPureRefactoring": true, "commitId": "f80c6cd0b31865ada2c77df0e159bb94646e1888", "packageNameBefore": "com.github.javaparser.utils", "classNameBefore": "com.github.javaparser.utils.TestUtils", "methodNameBefore": "com.github.javaparser.utils.TestUtils#assertProblems", "invokedMethod": "methodSignature: com.github.javaparser.utils.TestUtils#assertCollections\n methodBody: public static void assertCollections(Collection<?> expected, Collection<?> actual) {\nfinal StringBuilder out=new StringBuilder();\nfor(Object e: expected){if(actual.contains(e)){actual.remove(e);\n}{out.append(\"Missing: \").append(e).append(EOL);\n}}for(Object a: actual){out.append(\"Unexpected: \").append(a).append(EOL);\n}String s=out.toString();\nif(s.isEmpty()){return;\n}fail(s);\n}", "classSignatureBefore": "public class TestUtils ", "methodNameBeforeSet": ["com.github.javaparser.utils.TestUtils#assertProblems"], "classNameBeforeSet": ["com.github.javaparser.utils.TestUtils"], "classSignatureBeforeSet": ["public class TestUtils "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.utils;\n\nimport com.github.javaparser.*;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.validator.Java9Validator;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.github.javaparser.utils.CodeGenerationUtils.f;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.Utils.EOL;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\npublic class TestUtils {\n    /**\n     * Takes care of setting all the end of line character to platform specific ones.\n     */\n    public static String readResource(String resourceName) throws IOException {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"not found: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, \"utf-8\");\n                 final BufferedReader br = new BufferedReader(reader)) {\n                final StringBuilder builder = new StringBuilder();\n                String line;\n                while ((line = br.readLine()) != null) {\n                    builder.append(line).append(Utils.EOL);\n                }\n                return builder.toString();\n            }\n        }\n    }\n\n    public static void assertInstanceOf(Class<?> expectedType, Object instance) {\n        assertTrue(f(\"%s is not an instance of %s.\", instance.getClass(), expectedType), expectedType.isAssignableFrom(instance.getClass()));\n    }\n\n    /**\n     * Unzip a zip file into a directory.\n     */\n    public static void unzip(Path zipFile, Path outputFolder) throws IOException {\n        Log.info(\"Unzipping %s to %s\", zipFile, outputFolder);\n\n        final byte[] buffer = new byte[1024 * 1024];\n\n        outputFolder.toFile().mkdirs();\n\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {\n            ZipEntry ze = zis.getNextEntry();\n\n            while (ze != null) {\n                final Path newFile = outputFolder.resolve(ze.getName());\n\n                if (ze.isDirectory()) {\n                    Log.trace(\"mkdir %s\", newFile.toAbsolutePath());\n                    newFile.toFile().mkdirs();\n                } else {\n                    Log.info(\"unzip %s\", newFile.toAbsolutePath());\n                    try (FileOutputStream fos = new FileOutputStream(newFile.toFile())) {\n                        int len;\n                        while ((len = zis.read(buffer)) > 0) {\n                            fos.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n\n        }\n        Log.info(\"Unzipped %s to %s\", zipFile, outputFolder);\n    }\n\n    /**\n     * Download a file from a URL to disk.\n     */\n    public static void download(URL url, Path destination) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        Response response = client.newCall(request).execute();\n        Files.write(destination, response.body().bytes());\n    }\n\n    public static String temporaryDirectory() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }\n\n    public static void assertCollections(Collection<?> expected, Collection<?> actual) {\n        final StringBuilder out = new StringBuilder();\n        for (Object e : expected) {\n            if (actual.contains(e)) {\n                actual.remove(e);\n            } else {\n                out.append(\"Missing: \").append(e).append(EOL);\n            }\n        }\n        for (Object a : actual) {\n            out.append(\"Unexpected: \").append(a).append(EOL);\n        }\n\n        String s = out.toString();\n        if (s.isEmpty()) {\n            return;\n        }\n        fail(s);\n    }\n\n    public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        Set<String> actual = result.getProblems().stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>();\n        expected.addAll(Arrays.asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\n    public static void assertNoProblems(ParseResult<?> result) {\n        assertProblems(result);\n    }\n\n    public static void assertExpressionValid(String expression) {\n        JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java9Validator()));\n        ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n        assertTrue(result.getProblems().toString(), result.isSuccessful());\n    }\n}\n", "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java", "sourceCodeAfterForWhole": "package com.github.javaparser.utils;\n\nimport com.github.javaparser.*;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.validator.Java9Validator;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.github.javaparser.utils.CodeGenerationUtils.f;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.Utils.EOL;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\npublic class TestUtils {\n    /**\n     * Takes care of setting all the end of line character to platform specific ones.\n     */\n    public static String readResource(String resourceName) throws IOException {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"not found: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, \"utf-8\");\n                 final BufferedReader br = new BufferedReader(reader)) {\n                final StringBuilder builder = new StringBuilder();\n                String line;\n                while ((line = br.readLine()) != null) {\n                    builder.append(line).append(Utils.EOL);\n                }\n                return builder.toString();\n            }\n        }\n    }\n\n    public static void assertInstanceOf(Class<?> expectedType, Object instance) {\n        assertTrue(f(\"%s is not an instance of %s.\", instance.getClass(), expectedType), expectedType.isAssignableFrom(instance.getClass()));\n    }\n\n    /**\n     * Unzip a zip file into a directory.\n     */\n    public static void unzip(Path zipFile, Path outputFolder) throws IOException {\n        Log.info(\"Unzipping %s to %s\", zipFile, outputFolder);\n\n        final byte[] buffer = new byte[1024 * 1024];\n\n        outputFolder.toFile().mkdirs();\n\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {\n            ZipEntry ze = zis.getNextEntry();\n\n            while (ze != null) {\n                final Path newFile = outputFolder.resolve(ze.getName());\n\n                if (ze.isDirectory()) {\n                    Log.trace(\"mkdir %s\", newFile.toAbsolutePath());\n                    newFile.toFile().mkdirs();\n                } else {\n                    Log.info(\"unzip %s\", newFile.toAbsolutePath());\n                    try (FileOutputStream fos = new FileOutputStream(newFile.toFile())) {\n                        int len;\n                        while ((len = zis.read(buffer)) > 0) {\n                            fos.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n\n        }\n        Log.info(\"Unzipped %s to %s\", zipFile, outputFolder);\n    }\n\n    /**\n     * Download a file from a URL to disk.\n     */\n    public static void download(URL url, Path destination) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        Response response = client.newCall(request).execute();\n        Files.write(destination, response.body().bytes());\n    }\n\n    public static String temporaryDirectory() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }\n\n    public static void assertCollections(Collection<?> expected, Collection<?> actual) {\n        final StringBuilder out = new StringBuilder();\n        for (Object e : expected) {\n            if (actual.contains(e)) {\n                actual.remove(e);\n            } else {\n                out.append(\"Missing: \").append(e).append(EOL);\n            }\n        }\n        for (Object a : actual) {\n            out.append(\"Unexpected: \").append(a).append(EOL);\n        }\n\n        String s = out.toString();\n        if (s.isEmpty()) {\n            return;\n        }\n        fail(s);\n    }\n\n    public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        assertProblems(result.getProblems(), expectedArg);\n    }\n\n    public static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>();\n        expected.addAll(Arrays.asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\n    public static void assertNoProblems(ParseResult<?> result) {\n        assertProblems(result);\n    }\n\n    public static void assertExpressionValid(String expression) {\n        JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java9Validator()));\n        ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n        assertTrue(result.getProblems().toString(), result.isSuccessful());\n    }\n}\n", "diffSourceCodeSet": ["public static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>();\n        expected.addAll(Arrays.asList(expectedArg));\n        assertCollections(expected, actual);\n    }"], "invokedMethodSet": ["methodSignature: com.github.javaparser.utils.TestUtils#assertCollections\n methodBody: public static void assertCollections(Collection<?> expected, Collection<?> actual) {\nfinal StringBuilder out=new StringBuilder();\nfor(Object e: expected){if(actual.contains(e)){actual.remove(e);\n}{out.append(\"Missing: \").append(e).append(EOL);\n}}for(Object a: actual){out.append(\"Unexpected: \").append(a).append(EOL);\n}String s=out.toString();\nif(s.isEmpty()){return;\n}fail(s);\n}"], "sourceCodeAfterRefactoring": "public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        assertProblems(result.getProblems(), expectedArg);\n    }\npublic static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>();\n        expected.addAll(Arrays.asList(expectedArg));\n        assertCollections(expected, actual);\n    }", "diffSourceCode": "-  126:         fail(s);\n-  127:     }\n-  128: \n-  129:     public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n-  130:         Set<String> actual = result.getProblems().stream().map(Problem::toString).collect(Collectors.toSet());\n-  131:         Set<String> expected = new HashSet<>();\n-  132:         expected.addAll(Arrays.asList(expectedArg));\n-  133:         assertCollections(expected, actual);\n-  134:     }\n-  135: \n+  126:     public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n+  127:         assertProblems(result.getProblems(), expectedArg);\n+  128:     }\n+  129: \n+  130:     public static void assertProblems(List<Problem> result, String... expectedArg) {\n+  131:         Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n+  132:         Set<String> expected = new HashSet<>();\n+  133:         expected.addAll(Arrays.asList(expectedArg));\n+  134:         assertCollections(expected, actual);\n+  135:     }\n", "uniqueId": "f80c6cd0b31865ada2c77df0e159bb94646e1888_129_134_130_135_126_128", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `assertProblems` method, we can extract the logic for converting the expected arguments into a set into a separate method. This will make the `assertProblems` method cleaner and more focused on its primary responsibility.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\npublic static void assertProblems(ParseResult<?> result, String... expectedArg) {\n    Set<String> actual = result.getProblems().stream().map(Problem::toString).collect(Collectors.toSet());\n    Set<String> expected = createExpectedSet(expectedArg);\n    assertCollections(expected, actual);\n}\n\nprivate static Set<String> createExpectedSet(String... expectedArg) {\n    return new HashSet<>(Arrays.asList(expectedArg));\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The logic for creating the `expected` set from the `expectedArg` array has been moved to a new private method called `createExpectedSet`. This method takes a variable number of string arguments and returns a `Set<String>`.\n2. **Improved Readability**: The `assertProblems` method is now more concise and easier to read, as it clearly shows that it is asserting problems without being cluttered by the details of how the expected set is constructed.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\npublic static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        Set<String> actual = result.getProblems().stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>();\n        expected.addAll(Arrays.asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\nClass content:\npackage com.github.javaparser.utils;\n\nimport com.github.javaparser.*;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.validator.Java9Validator;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.github.javaparser.utils.CodeGenerationUtils.f;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.Utils.EOL;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\npublic class TestUtils {\n    /**\n     * Takes care of setting all the end of line character to platform specific ones.\n     */\n    public static String readResource(String resourceName) throws IOException {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"not found: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, \"utf-8\");\n                 final BufferedReader br = new BufferedReader(reader)) {\n                final StringBuilder builder = new StringBuilder();\n                String line;\n                while ((line = br.readLine()) != null) {\n                    builder.append(line).append(Utils.EOL);\n                }\n                return builder.toString();\n            }\n        }\n    }\n\n    public static void assertInstanceOf(Class<?> expectedType, Object instance) {\n        assertTrue(f(\"%s is not an instance of %s.\", instance.getClass(), expectedType), expectedType.isAssignableFrom(instance.getClass()));\n    }\n\n    /**\n     * Unzip a zip file into a directory.\n     */\n    public static void unzip(Path zipFile, Path outputFolder) throws IOException {\n        Log.info(\"Unzipping %s to %s\", zipFile, outputFolder);\n\n        final byte[] buffer = new byte[1024 * 1024];\n\n        outputFolder.toFile().mkdirs();\n\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {\n            ZipEntry ze = zis.getNextEntry();\n\n            while (ze != null) {\n                final Path newFile = outputFolder.resolve(ze.getName());\n\n                if (ze.isDirectory()) {\n                    Log.trace(\"mkdir %s\", newFile.toAbsolutePath());\n                    newFile.toFile().mkdirs();\n                } else {\n                    Log.info(\"unzip %s\", newFile.toAbsolutePath());\n                    try (FileOutputStream fos = new FileOutputStream(newFile.toFile())) {\n                        int len;\n                        while ((len = zis.read(buffer)) > 0) {\n                            fos.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n\n        }\n        Log.info(\"Unzipped %s to %s\", zipFile, outputFolder);\n    }\n\n    /**\n     * Download a file from a URL to disk.\n     */\n    public static void download(URL url, Path destination) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        Response response = client.newCall(request).execute();\n        Files.write(destination, response.body().bytes());\n    }\n\n    public static String temporaryDirectory() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }\n\n    public static void assertCollections(Collection<?> expected, Collection<?> actual) {\n        final StringBuilder out = new StringBuilder();\n        for (Object e : expected) {\n            if (actual.contains(e)) {\n                actual.remove(e);\n            } else {\n                out.append(\"Missing: \").append(e).append(EOL);\n            }\n        }\n        for (Object a : actual) {\n            out.append(\"Unexpected: \").append(a).append(EOL);\n        }\n\n        String s = out.toString();\n        if (s.isEmpty()) {\n            return;\n        }\n        fail(s);\n    }\n\n    public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        Set<String> actual = result.getProblems().stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>();\n        expected.addAll(Arrays.asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\n    public static void assertNoProblems(ParseResult<?> result) {\n        assertProblems(result);\n    }\n\n    public static void assertExpressionValid(String expression) {\n        JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java9Validator()));\n        ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n        assertTrue(result.getProblems().toString(), result.isSuccessful());\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpublic moduleRequires() : void from class com.github.javaparser.ast.validator.Java1_2ValidatorTest to public moduleRequires() : void from class com.github.javaparser.ast.validator.Java9ValidatorTest", "diffLocations": [{"filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java", "startLine": 110, "endLine": 129, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java9ValidatorTest.java", "startLine": 31, "endLine": 50, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }", "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java", "isPureRefactoring": true, "commitId": "60236c613723e7add97cc5e529d0d9bad02872ff", "packageNameBefore": "com.github.javaparser.ast.validator", "classNameBefore": "com.github.javaparser.ast.validator.Java1_2ValidatorTest", "methodNameBefore": "com.github.javaparser.ast.validator.Java1_2ValidatorTest#moduleRequires", "classSignatureBefore": "public class Java1_2ValidatorTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.validator.Java1_2ValidatorTest#moduleRequires"], "classNameBeforeSet": ["com.github.javaparser.ast.validator.Java1_2ValidatorTest"], "classSignatureBeforeSet": ["public class Java1_2ValidatorTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class Java1_2ValidatorTest {\n    public static final JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java1_2Validator()));\n\n    private final String allModifiers = \"public protected private abstract static final transient volatile synchronized native strictfp transitive default \";\n\n    @Test\n    public void topClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"class X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"class I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{ void x() {\" + allModifiers + \"class I{}}}\"));\n        assertProblems(result,\n                \"(line 1,col 20) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 20) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 20) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 20) 'transient' is not allowed here.\",\n                \"(line 1,col 20) 'volatile' is not allowed here.\",\n                \"(line 1,col 20) 'default' is not allowed here.\",\n                \"(line 1,col 20) 'synchronized' is not allowed here.\",\n                \"(line 1,col 20) 'native' is not allowed here.\",\n                \"(line 1,col 20) 'transitive' is not allowed here.\",\n                \"(line 1,col 20) 'static' is not allowed here.\",\n                \"(line 1,col 20) 'public' is not allowed here.\",\n                \"(line 1,col 20) 'private' is not allowed here.\",\n                \"(line 1,col 20) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"interface X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"interface I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructor() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"X(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'static' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructorParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{X(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 11) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 11) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 11) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 11) 'transient' is not allowed here.\",\n                \"(line 1,col 11) 'volatile' is not allowed here.\",\n                \"(line 1,col 11) 'synchronized' is not allowed here.\",\n                \"(line 1,col 11) 'native' is not allowed here.\",\n                \"(line 1,col 11) 'strictfp' is not allowed here.\",\n                \"(line 1,col 11) 'default' is not allowed here.\",\n                \"(line 1,col 11) 'abstract' is not allowed here.\",\n                \"(line 1,col 11) 'static' is not allowed here.\",\n                \"(line 1,col 11) 'transitive' is not allowed here.\",\n                \"(line 1,col 11) 'private' is not allowed here.\",\n                \"(line 1,col 11) 'public' is not allowed here.\",\n                \"(line 1,col 11) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void classMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void interfaceMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"interface X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 13) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 13) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 13) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 13) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 13) 'transient' is not allowed here.\",\n                \"(line 1,col 13) 'volatile' is not allowed here.\",\n                \"(line 1,col 13) 'default' is not allowed here.\",\n                \"(line 1,col 13) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void methodParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 15) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 15) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 15) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 15) 'transient' is not allowed here.\",\n                \"(line 1,col 15) 'volatile' is not allowed here.\",\n                \"(line 1,col 15) 'synchronized' is not allowed here.\",\n                \"(line 1,col 15) 'native' is not allowed here.\",\n                \"(line 1,col 15) 'strictfp' is not allowed here.\",\n                \"(line 1,col 15) 'abstract' is not allowed here.\",\n                \"(line 1,col 15) 'default' is not allowed here.\",\n                \"(line 1,col 15) 'static' is not allowed here.\",\n                \"(line 1,col 15) 'transitive' is not allowed here.\",\n                \"(line 1,col 15) 'private' is not allowed here.\",\n                \"(line 1,col 15) 'public' is not allowed here.\",\n                \"(line 1,col 15) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void field() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int i;}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localVariable() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){\" + allModifiers + \"int i;}}\"));\n        assertProblems(result,\n                \"(line 1,col 17) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 17) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 17) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 17) 'transient' is not allowed here.\",\n                \"(line 1,col 17) 'volatile' is not allowed here.\",\n                \"(line 1,col 17) 'synchronized' is not allowed here.\",\n                \"(line 1,col 17) 'native' is not allowed here.\",\n                \"(line 1,col 17) 'default' is not allowed here.\",\n                \"(line 1,col 17) 'strictfp' is not allowed here.\",\n                \"(line 1,col 17) 'abstract' is not allowed here.\",\n                \"(line 1,col 17) 'static' is not allowed here.\",\n                \"(line 1,col 17) 'transitive' is not allowed here.\",\n                \"(line 1,col 17) 'private' is not allowed here.\",\n                \"(line 1,col 17) 'public' is not allowed here.\",\n                \"(line 1,col 17) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void catchParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){ try{}catch(\"+ allModifiers +\" Integer x){}}}\"));\n        assertProblems(result,\n                \"(line 1,col 144) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 144) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 144) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 144) 'transient' is not allowed here.\",\n                \"(line 1,col 144) 'volatile' is not allowed here.\",\n                \"(line 1,col 144) 'synchronized' is not allowed here.\",\n                \"(line 1,col 144) 'native' is not allowed here.\",\n                \"(line 1,col 144) 'default' is not allowed here.\",\n                \"(line 1,col 144) 'strictfp' is not allowed here.\",\n                \"(line 1,col 144) 'abstract' is not allowed here.\",\n                \"(line 1,col 144) 'static' is not allowed here.\",\n                \"(line 1,col 144) 'transitive' is not allowed here.\",\n                \"(line 1,col 144) 'private' is not allowed here.\",\n                \"(line 1,col 144) 'public' is not allowed here.\",\n                \"(line 1,col 144) 'protected' is not allowed here.\"\n        );\n    }\n}\n", "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java9ValidatorTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.stmt.Statement;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.ParseStart.STATEMENT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.ast.validator.Java1_1ValidatorTest.allModifiers;\nimport static com.github.javaparser.utils.TestUtils.assertNoProblems;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class Java9ValidatorTest {\n    public static final JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java9Validator()));\n\n    @Test\n    public void underscoreIdentifiers() {\n        ParseResult<Statement> result = javaParser.parse(STATEMENT, provider(\"a.b._.c.d = act(_, _ -> _);\"));\n        assertProblems(result,\n                \"(line 1,col 5) '_' is a reserved keyword.\",\n                \"(line 1,col 17) '_' is a reserved keyword.\",\n                \"(line 1,col 20) '_' is a reserved keyword.\",\n                \"(line 1,col 25) '_' is a reserved keyword.\"\n        );\n    }\n\n    @Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void modules() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"open module x {}\"));\n        assertNoProblems(result);\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }", "diffSourceCode": "-   31:                 \"(line 1,col 1) 'native' is not allowed here.\",\n-   32:                 \"(line 1,col 1) 'transitive' is not allowed here.\",\n-   33:                 \"(line 1,col 1) 'static' is not allowed here.\"\n-   34:         );\n-   35:     }\n-   36: \n-   37:     @Test\n-   38:     public void nestedClass() {\n-   39:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"class I{}}\"));\n-   40:         assertProblems(result,\n-   41:                 \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n-   42:                 \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n-   43:                 \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n-   44:                 \"(line 1,col 9) 'transient' is not allowed here.\",\n-   45:                 \"(line 1,col 9) 'default' is not allowed here.\",\n-   46:                 \"(line 1,col 9) 'volatile' is not allowed here.\",\n-   47:                 \"(line 1,col 9) 'synchronized' is not allowed here.\",\n-   48:                 \"(line 1,col 9) 'native' is not allowed here.\",\n-   49:                 \"(line 1,col 9) 'transitive' is not allowed here.\"\n-   50:         );\n-  110:     @Test\n-  111:     public void moduleRequires() {\n-  112:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n-  113:         assertProblems(result,\n-  114:                 \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n-  115:                 \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n-  116:                 \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n-  117:                 \"(line 1,col 10) 'transient' is not allowed here.\",\n-  118:                 \"(line 1,col 10) 'volatile' is not allowed here.\",\n-  119:                 \"(line 1,col 10) 'final' is not allowed here.\",\n-  120:                 \"(line 1,col 10) 'synchronized' is not allowed here.\",\n-  121:                 \"(line 1,col 10) 'default' is not allowed here.\",\n-  122:                 \"(line 1,col 10) 'native' is not allowed here.\",\n-  123:                 \"(line 1,col 10) 'private' is not allowed here.\",\n-  124:                 \"(line 1,col 10) 'protected' is not allowed here.\",\n-  125:                 \"(line 1,col 10) 'strictfp' is not allowed here.\",\n-  126:                 \"(line 1,col 10) 'abstract' is not allowed here.\",\n-  127:                 \"(line 1,col 10) 'public' is not allowed here.\"\n-  128:         );\n-  129:     }\n+   31:     @Test\n+   32:     public void moduleRequires() {\n+   33:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n+   34:         assertProblems(result,\n+   35:                 \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n+   36:                 \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n+   37:                 \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n+   38:                 \"(line 1,col 10) 'transient' is not allowed here.\",\n+   39:                 \"(line 1,col 10) 'volatile' is not allowed here.\",\n+   40:                 \"(line 1,col 10) 'final' is not allowed here.\",\n+   41:                 \"(line 1,col 10) 'synchronized' is not allowed here.\",\n+   42:                 \"(line 1,col 10) 'default' is not allowed here.\",\n+   43:                 \"(line 1,col 10) 'native' is not allowed here.\",\n+   44:                 \"(line 1,col 10) 'private' is not allowed here.\",\n+   45:                 \"(line 1,col 10) 'protected' is not allowed here.\",\n+   46:                 \"(line 1,col 10) 'strictfp' is not allowed here.\",\n+   47:                 \"(line 1,col 10) 'abstract' is not allowed here.\",\n+   48:                 \"(line 1,col 10) 'public' is not allowed here.\"\n+   49:         );\n+   50:     }\n", "uniqueId": "60236c613723e7add97cc5e529d0d9bad02872ff_110_129__31_50", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To perform the requested refactoring operation, we will move the `moduleRequires` method from the `Java1_2ValidatorTest` class to an existing test class that is appropriate for the context. Given the project structure, it seems that the `Java1_2ValidatorTest` class is already focused on validating Java 1.2 constructs, and the `moduleRequires` method fits within that context.\n\nWe will move the `moduleRequires` method to the `Java1_2ValidatorTest` class and refactor it to call a new static method in a utility class. \n\n### Step 1: Identify the Target File Path\nWe will move the `moduleRequires` method to the `Java1_2ValidatorTest` class, which is already in the correct package.\n\n### Step 2: Create a New Utility Class\nWe will create a new utility class named `JavaValidatorUtils` to hold the static method that will perform the parsing and assertion.\n\n### Step 3: Move the Method and Refactor\nWe will move the `moduleRequires` method to the `JavaValidatorUtils` class and refactor the original test method to call this new static method.\n\n### Target File Path\nThe target file path for the moved class will be:\n```\njavaparser-testing/src/test/java/com/github/javaparser/ast/validator/JavaValidatorUtils.java\n```\n\n### Moved Class Code\nHere is the code for the new utility class `JavaValidatorUtils`:\n```java\npackage com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ast.CompilationUnit;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class JavaValidatorUtils {\n    public static void validateModuleRequires(JavaParser javaParser, String allModifiers) {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }\n}\n```\n\n### Refactored Method Code\nHere is the refactored `moduleRequires` method in the `Java1_2ValidatorTest` class:\n```java\n@Test\npublic void moduleRequires() {\n    JavaValidatorUtils.validateModuleRequires(javaParser, allModifiers);\n}\n```\n\n### Final Output\nHere is the final output in the requested format:\n\n##########################\njavaparser-testing/src/test/java/com/github/javaparser/ast/validator/JavaValidatorUtils.java\n##########################\npackage com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ast.CompilationUnit;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class JavaValidatorUtils {\n    public static void validateModuleRequires(JavaParser javaParser, String allModifiers) {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }\n}\n##########################\n@Test\npublic void moduleRequires() {\n    JavaValidatorUtils.validateModuleRequires(javaParser, allModifiers);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }\n\nClass content:\npackage com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class Java1_2ValidatorTest {\n    public static final JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java1_2Validator()));\n\n    private final String allModifiers = \"public protected private abstract static final transient volatile synchronized native strictfp transitive default \";\n\n    @Test\n    public void topClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"class X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"class I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{ void x() {\" + allModifiers + \"class I{}}}\"));\n        assertProblems(result,\n                \"(line 1,col 20) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 20) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 20) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 20) 'transient' is not allowed here.\",\n                \"(line 1,col 20) 'volatile' is not allowed here.\",\n                \"(line 1,col 20) 'default' is not allowed here.\",\n                \"(line 1,col 20) 'synchronized' is not allowed here.\",\n                \"(line 1,col 20) 'native' is not allowed here.\",\n                \"(line 1,col 20) 'transitive' is not allowed here.\",\n                \"(line 1,col 20) 'static' is not allowed here.\",\n                \"(line 1,col 20) 'public' is not allowed here.\",\n                \"(line 1,col 20) 'private' is not allowed here.\",\n                \"(line 1,col 20) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"interface X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"interface I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructor() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"X(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'static' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructorParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{X(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 11) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 11) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 11) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 11) 'transient' is not allowed here.\",\n                \"(line 1,col 11) 'volatile' is not allowed here.\",\n                \"(line 1,col 11) 'synchronized' is not allowed here.\",\n                \"(line 1,col 11) 'native' is not allowed here.\",\n                \"(line 1,col 11) 'strictfp' is not allowed here.\",\n                \"(line 1,col 11) 'default' is not allowed here.\",\n                \"(line 1,col 11) 'abstract' is not allowed here.\",\n                \"(line 1,col 11) 'static' is not allowed here.\",\n                \"(line 1,col 11) 'transitive' is not allowed here.\",\n                \"(line 1,col 11) 'private' is not allowed here.\",\n                \"(line 1,col 11) 'public' is not allowed here.\",\n                \"(line 1,col 11) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void classMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void interfaceMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"interface X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 13) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 13) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 13) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 13) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 13) 'transient' is not allowed here.\",\n                \"(line 1,col 13) 'volatile' is not allowed here.\",\n                \"(line 1,col 13) 'default' is not allowed here.\",\n                \"(line 1,col 13) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void methodParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 15) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 15) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 15) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 15) 'transient' is not allowed here.\",\n                \"(line 1,col 15) 'volatile' is not allowed here.\",\n                \"(line 1,col 15) 'synchronized' is not allowed here.\",\n                \"(line 1,col 15) 'native' is not allowed here.\",\n                \"(line 1,col 15) 'strictfp' is not allowed here.\",\n                \"(line 1,col 15) 'abstract' is not allowed here.\",\n                \"(line 1,col 15) 'default' is not allowed here.\",\n                \"(line 1,col 15) 'static' is not allowed here.\",\n                \"(line 1,col 15) 'transitive' is not allowed here.\",\n                \"(line 1,col 15) 'private' is not allowed here.\",\n                \"(line 1,col 15) 'public' is not allowed here.\",\n                \"(line 1,col 15) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void field() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int i;}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localVariable() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){\" + allModifiers + \"int i;}}\"));\n        assertProblems(result,\n                \"(line 1,col 17) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 17) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 17) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 17) 'transient' is not allowed here.\",\n                \"(line 1,col 17) 'volatile' is not allowed here.\",\n                \"(line 1,col 17) 'synchronized' is not allowed here.\",\n                \"(line 1,col 17) 'native' is not allowed here.\",\n                \"(line 1,col 17) 'default' is not allowed here.\",\n                \"(line 1,col 17) 'strictfp' is not allowed here.\",\n                \"(line 1,col 17) 'abstract' is not allowed here.\",\n                \"(line 1,col 17) 'static' is not allowed here.\",\n                \"(line 1,col 17) 'transitive' is not allowed here.\",\n                \"(line 1,col 17) 'private' is not allowed here.\",\n                \"(line 1,col 17) 'public' is not allowed here.\",\n                \"(line 1,col 17) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void catchParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){ try{}catch(\"+ allModifiers +\" Integer x){}}}\"));\n        assertProblems(result,\n                \"(line 1,col 144) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 144) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 144) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 144) 'transient' is not allowed here.\",\n                \"(line 1,col 144) 'volatile' is not allowed here.\",\n                \"(line 1,col 144) 'synchronized' is not allowed here.\",\n                \"(line 1,col 144) 'native' is not allowed here.\",\n                \"(line 1,col 144) 'default' is not allowed here.\",\n                \"(line 1,col 144) 'strictfp' is not allowed here.\",\n                \"(line 1,col 144) 'abstract' is not allowed here.\",\n                \"(line 1,col 144) 'static' is not allowed here.\",\n                \"(line 1,col 144) 'transitive' is not allowed here.\",\n                \"(line 1,col 144) 'private' is not allowed here.\",\n                \"(line 1,col 144) 'public' is not allowed here.\",\n                \"(line 1,col 144) 'protected' is not allowed here.\"\n        );\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['javaparser-testing/src/test/java/com/github/javaparser/CommentsInserterTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/JavaParserTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/JavaTokenTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/JavadocParserTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ProblemTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ProvidersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/RangeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/CompilationUnitTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/DataKeyTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/NodeListTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/NodePositionTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/NodeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/ParseResultTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/body/AnnotationMemberDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/body/MethodDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/comments/CommentTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/InstanceOfExprTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/MethodReferenceTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/NameTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/SimpleNameTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/imports/ImportDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithJavadocTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithModifiersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithOptionalScopeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithVariablesTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/observer/PropagatingAstObserverTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/stmt/BlockStmtTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/type/ArrayTypeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/type/TypeConstructionTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_0ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_1ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_3ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_4ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java5ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java6ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java7ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java8ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java9ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/CloneVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/HashCodeVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/ModifierVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/TreeStructureVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/TreeVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/BasicJBehaveTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/CommentParsingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ComparingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ManipulationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ParsingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/PositionRangeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/PrettyPrintingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/TestUtils.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/VisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ComparingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ExistenceOfParentNodeVerifier.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ManipulationSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ParsingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/PositionRangeSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/PrettyPrintingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/SharedSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/VisitorSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/visitors/PositionTestVisitor.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/ClassOrInterfaceDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/CompilationUnitBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/EnumDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/FieldDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithAnnotationsBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithMembersBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithParametersBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithThrownExceptionsBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/javadoc/JavadocExtractorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/javadoc/JavadocTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/javadoc/description/JavadocInlineTagTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/manual/BulkParseTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/metamodel/BaseNodeMetaModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/metamodel/JavaParserMetaModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/metamodel/PropertyMetaModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/modules/ModuleDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelAcceptanceTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/PrettyPrintVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/PrettyPrinterTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/TestVisitor.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/AbstractLexicalPreservingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/DifferenceTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinterTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/TransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/ArrayCreationLevelTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/CompilationUnitTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationMemberDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ClassOrInterfaceDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ConstructorDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumConstantDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/FieldDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/InitializerDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/MethodDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/remove/NodeRemovalTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/CodeGenerationUtilsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/SourceRootTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/UtilsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/ChangingMethodsFromAClassWithAVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/ChangingMethodsFromAClassWithoutAVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/ClassCreator.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/CreatingACompilationUnitFromScratch.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/CuPrinter.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/MethodChanger_1.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/MethodChanger_2.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/MethodPrinter.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/PrintingTheCompilationUnitToSystemOutputTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/TestFileToken.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/VisitingClassMethodsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/removenode/D.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/removenode/ModifierVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/removenode/RemoveDeleteNodeFromAst.java', 'javaparser-testing/src/test/resources/com/github/javaparser/TestFileIso88591.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/ClassInLatin1.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/JavaConcepts.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/package-info.java', 'javaparser-testing/src/test/resources/com/github/javaparser/printer/JavaConcepts_saved.java', 'javaparser-testing/src/test/resources/com/github/javaparser/printer/PrettyPrintVisitor_saved.java', 'javaparser-testing/src/test/resources/com/github/javaparser/utils/Bla.java', 'javaparser-testing/src/test/resources/com/github/javaparser/utils/module-info.java', 'javaparser-testing/src/test/resources/com/github/javaparser/utils/source/root/Y.java', 'javaparser-testing/src/test/resources/com/github/javaparser/wiki_samples/TestFile.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpublic nestedEnum() : void from class com.github.javaparser.ast.validator.Java1_2ValidatorTest to public nestedEnum() : void from class com.github.javaparser.ast.validator.Java5ValidatorTest", "diffLocations": [{"filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java", "startLine": 131, "endLine": 147, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java5ValidatorTest.java", "startLine": 102, "endLine": 118, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void nestedEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }", "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java", "isPureRefactoring": true, "commitId": "da6302311ef508f830434a997a9b61f24750c6a1", "packageNameBefore": "com.github.javaparser.ast.validator", "classNameBefore": "com.github.javaparser.ast.validator.Java1_2ValidatorTest", "methodNameBefore": "com.github.javaparser.ast.validator.Java1_2ValidatorTest#nestedEnum", "classSignatureBefore": "public class Java1_2ValidatorTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.validator.Java1_2ValidatorTest#nestedEnum"], "classNameBeforeSet": ["com.github.javaparser.ast.validator.Java1_2ValidatorTest"], "classSignatureBeforeSet": ["public class Java1_2ValidatorTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class Java1_2ValidatorTest {\n    public static final JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java1_2Validator()));\n\n    private final String allModifiers = \"public protected private abstract static final transient volatile synchronized native strictfp transitive default \";\n\n    @Test\n    public void topClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"class X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"class I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{ void x() {\" + allModifiers + \"class I{}}}\"));\n        assertProblems(result,\n                \"(line 1,col 20) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 20) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 20) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 20) 'transient' is not allowed here.\",\n                \"(line 1,col 20) 'volatile' is not allowed here.\",\n                \"(line 1,col 20) 'default' is not allowed here.\",\n                \"(line 1,col 20) 'synchronized' is not allowed here.\",\n                \"(line 1,col 20) 'native' is not allowed here.\",\n                \"(line 1,col 20) 'transitive' is not allowed here.\",\n                \"(line 1,col 20) 'static' is not allowed here.\",\n                \"(line 1,col 20) 'public' is not allowed here.\",\n                \"(line 1,col 20) 'private' is not allowed here.\",\n                \"(line 1,col 20) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"interface X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"interface I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'abstract' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n    @Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructor() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"X(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'static' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructorParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{X(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 11) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 11) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 11) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 11) 'transient' is not allowed here.\",\n                \"(line 1,col 11) 'volatile' is not allowed here.\",\n                \"(line 1,col 11) 'synchronized' is not allowed here.\",\n                \"(line 1,col 11) 'native' is not allowed here.\",\n                \"(line 1,col 11) 'strictfp' is not allowed here.\",\n                \"(line 1,col 11) 'default' is not allowed here.\",\n                \"(line 1,col 11) 'abstract' is not allowed here.\",\n                \"(line 1,col 11) 'static' is not allowed here.\",\n                \"(line 1,col 11) 'transitive' is not allowed here.\",\n                \"(line 1,col 11) 'private' is not allowed here.\",\n                \"(line 1,col 11) 'public' is not allowed here.\",\n                \"(line 1,col 11) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void classMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void interfaceMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"interface X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 13) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 13) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 13) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 13) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 13) 'transient' is not allowed here.\",\n                \"(line 1,col 13) 'volatile' is not allowed here.\",\n                \"(line 1,col 13) 'default' is not allowed here.\",\n                \"(line 1,col 13) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void methodParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 15) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 15) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 15) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 15) 'transient' is not allowed here.\",\n                \"(line 1,col 15) 'volatile' is not allowed here.\",\n                \"(line 1,col 15) 'synchronized' is not allowed here.\",\n                \"(line 1,col 15) 'native' is not allowed here.\",\n                \"(line 1,col 15) 'strictfp' is not allowed here.\",\n                \"(line 1,col 15) 'abstract' is not allowed here.\",\n                \"(line 1,col 15) 'default' is not allowed here.\",\n                \"(line 1,col 15) 'static' is not allowed here.\",\n                \"(line 1,col 15) 'transitive' is not allowed here.\",\n                \"(line 1,col 15) 'private' is not allowed here.\",\n                \"(line 1,col 15) 'public' is not allowed here.\",\n                \"(line 1,col 15) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void field() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int i;}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localVariable() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){\" + allModifiers + \"int i;}}\"));\n        assertProblems(result,\n                \"(line 1,col 17) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 17) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 17) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 17) 'transient' is not allowed here.\",\n                \"(line 1,col 17) 'volatile' is not allowed here.\",\n                \"(line 1,col 17) 'synchronized' is not allowed here.\",\n                \"(line 1,col 17) 'native' is not allowed here.\",\n                \"(line 1,col 17) 'default' is not allowed here.\",\n                \"(line 1,col 17) 'strictfp' is not allowed here.\",\n                \"(line 1,col 17) 'abstract' is not allowed here.\",\n                \"(line 1,col 17) 'static' is not allowed here.\",\n                \"(line 1,col 17) 'transitive' is not allowed here.\",\n                \"(line 1,col 17) 'private' is not allowed here.\",\n                \"(line 1,col 17) 'public' is not allowed here.\",\n                \"(line 1,col 17) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void catchParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){ try{}catch(\"+ allModifiers +\" Integer x){}}}\"));\n        assertProblems(result,\n                \"(line 1,col 144) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 144) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 144) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 144) 'transient' is not allowed here.\",\n                \"(line 1,col 144) 'volatile' is not allowed here.\",\n                \"(line 1,col 144) 'synchronized' is not allowed here.\",\n                \"(line 1,col 144) 'native' is not allowed here.\",\n                \"(line 1,col 144) 'default' is not allowed here.\",\n                \"(line 1,col 144) 'strictfp' is not allowed here.\",\n                \"(line 1,col 144) 'abstract' is not allowed here.\",\n                \"(line 1,col 144) 'static' is not allowed here.\",\n                \"(line 1,col 144) 'transitive' is not allowed here.\",\n                \"(line 1,col 144) 'private' is not allowed here.\",\n                \"(line 1,col 144) 'public' is not allowed here.\",\n                \"(line 1,col 144) 'protected' is not allowed here.\"\n        );\n    }\n}\n", "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java5ValidatorTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.ast.validator.Java1_1ValidatorTest.allModifiers;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class Java5ValidatorTest {\n    public static final JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java5Validator()));\n\n    @Test\n    public void genericsWithoutDiamond() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X<A>{List<String> b = new ArrayList<>();}\"));\n        assertProblems(result, \"(line 1,col 33) The diamond operator is not supported.\");\n    }\n\n    @Test\n    public void topAnnotationDeclaration() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"@interface X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedAnnotationDeclaration() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"@interface I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void annotationMember() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"@interface X{\" + allModifiers + \"int x();}\"));\n        assertProblems(result,\n                \"(line 1,col 14) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 14) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 14) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 14) 'transient' is not allowed here.\",\n                \"(line 1,col 14) 'volatile' is not allowed here.\",\n                \"(line 1,col 14) 'final' is not allowed here.\",\n                \"(line 1,col 14) 'synchronized' is not allowed here.\",\n                \"(line 1,col 14) 'default' is not allowed here.\",\n                \"(line 1,col 14) 'native' is not allowed here.\",\n                \"(line 1,col 14) 'protected' is not allowed here.\",\n                \"(line 1,col 14) 'private' is not allowed here.\",\n                \"(line 1,col 14) 'strictfp' is not allowed here.\",\n                \"(line 1,col 14) 'static' is not allowed here.\",\n                \"(line 1,col 14) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'abstract' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Test\n    public void nestedEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }", "diffSourceCode": "-  102:                 \"(line 1,col 9) 'default' is not allowed here.\",\n-  103:                 \"(line 1,col 9) 'final' is not allowed here.\",\n-  104:                 \"(line 1,col 9) 'synchronized' is not allowed here.\",\n-  105:                 \"(line 1,col 9) 'native' is not allowed here.\",\n-  106:                 \"(line 1,col 9) 'transitive' is not allowed here.\"\n-  107:         );\n-  108:     }\n-  109: \n-  110:     @Test\n-  111:     public void topEnum() {\n-  112:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n-  113:         assertProblems(result,\n-  114:                 \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n-  115:                 \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n-  116:                 \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n-  117:                 \"(line 1,col 1) 'transient' is not allowed here.\",\n-  118:                 \"(line 1,col 1) 'volatile' is not allowed here.\",\n-  131:     @Test\n-  132:     public void nestedEnum() {\n-  133:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n-  134:         assertProblems(result,\n-  135:                 \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n-  136:                 \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n-  137:                 \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n-  138:                 \"(line 1,col 9) 'transient' is not allowed here.\",\n-  139:                 \"(line 1,col 9) 'volatile' is not allowed here.\",\n-  140:                 \"(line 1,col 9) 'default' is not allowed here.\",\n-  141:                 \"(line 1,col 9) 'abstract' is not allowed here.\",\n-  142:                 \"(line 1,col 9) 'final' is not allowed here.\",\n-  143:                 \"(line 1,col 9) 'synchronized' is not allowed here.\",\n-  144:                 \"(line 1,col 9) 'native' is not allowed here.\",\n-  145:                 \"(line 1,col 9) 'transitive' is not allowed here.\"\n-  146:         );\n-  147:     }\n+  102:     @Test\n+  103:     public void nestedEnum() {\n+  104:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n+  105:         assertProblems(result,\n+  106:                 \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n+  107:                 \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n+  108:                 \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n+  109:                 \"(line 1,col 9) 'transient' is not allowed here.\",\n+  110:                 \"(line 1,col 9) 'volatile' is not allowed here.\",\n+  111:                 \"(line 1,col 9) 'default' is not allowed here.\",\n+  112:                 \"(line 1,col 9) 'abstract' is not allowed here.\",\n+  113:                 \"(line 1,col 9) 'final' is not allowed here.\",\n+  114:                 \"(line 1,col 9) 'synchronized' is not allowed here.\",\n+  115:                 \"(line 1,col 9) 'native' is not allowed here.\",\n+  116:                 \"(line 1,col 9) 'transitive' is not allowed here.\"\n+  117:         );\n+  118:     }\n", "uniqueId": "da6302311ef508f830434a997a9b61f24750c6a1_131_147__102_118", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To refactor the provided code by moving the `nestedEnum` method to an existing Java file, we will choose to move it to the `Java1_2ValidatorTest.java` file, as it is the most relevant context for the method. \n\n### Step 1: Analyze the Code\nThe `nestedEnum` method is a test case that checks for parsing issues related to nested enums in Java. It uses the `javaParser` to parse a string representation of a Java class containing a nested enum and asserts the expected problems.\n\n### Step 2: Move Method Refactoring\nWe will move the `nestedEnum` method to the `Java1_2ValidatorTest` class and update it to be a public static method. The original method will be refactored to call this new static method.\n\n### Target File Path\nThe target file path for the moved method will be:\n```\njavaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java\n```\n\n### Moved Class Code\nThe moved method code will be added to the `Java1_2ValidatorTest` class as follows:\n```java\n@Test\npublic static void nestedEnum() {\n    ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n    assertProblems(result,\n            \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n            \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n            \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n            \"(line 1,col 9) 'transient' is not allowed here.\",\n            \"(line 1,col 9) 'volatile' is not allowed here.\",\n            \"(line 1,col 9) 'default' is not allowed here.\",\n            \"(line 1,col 9) 'abstract' is not allowed here.\",\n            \"(line 1,col 9) 'final' is not allowed here.\",\n            \"(line 1,col 9) 'synchronized' is not allowed here.\",\n            \"(line 1,col 9) 'native' is not allowed here.\",\n            \"(line 1,col 9) 'transitive' is not allowed here.\"\n    );\n}\n```\n\n### Refactored Method Code\nThe original `nestedEnum` method in the `Java1_2ValidatorTest` class will be refactored to call the new static method:\n```java\n@Test\npublic void nestedEnum() {\n    Java1_2ValidatorTest.nestedEnum();\n}\n```\n\n### Final Output\nHere is the final output in the required format:\n\n##########################\njavaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java\n##########################\n@Test\npublic static void nestedEnum() {\n    ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n    assertProblems(result,\n            \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n            \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n            \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n            \"(line 1,col 9) 'transient' is not allowed here.\",\n            \"(line 1,col 9) 'volatile' is not allowed here.\",\n            \"(line 1,col 9) 'default' is not allowed here.\",\n            \"(line 1,col 9) 'abstract' is not allowed here.\",\n            \"(line 1,col 9) 'final' is not allowed here.\",\n            \"(line 1,col 9) 'synchronized' is not allowed here.\",\n            \"(line 1,col 9) 'native' is not allowed here.\",\n            \"(line 1,col 9) 'transitive' is not allowed here.\"\n    );\n}\n##########################\n@Test\npublic void nestedEnum() {\n    Java1_2ValidatorTest.nestedEnum();\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    public void nestedEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\nClass content:\npackage com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class Java1_2ValidatorTest {\n    public static final JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java1_2Validator()));\n\n    private final String allModifiers = \"public protected private abstract static final transient volatile synchronized native strictfp transitive default \";\n\n    @Test\n    public void topClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"class X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"class I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{ void x() {\" + allModifiers + \"class I{}}}\"));\n        assertProblems(result,\n                \"(line 1,col 20) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 20) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 20) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 20) 'transient' is not allowed here.\",\n                \"(line 1,col 20) 'volatile' is not allowed here.\",\n                \"(line 1,col 20) 'default' is not allowed here.\",\n                \"(line 1,col 20) 'synchronized' is not allowed here.\",\n                \"(line 1,col 20) 'native' is not allowed here.\",\n                \"(line 1,col 20) 'transitive' is not allowed here.\",\n                \"(line 1,col 20) 'static' is not allowed here.\",\n                \"(line 1,col 20) 'public' is not allowed here.\",\n                \"(line 1,col 20) 'private' is not allowed here.\",\n                \"(line 1,col 20) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"interface X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"interface I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'abstract' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n    @Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructor() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"X(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'static' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructorParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{X(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 11) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 11) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 11) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 11) 'transient' is not allowed here.\",\n                \"(line 1,col 11) 'volatile' is not allowed here.\",\n                \"(line 1,col 11) 'synchronized' is not allowed here.\",\n                \"(line 1,col 11) 'native' is not allowed here.\",\n                \"(line 1,col 11) 'strictfp' is not allowed here.\",\n                \"(line 1,col 11) 'default' is not allowed here.\",\n                \"(line 1,col 11) 'abstract' is not allowed here.\",\n                \"(line 1,col 11) 'static' is not allowed here.\",\n                \"(line 1,col 11) 'transitive' is not allowed here.\",\n                \"(line 1,col 11) 'private' is not allowed here.\",\n                \"(line 1,col 11) 'public' is not allowed here.\",\n                \"(line 1,col 11) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void classMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void interfaceMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"interface X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 13) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 13) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 13) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 13) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 13) 'transient' is not allowed here.\",\n                \"(line 1,col 13) 'volatile' is not allowed here.\",\n                \"(line 1,col 13) 'default' is not allowed here.\",\n                \"(line 1,col 13) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void methodParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 15) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 15) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 15) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 15) 'transient' is not allowed here.\",\n                \"(line 1,col 15) 'volatile' is not allowed here.\",\n                \"(line 1,col 15) 'synchronized' is not allowed here.\",\n                \"(line 1,col 15) 'native' is not allowed here.\",\n                \"(line 1,col 15) 'strictfp' is not allowed here.\",\n                \"(line 1,col 15) 'abstract' is not allowed here.\",\n                \"(line 1,col 15) 'default' is not allowed here.\",\n                \"(line 1,col 15) 'static' is not allowed here.\",\n                \"(line 1,col 15) 'transitive' is not allowed here.\",\n                \"(line 1,col 15) 'private' is not allowed here.\",\n                \"(line 1,col 15) 'public' is not allowed here.\",\n                \"(line 1,col 15) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void field() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int i;}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localVariable() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){\" + allModifiers + \"int i;}}\"));\n        assertProblems(result,\n                \"(line 1,col 17) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 17) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 17) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 17) 'transient' is not allowed here.\",\n                \"(line 1,col 17) 'volatile' is not allowed here.\",\n                \"(line 1,col 17) 'synchronized' is not allowed here.\",\n                \"(line 1,col 17) 'native' is not allowed here.\",\n                \"(line 1,col 17) 'default' is not allowed here.\",\n                \"(line 1,col 17) 'strictfp' is not allowed here.\",\n                \"(line 1,col 17) 'abstract' is not allowed here.\",\n                \"(line 1,col 17) 'static' is not allowed here.\",\n                \"(line 1,col 17) 'transitive' is not allowed here.\",\n                \"(line 1,col 17) 'private' is not allowed here.\",\n                \"(line 1,col 17) 'public' is not allowed here.\",\n                \"(line 1,col 17) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void catchParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){ try{}catch(\"+ allModifiers +\" Integer x){}}}\"));\n        assertProblems(result,\n                \"(line 1,col 144) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 144) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 144) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 144) 'transient' is not allowed here.\",\n                \"(line 1,col 144) 'volatile' is not allowed here.\",\n                \"(line 1,col 144) 'synchronized' is not allowed here.\",\n                \"(line 1,col 144) 'native' is not allowed here.\",\n                \"(line 1,col 144) 'default' is not allowed here.\",\n                \"(line 1,col 144) 'strictfp' is not allowed here.\",\n                \"(line 1,col 144) 'abstract' is not allowed here.\",\n                \"(line 1,col 144) 'static' is not allowed here.\",\n                \"(line 1,col 144) 'transitive' is not allowed here.\",\n                \"(line 1,col 144) 'private' is not allowed here.\",\n                \"(line 1,col 144) 'public' is not allowed here.\",\n                \"(line 1,col 144) 'protected' is not allowed here.\"\n        );\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['javaparser-testing/src/test/java/com/github/javaparser/CommentsInserterTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/JavaParserTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/JavaTokenTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/JavadocParserTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ProblemTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ProvidersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/RangeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/CompilationUnitTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/DataKeyTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/NodeListTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/NodePositionTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/NodeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/ParseResultTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/body/AnnotationMemberDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/body/MethodDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/comments/CommentTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/InstanceOfExprTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/MethodReferenceTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/NameTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/SimpleNameTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/imports/ImportDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithJavadocTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithModifiersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithOptionalScopeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithVariablesTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/observer/PropagatingAstObserverTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/stmt/BlockStmtTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/type/ArrayTypeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/type/TypeConstructionTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_0ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_1ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_3ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_4ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java5ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java6ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java7ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java8ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java9ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/CloneVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/HashCodeVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/ModifierVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/TreeStructureVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/TreeVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/BasicJBehaveTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/CommentParsingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ComparingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ManipulationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ParsingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/PositionRangeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/PrettyPrintingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/TestUtils.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/VisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ComparingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ExistenceOfParentNodeVerifier.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ManipulationSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ParsingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/PositionRangeSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/PrettyPrintingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/SharedSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/VisitorSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/visitors/PositionTestVisitor.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/ClassOrInterfaceDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/CompilationUnitBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/EnumDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/FieldDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithAnnotationsBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithMembersBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithParametersBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithThrownExceptionsBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/javadoc/JavadocExtractorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/javadoc/JavadocTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/javadoc/description/JavadocInlineTagTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/manual/BulkParseTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/metamodel/BaseNodeMetaModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/metamodel/JavaParserMetaModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/metamodel/PropertyMetaModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/modules/ModuleDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelAcceptanceTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/PrettyPrintVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/PrettyPrinterTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/TestVisitor.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/AbstractLexicalPreservingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/DifferenceTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinterTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/TransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/ArrayCreationLevelTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/CompilationUnitTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationMemberDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ClassOrInterfaceDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ConstructorDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumConstantDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/FieldDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/InitializerDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/MethodDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/remove/NodeRemovalTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/CodeGenerationUtilsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/SourceRootTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/UtilsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/ChangingMethodsFromAClassWithAVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/ChangingMethodsFromAClassWithoutAVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/ClassCreator.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/CreatingACompilationUnitFromScratch.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/CuPrinter.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/MethodChanger_1.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/MethodChanger_2.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/MethodPrinter.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/PrintingTheCompilationUnitToSystemOutputTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/TestFileToken.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/VisitingClassMethodsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/removenode/D.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/removenode/ModifierVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/removenode/RemoveDeleteNodeFromAst.java', 'javaparser-testing/src/test/resources/com/github/javaparser/TestFileIso88591.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/ClassInLatin1.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/JavaConcepts.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/package-info.java', 'javaparser-testing/src/test/resources/com/github/javaparser/printer/JavaConcepts_saved.java', 'javaparser-testing/src/test/resources/com/github/javaparser/printer/PrettyPrintVisitor_saved.java', 'javaparser-testing/src/test/resources/com/github/javaparser/utils/Bla.java', 'javaparser-testing/src/test/resources/com/github/javaparser/utils/module-info.java', 'javaparser-testing/src/test/resources/com/github/javaparser/utils/source/root/Y.java', 'javaparser-testing/src/test/resources/com/github/javaparser/wiki_samples/TestFile.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move And Inline Method", "description": "Move And Inline Method\tpublic solveSymbol(name String) : SymbolReference<? extends ResolvedValueDeclaration> moved from class com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext to class com.github.javaparser.symbolsolver.javaparsermodel.contexts.BlockStmtContext & inlined to public solveSymbol(name String) : SymbolReference<? extends ResolvedValueDeclaration>", "diffLocations": [{"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java", "startLine": 76, "endLine": 98, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java", "startLine": 79, "endLine": 110, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java", "startLine": 156, "endLine": 161, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "", "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java", "isPureRefactoring": true, "commitId": "2903fc918dd87be53192aa1065047392f7adf4d1", "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.contexts", "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext", "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext#solveSymbol", "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.StatementContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nSymbolDeclarator symbolDeclarator=JavaParserFactory.getSymbolDeclarator(wrappedNode,typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=solveWith(symbolDeclarator,name);\nif(symbolReference.isSolved()){return symbolReference;\n}Context parentContext=getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\"));\nNode parentOfWrappedNode=demandParentNode(wrappedNode);\nif(parentOfWrappedNode instanceof MethodDeclaration){return parentContext.solveSymbol(name);\n}if(parentOfWrappedNode instanceof ConstructorDeclaration){return parentContext.solveSymbol(name);\n}if(parentOfWrappedNode instanceof LambdaExpr){return parentContext.solveSymbol(name);\n}if(!(parentOfWrappedNode instanceof NodeWithStatements)){return parentContext.solveSymbol(name);\n}NodeWithStatements<?> nodeWithStmt=(NodeWithStatements<?>)parentOfWrappedNode;\nint position=-1;\nfor(int i=0; i < nodeWithStmt.getStatements().size(); i++){if(nodeWithStmt.getStatements().get(i).equals(wrappedNode)){position=i;\n}}if(position == -1){throw new RuntimeException();\n}for(int i=position - 1; i >= 0; i--){symbolDeclarator=JavaParserFactory.getSymbolDeclarator(nodeWithStmt.getStatements().get(i),typeSolver);\nsymbolReference=solveWith(symbolDeclarator,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}return parentContext.solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractMethodLikeDeclarationContext#solveSymbol\n methodBody: public final SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Parameter parameter: wrappedNode.getParameters()){SymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(parameter,typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=AbstractJavaParserContext.solveWith(sb,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.CatchClauseContext#solveSymbol\n methodBody: public final SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nSymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(wrappedNode.getParameter(),typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=AbstractJavaParserContext.solveWith(sb,name);\nif(symbolReference.isSolved()){return symbolReference;\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.LambdaExprContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Parameter parameter: wrappedNode.getParameters()){SymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(parameter,typeSolver);\nSymbolReference<ResolvedValueDeclaration> symbolReference=solveWith(sb,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.core.resolution.Context#getParent\n methodBody: Optional<Context> getParent();\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AnnotationDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(typeSolver == null)throw new IllegalArgumentException();\nif(this.getDeclaration().hasField(name)){return SymbolReference.solved(this.getDeclaration().getField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.TryWithResourceContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Expression expr: wrappedNode.getResources()){if(expr instanceof VariableDeclarationExpr){for(VariableDeclarator v: ((VariableDeclarationExpr)expr).getVariables()){if(v.getName().getIdentifier().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(v,typeSolver));\n}}}}if(demandParentNode(wrappedNode) instanceof BlockStmt){return StatementContext.solveInBlock(name,typeSolver,wrappedNode);\n}{return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext#getParent\n methodBody: public final Optional<Context> getParent() {\nNode parent=wrappedNode.getParentNode().orElse(null);\nif(parent instanceof MethodCallExpr){MethodCallExpr parentCall=(MethodCallExpr)parent;\nboolean found=false;\nif(parentCall.getArguments() != null){for(Expression expression: parentCall.getArguments()){if(expression == wrappedNode){found=true;\nbreak;\n}}}if(found){Node notMethod=parent;\nwhile(notMethod instanceof MethodCallExpr){notMethod=demandParentNode(notMethod);\n}return Optional.of(JavaParserFactory.getContext(notMethod,typeSolver));\n}}Node notMethod=parent;\nwhile(notMethod instanceof MethodCallExpr || notMethod instanceof FieldAccessExpr){notMethod=notMethod.getParentNode().orElse(null);\n}if(notMethod == null){return Optional.empty();\n}return Optional.of(JavaParserFactory.getContext(notMethod,typeSolver));\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.ForEachStatementContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(wrappedNode.getVariable().getVariables().size() != 1){throw new IllegalStateException();\n}VariableDeclarator variableDeclarator=wrappedNode.getVariable().getVariables().get(0);\nif(variableDeclarator.getName().getId().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(variableDeclarator,typeSolver));\n}{if(demandParentNode(wrappedNode) instanceof BlockStmt){return StatementContext.solveInBlock(name,typeSolver,wrappedNode);\n}{return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}}}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.ClassOrInterfaceDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(typeSolver == null)throw new IllegalArgumentException();\nif(this.getDeclaration().hasVisibleField(name)){return SymbolReference.solved(this.getDeclaration().getVisibleField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(wrappedNode.getName().toString().equals(name)){if(wrappedNode.getScope() instanceof ThisExpr){ResolvedType typeOfThis=JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\nif(typeOfThis.asReferenceType().getTypeDeclaration().isPresent()){return new SymbolSolver(typeSolver).solveSymbolInType(typeOfThis.asReferenceType().getTypeDeclaration().get(),name);\n}}}return JavaParserFactory.getContext(demandParentNode(wrappedNode),typeSolver).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AnonymousClassDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nPreconditions.checkArgument(typeSolver != null);\nif(myDeclaration.hasField(name)){return SymbolReference.solved(myDeclaration.getField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.core.resolution.Context#solveSymbol\n methodBody: default SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nreturn getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.SwitchEntryContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nSwitchStmt switchStmt=(SwitchStmt)demandParentNode(wrappedNode);\nResolvedType type=JavaParserFacade.get(typeSolver).getType(switchStmt.getSelector());\nif(type.isReferenceType() && type.asReferenceType().getTypeDeclaration().isPresent()){ResolvedReferenceTypeDeclaration typeDeclaration=type.asReferenceType().getTypeDeclaration().get();\nif(typeDeclaration.isEnum()){if(type instanceof ReferenceTypeImpl){ReferenceTypeImpl referenceType=(ReferenceTypeImpl)type;\nif(referenceType.getTypeDeclaration().isPresent()){ResolvedReferenceTypeDeclaration typeUsageTypeDeclaration=referenceType.getTypeDeclaration().get();\nif(typeUsageTypeDeclaration.asEnum().hasEnumConstant(name)){return SymbolReference.solved(typeUsageTypeDeclaration.asEnum().getEnumConstant(name));\n}if(typeUsageTypeDeclaration.hasField(name)){return SymbolReference.solved(typeUsageTypeDeclaration.getField(name));\n}}{}}{throw new UnsupportedOperationException();\n}}}for(SwitchEntry seStmt: switchStmt.getEntries()){for(Statement stmt: seStmt.getStatements()){SymbolDeclarator symbolDeclarator=JavaParserFactory.getSymbolDeclarator(stmt,typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=solveWith(symbolDeclarator,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}if(seStmt == wrappedNode){break;\n}}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.EnumDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(typeSolver == null)throw new IllegalArgumentException();\nfor(EnumConstantDeclaration constant: wrappedNode.getEntries()){if(constant.getName().getId().equals(name)){return SymbolReference.solved(new JavaParserEnumConstantDeclaration(constant,typeSolver));\n}}if(this.getDeclaration().hasField(name)){return SymbolReference.solved(this.getDeclaration().getField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.resolution.SymbolSolver#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name, Node node) {\nreturn solveSymbol(name,JavaParserFactory.getContext(node,typeSolver));\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.BlockStmtContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(wrappedNode.getStatements().size() > 0){List<VariableDeclarator> variableDeclarators=new LinkedList<>();\nwrappedNode.getStatements().forEach(stmt -> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\nif(!variableDeclarators.isEmpty()){for(VariableDeclarator vd: variableDeclarators){if(vd.getNameAsString().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd,typeSolver));\n}}}}return super.solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nreturn getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.ForStatementContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Expression expression: wrappedNode.getInitialization()){if(expression instanceof VariableDeclarationExpr){VariableDeclarationExpr variableDeclarationExpr=(VariableDeclarationExpr)expression;\nfor(VariableDeclarator variableDeclarator: variableDeclarationExpr.getVariables()){if(variableDeclarator.getName().getId().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(variableDeclarator,typeSolver));\n}}}if(!(expression instanceof AssignExpr || expression instanceof MethodCallExpr || expression instanceof UnaryExpr)){throw new UnsupportedOperationException(expression.getClass().getCanonicalName());\n}}if(demandParentNode(wrappedNode) instanceof NodeWithStatements){return StatementContext.solveInBlock(name,typeSolver,wrappedNode);\n}{return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}}", "classSignatureBefore": "public class MethodCallExprContext extends AbstractJavaParserContext<MethodCallExpr> ", "methodNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext#solveSymbol"], "classNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext"], "classSignatureBeforeSet": ["public class MethodCallExprContext extends AbstractJavaParserContext<MethodCallExpr> "], "purityCheckResultList": [{"isPure": true, "purityComment": "Tolerable changes in the body\n", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.contexts;\n\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.VariableDeclarationExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.Statement;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n\npublic class BlockStmtContext extends AbstractJavaParserContext<BlockStmt> {\n\n    public BlockStmtContext(BlockStmt wrappedNode, TypeSolver typeSolver) {\n        super(wrappedNode, typeSolver);\n    }\n\n    @Override\n    public List<VariableDeclarator> localVariablesExposedToChild(Node child) {\n        int position = -1;\n        for (int i = 0; i < wrappedNode.getStatements().size(); i++) {\n            if (wrappedNode.getStatements().get(i).equals(child)) {\n                position = i;\n            }\n        }\n        if (position == -1) {\n            throw new RuntimeException();\n        }\n        List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n        for (int i = position - 1; i >= 0; i--) {\n            variableDeclarators.addAll(localVariablesDeclaredIn(wrappedNode.getStatement(i)));\n        }\n        return variableDeclarators;\n    }\n\n    private List<VariableDeclarator> localVariablesDeclaredIn(Statement statement) {\n        if (statement instanceof ExpressionStmt) {\n            ExpressionStmt expressionStmt = (ExpressionStmt)statement;\n            if (expressionStmt.getExpression() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr variableDeclarationExpr = (VariableDeclarationExpr)expressionStmt.getExpression();\n                List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n                variableDeclarators.addAll(variableDeclarationExpr.getVariables());\n                return variableDeclarators;\n            }\n        }\n        return Collections.emptyList();\n    }\n    \n    @Override\n    public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\n        // tries to resolve a declaration from local variables defined in child statements\n        // or from parent node context\n        // for example resolve declaration for the MethodCallExpr a.method() in\n        // A a = this;\n        // { \n        //   a.method(); \n        // }\n        if (wrappedNode.getStatements().size() > 0) {\n            List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n            // find all variable declarators exposed in child\n            wrappedNode.getStatements().forEach(stmt-> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\n            if (!variableDeclarators.isEmpty()) {\n                for (VariableDeclarator vd : variableDeclarators) {\n                    if (vd.getNameAsString().equals(name) ) {\n                        return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd, typeSolver));\n                    }\n                }\n            }\n        }\n        return super.solveSymbol(name);\n    } \n}\n", "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.contexts;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.PatternExpr;\nimport com.github.javaparser.ast.expr.VariableDeclarationExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.Statement;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\n\npublic class BlockStmtContext extends AbstractJavaParserContext<BlockStmt> {\n\n    public BlockStmtContext(BlockStmt wrappedNode, TypeSolver typeSolver) {\n        super(wrappedNode, typeSolver);\n    }\n\n    @Override\n    public List<VariableDeclarator> localVariablesExposedToChild(Node child) {\n        int position = -1;\n        for (int i = 0; i < wrappedNode.getStatements().size(); i++) {\n            if (wrappedNode.getStatements().get(i).equals(child)) {\n                position = i;\n            }\n        }\n        if (position == -1) {\n            throw new RuntimeException();\n        }\n        List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n        for (int i = position - 1; i >= 0; i--) {\n            variableDeclarators.addAll(localVariablesDeclaredIn(wrappedNode.getStatement(i)));\n        }\n        return variableDeclarators;\n    }\n\n    private List<VariableDeclarator> localVariablesDeclaredIn(Statement statement) {\n        if (statement instanceof ExpressionStmt) {\n            ExpressionStmt expressionStmt = (ExpressionStmt) statement;\n            if (expressionStmt.getExpression() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr variableDeclarationExpr = (VariableDeclarationExpr) expressionStmt.getExpression();\n                List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n                variableDeclarators.addAll(variableDeclarationExpr.getVariables());\n                return variableDeclarators;\n            }\n        }\n        return Collections.emptyList();\n    }\n\n    @Override\n    public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\n        Optional<Context> optionalParent = getParent();\n        if (!optionalParent.isPresent()) {\n            return SymbolReference.unsolved(ResolvedValueDeclaration.class);\n        }\n\n        if (wrappedNode.getStatements().size() > 0) {\n            // tries to resolve a declaration from local variables defined in child statements\n            // or from parent node context\n            // for example resolve declaration for the MethodCallExpr a.method() in\n            // A a = this;\n            // {\n            //   a.method();\n            // }\n\n            List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n            // find all variable declarators exposed in child\n            wrappedNode.getStatements().forEach(stmt -> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\n            if (!variableDeclarators.isEmpty()) {\n                // FIXME: Work backwards from the current statement, to only consider declarations prior to this statement.\n                for (VariableDeclarator vd : variableDeclarators) {\n                    if (vd.getNameAsString().equals(name)) {\n                        return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd, typeSolver));\n                    }\n                }\n            }\n        }\n\n        // Otherwise continue as normal...\n        return solveSymbolInParentContext(name);\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": ["methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.StatementContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nSymbolDeclarator symbolDeclarator=JavaParserFactory.getSymbolDeclarator(wrappedNode,typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=solveWith(symbolDeclarator,name);\nif(symbolReference.isSolved()){return symbolReference;\n}Context parentContext=getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\"));\nNode parentOfWrappedNode=demandParentNode(wrappedNode);\nif(parentOfWrappedNode instanceof MethodDeclaration){return parentContext.solveSymbol(name);\n}if(parentOfWrappedNode instanceof ConstructorDeclaration){return parentContext.solveSymbol(name);\n}if(parentOfWrappedNode instanceof LambdaExpr){return parentContext.solveSymbol(name);\n}if(!(parentOfWrappedNode instanceof NodeWithStatements)){return parentContext.solveSymbol(name);\n}NodeWithStatements<?> nodeWithStmt=(NodeWithStatements<?>)parentOfWrappedNode;\nint position=-1;\nfor(int i=0; i < nodeWithStmt.getStatements().size(); i++){if(nodeWithStmt.getStatements().get(i).equals(wrappedNode)){position=i;\n}}if(position == -1){throw new RuntimeException();\n}for(int i=position - 1; i >= 0; i--){symbolDeclarator=JavaParserFactory.getSymbolDeclarator(nodeWithStmt.getStatements().get(i),typeSolver);\nsymbolReference=solveWith(symbolDeclarator,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}return parentContext.solveSymbol(name);\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractMethodLikeDeclarationContext#solveSymbol\n methodBody: public final SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Parameter parameter: wrappedNode.getParameters()){SymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(parameter,typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=AbstractJavaParserContext.solveWith(sb,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.CatchClauseContext#solveSymbol\n methodBody: public final SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nSymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(wrappedNode.getParameter(),typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=AbstractJavaParserContext.solveWith(sb,name);\nif(symbolReference.isSolved()){return symbolReference;\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.LambdaExprContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Parameter parameter: wrappedNode.getParameters()){SymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(parameter,typeSolver);\nSymbolReference<ResolvedValueDeclaration> symbolReference=solveWith(sb,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}", "methodSignature: com.github.javaparser.symbolsolver.core.resolution.Context#getParent\n methodBody: Optional<Context> getParent();", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AnnotationDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(typeSolver == null)throw new IllegalArgumentException();\nif(this.getDeclaration().hasField(name)){return SymbolReference.solved(this.getDeclaration().getField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.TryWithResourceContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Expression expr: wrappedNode.getResources()){if(expr instanceof VariableDeclarationExpr){for(VariableDeclarator v: ((VariableDeclarationExpr)expr).getVariables()){if(v.getName().getIdentifier().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(v,typeSolver));\n}}}}if(demandParentNode(wrappedNode) instanceof BlockStmt){return StatementContext.solveInBlock(name,typeSolver,wrappedNode);\n}{return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext#getParent\n methodBody: public final Optional<Context> getParent() {\nNode parent=wrappedNode.getParentNode().orElse(null);\nif(parent instanceof MethodCallExpr){MethodCallExpr parentCall=(MethodCallExpr)parent;\nboolean found=false;\nif(parentCall.getArguments() != null){for(Expression expression: parentCall.getArguments()){if(expression == wrappedNode){found=true;\nbreak;\n}}}if(found){Node notMethod=parent;\nwhile(notMethod instanceof MethodCallExpr){notMethod=demandParentNode(notMethod);\n}return Optional.of(JavaParserFactory.getContext(notMethod,typeSolver));\n}}Node notMethod=parent;\nwhile(notMethod instanceof MethodCallExpr || notMethod instanceof FieldAccessExpr){notMethod=notMethod.getParentNode().orElse(null);\n}if(notMethod == null){return Optional.empty();\n}return Optional.of(JavaParserFactory.getContext(notMethod,typeSolver));\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.ForEachStatementContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(wrappedNode.getVariable().getVariables().size() != 1){throw new IllegalStateException();\n}VariableDeclarator variableDeclarator=wrappedNode.getVariable().getVariables().get(0);\nif(variableDeclarator.getName().getId().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(variableDeclarator,typeSolver));\n}{if(demandParentNode(wrappedNode) instanceof BlockStmt){return StatementContext.solveInBlock(name,typeSolver,wrappedNode);\n}{return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}}}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.ClassOrInterfaceDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(typeSolver == null)throw new IllegalArgumentException();\nif(this.getDeclaration().hasVisibleField(name)){return SymbolReference.solved(this.getDeclaration().getVisibleField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(wrappedNode.getName().toString().equals(name)){if(wrappedNode.getScope() instanceof ThisExpr){ResolvedType typeOfThis=JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\nif(typeOfThis.asReferenceType().getTypeDeclaration().isPresent()){return new SymbolSolver(typeSolver).solveSymbolInType(typeOfThis.asReferenceType().getTypeDeclaration().get(),name);\n}}}return JavaParserFactory.getContext(demandParentNode(wrappedNode),typeSolver).solveSymbol(name);\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AnonymousClassDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nPreconditions.checkArgument(typeSolver != null);\nif(myDeclaration.hasField(name)){return SymbolReference.solved(myDeclaration.getField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}", "methodSignature: com.github.javaparser.symbolsolver.core.resolution.Context#solveSymbol\n methodBody: default SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nreturn getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.SwitchEntryContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nSwitchStmt switchStmt=(SwitchStmt)demandParentNode(wrappedNode);\nResolvedType type=JavaParserFacade.get(typeSolver).getType(switchStmt.getSelector());\nif(type.isReferenceType() && type.asReferenceType().getTypeDeclaration().isPresent()){ResolvedReferenceTypeDeclaration typeDeclaration=type.asReferenceType().getTypeDeclaration().get();\nif(typeDeclaration.isEnum()){if(type instanceof ReferenceTypeImpl){ReferenceTypeImpl referenceType=(ReferenceTypeImpl)type;\nif(referenceType.getTypeDeclaration().isPresent()){ResolvedReferenceTypeDeclaration typeUsageTypeDeclaration=referenceType.getTypeDeclaration().get();\nif(typeUsageTypeDeclaration.asEnum().hasEnumConstant(name)){return SymbolReference.solved(typeUsageTypeDeclaration.asEnum().getEnumConstant(name));\n}if(typeUsageTypeDeclaration.hasField(name)){return SymbolReference.solved(typeUsageTypeDeclaration.getField(name));\n}}{}}{throw new UnsupportedOperationException();\n}}}for(SwitchEntry seStmt: switchStmt.getEntries()){for(Statement stmt: seStmt.getStatements()){SymbolDeclarator symbolDeclarator=JavaParserFactory.getSymbolDeclarator(stmt,typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=solveWith(symbolDeclarator,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}if(seStmt == wrappedNode){break;\n}}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.EnumDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(typeSolver == null)throw new IllegalArgumentException();\nfor(EnumConstantDeclaration constant: wrappedNode.getEntries()){if(constant.getName().getId().equals(name)){return SymbolReference.solved(new JavaParserEnumConstantDeclaration(constant,typeSolver));\n}}if(this.getDeclaration().hasField(name)){return SymbolReference.solved(this.getDeclaration().getField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}", "methodSignature: com.github.javaparser.symbolsolver.resolution.SymbolSolver#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name, Node node) {\nreturn solveSymbol(name,JavaParserFactory.getContext(node,typeSolver));\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.BlockStmtContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(wrappedNode.getStatements().size() > 0){List<VariableDeclarator> variableDeclarators=new LinkedList<>();\nwrappedNode.getStatements().forEach(stmt -> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\nif(!variableDeclarators.isEmpty()){for(VariableDeclarator vd: variableDeclarators){if(vd.getNameAsString().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd,typeSolver));\n}}}}return super.solveSymbol(name);\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nreturn getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.ForStatementContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Expression expression: wrappedNode.getInitialization()){if(expression instanceof VariableDeclarationExpr){VariableDeclarationExpr variableDeclarationExpr=(VariableDeclarationExpr)expression;\nfor(VariableDeclarator variableDeclarator: variableDeclarationExpr.getVariables()){if(variableDeclarator.getName().getId().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(variableDeclarator,typeSolver));\n}}}if(!(expression instanceof AssignExpr || expression instanceof MethodCallExpr || expression instanceof UnaryExpr)){throw new UnsupportedOperationException(expression.getClass().getCanonicalName());\n}}if(demandParentNode(wrappedNode) instanceof NodeWithStatements){return StatementContext.solveInBlock(name,typeSolver,wrappedNode);\n}{return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}}"], "sourceCodeAfterRefactoring": "@Override\n    public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\n        Optional<Context> optionalParent = getParent();\n        if (!optionalParent.isPresent()) {\n            return SymbolReference.unsolved(ResolvedValueDeclaration.class);\n        }\n\n        if (wrappedNode.getStatements().size() > 0) {\n            // tries to resolve a declaration from local variables defined in child statements\n            // or from parent node context\n            // for example resolve declaration for the MethodCallExpr a.method() in\n            // A a = this;\n            // {\n            //   a.method();\n            // }\n\n            List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n            // find all variable declarators exposed in child\n            wrappedNode.getStatements().forEach(stmt -> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\n            if (!variableDeclarators.isEmpty()) {\n                // FIXME: Work backwards from the current statement, to only consider declarations prior to this statement.\n                for (VariableDeclarator vd : variableDeclarators) {\n                    if (vd.getNameAsString().equals(name)) {\n                        return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd, typeSolver));\n                    }\n                }\n            }\n        }\n\n        // Otherwise continue as normal...\n        return solveSymbolInParentContext(name);\n    }", "diffSourceCode": "-   76:     @Override\n-   77:     public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\n-   78:         // tries to resolve a declaration from local variables defined in child statements\n-   79:         // or from parent node context\n-   80:         // for example resolve declaration for the MethodCallExpr a.method() in\n-   81:         // A a = this;\n-   82:         // { \n-   83:         //   a.method(); \n-   84:         // }\n-   85:         if (wrappedNode.getStatements().size() > 0) {\n-   86:             List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n-   87:             // find all variable declarators exposed in child\n-   88:             wrappedNode.getStatements().forEach(stmt-> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\n-   89:             if (!variableDeclarators.isEmpty()) {\n-   90:                 for (VariableDeclarator vd : variableDeclarators) {\n-   91:                     if (vd.getNameAsString().equals(name) ) {\n-   92:                         return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd, typeSolver));\n-   93:                     }\n-   94:                 }\n-   95:             }\n-   96:         }\n-   97:         return super.solveSymbol(name);\n-   98:     } \n-   99: }\n+   76:         return Collections.emptyList();\n+   77:     }\n+   78: \n+   79:     @Override\n+   80:     public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\n+   81:         Optional<Context> optionalParent = getParent();\n+   82:         if (!optionalParent.isPresent()) {\n+   83:             return SymbolReference.unsolved(ResolvedValueDeclaration.class);\n+   84:         }\n+   85: \n+   86:         if (wrappedNode.getStatements().size() > 0) {\n+   87:             // tries to resolve a declaration from local variables defined in child statements\n+   88:             // or from parent node context\n+   89:             // for example resolve declaration for the MethodCallExpr a.method() in\n+   90:             // A a = this;\n+   91:             // {\n+   92:             //   a.method();\n+   93:             // }\n+   94: \n+   95:             List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n+   96:             // find all variable declarators exposed in child\n+   97:             wrappedNode.getStatements().forEach(stmt -> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\n+   98:             if (!variableDeclarators.isEmpty()) {\n+   99:                 // FIXME: Work backwards from the current statement, to only consider declarations prior to this statement.\n+  100:                 for (VariableDeclarator vd : variableDeclarators) {\n+  101:                     if (vd.getNameAsString().equals(name)) {\n+  102:                         return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd, typeSolver));\n+  103:                     }\n+  104:                 }\n+  105:             }\n+  106:         }\n+  107: \n+  108:         // Otherwise continue as normal...\n+  109:         return solveSymbolInParentContext(name);\n+  110:     }\n", "uniqueId": "2903fc918dd87be53192aa1065047392f7adf4d1_76_98__79_110_156_161", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 8}, "LINE": {"missed": 0, "covered": 3}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "After analyzing the provided code, I will perform the \"Move And Inline Method\" refactoring operation on the `BlockStmtContext` class. The method `localVariablesDeclaredIn` can be inlined into the `localVariablesExposedToChild` method since it is only used there and does not need to be a separate method.\n\nHere is the refactored class code:\n\n```java\njavaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java:\npackage com.github.javaparser.symbolsolver.javaparsermodel.contexts;\n\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.VariableDeclarationExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.Statement;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n\npublic class BlockStmtContext extends AbstractJavaParserContext<BlockStmt> {\n\n    public BlockStmtContext(BlockStmt wrappedNode, TypeSolver typeSolver) {\n        super(wrappedNode, typeSolver);\n    }\n\n    @Override\n    public List<VariableDeclarator> localVariablesExposedToChild(Node child) {\n        int position = -1;\n        for (int i = 0; i < wrappedNode.getStatements().size(); i++) {\n            if (wrappedNode.getStatements().get(i).equals(child)) {\n                position = i;\n            }\n        }\n        if (position == -1) {\n            throw new RuntimeException();\n        }\n        List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n        for (int i = position - 1; i >= 0; i--) {\n            Statement statement = wrappedNode.getStatement(i);\n            if (statement instanceof ExpressionStmt) {\n                ExpressionStmt expressionStmt = (ExpressionStmt) statement;\n                if (expressionStmt.getExpression() instanceof VariableDeclarationExpr) {\n                    VariableDeclarationExpr variableDeclarationExpr = (VariableDeclarationExpr) expressionStmt.getExpression();\n                    variableDeclarators.addAll(variableDeclarationExpr.getVariables());\n                }\n            }\n        }\n        return variableDeclarators;\n    }\n    \n    @Override\n    public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\n        // tries to resolve a declaration from local variables defined in child statements\n        // or from parent node context\n        // for example resolve declaration for the MethodCallExpr a.method() in\n        // A a = this;\n        // { \n        //   a.method(); \n        // }\n        if (wrappedNode.getStatements().size() > 0) {\n            List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n            // find all variable declarators exposed in child\n            wrappedNode.getStatements().forEach(stmt -> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\n            if (!variableDeclarators.isEmpty()) {\n                for (VariableDeclarator vd : variableDeclarators) {\n                    if (vd.getNameAsString().equals(name)) {\n                        return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd, typeSolver));\n                    }\n                }\n            }\n        }\n        return super.solveSymbol(name);\n    } \n}\n```\n\n### Summary of Changes:\n- The `localVariablesDeclaredIn` method has been inlined into the `localVariablesExposedToChild` method. This improves readability by reducing the number of methods and keeping related logic together. The logic for extracting variable declarators from statements is now directly within the loop that processes the statements.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n\n\nClass content:\n/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.contexts;\n\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.VariableDeclarationExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.Statement;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n\npublic class BlockStmtContext extends AbstractJavaParserContext<BlockStmt> {\n\n    public BlockStmtContext(BlockStmt wrappedNode, TypeSolver typeSolver) {\n        super(wrappedNode, typeSolver);\n    }\n\n    @Override\n    public List<VariableDeclarator> localVariablesExposedToChild(Node child) {\n        int position = -1;\n        for (int i = 0; i < wrappedNode.getStatements().size(); i++) {\n            if (wrappedNode.getStatements().get(i).equals(child)) {\n                position = i;\n            }\n        }\n        if (position == -1) {\n            throw new RuntimeException();\n        }\n        List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n        for (int i = position - 1; i >= 0; i--) {\n            variableDeclarators.addAll(localVariablesDeclaredIn(wrappedNode.getStatement(i)));\n        }\n        return variableDeclarators;\n    }\n\n    private List<VariableDeclarator> localVariablesDeclaredIn(Statement statement) {\n        if (statement instanceof ExpressionStmt) {\n            ExpressionStmt expressionStmt = (ExpressionStmt)statement;\n            if (expressionStmt.getExpression() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr variableDeclarationExpr = (VariableDeclarationExpr)expressionStmt.getExpression();\n                List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n                variableDeclarators.addAll(variableDeclarationExpr.getVariables());\n                return variableDeclarators;\n            }\n        }\n        return Collections.emptyList();\n    }\n    \n    @Override\n    public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\n        // tries to resolve a declaration from local variables defined in child statements\n        // or from parent node context\n        // for example resolve declaration for the MethodCallExpr a.method() in\n        // A a = this;\n        // { \n        //   a.method(); \n        // }\n        if (wrappedNode.getStatements().size() > 0) {\n            List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n            // find all variable declarators exposed in child\n            wrappedNode.getStatements().forEach(stmt-> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\n            if (!variableDeclarators.isEmpty()) {\n                for (VariableDeclarator vd : variableDeclarators) {\n                    if (vd.getNameAsString().equals(name) ) {\n                        return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd, typeSolver));\n                    }\n                }\n            }\n        }\n        return super.solveSymbol(name);\n    } \n}\n\nRefactoring Operation:\nMove And Inline Method\n\nProject Structure:\n['javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/JavaSymbolSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/SourceFileInfoExtractor.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/core/resolution/Context.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/core/resolution/MethodUsageResolutionCapability.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/core/resolution/TypeVariableResolutionCapability.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/declarations/common/MethodDeclarationCommonLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparser/Navigator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparser/package-info.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/DefaultVisitorAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFactory.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/LambdaArgumentTypePlaceholder.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractJavaParserContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractMethodLikeDeclarationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AnnotationDeclarationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AnonymousClassDeclarationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BinaryExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/CatchClauseContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ClassOrInterfaceDeclarationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/CompilationUnitContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ConstructorContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ContextHelper.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/EnclosedExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/EnumDeclarationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/FieldAccessContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ForEachStatementContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ForStatementContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/IfStatementContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/InstanceOfExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/JavaParserTypeDeclarationAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodReferenceExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ObjectCreationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/StatementContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/SwitchEntryContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/TryWithResourceContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/UnaryExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/VariableDeclarationExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/VariableDeclaratorContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/AstResolutionUtils.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/DefaultConstructorDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnnotationDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnnotationMemberDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnonymousClassDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserConstructorDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumConstantDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserFieldDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserMethodDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserParameterDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserPatternDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserSymbolDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeParameter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeVariableDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserVariableDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/AbstractSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/FieldSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/NoSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/ParameterSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/PatternSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/VariableSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/package-info.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationMemberDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistConstructorDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumConstantDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistFactory.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistFieldDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistInterfaceDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistParameterDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeParameter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistUtils.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/package-info.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/AbstractClassDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/AbstractTypeDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/ConfilictingGenericTypesException.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/FunctionalInterfaceLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/InferenceContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/InferenceVariableType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/MethodResolutionCapability.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/ObjectProvider.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/resolution/SymbolReference.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/resolution/TypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/resolution/Value.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/typesystem/LazyType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/typesystem/NullType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/typesystem/ReferenceTypeImpl.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/MyObjectProvider.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationMemberDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionConstructorDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionEnumConstantDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionEnumDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionFactory.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionFieldDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionInterfaceDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionMethodDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionMethodResolutionLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionParameterDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionPatternDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionTypeParameter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/comparators/ClassComparator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/comparators/MethodComparator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/comparators/ParameterComparator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/package-info.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/ConstructorResolutionLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/SymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/SymbolSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameCategory.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameRole.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/Bound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ConstraintFormula.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ConstraintFormulaSet.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ControlFlowLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ExpressionHelper.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/InferenceVariable.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/InferenceVariableSubstitution.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/Instantiation.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/InstantiationSet.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/MethodType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ProperLowerBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ProperUpperBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/Substitution.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInference.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInferenceCache.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/CapturesBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/FalseBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/SameAsBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/SubtypeOfBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/ThrowsBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/ExpressionCompatibleWithType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/LambdaThrowsCompatibleWithType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/MethodReferenceThrowsCompatibleWithType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeCompatibleWithType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeContainedByType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeSameAsType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeSubtypeOfType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/AarTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/ClassLoaderTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/CombinedTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/JarTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/JavaParserTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/MemoryTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/ReflectionTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/utils/SymbolSolverCollectionStrategy.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, output the target file path.\n2. If refactoring is performed, output the refactored class code in the following format:\n$target_file_path$:\n$refactored_class_code$:\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate parse(languageLevel ParserConfiguration.LanguageLevel, code String, parseStart ParseStart<PS>) : PS extracted from private parse(code String, parseStart ParseStart<PS>) : PS in class com.github.javaparser.symbolsolver.resolution.ContextTest", "diffLocations": [{"filePath": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/resolution/ContextTest.java", "startLine": 594, "endLine": 604, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/resolution/ContextTest.java", "startLine": 610, "endLine": 612, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/resolution/ContextTest.java", "startLine": 614, "endLine": 624, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\n        ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n        if (!parseResult.isSuccessful()) {\n            parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n        }\n        assertTrue(parseResult.isSuccessful());\n        PS root = parseResult.getResult().get();\n        return root;\n    }", "filePathBefore": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/resolution/ContextTest.java", "isPureRefactoring": true, "commitId": "2903fc918dd87be53192aa1065047392f7adf4d1", "packageNameBefore": "com.github.javaparser.symbolsolver.resolution", "classNameBefore": "com.github.javaparser.symbolsolver.resolution.ContextTest", "methodNameBefore": "com.github.javaparser.symbolsolver.resolution.ContextTest#parse", "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.resolution.ContextTest#parse\n methodBody: private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\nParserConfiguration parserConfiguration=new ParserConfiguration();\nparserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\nParseResult<PS> parseResult=new JavaParser(parserConfiguration).parse(parseStart,new StringProvider(code));\nif(!parseResult.isSuccessful()){parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n}assertTrue(parseResult.isSuccessful());\nPS root=parseResult.getResult().get();\nreturn root;\n}\nmethodSignature: com.github.javaparser.symbolsolver.resolution.naming.AbstractNameLogicTest#parse\n methodBody: protected <N extends Node> N parse(String code, ParseStart<N> parseStart, Optional<TypeSolver> typeSolver) {\nParserConfiguration parserConfiguration=new ParserConfiguration();\nparserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\nif(typeSolver.isPresent()){parserConfiguration.setSymbolResolver(new JavaSymbolSolver(typeSolver.get()));\n}ParseResult<N> parseResult=new JavaParser(parserConfiguration).parse(parseStart,new StringProvider(code));\nif(!parseResult.isSuccessful()){parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n}assertTrue(parseResult.isSuccessful());\nN root=parseResult.getResult().get();\nreturn root;\n}", "classSignatureBefore": "class ContextTest extends AbstractSymbolResolutionTest ", "methodNameBeforeSet": ["com.github.javaparser.symbolsolver.resolution.ContextTest#parse"], "classNameBeforeSet": ["com.github.javaparser.symbolsolver.resolution.ContextTest"], "classSignatureBeforeSet": ["class ContextTest extends AbstractSymbolResolutionTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All the mappings are matched! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.resolution;\n\nimport com.github.javaparser.*;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.ConstructorDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.*;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.AbstractSymbolResolutionTest;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparser.Navigator;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.*;\nimport com.github.javaparser.symbolsolver.utils.LeanParserConfiguration;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Path;\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nclass ContextTest extends AbstractSymbolResolutionTest {\n\n    private TypeSolver typeSolver = new CombinedTypeSolver(new MemoryTypeSolver(), new ReflectionTypeSolver());\n\n    private CompilationUnit parseSample(String sampleName) {\n        InputStream is = ContextTest.class.getClassLoader().getResourceAsStream(sampleName + \".java.txt\");\n        return StaticJavaParser.parse(is);\n    }\n\n    @Test\n    void resolveDeclaredFieldReference() {\n        CompilationUnit cu = parseSample(\"ReferencesToField\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"ReferencesToField\");\n        MethodDeclaration method1 = Navigator.demandMethod(referencesToField, \"method1\");\n        ExpressionStmt stmt = (ExpressionStmt) method1.getBody().get().getStatements().get(0);\n        AssignExpr assignExpr = (AssignExpr) stmt.getExpression();\n\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        SymbolReference symbolReference = symbolSolver.solveSymbol(\"i\", assignExpr.getTarget());\n\n        assertTrue(symbolReference.isSolved());\n        assertEquals(\"i\", symbolReference.getCorrespondingDeclaration().getName());\n        assertTrue(symbolReference.getCorrespondingDeclaration().isField());\n    }\n\n    @Test\n    void resolveInheritedFieldReference() {\n        CompilationUnit cu = parseSample(\"ReferencesToField\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"ReferencesToFieldExtendingClass\");\n        MethodDeclaration method1 = Navigator.demandMethod(referencesToField, \"method2\");\n        ExpressionStmt stmt = (ExpressionStmt) method1.getBody().get().getStatements().get(0);\n        AssignExpr assignExpr = (AssignExpr) stmt.getExpression();\n\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        SymbolReference symbolReference = symbolSolver.solveSymbol(\"i\", assignExpr.getTarget());\n\n        assertTrue(symbolReference.isSolved());\n        assertEquals(\"i\", symbolReference.getCorrespondingDeclaration().getName());\n        assertTrue(symbolReference.getCorrespondingDeclaration().isField());\n    }\n\n    @Test\n    void resolveParameterReference() {\n        CompilationUnit cu = parseSample(\"ReferencesToParameter\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"ReferenceToParameter\");\n        MethodDeclaration method1 = Navigator.demandMethod(referencesToField, \"aMethod\");\n        NameExpr foo = Navigator.findNameExpression(method1, \"foo\").get();\n\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        SymbolReference symbolReference = symbolSolver.solveSymbol(\"foo\", foo);\n\n        assertTrue(symbolReference.isSolved());\n        assertEquals(\"foo\", symbolReference.getCorrespondingDeclaration().getName());\n        assertTrue(symbolReference.getCorrespondingDeclaration().isParameter());\n    }\n\n    @Test\n    void resolveReferenceToImportedType() {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(0);\n\n        ResolvedClassDeclaration compilationUnitDecl = mock(ResolvedClassDeclaration.class);\n        when(compilationUnitDecl.getName()).thenReturn(\"CompilationUnit\");\n        when(compilationUnitDecl.getQualifiedName()).thenReturn(\"com.github.javaparser.ast.CompilationUnit\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"com.github.javaparser.ast.CompilationUnit\")).thenReturn(SymbolReference.solved(compilationUnitDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"CompilationUnit\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"CompilationUnit\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"com.github.javaparser.ast.CompilationUnit\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceUsingQualifiedName() {\n        CompilationUnit cu = parseSample(\"Navigator2\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(0);\n\n        ResolvedClassDeclaration compilationUnitDecl = mock(ResolvedClassDeclaration.class);\n        when(compilationUnitDecl.getName()).thenReturn(\"CompilationUnit\");\n        when(compilationUnitDecl.getQualifiedName()).thenReturn(\"com.github.javaparser.ast.CompilationUnit\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        //when(typeSolver.tryToSolveType(\"java.lang.com.github.javaparser.ast.CompilationUnit\")).thenReturn(SymbolReference.unsolved(ClassDeclaration.class));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"com.github.javaparser.ast.CompilationUnit\")).thenReturn(SymbolReference.solved(compilationUnitDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        \n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"com.github.javaparser.ast.CompilationUnit\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"CompilationUnit\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"com.github.javaparser.ast.CompilationUnit\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToClassesInTheSamePackage() {\n        CompilationUnit cu = parseSample(\"Navigator3\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(0);\n\n        ResolvedClassDeclaration compilationUnitDecl = mock(ResolvedClassDeclaration.class);\n        when(compilationUnitDecl.getName()).thenReturn(\"CompilationUnit\");\n        when(compilationUnitDecl.getQualifiedName()).thenReturn(\"my.packagez.CompilationUnit\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"my.packagez.CompilationUnit\")).thenReturn(SymbolReference.solved(compilationUnitDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"CompilationUnit\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"CompilationUnit\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"my.packagez.CompilationUnit\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToClassInJavaLang() {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(1);\n\n        ResolvedClassDeclaration stringDecl = mock(ResolvedClassDeclaration.class);\n        when(stringDecl.getName()).thenReturn(\"String\");\n        when(stringDecl.getQualifiedName()).thenReturn(\"java.lang.String\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"me.tomassetti.symbolsolver.javaparser.String\")).thenReturn(SymbolReference.unsolved(ResolvedReferenceTypeDeclaration.class));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"java.lang.String\")).thenReturn(SymbolReference.solved(stringDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"String\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"String\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"java.lang.String\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToMethod() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        MethodCallExpr callToGetTypes = Navigator.findMethodCall(method, \"getTypes\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new JarTypeSolver(pathToJar), new ReflectionTypeSolver(true));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        MethodUsage ref = symbolSolver.solveMethod(\"getTypes\", Collections.emptyList(), callToGetTypes);\n\n        assertEquals(\"getTypes\", ref.getName());\n        assertEquals(\"com.github.javaparser.ast.CompilationUnit\", ref.declaringType().getQualifiedName());\n\n        //verify(typeSolver);\n    }\n\n    @Test\n    void resolveCascadeOfReferencesToMethod() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        MethodCallExpr callToStream = Navigator.findMethodCall(method, \"stream\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new JarTypeSolver(pathToJar), new ReflectionTypeSolver(true));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        MethodUsage ref = symbolSolver.solveMethod(\"stream\", Collections.emptyList(), callToStream);\n\n        assertEquals(\"stream\", ref.getName());\n        assertEquals(\"java.util.Collection\", ref.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToMethodCalledOnArrayAccess() {\n        CompilationUnit cu = parseSample(\"ArrayAccess\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"ArrayAccess\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"access\");\n        MethodCallExpr callToTrim = Navigator.findMethodCall(method, \"trim\").get();\n\n        Path src = adaptPath(\"src/test/resources\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JavaParserTypeSolver(src, new LeanParserConfiguration()));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        MethodUsage ref = symbolSolver.solveMethod(\"trim\", Collections.emptyList(), callToTrim);\n\n        assertEquals(\"trim\", ref.getName());\n        assertEquals(\"java.lang.String\", ref.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToJreType() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"foo\");\n        com.github.javaparser.ast.type.Type streamJavaParserType = method.getParameters().get(0).getType();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ResolvedType streamType = JavaParserFacade.get(typeSolver).convert(streamJavaParserType, method);\n\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", streamType.describe());\n    }\n\n    @Test\n    void resolveReferenceToMethodWithLambda() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr methodCallExpr = Navigator.findMethodCall(method, \"filter\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ResolvedType ref = JavaParserFacade.get(typeSolver).getType(methodCallExpr);\n\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", ref.describe());\n        assertEquals(1, ref.asReferenceType().typeParametersValues().size());\n        assertEquals(\"java.lang.String\", ref.asReferenceType().typeParametersValues().get(0).describe());\n    }\n\n    @Test\n    void resolveReferenceToLambdaParamBase() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        NameExpr refToT = Navigator.findNameExpression(method, \"t\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        JavaParserFacade javaParserFacade = JavaParserFacade.get(typeSolver);\n        ResolvedType ref = javaParserFacade.getType(refToT);\n\n        assertEquals(\"? super java.lang.String\", ref.describe());\n    }\n\n    @Test\n    void resolveReferenceToLambdaParamSimplified() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"isEmpty\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        MethodUsage ref = symbolSolver.solveMethod(\"isEmpty\", Collections.emptyList(), call);\n\n        assertEquals(\"isEmpty\", ref.getName());\n        assertEquals(\"java.lang.String\", ref.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"getTypes\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"getTypes\", methodUsage.getName());\n        assertEquals(\"java.util.List<com.github.javaparser.ast.body.TypeDeclaration>\", methodUsage.returnType().describe());\n        assertEquals(1, methodUsage.returnType().asReferenceType().typeParametersValues().size());\n        assertEquals(\"com.github.javaparser.ast.body.TypeDeclaration\", methodUsage.returnType().asReferenceType().typeParametersValues().get(0).describe());\n    }\n\n    @Test\n    void resolveCompoundGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"doubleTyped\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"genericMethodWithDoubleTypedReturnType\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"genericMethodWithDoubleTypedReturnType\", methodUsage.getName());\n        assertEquals(\"java.util.Map<T, V>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveNestedGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"nestedTyped\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"genericMethodWithNestedReturnType\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"genericMethodWithNestedReturnType\", methodUsage.getName());\n        assertEquals(\"java.util.List<java.util.List<T>>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveSimpleGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"simple\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"get\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"get\", methodUsage.getName());\n        assertEquals(\"java.util.List<java.util.List<java.lang.String>>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveGenericReturnTypeFromInputParam() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"input\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"copy\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"copy\", methodUsage.getName());\n        assertEquals(\"javaparser.GenericClass<java.util.List<java.lang.String>>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveComplexGenericReturnType() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"complex\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"complexGenerics\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"complexGenerics\", methodUsage.getName());\n        assertEquals(\"T\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveDoubleNestedClassType() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"nestedTypes\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"asList\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"asList\", methodUsage.getName());\n        assertEquals(\"java.util.List<javaparser.GenericClass.Bar.NestedBar>\", methodUsage.getParamType(0).describe());\n    }\n\n    @Test\n    void resolveTypeUsageOfFirstMethodInGenericClass() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToGetTypes = Navigator.findMethodCall(method, \"getTypes\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage filterUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToGetTypes);\n\n        assertEquals(\"java.util.List<com.github.javaparser.ast.body.TypeDeclaration>\", filterUsage.returnType().describe());\n        assertEquals(1, filterUsage.returnType().asReferenceType().typeParametersValues().size());\n        assertEquals(\"com.github.javaparser.ast.body.TypeDeclaration\", filterUsage.returnType().asReferenceType().typeParametersValues().get(0).describe());\n    }\n\n    @Test\n    void resolveTypeUsageOfMethodInGenericClass() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToStream = Navigator.findMethodCall(method, \"stream\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage filterUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToStream);\n\n        assertEquals(\"java.util.stream.Stream<com.github.javaparser.ast.body.TypeDeclaration>\", filterUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveTypeUsageOfCascadeMethodInGenericClass() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToFilter = Navigator.findMethodCall(method, \"filter\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage filterUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToFilter);\n\n        assertEquals(\"java.util.stream.Stream<com.github.javaparser.ast.body.TypeDeclaration>\", filterUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveLambdaType() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToFilter = Navigator.findMethodCall(method, \"filter\").get();\n        Expression lambdaExpr = callToFilter.getArguments().get(0);\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        ResolvedType typeOfLambdaExpr = JavaParserFacade.get(typeSolver).getType(lambdaExpr);\n\n        assertEquals(\"java.util.function.Predicate<? super com.github.javaparser.ast.body.TypeDeclaration>\", typeOfLambdaExpr.describe());\n    }\n\n    @Test\n    void resolveReferenceToLambdaParam() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToGetName = Navigator.findMethodCall(method, \"getName\").get();\n        Expression referenceToT = callToGetName.getScope().get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        ResolvedType typeOfT = JavaParserFacade.get(typeSolver).getType(referenceToT);\n\n        assertEquals(\"? super com.github.javaparser.ast.body.TypeDeclaration\", typeOfT.describe());\n    }\n\n    @Test\n    void resolveReferenceToCallOnLambdaParam() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToGetName = Navigator.findMethodCall(method, \"getName\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToGetName);\n\n        assertEquals(\"getName\", methodUsage.getName());\n        assertEquals(\"com.github.javaparser.ast.body.TypeDeclaration\", methodUsage.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToOverloadMethodWithNullParam() {\n        CompilationUnit cu = parseSample(\"OverloadedMethods\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"m1\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"overloaded\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.String\", ref.getParamTypes().get(0).describe());\n    }\n\n    @Test\n    void resolveReferenceToOverloadMethodFindStricter() {\n        CompilationUnit cu = parseSample(\"OverloadedMethods\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"m2\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"overloaded\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.String\", ref.getParamTypes().get(0).describe());\n    }\n\n    @Test\n    void resolveReferenceToMethodWithGenericArrayTypeParam() {\n        CompilationUnit cu = parseSample(\"GenericArrayMethodArgument\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericArrayMethodArgument\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"bar\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"foo\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"foo\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.String[]\", ref.getParamType(0).describe());\n    }\n\n    @Test\n    void resolveInheritedMethodFromInterface() {\n        CompilationUnit cu = parseSample(\"InterfaceInheritance\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Test\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"test\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"foobar\").get();\n\n        Path src = adaptPath(\"src/test/resources\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JavaParserTypeSolver(src));\n        ResolvedType type = JavaParserFacade.get(typeSolver).getType(call);\n\n        assertEquals(\"double\", type.describe());\n    }\n\n    @Test\n    void resolveReferenceToOverloadMethodFindOnlyCompatible() {\n        CompilationUnit cu = parseSample(\"OverloadedMethods\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"m3\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"overloaded\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.Object\", ref.getParamTypes().get(0).describe());\n    }\n\n    private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\n        ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n        if (!parseResult.isSuccessful()) {\n            parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n        }\n        assertTrue(parseResult.isSuccessful());\n        PS root = parseResult.getResult().get();\n        return root;\n    }\n\n    @Test\n    void localVariableDeclarationInScope() {\n        String name = \"a\";\n        CompilationUnit cu = parse(\"class A { void foo() {\\n\" +\n                \"SomeClass a; a.aField;\" + \"\\n\" +\n                \"} }\", ParseStart.COMPILATION_UNIT);\n\n        // The block statement expose to the 2nd statement the local var\n        BlockStmt blockStmt = cu.findAll(BlockStmt.class).get(0);\n        Context context1 = JavaParserFactory.getContext(blockStmt, typeSolver);\n        assertEquals(1, context1.localVariablesExposedToChild(blockStmt.getStatement(1)).size());\n\n        Node nameNode = cu.findAll(NameExpr.class).get(0);\n        Context context = JavaParserFactory.getContext(nameNode, typeSolver);\n        assertTrue(context.localVariableDeclarationInScope(name).isPresent());\n    }\n\n    //\n    // Testing JLS 6.3 Scope of a Declaration\n    //\n\n    // The scope of a formal parameter of a method (\u00a78.4.1), constructor (\u00a78.8.1), or lambda expression (\u00a715.27) is the\n    // entire body of the method, constructor, or lambda expression.\n\n    private void assertNoParamsExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfParamsExposedToChildInContextNamed(parent, child, paramName, 0, \"the element is exposed and it should not\");\n    }\n\n    private void assertOneParamExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfParamsExposedToChildInContextNamed(parent, child, paramName, 1, \"the element is not exposed as expected\");\n    }\n\n    private void assertNumberOfParamsExposedToChildInContextNamed(Node parent, Node child, String paramName,\n                                                                  int expectedNumber, String message) {\n        assertEquals(expectedNumber, JavaParserFactory.getContext(parent, typeSolver)\n                .parametersExposedToChild(child).stream().filter(p -> p.getNameAsString().equals(paramName)).count(), message);\n    }\n\n    private void assertNoVarsExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfVarsExposedToChildInContextNamed(parent, child, paramName, 0, \"the element is exposed and it should not\");\n    }\n\n    private void assertOneVarExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfVarsExposedToChildInContextNamed(parent, child, paramName, 1, \"the element is not exposed as expected\");\n    }\n\n    private void assertNumberOfVarsExposedToChildInContextNamed(Node parent, Node child, String paramName,\n                                                                  int expectedNumber, String message) {\n        List<VariableDeclarator> vars = JavaParserFactory.getContext(parent, typeSolver)\n                .localVariablesExposedToChild(child);\n        assertEquals(expectedNumber, vars.stream().filter(p -> p.getNameAsString().equals(paramName)).count(), message);\n    }\n\n    @Test\n    void parametersExposedToChildForMethod() {\n        MethodDeclaration method = parse(\"void foo(int myParam) { aCall(); }\",\n                ParseStart.CLASS_BODY).asMethodDeclaration();\n        assertOneParamExposedToChildInContextNamed(method, method.getBody().get(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(method, method.getType(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(method, method.getParameter(0), \"myParam\");\n    }\n\n    @Test\n    void parametersExposedToChildForConstructor() {\n        ConstructorDeclaration constructor = parse(\"Foo(int myParam) { aCall(); }\",\n                ParseStart.CLASS_BODY).asConstructorDeclaration();\n        assertOneParamExposedToChildInContextNamed(constructor, constructor.getBody(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(constructor, constructor.getParameter(0), \"myParam\");\n    }\n\n    @Test\n    void parametersExposedToChildForLambda() {\n        LambdaExpr lambda = (LambdaExpr)parse(\"Object myLambda = (myParam) -> myParam * 2;\",\n                ParseStart.STATEMENT).asExpressionStmt().getExpression().asVariableDeclarationExpr()\n                .getVariables().get(0).getInitializer().get();\n        assertOneParamExposedToChildInContextNamed(lambda, lambda.getBody(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(lambda, lambda.getParameter(0), \"myParam\");\n    }\n\n    // The scope of a local variable declaration in a block (\u00a714.4) is the rest of the block in which the declaration\n    // appears, starting with its own initializer and including any further declarators to the right in the local\n    // variable declaration statement.\n\n    @Test\n    void localVariablesExposedToChildWithinABlock() {\n        BlockStmt blockStmt = parse(\"{ preStatement(); int a = 1, b = 2; otherStatement(); }\",\n                ParseStart.STATEMENT).asBlockStmt();\n        assertNoVarsExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(0), \"a\");\n        assertNoVarsExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(0), \"b\");\n        assertOneVarExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(2), \"a\");\n        assertOneVarExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(2), \"b\");\n\n        VariableDeclarationExpr varDecl = blockStmt.getStatement(1).asExpressionStmt().getExpression()\n                .asVariableDeclarationExpr();\n        VariableDeclarator varA = varDecl.getVariables().get(0);\n        VariableDeclarator varB = varDecl.getVariables().get(1);\n        assertOneVarExposedToChildInContextNamed(varA,\n                varA.getInitializer().get(), \"a\");\n        assertOneVarExposedToChildInContextNamed(varDecl,\n                varB, \"a\");\n        assertNoVarsExposedToChildInContextNamed(varDecl,\n                varA, \"b\");\n    }\n\n    // The scope of a local variable declared in the ForInit part of a basic for statement (\u00a714.14.1) includes all of the following:\n    // * Its own initializer\n    // * Any further declarators to the right in the ForInit part of the for statement\n    // * The Expression and ForUpdate parts of the for statement\n    // * The contained Statement\n\n    @Test\n    void localVariablesExposedToChildWithinForStmt() {\n        ForStmt forStmt = parse(\"for (int i=0, j=1;i<10;i++) { body(); }\",\n                ParseStart.STATEMENT).asForStmt();\n        VariableDeclarationExpr initializations = forStmt.getInitialization().get(0).asVariableDeclarationExpr();\n        assertOneVarExposedToChildInContextNamed(initializations,\n                initializations.getVariable(1),\n                \"i\");\n        assertOneVarExposedToChildInContextNamed(forStmt,\n                forStmt.getCompare().get(),\n                \"i\");\n        assertOneVarExposedToChildInContextNamed(forStmt,\n                forStmt.getUpdate().get(0),\n                \"i\");\n        assertOneVarExposedToChildInContextNamed(forStmt,\n                forStmt.getBody(),\n                \"i\");\n    }\n\n    // The scope of a local variable declared in the FormalParameter part of an enhanced for statement (\u00a714.14.2) is\n    // the contained Statement.\n\n    @Test\n    void localVariablesExposedToChildWithinEnhancedForeachStmt() {\n        ForEachStmt foreachStmt = parse(\"for (int i: myList) { body(); }\",\n                ParseStart.STATEMENT).asForEachStmt();\n        assertOneVarExposedToChildInContextNamed(foreachStmt, foreachStmt.getBody(), \"i\");\n        assertNoVarsExposedToChildInContextNamed(foreachStmt, foreachStmt.getVariable(), \"i\");\n        assertNoVarsExposedToChildInContextNamed(foreachStmt, foreachStmt.getIterable(), \"i\");\n    }\n\n    // The scope of a parameter of an exception handler that is declared in a catch clause of a try statement (\u00a714.20)\n    // is the entire block associated with the catch.\n\n    @Test\n    void parametersExposedToChildWithinTryStatement() {\n        CatchClause catchClause = parse(\"try {  } catch(Exception e) { body(); }\",\n                ParseStart.STATEMENT).asTryStmt().getCatchClauses().get(0);\n        assertOneParamExposedToChildInContextNamed(catchClause, catchClause.getBody(), \"e\");\n        assertNoParamsExposedToChildInContextNamed(catchClause, catchClause.getParameter(), \"e\");\n    }\n\n    // The scope of a variable declared in the ResourceSpecification of a try-with-resources statement (\u00a714.20.3) is\n    // from the declaration rightward over the remainder of the ResourceSpecification and the entire try block\n    // associated with the try-with-resources statement.\n\n    @Test\n    void localVariablesExposedToChildWithinTryWithResourcesStatement() {\n        TryStmt stmt = parse(\"try (Object res1 = foo(); Object res2 = foo()) { body(); }\",\n                ParseStart.STATEMENT).asTryStmt();\n        assertOneVarExposedToChildInContextNamed(stmt, stmt.getResources().get(1), \"res1\");\n        assertNoVarsExposedToChildInContextNamed(stmt, stmt.getResources().get(0), \"res1\");\n        assertOneVarExposedToChildInContextNamed(stmt, stmt.getTryBlock(), \"res1\");\n    }\n\n}\n", "filePathAfter": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/resolution/ContextTest.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.resolution;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParseStart;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.StringProvider;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.ConstructorDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.*;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.AbstractSymbolResolutionTest;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparser.Navigator;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.JarTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.github.javaparser.symbolsolver.utils.LeanParserConfiguration;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Path;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nclass ContextTest extends AbstractSymbolResolutionTest {\n\n    private final TypeSolver typeSolver = new CombinedTypeSolver(new MemoryTypeSolver(), new ReflectionTypeSolver());\n\n    private CompilationUnit parseSample(String sampleName) {\n        InputStream is = ContextTest.class.getClassLoader().getResourceAsStream(sampleName + \".java.txt\");\n        return StaticJavaParser.parse(is);\n    }\n\n    @Test\n    void resolveDeclaredFieldReference() {\n        CompilationUnit cu = parseSample(\"ReferencesToField\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"ReferencesToField\");\n        MethodDeclaration method1 = Navigator.demandMethod(referencesToField, \"method1\");\n        ExpressionStmt stmt = (ExpressionStmt) method1.getBody().get().getStatements().get(0);\n        AssignExpr assignExpr = (AssignExpr) stmt.getExpression();\n\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        SymbolReference symbolReference = symbolSolver.solveSymbol(\"i\", assignExpr.getTarget());\n\n        assertTrue(symbolReference.isSolved());\n        assertEquals(\"i\", symbolReference.getCorrespondingDeclaration().getName());\n        assertTrue(symbolReference.getCorrespondingDeclaration().isField());\n    }\n\n    @Test\n    void resolveInheritedFieldReference() {\n        CompilationUnit cu = parseSample(\"ReferencesToField\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"ReferencesToFieldExtendingClass\");\n        MethodDeclaration method1 = Navigator.demandMethod(referencesToField, \"method2\");\n        ExpressionStmt stmt = (ExpressionStmt) method1.getBody().get().getStatements().get(0);\n        AssignExpr assignExpr = (AssignExpr) stmt.getExpression();\n\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        SymbolReference symbolReference = symbolSolver.solveSymbol(\"i\", assignExpr.getTarget());\n\n        assertTrue(symbolReference.isSolved());\n        assertEquals(\"i\", symbolReference.getCorrespondingDeclaration().getName());\n        assertTrue(symbolReference.getCorrespondingDeclaration().isField());\n    }\n\n    @Test\n    void resolveParameterReference() {\n        CompilationUnit cu = parseSample(\"ReferencesToParameter\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"ReferenceToParameter\");\n        MethodDeclaration method1 = Navigator.demandMethod(referencesToField, \"aMethod\");\n        NameExpr foo = Navigator.findNameExpression(method1, \"foo\").get();\n\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        SymbolReference symbolReference = symbolSolver.solveSymbol(\"foo\", foo);\n\n        assertTrue(symbolReference.isSolved());\n        assertEquals(\"foo\", symbolReference.getCorrespondingDeclaration().getName());\n        assertTrue(symbolReference.getCorrespondingDeclaration().isParameter());\n    }\n\n    @Test\n    void resolveReferenceToImportedType() {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(0);\n\n        ResolvedClassDeclaration compilationUnitDecl = mock(ResolvedClassDeclaration.class);\n        when(compilationUnitDecl.getName()).thenReturn(\"CompilationUnit\");\n        when(compilationUnitDecl.getQualifiedName()).thenReturn(\"com.github.javaparser.ast.CompilationUnit\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"com.github.javaparser.ast.CompilationUnit\")).thenReturn(SymbolReference.solved(compilationUnitDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"CompilationUnit\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"CompilationUnit\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"com.github.javaparser.ast.CompilationUnit\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceUsingQualifiedName() {\n        CompilationUnit cu = parseSample(\"Navigator2\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(0);\n\n        ResolvedClassDeclaration compilationUnitDecl = mock(ResolvedClassDeclaration.class);\n        when(compilationUnitDecl.getName()).thenReturn(\"CompilationUnit\");\n        when(compilationUnitDecl.getQualifiedName()).thenReturn(\"com.github.javaparser.ast.CompilationUnit\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        //when(typeSolver.tryToSolveType(\"java.lang.com.github.javaparser.ast.CompilationUnit\")).thenReturn(SymbolReference.unsolved(ClassDeclaration.class));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"com.github.javaparser.ast.CompilationUnit\")).thenReturn(SymbolReference.solved(compilationUnitDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"com.github.javaparser.ast.CompilationUnit\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"CompilationUnit\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"com.github.javaparser.ast.CompilationUnit\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToClassesInTheSamePackage() {\n        CompilationUnit cu = parseSample(\"Navigator3\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(0);\n\n        ResolvedClassDeclaration compilationUnitDecl = mock(ResolvedClassDeclaration.class);\n        when(compilationUnitDecl.getName()).thenReturn(\"CompilationUnit\");\n        when(compilationUnitDecl.getQualifiedName()).thenReturn(\"my.packagez.CompilationUnit\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"my.packagez.CompilationUnit\")).thenReturn(SymbolReference.solved(compilationUnitDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"CompilationUnit\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"CompilationUnit\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"my.packagez.CompilationUnit\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToClassInJavaLang() {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(1);\n\n        ResolvedClassDeclaration stringDecl = mock(ResolvedClassDeclaration.class);\n        when(stringDecl.getName()).thenReturn(\"String\");\n        when(stringDecl.getQualifiedName()).thenReturn(\"java.lang.String\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"me.tomassetti.symbolsolver.javaparser.String\")).thenReturn(SymbolReference.unsolved(ResolvedReferenceTypeDeclaration.class));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"java.lang.String\")).thenReturn(SymbolReference.solved(stringDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"String\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"String\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"java.lang.String\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToMethod() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        MethodCallExpr callToGetTypes = Navigator.findMethodCall(method, \"getTypes\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new JarTypeSolver(pathToJar), new ReflectionTypeSolver(true));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        MethodUsage ref = symbolSolver.solveMethod(\"getTypes\", Collections.emptyList(), callToGetTypes);\n\n        assertEquals(\"getTypes\", ref.getName());\n        assertEquals(\"com.github.javaparser.ast.CompilationUnit\", ref.declaringType().getQualifiedName());\n\n        //verify(typeSolver);\n    }\n\n    @Test\n    void resolveCascadeOfReferencesToMethod() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        MethodCallExpr callToStream = Navigator.findMethodCall(method, \"stream\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new JarTypeSolver(pathToJar), new ReflectionTypeSolver(true));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        MethodUsage ref = symbolSolver.solveMethod(\"stream\", Collections.emptyList(), callToStream);\n\n        assertEquals(\"stream\", ref.getName());\n        assertEquals(\"java.util.Collection\", ref.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToMethodCalledOnArrayAccess() {\n        CompilationUnit cu = parseSample(\"ArrayAccess\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"ArrayAccess\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"access\");\n        MethodCallExpr callToTrim = Navigator.findMethodCall(method, \"trim\").get();\n\n        Path src = adaptPath(\"src/test/resources\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JavaParserTypeSolver(src, new LeanParserConfiguration()));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        MethodUsage ref = symbolSolver.solveMethod(\"trim\", Collections.emptyList(), callToTrim);\n\n        assertEquals(\"trim\", ref.getName());\n        assertEquals(\"java.lang.String\", ref.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToJreType() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"foo\");\n        com.github.javaparser.ast.type.Type streamJavaParserType = method.getParameters().get(0).getType();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ResolvedType streamType = JavaParserFacade.get(typeSolver).convert(streamJavaParserType, method);\n\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", streamType.describe());\n    }\n\n    @Test\n    void resolveReferenceToMethodWithLambda() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr methodCallExpr = Navigator.findMethodCall(method, \"filter\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ResolvedType ref = JavaParserFacade.get(typeSolver).getType(methodCallExpr);\n\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", ref.describe());\n        assertEquals(1, ref.asReferenceType().typeParametersValues().size());\n        assertEquals(\"java.lang.String\", ref.asReferenceType().typeParametersValues().get(0).describe());\n    }\n\n    @Test\n    void resolveReferenceToLambdaParamBase() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        NameExpr refToT = Navigator.findNameExpression(method, \"t\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        JavaParserFacade javaParserFacade = JavaParserFacade.get(typeSolver);\n        ResolvedType ref = javaParserFacade.getType(refToT);\n\n        assertEquals(\"? super java.lang.String\", ref.describe());\n    }\n\n    @Test\n    void resolveReferenceToLambdaParamSimplified() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"isEmpty\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        MethodUsage ref = symbolSolver.solveMethod(\"isEmpty\", Collections.emptyList(), call);\n\n        assertEquals(\"isEmpty\", ref.getName());\n        assertEquals(\"java.lang.String\", ref.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"getTypes\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"getTypes\", methodUsage.getName());\n        assertEquals(\"java.util.List<com.github.javaparser.ast.body.TypeDeclaration>\", methodUsage.returnType().describe());\n        assertEquals(1, methodUsage.returnType().asReferenceType().typeParametersValues().size());\n        assertEquals(\"com.github.javaparser.ast.body.TypeDeclaration\", methodUsage.returnType().asReferenceType().typeParametersValues().get(0).describe());\n    }\n\n    @Test\n    void resolveCompoundGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"doubleTyped\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"genericMethodWithDoubleTypedReturnType\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"genericMethodWithDoubleTypedReturnType\", methodUsage.getName());\n        assertEquals(\"java.util.Map<T, V>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveNestedGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"nestedTyped\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"genericMethodWithNestedReturnType\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"genericMethodWithNestedReturnType\", methodUsage.getName());\n        assertEquals(\"java.util.List<java.util.List<T>>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveSimpleGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"simple\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"get\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"get\", methodUsage.getName());\n        assertEquals(\"java.util.List<java.util.List<java.lang.String>>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveGenericReturnTypeFromInputParam() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"input\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"copy\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"copy\", methodUsage.getName());\n        assertEquals(\"javaparser.GenericClass<java.util.List<java.lang.String>>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveComplexGenericReturnType() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"complex\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"complexGenerics\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"complexGenerics\", methodUsage.getName());\n        assertEquals(\"T\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveDoubleNestedClassType() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"nestedTypes\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"asList\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"asList\", methodUsage.getName());\n        assertEquals(\"java.util.List<javaparser.GenericClass.Bar.NestedBar>\", methodUsage.getParamType(0).describe());\n    }\n\n    @Test\n    void resolveTypeUsageOfFirstMethodInGenericClass() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToGetTypes = Navigator.findMethodCall(method, \"getTypes\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage filterUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToGetTypes);\n\n        assertEquals(\"java.util.List<com.github.javaparser.ast.body.TypeDeclaration>\", filterUsage.returnType().describe());\n        assertEquals(1, filterUsage.returnType().asReferenceType().typeParametersValues().size());\n        assertEquals(\"com.github.javaparser.ast.body.TypeDeclaration\", filterUsage.returnType().asReferenceType().typeParametersValues().get(0).describe());\n    }\n\n    @Test\n    void resolveTypeUsageOfMethodInGenericClass() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToStream = Navigator.findMethodCall(method, \"stream\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage filterUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToStream);\n\n        assertEquals(\"java.util.stream.Stream<com.github.javaparser.ast.body.TypeDeclaration>\", filterUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveTypeUsageOfCascadeMethodInGenericClass() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToFilter = Navigator.findMethodCall(method, \"filter\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage filterUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToFilter);\n\n        assertEquals(\"java.util.stream.Stream<com.github.javaparser.ast.body.TypeDeclaration>\", filterUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveLambdaType() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToFilter = Navigator.findMethodCall(method, \"filter\").get();\n        Expression lambdaExpr = callToFilter.getArguments().get(0);\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        ResolvedType typeOfLambdaExpr = JavaParserFacade.get(typeSolver).getType(lambdaExpr);\n\n        assertEquals(\"java.util.function.Predicate<? super com.github.javaparser.ast.body.TypeDeclaration>\", typeOfLambdaExpr.describe());\n    }\n\n    @Test\n    void resolveReferenceToLambdaParam() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToGetName = Navigator.findMethodCall(method, \"getName\").get();\n        Expression referenceToT = callToGetName.getScope().get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        ResolvedType typeOfT = JavaParserFacade.get(typeSolver).getType(referenceToT);\n\n        assertEquals(\"? super com.github.javaparser.ast.body.TypeDeclaration\", typeOfT.describe());\n    }\n\n    @Test\n    void resolveReferenceToCallOnLambdaParam() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToGetName = Navigator.findMethodCall(method, \"getName\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToGetName);\n\n        assertEquals(\"getName\", methodUsage.getName());\n        assertEquals(\"com.github.javaparser.ast.body.TypeDeclaration\", methodUsage.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToOverloadMethodWithNullParam() {\n        CompilationUnit cu = parseSample(\"OverloadedMethods\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"m1\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"overloaded\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.String\", ref.getParamTypes().get(0).describe());\n    }\n\n    @Test\n    void resolveReferenceToOverloadMethodFindStricter() {\n        CompilationUnit cu = parseSample(\"OverloadedMethods\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"m2\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"overloaded\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.String\", ref.getParamTypes().get(0).describe());\n    }\n\n    @Test\n    void resolveReferenceToMethodWithGenericArrayTypeParam() {\n        CompilationUnit cu = parseSample(\"GenericArrayMethodArgument\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericArrayMethodArgument\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"bar\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"foo\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"foo\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.String[]\", ref.getParamType(0).describe());\n    }\n\n    @Test\n    void resolveInheritedMethodFromInterface() {\n        CompilationUnit cu = parseSample(\"InterfaceInheritance\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Test\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"test\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"foobar\").get();\n\n        Path src = adaptPath(\"src/test/resources\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JavaParserTypeSolver(src));\n        ResolvedType type = JavaParserFacade.get(typeSolver).getType(call);\n\n        assertEquals(\"double\", type.describe());\n    }\n\n    @Test\n    void resolveReferenceToOverloadMethodFindOnlyCompatible() {\n        CompilationUnit cu = parseSample(\"OverloadedMethods\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"m3\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"overloaded\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.Object\", ref.getParamTypes().get(0).describe());\n    }\n\n    private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\n        return parse(ParserConfiguration.LanguageLevel.JAVA_10, code, parseStart);\n    }\n\n    private <PS extends Node> PS parse(ParserConfiguration.LanguageLevel languageLevel, String code, ParseStart<PS> parseStart) {\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setLanguageLevel(languageLevel);\n        ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n        if (!parseResult.isSuccessful()) {\n            parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n        }\n        assertTrue(parseResult.isSuccessful());\n        PS root = parseResult.getResult().get();\n        return root;\n    }\n\n    @Test\n    void localVariableDeclarationInScope() {\n        String name = \"a\";\n        CompilationUnit cu = parse(\"class A { void foo() {\\n\" +\n                \"SomeClass a; a.aField;\" + \"\\n\" +\n                \"} }\", ParseStart.COMPILATION_UNIT);\n\n        // The block statement expose to the 2nd statement the local var\n        BlockStmt blockStmt = cu.findAll(BlockStmt.class).get(0);\n        Context context1 = JavaParserFactory.getContext(blockStmt, typeSolver);\n        assertEquals(1, context1.localVariablesExposedToChild(blockStmt.getStatement(1)).size());\n\n        Node nameNode = cu.findAll(NameExpr.class).get(0);\n        Context context = JavaParserFactory.getContext(nameNode, typeSolver);\n        assertTrue(context.localVariableDeclarationInScope(name).isPresent());\n    }\n\n    //\n    // Testing JLS 6.3 Scope of a Declaration\n    //\n\n    // The scope of a formal parameter of a method (\u00a78.4.1), constructor (\u00a78.8.1), or lambda expression (\u00a715.27) is the\n    // entire body of the method, constructor, or lambda expression.\n\n    private void assertNoParamsExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfParamsExposedToChildInContextNamed(parent, child, paramName, 0, \"the element is exposed and it should not\");\n    }\n\n    private void assertOneParamExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfParamsExposedToChildInContextNamed(parent, child, paramName, 1, \"the element is not exposed as expected\");\n    }\n\n    private void assertNumberOfParamsExposedToChildInContextNamed(Node parent, Node child, String paramName,\n                                                                  int expectedNumber, String message) {\n        assertEquals(expectedNumber, JavaParserFactory.getContext(parent, typeSolver)\n                .parametersExposedToChild(child).stream().filter(p -> p.getNameAsString().equals(paramName)).count(), \"[\" + paramName + \"]: \" + message);\n    }\n\n    private void assertNoVarsExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfVarsExposedToChildInContextNamed(parent, child, paramName, 0, \"the element is exposed and it should not\");\n    }\n\n    private void assertOneVarExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfVarsExposedToChildInContextNamed(parent, child, paramName, 1, \"the element is not exposed as expected\");\n    }\n\n    private void assertNumberOfVarsExposedToChildInContextNamed(Node parent, Node child, String paramName,\n                                                                  int expectedNumber, String message) {\n        List<VariableDeclarator> vars = JavaParserFactory.getContext(parent, typeSolver)\n                .localVariablesExposedToChild(child);\n        assertEquals(expectedNumber, vars.stream().filter(p -> p.getNameAsString().equals(paramName)).count(), \"[\" + paramName + \"]: \" + message);\n    }\n\n    private void assertNoPatternExprsExposedToImmediateParentInContextNamed(Node parent, String patternExprName, String message) {\n        assertNumberOfPatternExprsExposedToImmediateParentInContextNamed(parent, patternExprName, 0, message);\n    }\n    private void assertOnePatternExprsExposedToImmediateParentInContextNamed(Node parent, String patternExprName, String message) {\n        assertNumberOfPatternExprsExposedToImmediateParentInContextNamed(parent, patternExprName, 1, message);\n    }\n    private void assertNumberOfPatternExprsExposedToImmediateParentInContextNamed(Node parent, String patternExprName,\n                                                                  int expectedNumber, String message) {\n        List<PatternExpr> vars = JavaParserFactory.getContext(parent, typeSolver)\n                .patternExprsExposedFromChildren();\n        assertEquals(expectedNumber, vars.stream().filter(p -> p.getNameAsString().equals(patternExprName)).count(), \"[\" + patternExprName + \"]: \" + message);\n    }\n\n    private void assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(Node parent, String patternExprName, String message) {\n        assertNumberOfNegatedPatternExprsExposedToImmediateParentInContextNamed(parent, patternExprName, 0, message);\n    }\n    private void assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(Node parent, String patternExprName, String message) {\n        assertNumberOfNegatedPatternExprsExposedToImmediateParentInContextNamed(parent, patternExprName, 1, message);\n    }\n    private void assertNumberOfNegatedPatternExprsExposedToImmediateParentInContextNamed(Node parent, String patternExprName,\n                                                                  int expectedNumber, String message) {\n        List<PatternExpr> vars = JavaParserFactory.getContext(parent, typeSolver)\n                .negatedPatternExprsExposedFromChildren();\n        assertEquals(expectedNumber, vars.stream().filter(p -> p.getNameAsString().equals(patternExprName)).count(), \"[\" + patternExprName + \"]: \" + message);\n    }\n\n    @Test\n    void parametersExposedToChildForMethod() {\n        MethodDeclaration method = parse(\"void foo(int myParam) { aCall(); }\",\n                ParseStart.CLASS_BODY).asMethodDeclaration();\n        assertOneParamExposedToChildInContextNamed(method, method.getBody().get(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(method, method.getType(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(method, method.getParameter(0), \"myParam\");\n    }\n\n    @Test\n    void parametersExposedToChildForConstructor() {\n        ConstructorDeclaration constructor = parse(\"Foo(int myParam) { aCall(); }\",\n                ParseStart.CLASS_BODY).asConstructorDeclaration();\n        assertOneParamExposedToChildInContextNamed(constructor, constructor.getBody(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(constructor, constructor.getParameter(0), \"myParam\");\n    }\n\n    @Test\n    void parametersExposedToChildForLambda() {\n        LambdaExpr lambda = (LambdaExpr) parse(\"Object myLambda = (myParam) -> myParam * 2;\",\n                ParseStart.STATEMENT).asExpressionStmt().getExpression().asVariableDeclarationExpr()\n                .getVariables().get(0).getInitializer().get();\n        assertOneParamExposedToChildInContextNamed(lambda, lambda.getBody(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(lambda, lambda.getParameter(0), \"myParam\");\n    }\n\n    // The scope of a local variable declaration in a block (\u00a714.4) is the rest of the block in which the declaration\n    // appears, starting with its own initializer and including any further declarators to the right in the local\n    // variable declaration statement.\n\n    @Test\n    void localVariablesExposedToChildWithinABlock() {\n        BlockStmt blockStmt = parse(\"{ preStatement(); int a = 1, b = 2; otherStatement(); }\",\n                ParseStart.STATEMENT).asBlockStmt();\n        assertNoVarsExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(0), \"a\");\n        assertNoVarsExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(0), \"b\");\n        assertOneVarExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(2), \"a\");\n        assertOneVarExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(2), \"b\");\n\n        VariableDeclarationExpr varDecl = blockStmt.getStatement(1).asExpressionStmt().getExpression()\n                .asVariableDeclarationExpr();\n        VariableDeclarator varA = varDecl.getVariables().get(0);\n        VariableDeclarator varB = varDecl.getVariables().get(1);\n        assertOneVarExposedToChildInContextNamed(varA,\n                varA.getInitializer().get(), \"a\");\n        assertOneVarExposedToChildInContextNamed(varDecl,\n                varB, \"a\");\n        assertNoVarsExposedToChildInContextNamed(varDecl,\n                varA, \"b\");\n    }\n\n    // The scope of a local variable declared in the ForInit part of a basic for statement (\u00a714.14.1) includes all of the following:\n    // * Its own initializer\n    // * Any further declarators to the right in the ForInit part of the for statement\n    // * The Expression and ForUpdate parts of the for statement\n    // * The contained Statement\n\n    @Test\n    void localVariablesExposedToChildWithinForStmt() {\n        ForStmt forStmt = parse(\"for (int i=0, j=1;i<10;i++) { body(); }\",\n                ParseStart.STATEMENT).asForStmt();\n        VariableDeclarationExpr initializations = forStmt.getInitialization().get(0).asVariableDeclarationExpr();\n        assertOneVarExposedToChildInContextNamed(initializations,\n                initializations.getVariable(1),\n                \"i\");\n        assertOneVarExposedToChildInContextNamed(forStmt,\n                forStmt.getCompare().get(),\n                \"i\");\n        assertOneVarExposedToChildInContextNamed(forStmt,\n                forStmt.getUpdate().get(0),\n                \"i\");\n        assertOneVarExposedToChildInContextNamed(forStmt,\n                forStmt.getBody(),\n                \"i\");\n    }\n\n    // The scope of a local variable declared in the FormalParameter part of an enhanced for statement (\u00a714.14.2) is\n    // the contained Statement.\n\n    @Test\n    void localVariablesExposedToChildWithinEnhancedForeachStmt() {\n        ForEachStmt foreachStmt = parse(\"for (int i: myList) { body(); }\",\n                ParseStart.STATEMENT).asForEachStmt();\n        assertOneVarExposedToChildInContextNamed(foreachStmt, foreachStmt.getBody(), \"i\");\n        assertNoVarsExposedToChildInContextNamed(foreachStmt, foreachStmt.getVariable(), \"i\");\n        assertNoVarsExposedToChildInContextNamed(foreachStmt, foreachStmt.getIterable(), \"i\");\n    }\n\n    // The scope of a parameter of an exception handler that is declared in a catch clause of a try statement (\u00a714.20)\n    // is the entire block associated with the catch.\n\n    @Test\n    void parametersExposedToChildWithinTryStatement() {\n        CatchClause catchClause = parse(\"try {  } catch(Exception e) { body(); }\",\n                ParseStart.STATEMENT).asTryStmt().getCatchClauses().get(0);\n        assertOneParamExposedToChildInContextNamed(catchClause, catchClause.getBody(), \"e\");\n        assertNoParamsExposedToChildInContextNamed(catchClause, catchClause.getParameter(), \"e\");\n    }\n\n    // The scope of a variable declared in the ResourceSpecification of a try-with-resources statement (\u00a714.20.3) is\n    // from the declaration rightward over the remainder of the ResourceSpecification and the entire try block\n    // associated with the try-with-resources statement.\n\n    @Test\n    void localVariablesExposedToChildWithinTryWithResourcesStatement() {\n        TryStmt stmt = parse(\"try (Object res1 = foo(); Object res2 = foo()) { body(); }\",\n                ParseStart.STATEMENT).asTryStmt();\n        assertOneVarExposedToChildInContextNamed(stmt, stmt.getResources().get(1), \"res1\");\n        assertNoVarsExposedToChildInContextNamed(stmt, stmt.getResources().get(0), \"res1\");\n        assertOneVarExposedToChildInContextNamed(stmt, stmt.getTryBlock(), \"res1\");\n    }\n\n    @Nested\n    class PatternExprTests {\n        @Test\n        void instanceOfPatternExpr0() {\n            InstanceOfExpr instanceOfExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String\", ParseStart.EXPRESSION).asInstanceOfExpr();\n            String message = \"No Pattern Expr must be available from this expression.\";\n            assertNoPatternExprsExposedToImmediateParentInContextNamed(instanceOfExpr, \"\", message);\n            assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(instanceOfExpr, \"s\", message);\n        }\n\n        @Test\n        void instanceOfPatternExpr1() {\n            String message = \"Only s must be available from this expression.\";\n            InstanceOfExpr instanceOfExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s\", ParseStart.EXPRESSION).asInstanceOfExpr();\n            assertOnePatternExprsExposedToImmediateParentInContextNamed(instanceOfExpr, \"s\", message);\n            assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(instanceOfExpr, \"s\", message);\n        }\n\n        @Test\n        void instanceOfPatternExpr2() {\n            String message = \"Only s must be available from this enclosed expression.\";\n            EnclosedExpr enclosedExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"(a instanceof String s)\", ParseStart.EXPRESSION).asEnclosedExpr();\n            assertOnePatternExprsExposedToImmediateParentInContextNamed(enclosedExpr, \"s\", message);\n            assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(enclosedExpr, \"s\", message);\n        }\n\n        @Test\n        void instanceOfPatternExpr3() {\n            String message = \"Only s must be available from this multiple-enclosed expression.\";\n            EnclosedExpr enclosedExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"(((a instanceof String s)))\", ParseStart.EXPRESSION).asEnclosedExpr();\n            assertOnePatternExprsExposedToImmediateParentInContextNamed(enclosedExpr, \"s\", message);\n            assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(enclosedExpr, \"s\", message);\n        }\n\n\n        @Nested\n        class PatternExprNegationTests {\n            @Test\n            void instanceOfPatternExpr4() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!(a instanceof String s)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n                assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExpr5() {\n                String message = \"Only s must be available from this double-negated expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!!(a instanceof String s)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", \"Double negative means that it is true - it should be available.\");\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExpr6() {\n                String message = \"Only s (NEGATED) must be available from this triple-negated expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!!!(a instanceof String s)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n                assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExpr7() {\n                String message = \"Only s must be available from this quadruple-negated expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!!!!(a instanceof String s)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message + \" -- \" + \"Double negative means that it is true - it should be available.\");\n            }\n        }\n\n\n        @Nested\n        class PatternExprBinaryExprTests {\n\n            @Test\n            void instanceOfPatternExprBinaryExpr1() {\n                String message = \"Only s must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s == true\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr2() {\n                String message = \"Only s must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"true == a instanceof String s\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr3() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s == false\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n                assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr4() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"false == a instanceof String s\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n                assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr5() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s != true\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr5_negated() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s != true\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr5b() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                EnclosedExpr enclosedExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"(a instanceof String s != true)\", ParseStart.EXPRESSION).asEnclosedExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(enclosedExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr5b_negated() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                EnclosedExpr enclosedExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"(a instanceof String s != true)\", ParseStart.EXPRESSION).asEnclosedExpr();\n                assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(enclosedExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr6() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s != false\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr6_negated() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s != false\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr7() {\n                String message = \"Only s (NEGATED) must be available from this double-negated expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!(a instanceof String s != true)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr7_negated() {\n                String message = \"Only s must be available from this double-negated expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!(a instanceof String s != true)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr8() {\n                String message = \"Only s must be available from this double-negated expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!(a instanceof String s != false)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr8_negated() {\n                String message = \"Only s must be available from this double-negated expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!(a instanceof String s != false)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr9() {\n                String message = \"Must be no patterns available from this || expression (neither is guaranteed to be true).\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"(a instanceof String s) || a instanceof String s2\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n        }\n\n\n        @Nested\n        class PatternExprVariableDeclarationTests {\n\n            @Test\n            void instanceOfPatternExprVariableDeclaration_variableDeclaration() {\n                ExpressionStmt expressionStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"boolean x = a instanceof String s == true;\", ParseStart.STATEMENT).asExpressionStmt();\n\n                String message = \"No pattern must be available outside of this variable declaration expression (note that the declaration expr contains many declarators).\";\n                VariableDeclarationExpr variableDeclarationExpr = expressionStmt.getExpression().asVariableDeclarationExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprVariableDeclaration_variableDeclarator() {\n                ExpressionStmt expressionStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"boolean x = a instanceof String s == true;\", ParseStart.STATEMENT).asExpressionStmt();\n\n                String message = \"No pattern must be available outside of this variable declaration expression (note that the declaration expr contains many declarators).\";\n                VariableDeclarationExpr variableDeclarationExpr = expressionStmt.getExpression().asVariableDeclarationExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n\n                NodeList<VariableDeclarator> variables = variableDeclarationExpr.getVariables();\n                assertEquals(1, variables.size(), \"Expected 1 variable -- issue with test configuration/sample?\");\n\n\n                message = \"No pattern must be available outside of this variable declarator (x).\";\n                VariableDeclarator variableDeclaratorX = variables.get(0);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclaratorX, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclaratorX, \"s\", message);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclaratorX, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclaratorX, \"s2\", message);\n\n            }\n\n            @Test\n            void instanceOfPatternExprVariableDeclaration_variableDeclaratorStatements1() {\n                String x = \"\" +\n                        \"{\\n\" +\n                        \"    boolean x = a instanceof String s;\\n\" +\n                        \"    boolean result = s.contains(\\\"b\\\");\\n\" +\n                        \"}\\n\" +\n                        \"\";\n                BlockStmt blockStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.BLOCK).asBlockStmt();\n\n                NodeList<Statement> statements = blockStmt.getStatements();\n                assertEquals(2, statements.size(), \"Expected 2 statements -- issue with test configuration/sample?\");\n\n                String message = \"No pattern must be available outside of this statement.\";\n                Statement xStatement = statements.get(0);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(xStatement, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(xStatement, \"s\", message);\n\n                Statement resultStatement = statements.get(1);\n                Expression expression = resultStatement.asExpressionStmt().getExpression();\n                VariableDeclarationExpr variableDeclarationExpr = expression.asVariableDeclarationExpr();\n\n                Context context = JavaParserFactory.getContext(variableDeclarationExpr, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> s = context.solveSymbol(\"s\");\n                assertFalse(s.isSolved(), \"s is not available -- it is not definitively true when in a separate statement.\");\n\n            }\n\n            @Test\n            void instanceOfPatternExprVariableDeclaration_variableDeclaratorStatements2() {\n                String x = \"\" +\n                        \"{\\n\" +\n                        \"    boolean x = (a instanceof String s);\\n\" +\n                        \"    boolean y = !(a instanceof String s);\\n\" +\n                        \"    boolean result = s.contains(\\\"b\\\");\\n\" +\n                        \"}\\n\" +\n                        \"\";\n                BlockStmt blockStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.BLOCK).asBlockStmt();\n\n                NodeList<Statement> statements = blockStmt.getStatements();\n                assertEquals(3, statements.size(), \"Expected 3 statements -- issue with test configuration/sample?\");\n\n                String message;\n                message = \"No pattern must be available outside of this statement (x)\";\n                Statement xStatement = statements.get(0);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(xStatement, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(xStatement, \"s\", message);\n\n                message = \"No pattern must be available outside of this statement (y)\";\n                Statement yStatement = statements.get(1);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(yStatement, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(yStatement, \"s\", message);\n\n                Statement resultStatement = statements.get(2);\n                Expression expression = resultStatement.asExpressionStmt().getExpression();\n                VariableDeclarationExpr variableDeclarationExpr = expression.asVariableDeclarationExpr();\n\n                Context context = JavaParserFactory.getContext(variableDeclarationExpr, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> s = context.solveSymbol(\"s\");\n                assertFalse(s.isSolved(), \"s is not available -- it is not definitively true when in a separate statement.\");\n            }\n\n            @Test\n            void instanceOfPatternExprVariableDeclaration_variableDeclaratorStatements3() {\n                String x = \"\" +\n                        \"{\\n\" +\n                        \"    boolean x = !(a instanceof String s);\\n\" +\n                        \"    boolean result = s.contains(\\\"b\\\");\\n\" +\n                        \"}\\n\" +\n                        \"\";\n                BlockStmt blockStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.BLOCK).asBlockStmt();\n\n                NodeList<Statement> statements = blockStmt.getStatements();\n                assertEquals(2, statements.size(), \"Expected 2 statements -- issue with test configuration/sample?\");\n\n                String message = \"No pattern must be available outside of this statement (x)\";\n                Statement xStatement = statements.get(0);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(xStatement, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(xStatement, \"s\", message);\n\n                Statement resultStatement = statements.get(1);\n                Expression expression = resultStatement.asExpressionStmt().getExpression();\n                VariableDeclarationExpr variableDeclarationExpr = expression.asVariableDeclarationExpr();\n\n                Context context = JavaParserFactory.getContext(variableDeclarationExpr, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> s = context.solveSymbol(\"s\");\n                assertFalse(s.isSolved(), \"s is not available -- it is not definitively true when in a separate statement.\");\n\n            }\n\n        }\n\n\n        @Nested\n        class PatternExprScopeTests {\n\n            @Test\n            void instanceOfPatternExprResolution_expr1() {\n                ExpressionStmt expressionStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"boolean x = a instanceof String s && a instanceof String s2;\", ParseStart.STATEMENT).asExpressionStmt();\n\n                String message = \"No pattern must be available outside of this variable declaration expression (note that the declaration expr contains many declarators).\";\n                VariableDeclarationExpr variableDeclarationExpr = expressionStmt.getExpression().asVariableDeclarationExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s2\", message);\n\n\n                NodeList<VariableDeclarator> variables = variableDeclarationExpr.getVariables();\n                assertEquals(1, variables.size(), \"Expected 1 variable -- issue with test configuration/sample?\");\n\n                BinaryExpr binaryExpr = variables.get(0).getInitializer().get().asBinaryExpr();\n\n                message = \"Only s must be available from this declarator (left).\";\n                Expression leftBranch = binaryExpr.getLeft();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s\", message);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s2\", message);\n\n                message = \"Only s2 must be available from this declarator (right).\";\n                Expression rightBranch = binaryExpr.getRight();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s\", message);\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s2\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprResolution_expr2() {\n                ExpressionStmt expressionStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"boolean x = !(a instanceof String s) && a instanceof String s2;\", ParseStart.STATEMENT).asExpressionStmt();\n\n                String message = \"No pattern must be available outside of this variable declaration expression (note that the declaration expr contains many declarators).\";\n                VariableDeclarationExpr variableDeclarationExpr = expressionStmt.getExpression().asVariableDeclarationExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s2\", message);\n\n                // TODO: Assert pattern available from the binaryexpr\n            }\n\n            @Test\n            void instanceOfPatternExprResolution_expr3() {\n                ExpressionStmt expressionStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"boolean x = \\\"\\\" instanceof String s || \\\"\\\" instanceof String s2;\", ParseStart.STATEMENT).asExpressionStmt();\n\n//                String message = \"Both s and s2 must be available from this declaration expression (AND).\";\n                String message = \"No pattern must be available outside of this statement.\";\n                VariableDeclarationExpr variableDeclarationExpr = expressionStmt.getExpression().asVariableDeclarationExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s2\", message);\n\n                // TODO: Assert pattern available from the binaryexpr\n            }\n\n            @Test\n            void instanceOfPatternExprResolution_expr_AND1() {\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s && s instanceof String s2\", ParseStart.EXPRESSION).asBinaryExpr();\n\n                String message;\n\n                message = \"Only s must be available from this declarator (left).\";\n                Expression leftBranch = binaryExpr.getLeft();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s\", message);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s2\", message);\n\n                message = \"s and s2 must be available from this declarator (right).\";\n                Expression rightBranch = binaryExpr.getRight();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s\", message);\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s2\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprResolution_expr_AND_solving1() {\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s && s instanceof String s2\", ParseStart.EXPRESSION).asBinaryExpr();\n\n                String message;\n\n                message = \"Only s must be available on the LEFT branch of an AND.\";\n                Expression leftBranch = binaryExpr.getLeft();\n                Context leftBranchContext = JavaParserFactory.getContext(leftBranch, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> left_s = leftBranchContext.solveSymbol(\"s\");\n                assertTrue(left_s.isSolved());\n                Optional<PatternExpr> optionalPatternExpr = leftBranchContext.patternExprInScope(\"s\");\n                SymbolReference<? extends ResolvedValueDeclaration> left_s2 = leftBranchContext.solveSymbol(\"s2\");\n                assertFalse(left_s2.isSolved());\n\n\n                message = \"s and s2 must be available on the RIGHT branch of an AND.\";\n                Expression rightBranch = binaryExpr.getRight();\n                Context rightBranchContext = JavaParserFactory.getContext(rightBranch, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> right_s = rightBranchContext.solveSymbol(\"s\");\n                assertTrue(right_s.isSolved());\n                SymbolReference<? extends ResolvedValueDeclaration> right_s2 = rightBranchContext.solveSymbol(\"s2\");\n                assertTrue(right_s2.isSolved());\n            }\n\n            @Test\n            void instanceOfPatternExprResolution_expr_OR1() {\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s || s instanceof String s2\", ParseStart.EXPRESSION).asBinaryExpr();\n\n                String message;\n\n                message = \"Only s must be available from this declarator (left).\";\n                Expression leftBranch = binaryExpr.getLeft();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s\", message);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s2\", message);\n\n                message = \"Only s2 must be available from this declarator (right).\";\n                Expression rightBranch = binaryExpr.getRight();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s\", message);\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s2\", message);\n            }\n\n\n            @Test\n            void instanceOfPatternExprResolution1() {\n                CompilationUnit compilationUnit = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"class X { void x() { boolean foo = ((a instanceof String s) && s.length() > 0); } }\", ParseStart.COMPILATION_UNIT);\n\n                List<EnclosedExpr> enclosedExprs = compilationUnit.findAll(EnclosedExpr.class);\n                assertEquals(2, enclosedExprs.size());\n\n                EnclosedExpr enclosedExpr = enclosedExprs.get(0);\n\n                List<NameExpr> nameExprs = enclosedExpr.findAll(NameExpr.class);\n                assertEquals(2, nameExprs.size());\n\n                NameExpr nameExpr = nameExprs.get(1);\n                assertEquals(\"s\", nameExpr.getNameAsString());\n\n                Context context = JavaParserFactory.getContext(nameExpr, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> symbolReference = context.solveSymbol(\"s\");\n                System.out.println(\"symbolReference = \" + symbolReference);\n\n                assertTrue(symbolReference.isSolved(), \"symbol not solved\");\n                ResolvedDeclaration correspondingDeclaration = symbolReference.getCorrespondingDeclaration();\n                assertEquals(\"s\", correspondingDeclaration.getName(), \"unexpected name for the solved symbol\");\n                assertTrue(correspondingDeclaration.isPattern());\n                assertEquals(\"s\", correspondingDeclaration.asPattern().getName(), \"unexpected name for the solved pattern\");\n                assertEquals(\"java.lang.String\", correspondingDeclaration.asPattern().getType().asReferenceType().getQualifiedName(), \"unexpected type for the solved pattern\");\n\n            }\n\n            @Test\n            void instanceOfPatternExprResolution1_negated() {\n                CompilationUnit compilationUnit = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"class X { void x() { boolean foo = (!(a instanceof String s) && s.length() > 0); } }\", ParseStart.COMPILATION_UNIT);\n\n                List<EnclosedExpr> enclosedExprs = compilationUnit.findAll(EnclosedExpr.class);\n                assertEquals(2, enclosedExprs.size());\n\n                EnclosedExpr enclosedExpr = enclosedExprs.get(0);\n\n                List<NameExpr> nameExprs = enclosedExpr.findAll(NameExpr.class);\n                assertEquals(2, nameExprs.size());\n\n                NameExpr nameExpr = nameExprs.get(1);\n                assertEquals(\"s\", nameExpr.getNameAsString());\n\n                Context context = JavaParserFactory.getContext(nameExpr, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> symbolReference = context.solveSymbol(\"s\");\n                System.out.println(\"symbolReference = \" + symbolReference);\n\n                assertFalse(symbolReference.isSolved(), \"symbol supposed to be not solved\");\n            }\n\n            @Test\n            void instanceOfPatternExprResolution2() {\n                CompilationUnit compilationUnit = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"class X { void x() { boolean foo = ((a instanceof String s) || s.length() > 0); } }\", ParseStart.COMPILATION_UNIT);\n\n                List<EnclosedExpr> enclosedExprs = compilationUnit.findAll(EnclosedExpr.class);\n                assertEquals(2, enclosedExprs.size());\n\n                EnclosedExpr enclosedExpr = enclosedExprs.get(0);\n\n                List<NameExpr> nameExprs = enclosedExpr.findAll(NameExpr.class);\n                assertEquals(2, nameExprs.size());\n\n                NameExpr nameExpr = nameExprs.get(1);\n                assertEquals(\"s\", nameExpr.getNameAsString());\n\n                Context context = JavaParserFactory.getContext(nameExpr, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> symbolReference = context.solveSymbol(\"s\");\n                System.out.println(\"symbolReference = \" + symbolReference);\n\n                assertFalse(symbolReference.isSolved(), \"symbol supposed to be not solved\");\n            }\n\n            @Nested\n            class IfElse {\n\n\n                @Test\n                void instanceOfPattern_ifBlock1() {\n                    String x = \"\" +\n                            \"if (a instanceof String s) {\\n\" +\n                            \"    result = s.contains(\\\"in scope\\\");\\n\" +\n                            \"}\\n\" +\n                            \"\";\n                    IfStmt ifStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.STATEMENT).asIfStmt();\n\n                    List<MethodCallExpr> methodCallExprs = ifStmt.findAll(MethodCallExpr.class);\n                    System.out.println(\"methodCallExprs = \" + methodCallExprs);\n                    assertEquals(1, methodCallExprs.size());\n\n                    MethodCallExpr methodCallExpr = methodCallExprs.get(0);\n                    Context context = JavaParserFactory.getContext(methodCallExpr, typeSolver);\n\n                    SymbolReference<? extends ResolvedValueDeclaration> s = context.solveSymbol(\"s\");\n                    assertTrue(s.isSolved());\n                    assertTrue(s.getCorrespondingDeclaration().isPattern());\n                }\n\n                @Test\n                void instanceOfPattern_ifBlock1_noBraces() {\n                    String x = \"\" +\n                            \"if (a instanceof String s) \\n\" +\n                            \"    result = s.contains(\\\"in scope\\\");\\n\" +\n                            \"\\n\" +\n                            \"\";\n                    IfStmt ifStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.STATEMENT).asIfStmt();\n\n                    List<MethodCallExpr> methodCallExprs = ifStmt.findAll(MethodCallExpr.class);\n                    System.out.println(\"methodCallExprs = \" + methodCallExprs);\n                    assertEquals(1, methodCallExprs.size());\n\n                    MethodCallExpr methodCallExpr = methodCallExprs.get(0);\n                    Context context = JavaParserFactory.getContext(methodCallExpr, typeSolver);\n\n                    SymbolReference<? extends ResolvedValueDeclaration> s = context.solveSymbol(\"s\");\n                    assertTrue(s.isSolved());\n                    assertTrue(s.getCorrespondingDeclaration().isPattern());\n                }\n\n                @Test\n                void instanceOfPattern_ifBlock1_negatedCondition() {\n                    String x = \"\" +\n                            \"if (!(a instanceof String s)) {\\n\" +\n                            \"    result = s.contains(\\\"NOT in scope\\\");\\n\" +\n                            \"}\\n\" +\n                            \"\";\n                    IfStmt ifStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.STATEMENT).asIfStmt();\n\n                    List<MethodCallExpr> methodCallExprs = ifStmt.findAll(MethodCallExpr.class);\n                    System.out.println(\"methodCallExprs = \" + methodCallExprs);\n                    assertEquals(1, methodCallExprs.size());\n\n                    MethodCallExpr methodCallExpr = methodCallExprs.get(0);\n                    Context context = JavaParserFactory.getContext(methodCallExpr, typeSolver);\n\n                    SymbolReference<? extends ResolvedValueDeclaration> s = context.solveSymbol(\"s\");\n                    assertFalse(s.isSolved());\n                }\n\n                @Test\n                void instanceOfPattern_ifBlock1_noBraces_negatedCondition() {\n                    String x = \"\" +\n                            \"if (!(a instanceof String s)) \\n\" +\n                            \"    result = s.contains(\\\"NOT in scope\\\");\\n\" +\n                            \"\\n\" +\n                            \"\";\n                    IfStmt ifStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.STATEMENT).asIfStmt();\n\n                    List<MethodCallExpr> methodCallExprs = ifStmt.findAll(MethodCallExpr.class);\n                    System.out.println(\"methodCallExprs = \" + methodCallExprs);\n                    assertEquals(1, methodCallExprs.size());\n\n                    MethodCallExpr methodCallExpr = methodCallExprs.get(0);\n                    Context context = JavaParserFactory.getContext(methodCallExpr, typeSolver);\n\n                    SymbolReference<? extends ResolvedValueDeclaration> s = context.solveSymbol(\"s\");\n                    assertFalse(s.isSolved());\n                }\n\n                @Test\n                void instanceOfPattern_ifElseBlock1() {\n                    String x = \"\" +\n                            \"{\\n\" +\n                            \"    List s;\\n\" +\n                            \"    if (!(a instanceof String s)) {\\n\" +\n                            \"        result = s.contains(\\\"in scope\\\");\\n\" +\n                            \"    } else if (true) {\\n\" +\n                            \"        result = s.contains(\\\"in scope\\\");\\n\" +\n                            \"    }\\n\" +\n                            \"}\\n\" +\n                            \"\";\n                    BlockStmt blockStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.BLOCK).asBlockStmt();\n\n                    List<MethodCallExpr> methodCallExprs = blockStmt.findAll(MethodCallExpr.class);\n                    System.out.println(\"methodCallExprs = \" + methodCallExprs);\n                    assertEquals(2, methodCallExprs.size());\n\n                    // The first one should resolve to the standard variable (the list)\n                    MethodCallExpr methodCallExpr_list = methodCallExprs.get(0);\n                    Context context_list = JavaParserFactory.getContext(methodCallExpr_list, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_list = context_list.solveSymbol(\"s\");\n                    assertTrue(s_list.isSolved());\n                    assertFalse(s_list.getCorrespondingDeclaration().isPattern());\n//                    assertTrue(s_list.getCorrespondingDeclaration().isVariable()); // Should pass but seemingly not implemented/overridden, perhaps?\n\n                    // The second one should resolve to the pattern variable (the string).\n                    MethodCallExpr methodCallExpr_string = methodCallExprs.get(1);\n                    Context context_string = JavaParserFactory.getContext(methodCallExpr_string, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_string = context_string.solveSymbol(\"s\");\n                    assertTrue(s_string.isSolved());\n                    assertTrue(s_string.getCorrespondingDeclaration().isPattern());\n                }\n\n                @Test\n                void instanceOfPattern_ifElseBlock2() {\n                    String x = \"\" +\n                            \"{\\n\" +\n                            \"    List s;\\n\" +\n                            \"    if (!(a instanceof String s)) {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    } else if (true) {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    } else if (true) {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    } else {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    }\\n\" +\n                            \"}\\n\" +\n                            \"\";\n                    BlockStmt blockStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.BLOCK).asBlockStmt();\n\n                    List<MethodCallExpr> methodCallExprs = blockStmt.findAll(MethodCallExpr.class);\n                    System.out.println(\"methodCallExprs = \" + methodCallExprs);\n                    assertEquals(4, methodCallExprs.size());\n\n                    // The first one should resolve to the standard variable (the list)\n                    MethodCallExpr methodCallExpr_list = methodCallExprs.get(0);\n                    Context context_list = JavaParserFactory.getContext(methodCallExpr_list, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_list = context_list.solveSymbol(\"s\");\n                    assertTrue(s_list.isSolved());\n                    assertFalse(s_list.getCorrespondingDeclaration().isPattern());\n//                    assertTrue(s_list.getCorrespondingDeclaration().isVariable()); // Should pass but seemingly not implemented/overridden, perhaps?\n\n                    // The second one should resolve to the pattern variable (the string).\n                    MethodCallExpr methodCallExpr_string = methodCallExprs.get(1);\n                    Context context_string = JavaParserFactory.getContext(methodCallExpr_string, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_string = context_string.solveSymbol(\"s\");\n                    assertTrue(s_string.isSolved());\n                    assertTrue(s_string.getCorrespondingDeclaration().isPattern());\n\n                    // The third one should resolve to the pattern variable (the string).\n                    MethodCallExpr methodCallExpr_string2 = methodCallExprs.get(2);\n                    Context context_string2 = JavaParserFactory.getContext(methodCallExpr_string2, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_string2 = context_string2.solveSymbol(\"s\");\n                    assertTrue(s_string2.isSolved());\n                    assertTrue(s_string2.getCorrespondingDeclaration().isPattern());\n\n                    // The fourth one should resolve to the pattern variable (the string).\n                    MethodCallExpr methodCallExpr_string3 = methodCallExprs.get(2);\n                    Context context_string3 = JavaParserFactory.getContext(methodCallExpr_string3, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_string3 = context_string3.solveSymbol(\"s\");\n                    assertTrue(s_string3.isSolved());\n                    assertTrue(s_string3.getCorrespondingDeclaration().isPattern());\n                }\n\n                @Test\n                void instanceOfPattern_ifElseBlock3() {\n                    String x = \"\" +\n                            \"{\\n\" +\n                            \"    List s;\\n\" +\n                            \"    if (false) {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    } else if (!(a instanceof String s)) {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    } else if (true) {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    } else {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    }\\n\" +\n                            \"}\\n\" +\n                            \"\";\n                    BlockStmt blockStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.BLOCK).asBlockStmt();\n\n                    List<MethodCallExpr> methodCallExprs = blockStmt.findAll(MethodCallExpr.class);\n                    System.out.println(\"methodCallExprs = \" + methodCallExprs);\n                    assertEquals(4, methodCallExprs.size());\n\n                    // The first one should resolve to the standard variable (the list)\n                    MethodCallExpr methodCallExpr_list = methodCallExprs.get(0);\n                    Context context_list = JavaParserFactory.getContext(methodCallExpr_list, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_list = context_list.solveSymbol(\"s\");\n                    assertTrue(s_list.isSolved());\n                    assertFalse(s_list.getCorrespondingDeclaration().isPattern());\n\n                    // The second one should resolve to the standard variable (the list).\n                    MethodCallExpr methodCallExpr_string = methodCallExprs.get(1);\n                    Context context_string = JavaParserFactory.getContext(methodCallExpr_string, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_string = context_string.solveSymbol(\"s\");\n                    assertTrue(s_string.isSolved());\n                    assertFalse(s_string.getCorrespondingDeclaration().isPattern());\n\n                    // The third one should resolve to the pattern variable (the string).\n                    MethodCallExpr methodCallExpr_string2 = methodCallExprs.get(2);\n                    Context context_string2 = JavaParserFactory.getContext(methodCallExpr_string2, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_string2 = context_string2.solveSymbol(\"s\");\n                    assertTrue(s_string2.isSolved());\n                    assertTrue(s_string2.getCorrespondingDeclaration().isPattern());\n\n                    // The fourth one should resolve to the pattern variable (the string).\n                    MethodCallExpr methodCallExpr_string3 = methodCallExprs.get(2);\n                    Context context_string3 = JavaParserFactory.getContext(methodCallExpr_string3, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_string3 = context_string3.solveSymbol(\"s\");\n                    assertTrue(s_string3.isSolved());\n                    assertTrue(s_string3.getCorrespondingDeclaration().isPattern());\n                }\n            }\n        }\n\n    }\n\n}\n", "diffSourceCodeSet": ["private <PS extends Node> PS parse(ParserConfiguration.LanguageLevel languageLevel, String code, ParseStart<PS> parseStart) {\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setLanguageLevel(languageLevel);\n        ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n        if (!parseResult.isSuccessful()) {\n            parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n        }\n        assertTrue(parseResult.isSuccessful());\n        PS root = parseResult.getResult().get();\n        return root;\n    }"], "invokedMethodSet": ["methodSignature: com.github.javaparser.symbolsolver.resolution.ContextTest#parse\n methodBody: private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\nParserConfiguration parserConfiguration=new ParserConfiguration();\nparserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\nParseResult<PS> parseResult=new JavaParser(parserConfiguration).parse(parseStart,new StringProvider(code));\nif(!parseResult.isSuccessful()){parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n}assertTrue(parseResult.isSuccessful());\nPS root=parseResult.getResult().get();\nreturn root;\n}", "methodSignature: com.github.javaparser.symbolsolver.resolution.naming.AbstractNameLogicTest#parse\n methodBody: protected <N extends Node> N parse(String code, ParseStart<N> parseStart, Optional<TypeSolver> typeSolver) {\nParserConfiguration parserConfiguration=new ParserConfiguration();\nparserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\nif(typeSolver.isPresent()){parserConfiguration.setSymbolResolver(new JavaSymbolSolver(typeSolver.get()));\n}ParseResult<N> parseResult=new JavaParser(parserConfiguration).parse(parseStart,new StringProvider(code));\nif(!parseResult.isSuccessful()){parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n}assertTrue(parseResult.isSuccessful());\nN root=parseResult.getResult().get();\nreturn root;\n}"], "sourceCodeAfterRefactoring": "private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\n        return parse(ParserConfiguration.LanguageLevel.JAVA_10, code, parseStart);\n    }\nprivate <PS extends Node> PS parse(ParserConfiguration.LanguageLevel languageLevel, String code, ParseStart<PS> parseStart) {\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setLanguageLevel(languageLevel);\n        ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n        if (!parseResult.isSuccessful()) {\n            parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n        }\n        assertTrue(parseResult.isSuccessful());\n        PS root = parseResult.getResult().get();\n        return root;\n    }", "diffSourceCode": "-  594:     private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\n-  595:         ParserConfiguration parserConfiguration = new ParserConfiguration();\n-  596:         parserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\n-  597:         ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n-  598:         if (!parseResult.isSuccessful()) {\n-  599:             parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n-  600:         }\n-  601:         assertTrue(parseResult.isSuccessful());\n-  602:         PS root = parseResult.getResult().get();\n-  603:         return root;\n-  604:     }\n-  610:                 \"SomeClass a; a.aField;\" + \"\\n\" +\n-  611:                 \"} }\", ParseStart.COMPILATION_UNIT);\n-  612: \n-  614:         BlockStmt blockStmt = cu.findAll(BlockStmt.class).get(0);\n-  615:         Context context1 = JavaParserFactory.getContext(blockStmt, typeSolver);\n-  616:         assertEquals(1, context1.localVariablesExposedToChild(blockStmt.getStatement(1)).size());\n-  617: \n-  618:         Node nameNode = cu.findAll(NameExpr.class).get(0);\n-  619:         Context context = JavaParserFactory.getContext(nameNode, typeSolver);\n-  620:         assertTrue(context.localVariableDeclarationInScope(name).isPresent());\n-  621:     }\n-  622: \n-  623:     //\n-  624:     // Testing JLS 6.3 Scope of a Declaration\n+  594: \n+  595:     @Test\n+  596:     void resolveReferenceToOverloadMethodFindOnlyCompatible() {\n+  597:         CompilationUnit cu = parseSample(\"OverloadedMethods\");\n+  598:         ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n+  599:         MethodDeclaration method = Navigator.demandMethod(clazz, \"m3\");\n+  600:         MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n+  601: \n+  602:         ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n+  603:         MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n+  604: \n+  610:     private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\n+  611:         return parse(ParserConfiguration.LanguageLevel.JAVA_10, code, parseStart);\n+  612:     }\n+  614:     private <PS extends Node> PS parse(ParserConfiguration.LanguageLevel languageLevel, String code, ParseStart<PS> parseStart) {\n+  615:         ParserConfiguration parserConfiguration = new ParserConfiguration();\n+  616:         parserConfiguration.setLanguageLevel(languageLevel);\n+  617:         ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n+  618:         if (!parseResult.isSuccessful()) {\n+  619:             parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n+  620:         }\n+  621:         assertTrue(parseResult.isSuccessful());\n+  622:         PS root = parseResult.getResult().get();\n+  623:         return root;\n+  624:     }\n", "uniqueId": "2903fc918dd87be53192aa1065047392f7adf4d1_594_604_614_624_610_612", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To refactor the provided `parse` method, we can extract the error handling and configuration setup into separate methods. This will improve readability and maintainability by making the main parsing logic clearer and isolating concerns.\n\nHere\u2019s the refactored code:\n\n```java\nprivate <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\n    ParserConfiguration parserConfiguration = createParserConfiguration();\n    ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n    handleParseErrors(parseResult);\n    return getParseResultRoot(parseResult);\n}\n\nprivate ParserConfiguration createParserConfiguration() {\n    ParserConfiguration parserConfiguration = new ParserConfiguration();\n    parserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\n    return parserConfiguration;\n}\n\nprivate <PS extends Node> void handleParseErrors(ParseResult<PS> parseResult) {\n    if (!parseResult.isSuccessful()) {\n        parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n    }\n    assertTrue(parseResult.isSuccessful());\n}\n\nprivate <PS extends Node> PS getParseResultRoot(ParseResult<PS> parseResult) {\n    return parseResult.getResult().get();\n}\n```\n\n### Explanation of Changes:\n1. **Extracted Method for Parser Configuration**: The configuration setup for the `ParserConfiguration` is moved to a separate method `createParserConfiguration()`. This isolates the configuration logic and makes it reusable if needed elsewhere.\n\n2. **Extracted Method for Error Handling**: The error handling logic is moved to `handleParseErrors(ParseResult<PS> parseResult)`. This method checks if the parsing was successful and prints any errors, making the main `parse` method cleaner.\n\n3. **Extracted Method for Getting Parse Result Root**: The logic to retrieve the root node from the parse result is moved to `getParseResultRoot(ParseResult<PS> parseResult)`. This clarifies the purpose of that line in the main method.\n\nThis refactoring enhances the readability and maintainability of the code by clearly separating different responsibilities into distinct methods.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\n        ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n        if (!parseResult.isSuccessful()) {\n            parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n        }\n        assertTrue(parseResult.isSuccessful());\n        PS root = parseResult.getResult().get();\n        return root;\n    }\n\nClass content:\n/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.resolution;\n\nimport com.github.javaparser.*;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.ConstructorDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.*;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.AbstractSymbolResolutionTest;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparser.Navigator;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.*;\nimport com.github.javaparser.symbolsolver.utils.LeanParserConfiguration;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Path;\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nclass ContextTest extends AbstractSymbolResolutionTest {\n\n    private TypeSolver typeSolver = new CombinedTypeSolver(new MemoryTypeSolver(), new ReflectionTypeSolver());\n\n    private CompilationUnit parseSample(String sampleName) {\n        InputStream is = ContextTest.class.getClassLoader().getResourceAsStream(sampleName + \".java.txt\");\n        return StaticJavaParser.parse(is);\n    }\n\n    @Test\n    void resolveDeclaredFieldReference() {\n        CompilationUnit cu = parseSample(\"ReferencesToField\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"ReferencesToField\");\n        MethodDeclaration method1 = Navigator.demandMethod(referencesToField, \"method1\");\n        ExpressionStmt stmt = (ExpressionStmt) method1.getBody().get().getStatements().get(0);\n        AssignExpr assignExpr = (AssignExpr) stmt.getExpression();\n\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        SymbolReference symbolReference = symbolSolver.solveSymbol(\"i\", assignExpr.getTarget());\n\n        assertTrue(symbolReference.isSolved());\n        assertEquals(\"i\", symbolReference.getCorrespondingDeclaration().getName());\n        assertTrue(symbolReference.getCorrespondingDeclaration().isField());\n    }\n\n    @Test\n    void resolveInheritedFieldReference() {\n        CompilationUnit cu = parseSample(\"ReferencesToField\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"ReferencesToFieldExtendingClass\");\n        MethodDeclaration method1 = Navigator.demandMethod(referencesToField, \"method2\");\n        ExpressionStmt stmt = (ExpressionStmt) method1.getBody().get().getStatements().get(0);\n        AssignExpr assignExpr = (AssignExpr) stmt.getExpression();\n\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        SymbolReference symbolReference = symbolSolver.solveSymbol(\"i\", assignExpr.getTarget());\n\n        assertTrue(symbolReference.isSolved());\n        assertEquals(\"i\", symbolReference.getCorrespondingDeclaration().getName());\n        assertTrue(symbolReference.getCorrespondingDeclaration().isField());\n    }\n\n    @Test\n    void resolveParameterReference() {\n        CompilationUnit cu = parseSample(\"ReferencesToParameter\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"ReferenceToParameter\");\n        MethodDeclaration method1 = Navigator.demandMethod(referencesToField, \"aMethod\");\n        NameExpr foo = Navigator.findNameExpression(method1, \"foo\").get();\n\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        SymbolReference symbolReference = symbolSolver.solveSymbol(\"foo\", foo);\n\n        assertTrue(symbolReference.isSolved());\n        assertEquals(\"foo\", symbolReference.getCorrespondingDeclaration().getName());\n        assertTrue(symbolReference.getCorrespondingDeclaration().isParameter());\n    }\n\n    @Test\n    void resolveReferenceToImportedType() {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(0);\n\n        ResolvedClassDeclaration compilationUnitDecl = mock(ResolvedClassDeclaration.class);\n        when(compilationUnitDecl.getName()).thenReturn(\"CompilationUnit\");\n        when(compilationUnitDecl.getQualifiedName()).thenReturn(\"com.github.javaparser.ast.CompilationUnit\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"com.github.javaparser.ast.CompilationUnit\")).thenReturn(SymbolReference.solved(compilationUnitDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"CompilationUnit\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"CompilationUnit\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"com.github.javaparser.ast.CompilationUnit\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceUsingQualifiedName() {\n        CompilationUnit cu = parseSample(\"Navigator2\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(0);\n\n        ResolvedClassDeclaration compilationUnitDecl = mock(ResolvedClassDeclaration.class);\n        when(compilationUnitDecl.getName()).thenReturn(\"CompilationUnit\");\n        when(compilationUnitDecl.getQualifiedName()).thenReturn(\"com.github.javaparser.ast.CompilationUnit\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        //when(typeSolver.tryToSolveType(\"java.lang.com.github.javaparser.ast.CompilationUnit\")).thenReturn(SymbolReference.unsolved(ClassDeclaration.class));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"com.github.javaparser.ast.CompilationUnit\")).thenReturn(SymbolReference.solved(compilationUnitDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        \n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"com.github.javaparser.ast.CompilationUnit\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"CompilationUnit\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"com.github.javaparser.ast.CompilationUnit\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToClassesInTheSamePackage() {\n        CompilationUnit cu = parseSample(\"Navigator3\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(0);\n\n        ResolvedClassDeclaration compilationUnitDecl = mock(ResolvedClassDeclaration.class);\n        when(compilationUnitDecl.getName()).thenReturn(\"CompilationUnit\");\n        when(compilationUnitDecl.getQualifiedName()).thenReturn(\"my.packagez.CompilationUnit\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"my.packagez.CompilationUnit\")).thenReturn(SymbolReference.solved(compilationUnitDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"CompilationUnit\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"CompilationUnit\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"my.packagez.CompilationUnit\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToClassInJavaLang() {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(1);\n\n        ResolvedClassDeclaration stringDecl = mock(ResolvedClassDeclaration.class);\n        when(stringDecl.getName()).thenReturn(\"String\");\n        when(stringDecl.getQualifiedName()).thenReturn(\"java.lang.String\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"me.tomassetti.symbolsolver.javaparser.String\")).thenReturn(SymbolReference.unsolved(ResolvedReferenceTypeDeclaration.class));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"java.lang.String\")).thenReturn(SymbolReference.solved(stringDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"String\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"String\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"java.lang.String\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToMethod() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        MethodCallExpr callToGetTypes = Navigator.findMethodCall(method, \"getTypes\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new JarTypeSolver(pathToJar), new ReflectionTypeSolver(true));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        MethodUsage ref = symbolSolver.solveMethod(\"getTypes\", Collections.emptyList(), callToGetTypes);\n\n        assertEquals(\"getTypes\", ref.getName());\n        assertEquals(\"com.github.javaparser.ast.CompilationUnit\", ref.declaringType().getQualifiedName());\n\n        //verify(typeSolver);\n    }\n\n    @Test\n    void resolveCascadeOfReferencesToMethod() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        MethodCallExpr callToStream = Navigator.findMethodCall(method, \"stream\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new JarTypeSolver(pathToJar), new ReflectionTypeSolver(true));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        MethodUsage ref = symbolSolver.solveMethod(\"stream\", Collections.emptyList(), callToStream);\n\n        assertEquals(\"stream\", ref.getName());\n        assertEquals(\"java.util.Collection\", ref.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToMethodCalledOnArrayAccess() {\n        CompilationUnit cu = parseSample(\"ArrayAccess\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"ArrayAccess\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"access\");\n        MethodCallExpr callToTrim = Navigator.findMethodCall(method, \"trim\").get();\n\n        Path src = adaptPath(\"src/test/resources\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JavaParserTypeSolver(src, new LeanParserConfiguration()));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        MethodUsage ref = symbolSolver.solveMethod(\"trim\", Collections.emptyList(), callToTrim);\n\n        assertEquals(\"trim\", ref.getName());\n        assertEquals(\"java.lang.String\", ref.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToJreType() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"foo\");\n        com.github.javaparser.ast.type.Type streamJavaParserType = method.getParameters().get(0).getType();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ResolvedType streamType = JavaParserFacade.get(typeSolver).convert(streamJavaParserType, method);\n\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", streamType.describe());\n    }\n\n    @Test\n    void resolveReferenceToMethodWithLambda() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr methodCallExpr = Navigator.findMethodCall(method, \"filter\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ResolvedType ref = JavaParserFacade.get(typeSolver).getType(methodCallExpr);\n\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", ref.describe());\n        assertEquals(1, ref.asReferenceType().typeParametersValues().size());\n        assertEquals(\"java.lang.String\", ref.asReferenceType().typeParametersValues().get(0).describe());\n    }\n\n    @Test\n    void resolveReferenceToLambdaParamBase() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        NameExpr refToT = Navigator.findNameExpression(method, \"t\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        JavaParserFacade javaParserFacade = JavaParserFacade.get(typeSolver);\n        ResolvedType ref = javaParserFacade.getType(refToT);\n\n        assertEquals(\"? super java.lang.String\", ref.describe());\n    }\n\n    @Test\n    void resolveReferenceToLambdaParamSimplified() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"isEmpty\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        MethodUsage ref = symbolSolver.solveMethod(\"isEmpty\", Collections.emptyList(), call);\n\n        assertEquals(\"isEmpty\", ref.getName());\n        assertEquals(\"java.lang.String\", ref.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"getTypes\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"getTypes\", methodUsage.getName());\n        assertEquals(\"java.util.List<com.github.javaparser.ast.body.TypeDeclaration>\", methodUsage.returnType().describe());\n        assertEquals(1, methodUsage.returnType().asReferenceType().typeParametersValues().size());\n        assertEquals(\"com.github.javaparser.ast.body.TypeDeclaration\", methodUsage.returnType().asReferenceType().typeParametersValues().get(0).describe());\n    }\n\n    @Test\n    void resolveCompoundGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"doubleTyped\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"genericMethodWithDoubleTypedReturnType\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"genericMethodWithDoubleTypedReturnType\", methodUsage.getName());\n        assertEquals(\"java.util.Map<T, V>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveNestedGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"nestedTyped\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"genericMethodWithNestedReturnType\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"genericMethodWithNestedReturnType\", methodUsage.getName());\n        assertEquals(\"java.util.List<java.util.List<T>>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveSimpleGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"simple\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"get\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"get\", methodUsage.getName());\n        assertEquals(\"java.util.List<java.util.List<java.lang.String>>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveGenericReturnTypeFromInputParam() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"input\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"copy\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"copy\", methodUsage.getName());\n        assertEquals(\"javaparser.GenericClass<java.util.List<java.lang.String>>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveComplexGenericReturnType() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"complex\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"complexGenerics\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"complexGenerics\", methodUsage.getName());\n        assertEquals(\"T\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveDoubleNestedClassType() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"nestedTypes\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"asList\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"asList\", methodUsage.getName());\n        assertEquals(\"java.util.List<javaparser.GenericClass.Bar.NestedBar>\", methodUsage.getParamType(0).describe());\n    }\n\n    @Test\n    void resolveTypeUsageOfFirstMethodInGenericClass() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToGetTypes = Navigator.findMethodCall(method, \"getTypes\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage filterUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToGetTypes);\n\n        assertEquals(\"java.util.List<com.github.javaparser.ast.body.TypeDeclaration>\", filterUsage.returnType().describe());\n        assertEquals(1, filterUsage.returnType().asReferenceType().typeParametersValues().size());\n        assertEquals(\"com.github.javaparser.ast.body.TypeDeclaration\", filterUsage.returnType().asReferenceType().typeParametersValues().get(0).describe());\n    }\n\n    @Test\n    void resolveTypeUsageOfMethodInGenericClass() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToStream = Navigator.findMethodCall(method, \"stream\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage filterUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToStream);\n\n        assertEquals(\"java.util.stream.Stream<com.github.javaparser.ast.body.TypeDeclaration>\", filterUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveTypeUsageOfCascadeMethodInGenericClass() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToFilter = Navigator.findMethodCall(method, \"filter\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage filterUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToFilter);\n\n        assertEquals(\"java.util.stream.Stream<com.github.javaparser.ast.body.TypeDeclaration>\", filterUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveLambdaType() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToFilter = Navigator.findMethodCall(method, \"filter\").get();\n        Expression lambdaExpr = callToFilter.getArguments().get(0);\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        ResolvedType typeOfLambdaExpr = JavaParserFacade.get(typeSolver).getType(lambdaExpr);\n\n        assertEquals(\"java.util.function.Predicate<? super com.github.javaparser.ast.body.TypeDeclaration>\", typeOfLambdaExpr.describe());\n    }\n\n    @Test\n    void resolveReferenceToLambdaParam() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToGetName = Navigator.findMethodCall(method, \"getName\").get();\n        Expression referenceToT = callToGetName.getScope().get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        ResolvedType typeOfT = JavaParserFacade.get(typeSolver).getType(referenceToT);\n\n        assertEquals(\"? super com.github.javaparser.ast.body.TypeDeclaration\", typeOfT.describe());\n    }\n\n    @Test\n    void resolveReferenceToCallOnLambdaParam() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToGetName = Navigator.findMethodCall(method, \"getName\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToGetName);\n\n        assertEquals(\"getName\", methodUsage.getName());\n        assertEquals(\"com.github.javaparser.ast.body.TypeDeclaration\", methodUsage.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToOverloadMethodWithNullParam() {\n        CompilationUnit cu = parseSample(\"OverloadedMethods\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"m1\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"overloaded\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.String\", ref.getParamTypes().get(0).describe());\n    }\n\n    @Test\n    void resolveReferenceToOverloadMethodFindStricter() {\n        CompilationUnit cu = parseSample(\"OverloadedMethods\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"m2\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"overloaded\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.String\", ref.getParamTypes().get(0).describe());\n    }\n\n    @Test\n    void resolveReferenceToMethodWithGenericArrayTypeParam() {\n        CompilationUnit cu = parseSample(\"GenericArrayMethodArgument\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericArrayMethodArgument\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"bar\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"foo\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"foo\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.String[]\", ref.getParamType(0).describe());\n    }\n\n    @Test\n    void resolveInheritedMethodFromInterface() {\n        CompilationUnit cu = parseSample(\"InterfaceInheritance\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Test\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"test\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"foobar\").get();\n\n        Path src = adaptPath(\"src/test/resources\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JavaParserTypeSolver(src));\n        ResolvedType type = JavaParserFacade.get(typeSolver).getType(call);\n\n        assertEquals(\"double\", type.describe());\n    }\n\n    @Test\n    void resolveReferenceToOverloadMethodFindOnlyCompatible() {\n        CompilationUnit cu = parseSample(\"OverloadedMethods\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"m3\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"overloaded\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.Object\", ref.getParamTypes().get(0).describe());\n    }\n\n    private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\n        ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n        if (!parseResult.isSuccessful()) {\n            parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n        }\n        assertTrue(parseResult.isSuccessful());\n        PS root = parseResult.getResult().get();\n        return root;\n    }\n\n    @Test\n    void localVariableDeclarationInScope() {\n        String name = \"a\";\n        CompilationUnit cu = parse(\"class A { void foo() {\\n\" +\n                \"SomeClass a; a.aField;\" + \"\\n\" +\n                \"} }\", ParseStart.COMPILATION_UNIT);\n\n        // The block statement expose to the 2nd statement the local var\n        BlockStmt blockStmt = cu.findAll(BlockStmt.class).get(0);\n        Context context1 = JavaParserFactory.getContext(blockStmt, typeSolver);\n        assertEquals(1, context1.localVariablesExposedToChild(blockStmt.getStatement(1)).size());\n\n        Node nameNode = cu.findAll(NameExpr.class).get(0);\n        Context context = JavaParserFactory.getContext(nameNode, typeSolver);\n        assertTrue(context.localVariableDeclarationInScope(name).isPresent());\n    }\n\n    //\n    // Testing JLS 6.3 Scope of a Declaration\n    //\n\n    // The scope of a formal parameter of a method (\u00a78.4.1), constructor (\u00a78.8.1), or lambda expression (\u00a715.27) is the\n    // entire body of the method, constructor, or lambda expression.\n\n    private void assertNoParamsExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfParamsExposedToChildInContextNamed(parent, child, paramName, 0, \"the element is exposed and it should not\");\n    }\n\n    private void assertOneParamExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfParamsExposedToChildInContextNamed(parent, child, paramName, 1, \"the element is not exposed as expected\");\n    }\n\n    private void assertNumberOfParamsExposedToChildInContextNamed(Node parent, Node child, String paramName,\n                                                                  int expectedNumber, String message) {\n        assertEquals(expectedNumber, JavaParserFactory.getContext(parent, typeSolver)\n                .parametersExposedToChild(child).stream().filter(p -> p.getNameAsString().equals(paramName)).count(), message);\n    }\n\n    private void assertNoVarsExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfVarsExposedToChildInContextNamed(parent, child, paramName, 0, \"the element is exposed and it should not\");\n    }\n\n    private void assertOneVarExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfVarsExposedToChildInContextNamed(parent, child, paramName, 1, \"the element is not exposed as expected\");\n    }\n\n    private void assertNumberOfVarsExposedToChildInContextNamed(Node parent, Node child, String paramName,\n                                                                  int expectedNumber, String message) {\n        List<VariableDeclarator> vars = JavaParserFactory.getContext(parent, typeSolver)\n                .localVariablesExposedToChild(child);\n        assertEquals(expectedNumber, vars.stream().filter(p -> p.getNameAsString().equals(paramName)).count(), message);\n    }\n\n    @Test\n    void parametersExposedToChildForMethod() {\n        MethodDeclaration method = parse(\"void foo(int myParam) { aCall(); }\",\n                ParseStart.CLASS_BODY).asMethodDeclaration();\n        assertOneParamExposedToChildInContextNamed(method, method.getBody().get(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(method, method.getType(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(method, method.getParameter(0), \"myParam\");\n    }\n\n    @Test\n    void parametersExposedToChildForConstructor() {\n        ConstructorDeclaration constructor = parse(\"Foo(int myParam) { aCall(); }\",\n                ParseStart.CLASS_BODY).asConstructorDeclaration();\n        assertOneParamExposedToChildInContextNamed(constructor, constructor.getBody(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(constructor, constructor.getParameter(0), \"myParam\");\n    }\n\n    @Test\n    void parametersExposedToChildForLambda() {\n        LambdaExpr lambda = (LambdaExpr)parse(\"Object myLambda = (myParam) -> myParam * 2;\",\n                ParseStart.STATEMENT).asExpressionStmt().getExpression().asVariableDeclarationExpr()\n                .getVariables().get(0).getInitializer().get();\n        assertOneParamExposedToChildInContextNamed(lambda, lambda.getBody(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(lambda, lambda.getParameter(0), \"myParam\");\n    }\n\n    // The scope of a local variable declaration in a block (\u00a714.4) is the rest of the block in which the declaration\n    // appears, starting with its own initializer and including any further declarators to the right in the local\n    // variable declaration statement.\n\n    @Test\n    void localVariablesExposedToChildWithinABlock() {\n        BlockStmt blockStmt = parse(\"{ preStatement(); int a = 1, b = 2; otherStatement(); }\",\n                ParseStart.STATEMENT).asBlockStmt();\n        assertNoVarsExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(0), \"a\");\n        assertNoVarsExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(0), \"b\");\n        assertOneVarExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(2), \"a\");\n        assertOneVarExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(2), \"b\");\n\n        VariableDeclarationExpr varDecl = blockStmt.getStatement(1).asExpressionStmt().getExpression()\n                .asVariableDeclarationExpr();\n        VariableDeclarator varA = varDecl.getVariables().get(0);\n        VariableDeclarator varB = varDecl.getVariables().get(1);\n        assertOneVarExposedToChildInContextNamed(varA,\n                varA.getInitializer().get(), \"a\");\n        assertOneVarExposedToChildInContextNamed(varDecl,\n                varB, \"a\");\n        assertNoVarsExposedToChildInContextNamed(varDecl,\n                varA, \"b\");\n    }\n\n    // The scope of a local variable declared in the ForInit part of a basic for statement (\u00a714.14.1) includes all of the following:\n    // * Its own initializer\n    // * Any further declarators to the right in the ForInit part of the for statement\n    // * The Expression and ForUpdate parts of the for statement\n    // * The contained Statement\n\n    @Test\n    void localVariablesExposedToChildWithinForStmt() {\n        ForStmt forStmt = parse(\"for (int i=0, j=1;i<10;i++) { body(); }\",\n                ParseStart.STATEMENT).asForStmt();\n        VariableDeclarationExpr initializations = forStmt.getInitialization().get(0).asVariableDeclarationExpr();\n        assertOneVarExposedToChildInContextNamed(initializations,\n                initializations.getVariable(1),\n                \"i\");\n        assertOneVarExposedToChildInContextNamed(forStmt,\n                forStmt.getCompare().get(),\n                \"i\");\n        assertOneVarExposedToChildInContextNamed(forStmt,\n                forStmt.getUpdate().get(0),\n                \"i\");\n        assertOneVarExposedToChildInContextNamed(forStmt,\n                forStmt.getBody(),\n                \"i\");\n    }\n\n    // The scope of a local variable declared in the FormalParameter part of an enhanced for statement (\u00a714.14.2) is\n    // the contained Statement.\n\n    @Test\n    void localVariablesExposedToChildWithinEnhancedForeachStmt() {\n        ForEachStmt foreachStmt = parse(\"for (int i: myList) { body(); }\",\n                ParseStart.STATEMENT).asForEachStmt();\n        assertOneVarExposedToChildInContextNamed(foreachStmt, foreachStmt.getBody(), \"i\");\n        assertNoVarsExposedToChildInContextNamed(foreachStmt, foreachStmt.getVariable(), \"i\");\n        assertNoVarsExposedToChildInContextNamed(foreachStmt, foreachStmt.getIterable(), \"i\");\n    }\n\n    // The scope of a parameter of an exception handler that is declared in a catch clause of a try statement (\u00a714.20)\n    // is the entire block associated with the catch.\n\n    @Test\n    void parametersExposedToChildWithinTryStatement() {\n        CatchClause catchClause = parse(\"try {  } catch(Exception e) { body(); }\",\n                ParseStart.STATEMENT).asTryStmt().getCatchClauses().get(0);\n        assertOneParamExposedToChildInContextNamed(catchClause, catchClause.getBody(), \"e\");\n        assertNoParamsExposedToChildInContextNamed(catchClause, catchClause.getParameter(), \"e\");\n    }\n\n    // The scope of a variable declared in the ResourceSpecification of a try-with-resources statement (\u00a714.20.3) is\n    // from the declaration rightward over the remainder of the ResourceSpecification and the entire try block\n    // associated with the try-with-resources statement.\n\n    @Test\n    void localVariablesExposedToChildWithinTryWithResourcesStatement() {\n        TryStmt stmt = parse(\"try (Object res1 = foo(); Object res2 = foo()) { body(); }\",\n                ParseStart.STATEMENT).asTryStmt();\n        assertOneVarExposedToChildInContextNamed(stmt, stmt.getResources().get(1), \"res1\");\n        assertNoVarsExposedToChildInContextNamed(stmt, stmt.getResources().get(0), \"res1\");\n        assertOneVarExposedToChildInContextNamed(stmt, stmt.getTryBlock(), \"res1\");\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic assertEqualsStringIgnoringEol(expected String, actual String, message String) : void extracted from public assertEqualsNoEol(expected String, actual String, message String) : void in class com.github.javaparser.utils.TestUtils", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java", "startLine": 278, "endLine": 283, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java", "startLine": 267, "endLine": 274, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java", "startLine": 320, "endLine": 329, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual, String message) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY), message);\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java", "isPureRefactoring": true, "commitId": "339d45a5694b569dee7bab605eb700a564975b6c", "packageNameBefore": "com.github.javaparser.utils", "classNameBefore": "com.github.javaparser.utils.TestUtils", "methodNameBefore": "com.github.javaparser.utils.TestUtils#assertEqualsNoEol", "classSignatureBefore": "public class TestUtils ", "methodNameBeforeSet": ["com.github.javaparser.utils.TestUtils#assertEqualsNoEol"], "classNameBeforeSet": ["com.github.javaparser.utils.TestUtils"], "classSignatureBeforeSet": ["public class TestUtils "], "purityCheckResultList": [{"isPure": true, "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Extract Method-", "description": "Extract Method on top of the extracted method - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.utils;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParseStart;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.Problem;\nimport com.github.javaparser.ast.expr.Expression;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.github.javaparser.ParserConfiguration.LanguageLevel.JAVA_9;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.CodeGenerationUtils.f;\nimport static com.github.javaparser.utils.Utils.normalizeEolInTextBlock;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.Arrays.asList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TestUtils {\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>system's line separator</strong> to separate lines.\n     * Takes care of setting all the end of line character to platform specific ones.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResourceUsingSystemEol(String resourceName) {\n        return readResource(resourceName, LineEnding.SYSTEM);\n    }\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>given line separator</strong> to separate lines.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResource(String resourceName, LineEnding lineEnding) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"resource not found by name: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)) {\n                final StringBuilder builder = new StringBuilder(4096);\n                String line;\n                while ((line = br.readLine()) != null) {\n                    builder.append(line).append(lineEnding.toString());\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n\n    /**\n     * Read the resource's contents as-is.\n     * <br>\n     * <br>If you wish to specify the line endings,\n     * use {@link #readResourceUsingSystemEol(String)}\n     * or {@link #readResource(String, LineEnding)}\n     */\n    public static String readResource(String resourceName) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"not found: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)\n            ) {\n                // Switched to reading char-by-char as opposed to line-by-line.\n                // This helps to retain the resource's own line endings.\n                final StringBuilder builder = new StringBuilder(4096);\n                for (int c = br.read(); c != -1; c = br.read()) {\n                    builder.append((char) c);\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    /**\n     * Use this assertion if line endings are important, otherwise use {@link #assertEqualToTextResourceNoEol(String, String)}\n     */\n    public static void assertEqualToTextResource(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n\n        // First test equality ignoring EOL chars\n        assertEqualsNoEol(expected, actual);\n\n        // If this passes but the next one fails, the failure is due only to EOL differences, allowing a more precise test failure message.\n        assertEquals(\n                expected,\n                actual,\n                String.format(\"failed due to line separator differences -- Expected: %s, but actual: %s (system eol: %s)\",\n                        LineEnding.detect(expected).escaped(),\n                        LineEnding.detect(actual).escaped(),\n                        LineEnding.SYSTEM.escaped()\n                )\n        );\n    }\n\n    /**\n     * If line endings are important, use {@link #assertEqualToTextResource(String, String)}\n     */\n    public static void assertEqualToTextResourceNoEol(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n        assertEquals(expected, actual, \"failed due to line separator differences\");\n    }\n\n    public static String readTextResource(Class<?> relativeClass, String resourceName) {\n        final URL resourceAsStream = relativeClass.getResource(resourceName);\n        try {\n            byte[] bytes = Files.readAllBytes(Paths.get(resourceAsStream.toURI()));\n            return new String(bytes, UTF_8);\n        } catch (IOException | URISyntaxException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    public static void assertInstanceOf(Class<?> expectedType, Object instance) {\n        assertTrue(expectedType.isAssignableFrom(instance.getClass()), f(\"%s is not an instance of %s.\", instance.getClass(), expectedType));\n    }\n\n    /**\n     * Unzip a zip file into a directory.\n     */\n    public static void unzip(Path zipFile, Path outputFolder) throws IOException {\n        Log.info(\"Unzipping %s to %s\", () -> zipFile, () -> outputFolder);\n\n        final byte[] buffer = new byte[1024 * 1024];\n\n        outputFolder.toFile().mkdirs();\n\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {\n            ZipEntry ze = zis.getNextEntry();\n\n            while (ze != null) {\n                final Path newFile = outputFolder.resolve(ze.getName());\n\n                if (ze.isDirectory()) {\n                    Log.trace(\"mkdir %s\", newFile::toAbsolutePath);\n                    newFile.toFile().mkdirs();\n                } else {\n                    Log.info(\"unzip %s\", newFile::toAbsolutePath);\n                    try (FileOutputStream fos = new FileOutputStream(newFile.toFile())) {\n                        int len;\n                        while ((len = zis.read(buffer)) > 0) {\n                            fos.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n\n        }\n        Log.info(\"Unzipped %s to %s\", () -> zipFile, () -> outputFolder);\n    }\n\n    /**\n     * Download a file from a URL to disk.\n     */\n    public static void download(URL url, Path destination) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        Response response = client.newCall(request).execute();\n        Files.write(destination, response.body().bytes());\n    }\n\n    public static String temporaryDirectory() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }\n\n    public static void assertCollections(Collection<?> expected, Collection<?> actual) {\n        final StringBuilder out = new StringBuilder();\n        for (Object e : expected) {\n            if (actual.contains(e)) {\n                actual.remove(e);\n            } else {\n                out.append(\"Missing: \").append(e).append(LineEnding.SYSTEM);\n            }\n        }\n        for (Object a : actual) {\n            out.append(\"Unexpected: \").append(a).append(LineEnding.SYSTEM);\n        }\n\n        String s = out.toString();\n        if (s.isEmpty()) {\n            return;\n        }\n        fail(s);\n    }\n\n    public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        assertProblems(result.getProblems(), expectedArg);\n    }\n\n    public static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>(asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\n    public static void assertNoProblems(ParseResult<?> result) {\n        assertProblems(result);\n    }\n\n    public static void assertExpressionValid(String expression) {\n        JavaParser javaParser = new JavaParser(new ParserConfiguration().setLanguageLevel(JAVA_9));\n        ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n        assertTrue(result.isSuccessful(), result.getProblems().toString());\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY));\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual, String message) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY), message);\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.utils;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParseStart;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.Problem;\nimport com.github.javaparser.ast.expr.Expression;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.github.javaparser.ParserConfiguration.LanguageLevel.JAVA_9;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.CodeGenerationUtils.f;\nimport static com.github.javaparser.utils.Utils.normalizeEolInTextBlock;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.Arrays.asList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TestUtils {\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>system's line separator</strong> to separate lines.\n     * Takes care of setting all the end of line character to platform specific ones.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResourceUsingSystemEol(String resourceName) {\n        return readResource(resourceName, LineEnding.SYSTEM);\n    }\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>given line separator</strong> to separate lines.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResource(String resourceName, LineEnding lineEnding) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"resource not found by name: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)) {\n                final StringBuilder builder = new StringBuilder(4096);\n                String line;\n                while ((line = br.readLine()) != null) {\n                    builder.append(line).append(lineEnding.toString());\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n\n    /**\n     * Read the resource's contents as-is.\n     * <br>\n     * <br>If you wish to specify the line endings,\n     * use {@link #readResourceUsingSystemEol(String)}\n     * or {@link #readResource(String, LineEnding)}\n     */\n    public static String readResource(String resourceName) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"not found: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)\n            ) {\n                // Switched to reading char-by-char as opposed to line-by-line.\n                // This helps to retain the resource's own line endings.\n                final StringBuilder builder = new StringBuilder(4096);\n                for (int c = br.read(); c != -1; c = br.read()) {\n                    builder.append((char) c);\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    /**\n     * Use this assertion if line endings are important, otherwise use {@link #assertEqualToTextResourceNoEol(String, String)}\n     */\n    public static void assertEqualToTextResource(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n        assertEqualsString(expected, actual);\n    }\n\n    /**\n     * If line endings are important, use {@link #assertEqualToTextResource(String, String)}\n     */\n    public static void assertEqualToTextResourceNoEol(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n        assertEqualsNoEol(expected, actual);\n    }\n\n    public static String readTextResource(Class<?> relativeClass, String resourceName) {\n        final URL resourceAsStream = relativeClass.getResource(resourceName);\n        try {\n            byte[] bytes = Files.readAllBytes(Paths.get(resourceAsStream.toURI()));\n            return new String(bytes, UTF_8);\n        } catch (IOException | URISyntaxException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    public static void assertInstanceOf(Class<?> expectedType, Object instance) {\n        assertTrue(expectedType.isAssignableFrom(instance.getClass()), f(\"%s is not an instance of %s.\", instance.getClass(), expectedType));\n    }\n\n    /**\n     * Unzip a zip file into a directory.\n     */\n    public static void unzip(Path zipFile, Path outputFolder) throws IOException {\n        Log.info(\"Unzipping %s to %s\", () -> zipFile, () -> outputFolder);\n\n        final byte[] buffer = new byte[1024 * 1024];\n\n        outputFolder.toFile().mkdirs();\n\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {\n            ZipEntry ze = zis.getNextEntry();\n\n            while (ze != null) {\n                final Path newFile = outputFolder.resolve(ze.getName());\n\n                if (ze.isDirectory()) {\n                    Log.trace(\"mkdir %s\", newFile::toAbsolutePath);\n                    newFile.toFile().mkdirs();\n                } else {\n                    Log.info(\"unzip %s\", newFile::toAbsolutePath);\n                    try (FileOutputStream fos = new FileOutputStream(newFile.toFile())) {\n                        int len;\n                        while ((len = zis.read(buffer)) > 0) {\n                            fos.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n\n        }\n        Log.info(\"Unzipped %s to %s\", () -> zipFile, () -> outputFolder);\n    }\n\n    /**\n     * Download a file from a URL to disk.\n     */\n    public static void download(URL url, Path destination) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        Response response = client.newCall(request).execute();\n        Files.write(destination, response.body().bytes());\n    }\n\n    public static String temporaryDirectory() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }\n\n    public static void assertCollections(Collection<?> expected, Collection<?> actual) {\n        final StringBuilder out = new StringBuilder();\n        for (Object e : expected) {\n            if (actual.contains(e)) {\n                actual.remove(e);\n            } else {\n                out.append(\"Missing: \").append(e).append(LineEnding.SYSTEM);\n            }\n        }\n        for (Object a : actual) {\n            out.append(\"Unexpected: \").append(a).append(LineEnding.SYSTEM);\n        }\n\n        String s = out.toString();\n        if (s.isEmpty()) {\n            return;\n        }\n        fail(s);\n    }\n\n    public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        assertProblems(result.getProblems(), expectedArg);\n    }\n\n    public static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>(asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\n    public static void assertNoProblems(ParseResult<?> result) {\n        assertProblems(result);\n    }\n\n    public static void assertExpressionValid(String expression) {\n        JavaParser javaParser = new JavaParser(new ParserConfiguration().setLanguageLevel(JAVA_9));\n        ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n        assertTrue(result.isSuccessful(), result.getProblems().toString());\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String)}\n     */\n    @Deprecated\n    public static void assertEqualsNoEol(String expected, String actual) {\n        assertEqualsStringIgnoringEol(expected, actual);\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String, String)}\n     */\n    @Deprecated\n    public static void assertEqualsNoEol(String expected, String actual, String message) {\n        assertEqualsStringIgnoringEol(expected, actual, message);\n    }\n\n\n    /**\n     * Assert that \"actual\" equals \"expected\".\n     * <br>First checks if the content is equal ignoring line separators.\n     * <br>If this passes, then we check if the content is equal - if this fails then we can\n     *  advise that the difference is <em>only</em> in the line separators.\n     */\n    public static void assertEqualsString(String expected, String actual) {\n        assertEqualsString(expected, actual, \"\");\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\".\n     * <br>First checks if the content is equal ignoring line separators.\n     * <br>If this passes, then we check if the content is equal - if this fails then we can\n     *  advise that the difference is <em>only</em> in the line separators.\n     */\n    public static void assertEqualsString(String expected, String actual, String message) {\n        // First test equality ignoring EOL chars\n        assertEqualsNoEol(expected, actual, message);\n\n        // If this passes but the next one fails, the failure is due only to EOL differences, allowing a more precise test failure message.\n        assertEquals(\n                expected,\n                actual,\n                message + String.format(\" -- failed due to line separator differences -- Expected: %s, but actual: %s (system eol: %s)\",\n                        LineEnding.detect(expected).escaped(),\n                        LineEnding.detect(actual).escaped(),\n                        LineEnding.SYSTEM.escaped()\n                )\n        );\n    }\n\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY)\n        );\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual, String message) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY),\n                message\n        );\n    }\n\n\n    /**\n     * Assert that the given string is detected as having the given line separator.\n     */\n    public static void assertLineSeparator(String text, LineEnding expectedLineSeparator) {\n        LineEnding actualLineSeparator = LineEnding.detect(text);\n        assertEquals(expectedLineSeparator, actualLineSeparator);\n    }\n\n    /**\n     * Assert that the given string is detected as having the given line separator.\n     */\n    public static void assertLineSeparator(String text, LineEnding expectedLineSeparator, String message) {\n        LineEnding actualLineSeparator = LineEnding.detect(text);\n        assertEquals(expectedLineSeparator, actualLineSeparator, message);\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual, String message) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY),\n                message\n        );\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String, String)}\n     */\n    @Deprecated\n    public static void assertEqualsNoEol(String expected, String actual, String message) {\n        assertEqualsStringIgnoringEol(expected, actual, message);\n    }\n/**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual, String message) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY),\n                message\n        );\n    }", "diffSourceCode": "-  267:         ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n-  268:         assertTrue(result.isSuccessful(), result.getProblems().toString());\n-  269:     }\n-  270: \n-  271:     /**\n-  272:      * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n-  273:      */\n-  274:     public static void assertEqualsNoEol(String expected, String actual) {\n-  278:     /**\n-  279:      * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n-  280:      */\n-  281:     public static void assertEqualsNoEol(String expected, String actual, String message) {\n-  282:         assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY), message);\n-  283:     }\n+  267:     /**\n+  268:      * Assert that \"actual\" equals \"expected\", ignoring line separators.\n+  269:      * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String, String)}\n+  270:      */\n+  271:     @Deprecated\n+  272:     public static void assertEqualsNoEol(String expected, String actual, String message) {\n+  273:         assertEqualsStringIgnoringEol(expected, actual, message);\n+  274:     }\n+  278:      * Assert that \"actual\" equals \"expected\".\n+  279:      * <br>First checks if the content is equal ignoring line separators.\n+  280:      * <br>If this passes, then we check if the content is equal - if this fails then we can\n+  281:      *  advise that the difference is <em>only</em> in the line separators.\n+  282:      */\n+  283:     public static void assertEqualsString(String expected, String actual) {\n+  320:     /**\n+  321:      * Assert that \"actual\" equals \"expected\", ignoring line separators.\n+  322:      */\n+  323:     public static void assertEqualsStringIgnoringEol(String expected, String actual, String message) {\n+  324:         assertEqualsString(\n+  325:                 normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n+  326:                 normalizeEolInTextBlock(actual, LineEnding.ARBITRARY),\n+  327:                 message\n+  328:         );\n+  329:     }\n", "uniqueId": "339d45a5694b569dee7bab605eb700a564975b6c_278_283_320_329_267_274", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": false, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `assertEqualsNoEol` method, we can extract the logic that normalizes the end-of-line characters into a separate method. This will make the `assertEqualsNoEol` method cleaner and more focused on its primary responsibility, which is to assert equality.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\npublic static void assertEqualsNoEol(String expected, String actual, String message) {\n    String normalizedExpected = normalizeEol(expected);\n    String normalizedActual = normalizeEol(actual);\n    assertEquals(normalizedExpected, normalizedActual, message);\n}\n\nprivate static String normalizeEol(String text) {\n    return normalizeEolInTextBlock(text, LineEnding.ARBITRARY);\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The logic for normalizing the end-of-line characters has been moved to a new private method called `normalizeEol`. This method takes a string and returns it normalized.\n2. **Simplified `assertEqualsNoEol`**: The `assertEqualsNoEol` method now simply calls the `normalizeEol` method for both the expected and actual strings, making it easier to read and understand. \n\nThis refactoring enhances modularity and makes it easier to test the normalization logic independently if needed.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual, String message) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY), message);\n    }\n\nClass content:\n/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.utils;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParseStart;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.Problem;\nimport com.github.javaparser.ast.expr.Expression;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.github.javaparser.ParserConfiguration.LanguageLevel.JAVA_9;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.CodeGenerationUtils.f;\nimport static com.github.javaparser.utils.Utils.normalizeEolInTextBlock;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.Arrays.asList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TestUtils {\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>system's line separator</strong> to separate lines.\n     * Takes care of setting all the end of line character to platform specific ones.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResourceUsingSystemEol(String resourceName) {\n        return readResource(resourceName, LineEnding.SYSTEM);\n    }\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>given line separator</strong> to separate lines.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResource(String resourceName, LineEnding lineEnding) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"resource not found by name: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)) {\n                final StringBuilder builder = new StringBuilder(4096);\n                String line;\n                while ((line = br.readLine()) != null) {\n                    builder.append(line).append(lineEnding.toString());\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n\n    /**\n     * Read the resource's contents as-is.\n     * <br>\n     * <br>If you wish to specify the line endings,\n     * use {@link #readResourceUsingSystemEol(String)}\n     * or {@link #readResource(String, LineEnding)}\n     */\n    public static String readResource(String resourceName) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"not found: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)\n            ) {\n                // Switched to reading char-by-char as opposed to line-by-line.\n                // This helps to retain the resource's own line endings.\n                final StringBuilder builder = new StringBuilder(4096);\n                for (int c = br.read(); c != -1; c = br.read()) {\n                    builder.append((char) c);\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    /**\n     * Use this assertion if line endings are important, otherwise use {@link #assertEqualToTextResourceNoEol(String, String)}\n     */\n    public static void assertEqualToTextResource(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n\n        // First test equality ignoring EOL chars\n        assertEqualsNoEol(expected, actual);\n\n        // If this passes but the next one fails, the failure is due only to EOL differences, allowing a more precise test failure message.\n        assertEquals(\n                expected,\n                actual,\n                String.format(\"failed due to line separator differences -- Expected: %s, but actual: %s (system eol: %s)\",\n                        LineEnding.detect(expected).escaped(),\n                        LineEnding.detect(actual).escaped(),\n                        LineEnding.SYSTEM.escaped()\n                )\n        );\n    }\n\n    /**\n     * If line endings are important, use {@link #assertEqualToTextResource(String, String)}\n     */\n    public static void assertEqualToTextResourceNoEol(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n        assertEquals(expected, actual, \"failed due to line separator differences\");\n    }\n\n    public static String readTextResource(Class<?> relativeClass, String resourceName) {\n        final URL resourceAsStream = relativeClass.getResource(resourceName);\n        try {\n            byte[] bytes = Files.readAllBytes(Paths.get(resourceAsStream.toURI()));\n            return new String(bytes, UTF_8);\n        } catch (IOException | URISyntaxException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    public static void assertInstanceOf(Class<?> expectedType, Object instance) {\n        assertTrue(expectedType.isAssignableFrom(instance.getClass()), f(\"%s is not an instance of %s.\", instance.getClass(), expectedType));\n    }\n\n    /**\n     * Unzip a zip file into a directory.\n     */\n    public static void unzip(Path zipFile, Path outputFolder) throws IOException {\n        Log.info(\"Unzipping %s to %s\", () -> zipFile, () -> outputFolder);\n\n        final byte[] buffer = new byte[1024 * 1024];\n\n        outputFolder.toFile().mkdirs();\n\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {\n            ZipEntry ze = zis.getNextEntry();\n\n            while (ze != null) {\n                final Path newFile = outputFolder.resolve(ze.getName());\n\n                if (ze.isDirectory()) {\n                    Log.trace(\"mkdir %s\", newFile::toAbsolutePath);\n                    newFile.toFile().mkdirs();\n                } else {\n                    Log.info(\"unzip %s\", newFile::toAbsolutePath);\n                    try (FileOutputStream fos = new FileOutputStream(newFile.toFile())) {\n                        int len;\n                        while ((len = zis.read(buffer)) > 0) {\n                            fos.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n\n        }\n        Log.info(\"Unzipped %s to %s\", () -> zipFile, () -> outputFolder);\n    }\n\n    /**\n     * Download a file from a URL to disk.\n     */\n    public static void download(URL url, Path destination) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        Response response = client.newCall(request).execute();\n        Files.write(destination, response.body().bytes());\n    }\n\n    public static String temporaryDirectory() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }\n\n    public static void assertCollections(Collection<?> expected, Collection<?> actual) {\n        final StringBuilder out = new StringBuilder();\n        for (Object e : expected) {\n            if (actual.contains(e)) {\n                actual.remove(e);\n            } else {\n                out.append(\"Missing: \").append(e).append(LineEnding.SYSTEM);\n            }\n        }\n        for (Object a : actual) {\n            out.append(\"Unexpected: \").append(a).append(LineEnding.SYSTEM);\n        }\n\n        String s = out.toString();\n        if (s.isEmpty()) {\n            return;\n        }\n        fail(s);\n    }\n\n    public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        assertProblems(result.getProblems(), expectedArg);\n    }\n\n    public static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>(asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\n    public static void assertNoProblems(ParseResult<?> result) {\n        assertProblems(result);\n    }\n\n    public static void assertExpressionValid(String expression) {\n        JavaParser javaParser = new JavaParser(new ParserConfiguration().setLanguageLevel(JAVA_9));\n        ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n        assertTrue(result.isSuccessful(), result.getProblems().toString());\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY));\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual, String message) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY), message);\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic assertEqualsStringIgnoringEol(expected String, actual String) : void extracted from public assertEqualsNoEol(expected String, actual String) : void in class com.github.javaparser.utils.TestUtils", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java", "startLine": 271, "endLine": 276, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java", "startLine": 258, "endLine": 265, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java", "startLine": 310, "endLine": 318, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY));\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java", "isPureRefactoring": true, "commitId": "339d45a5694b569dee7bab605eb700a564975b6c", "packageNameBefore": "com.github.javaparser.utils", "classNameBefore": "com.github.javaparser.utils.TestUtils", "methodNameBefore": "com.github.javaparser.utils.TestUtils#assertEqualsNoEol", "classSignatureBefore": "public class TestUtils ", "methodNameBeforeSet": ["com.github.javaparser.utils.TestUtils#assertEqualsNoEol"], "classNameBeforeSet": ["com.github.javaparser.utils.TestUtils"], "classSignatureBeforeSet": ["public class TestUtils "], "purityCheckResultList": [{"isPure": true, "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Extract Method-", "description": "Extract Method on top of the extracted method - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.utils;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParseStart;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.Problem;\nimport com.github.javaparser.ast.expr.Expression;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.github.javaparser.ParserConfiguration.LanguageLevel.JAVA_9;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.CodeGenerationUtils.f;\nimport static com.github.javaparser.utils.Utils.normalizeEolInTextBlock;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.Arrays.asList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TestUtils {\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>system's line separator</strong> to separate lines.\n     * Takes care of setting all the end of line character to platform specific ones.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResourceUsingSystemEol(String resourceName) {\n        return readResource(resourceName, LineEnding.SYSTEM);\n    }\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>given line separator</strong> to separate lines.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResource(String resourceName, LineEnding lineEnding) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"resource not found by name: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)) {\n                final StringBuilder builder = new StringBuilder(4096);\n                String line;\n                while ((line = br.readLine()) != null) {\n                    builder.append(line).append(lineEnding.toString());\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n\n    /**\n     * Read the resource's contents as-is.\n     * <br>\n     * <br>If you wish to specify the line endings,\n     * use {@link #readResourceUsingSystemEol(String)}\n     * or {@link #readResource(String, LineEnding)}\n     */\n    public static String readResource(String resourceName) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"not found: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)\n            ) {\n                // Switched to reading char-by-char as opposed to line-by-line.\n                // This helps to retain the resource's own line endings.\n                final StringBuilder builder = new StringBuilder(4096);\n                for (int c = br.read(); c != -1; c = br.read()) {\n                    builder.append((char) c);\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    /**\n     * Use this assertion if line endings are important, otherwise use {@link #assertEqualToTextResourceNoEol(String, String)}\n     */\n    public static void assertEqualToTextResource(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n\n        // First test equality ignoring EOL chars\n        assertEqualsNoEol(expected, actual);\n\n        // If this passes but the next one fails, the failure is due only to EOL differences, allowing a more precise test failure message.\n        assertEquals(\n                expected,\n                actual,\n                String.format(\"failed due to line separator differences -- Expected: %s, but actual: %s (system eol: %s)\",\n                        LineEnding.detect(expected).escaped(),\n                        LineEnding.detect(actual).escaped(),\n                        LineEnding.SYSTEM.escaped()\n                )\n        );\n    }\n\n    /**\n     * If line endings are important, use {@link #assertEqualToTextResource(String, String)}\n     */\n    public static void assertEqualToTextResourceNoEol(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n        assertEquals(expected, actual, \"failed due to line separator differences\");\n    }\n\n    public static String readTextResource(Class<?> relativeClass, String resourceName) {\n        final URL resourceAsStream = relativeClass.getResource(resourceName);\n        try {\n            byte[] bytes = Files.readAllBytes(Paths.get(resourceAsStream.toURI()));\n            return new String(bytes, UTF_8);\n        } catch (IOException | URISyntaxException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    public static void assertInstanceOf(Class<?> expectedType, Object instance) {\n        assertTrue(expectedType.isAssignableFrom(instance.getClass()), f(\"%s is not an instance of %s.\", instance.getClass(), expectedType));\n    }\n\n    /**\n     * Unzip a zip file into a directory.\n     */\n    public static void unzip(Path zipFile, Path outputFolder) throws IOException {\n        Log.info(\"Unzipping %s to %s\", () -> zipFile, () -> outputFolder);\n\n        final byte[] buffer = new byte[1024 * 1024];\n\n        outputFolder.toFile().mkdirs();\n\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {\n            ZipEntry ze = zis.getNextEntry();\n\n            while (ze != null) {\n                final Path newFile = outputFolder.resolve(ze.getName());\n\n                if (ze.isDirectory()) {\n                    Log.trace(\"mkdir %s\", newFile::toAbsolutePath);\n                    newFile.toFile().mkdirs();\n                } else {\n                    Log.info(\"unzip %s\", newFile::toAbsolutePath);\n                    try (FileOutputStream fos = new FileOutputStream(newFile.toFile())) {\n                        int len;\n                        while ((len = zis.read(buffer)) > 0) {\n                            fos.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n\n        }\n        Log.info(\"Unzipped %s to %s\", () -> zipFile, () -> outputFolder);\n    }\n\n    /**\n     * Download a file from a URL to disk.\n     */\n    public static void download(URL url, Path destination) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        Response response = client.newCall(request).execute();\n        Files.write(destination, response.body().bytes());\n    }\n\n    public static String temporaryDirectory() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }\n\n    public static void assertCollections(Collection<?> expected, Collection<?> actual) {\n        final StringBuilder out = new StringBuilder();\n        for (Object e : expected) {\n            if (actual.contains(e)) {\n                actual.remove(e);\n            } else {\n                out.append(\"Missing: \").append(e).append(LineEnding.SYSTEM);\n            }\n        }\n        for (Object a : actual) {\n            out.append(\"Unexpected: \").append(a).append(LineEnding.SYSTEM);\n        }\n\n        String s = out.toString();\n        if (s.isEmpty()) {\n            return;\n        }\n        fail(s);\n    }\n\n    public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        assertProblems(result.getProblems(), expectedArg);\n    }\n\n    public static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>(asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\n    public static void assertNoProblems(ParseResult<?> result) {\n        assertProblems(result);\n    }\n\n    public static void assertExpressionValid(String expression) {\n        JavaParser javaParser = new JavaParser(new ParserConfiguration().setLanguageLevel(JAVA_9));\n        ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n        assertTrue(result.isSuccessful(), result.getProblems().toString());\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY));\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual, String message) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY), message);\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.utils;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParseStart;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.Problem;\nimport com.github.javaparser.ast.expr.Expression;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.github.javaparser.ParserConfiguration.LanguageLevel.JAVA_9;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.CodeGenerationUtils.f;\nimport static com.github.javaparser.utils.Utils.normalizeEolInTextBlock;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.Arrays.asList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TestUtils {\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>system's line separator</strong> to separate lines.\n     * Takes care of setting all the end of line character to platform specific ones.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResourceUsingSystemEol(String resourceName) {\n        return readResource(resourceName, LineEnding.SYSTEM);\n    }\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>given line separator</strong> to separate lines.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResource(String resourceName, LineEnding lineEnding) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"resource not found by name: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)) {\n                final StringBuilder builder = new StringBuilder(4096);\n                String line;\n                while ((line = br.readLine()) != null) {\n                    builder.append(line).append(lineEnding.toString());\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n\n    /**\n     * Read the resource's contents as-is.\n     * <br>\n     * <br>If you wish to specify the line endings,\n     * use {@link #readResourceUsingSystemEol(String)}\n     * or {@link #readResource(String, LineEnding)}\n     */\n    public static String readResource(String resourceName) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"not found: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)\n            ) {\n                // Switched to reading char-by-char as opposed to line-by-line.\n                // This helps to retain the resource's own line endings.\n                final StringBuilder builder = new StringBuilder(4096);\n                for (int c = br.read(); c != -1; c = br.read()) {\n                    builder.append((char) c);\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    /**\n     * Use this assertion if line endings are important, otherwise use {@link #assertEqualToTextResourceNoEol(String, String)}\n     */\n    public static void assertEqualToTextResource(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n        assertEqualsString(expected, actual);\n    }\n\n    /**\n     * If line endings are important, use {@link #assertEqualToTextResource(String, String)}\n     */\n    public static void assertEqualToTextResourceNoEol(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n        assertEqualsNoEol(expected, actual);\n    }\n\n    public static String readTextResource(Class<?> relativeClass, String resourceName) {\n        final URL resourceAsStream = relativeClass.getResource(resourceName);\n        try {\n            byte[] bytes = Files.readAllBytes(Paths.get(resourceAsStream.toURI()));\n            return new String(bytes, UTF_8);\n        } catch (IOException | URISyntaxException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    public static void assertInstanceOf(Class<?> expectedType, Object instance) {\n        assertTrue(expectedType.isAssignableFrom(instance.getClass()), f(\"%s is not an instance of %s.\", instance.getClass(), expectedType));\n    }\n\n    /**\n     * Unzip a zip file into a directory.\n     */\n    public static void unzip(Path zipFile, Path outputFolder) throws IOException {\n        Log.info(\"Unzipping %s to %s\", () -> zipFile, () -> outputFolder);\n\n        final byte[] buffer = new byte[1024 * 1024];\n\n        outputFolder.toFile().mkdirs();\n\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {\n            ZipEntry ze = zis.getNextEntry();\n\n            while (ze != null) {\n                final Path newFile = outputFolder.resolve(ze.getName());\n\n                if (ze.isDirectory()) {\n                    Log.trace(\"mkdir %s\", newFile::toAbsolutePath);\n                    newFile.toFile().mkdirs();\n                } else {\n                    Log.info(\"unzip %s\", newFile::toAbsolutePath);\n                    try (FileOutputStream fos = new FileOutputStream(newFile.toFile())) {\n                        int len;\n                        while ((len = zis.read(buffer)) > 0) {\n                            fos.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n\n        }\n        Log.info(\"Unzipped %s to %s\", () -> zipFile, () -> outputFolder);\n    }\n\n    /**\n     * Download a file from a URL to disk.\n     */\n    public static void download(URL url, Path destination) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        Response response = client.newCall(request).execute();\n        Files.write(destination, response.body().bytes());\n    }\n\n    public static String temporaryDirectory() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }\n\n    public static void assertCollections(Collection<?> expected, Collection<?> actual) {\n        final StringBuilder out = new StringBuilder();\n        for (Object e : expected) {\n            if (actual.contains(e)) {\n                actual.remove(e);\n            } else {\n                out.append(\"Missing: \").append(e).append(LineEnding.SYSTEM);\n            }\n        }\n        for (Object a : actual) {\n            out.append(\"Unexpected: \").append(a).append(LineEnding.SYSTEM);\n        }\n\n        String s = out.toString();\n        if (s.isEmpty()) {\n            return;\n        }\n        fail(s);\n    }\n\n    public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        assertProblems(result.getProblems(), expectedArg);\n    }\n\n    public static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>(asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\n    public static void assertNoProblems(ParseResult<?> result) {\n        assertProblems(result);\n    }\n\n    public static void assertExpressionValid(String expression) {\n        JavaParser javaParser = new JavaParser(new ParserConfiguration().setLanguageLevel(JAVA_9));\n        ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n        assertTrue(result.isSuccessful(), result.getProblems().toString());\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String)}\n     */\n    @Deprecated\n    public static void assertEqualsNoEol(String expected, String actual) {\n        assertEqualsStringIgnoringEol(expected, actual);\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String, String)}\n     */\n    @Deprecated\n    public static void assertEqualsNoEol(String expected, String actual, String message) {\n        assertEqualsStringIgnoringEol(expected, actual, message);\n    }\n\n\n    /**\n     * Assert that \"actual\" equals \"expected\".\n     * <br>First checks if the content is equal ignoring line separators.\n     * <br>If this passes, then we check if the content is equal - if this fails then we can\n     *  advise that the difference is <em>only</em> in the line separators.\n     */\n    public static void assertEqualsString(String expected, String actual) {\n        assertEqualsString(expected, actual, \"\");\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\".\n     * <br>First checks if the content is equal ignoring line separators.\n     * <br>If this passes, then we check if the content is equal - if this fails then we can\n     *  advise that the difference is <em>only</em> in the line separators.\n     */\n    public static void assertEqualsString(String expected, String actual, String message) {\n        // First test equality ignoring EOL chars\n        assertEqualsNoEol(expected, actual, message);\n\n        // If this passes but the next one fails, the failure is due only to EOL differences, allowing a more precise test failure message.\n        assertEquals(\n                expected,\n                actual,\n                message + String.format(\" -- failed due to line separator differences -- Expected: %s, but actual: %s (system eol: %s)\",\n                        LineEnding.detect(expected).escaped(),\n                        LineEnding.detect(actual).escaped(),\n                        LineEnding.SYSTEM.escaped()\n                )\n        );\n    }\n\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY)\n        );\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual, String message) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY),\n                message\n        );\n    }\n\n\n    /**\n     * Assert that the given string is detected as having the given line separator.\n     */\n    public static void assertLineSeparator(String text, LineEnding expectedLineSeparator) {\n        LineEnding actualLineSeparator = LineEnding.detect(text);\n        assertEquals(expectedLineSeparator, actualLineSeparator);\n    }\n\n    /**\n     * Assert that the given string is detected as having the given line separator.\n     */\n    public static void assertLineSeparator(String text, LineEnding expectedLineSeparator, String message) {\n        LineEnding actualLineSeparator = LineEnding.detect(text);\n        assertEquals(expectedLineSeparator, actualLineSeparator, message);\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY)\n        );\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String)}\n     */\n    @Deprecated\n    public static void assertEqualsNoEol(String expected, String actual) {\n        assertEqualsStringIgnoringEol(expected, actual);\n    }\n/**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY)\n        );\n    }", "diffSourceCode": "-  258:         assertCollections(expected, actual);\n-  259:     }\n-  260: \n-  261:     public static void assertNoProblems(ParseResult<?> result) {\n-  262:         assertProblems(result);\n-  263:     }\n-  264: \n-  265:     public static void assertExpressionValid(String expression) {\n-  271:     /**\n-  272:      * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n-  273:      */\n-  274:     public static void assertEqualsNoEol(String expected, String actual) {\n-  275:         assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY));\n-  276:     }\n+  258:     /**\n+  259:      * Assert that \"actual\" equals \"expected\", ignoring line separators.\n+  260:      * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String)}\n+  261:      */\n+  262:     @Deprecated\n+  263:     public static void assertEqualsNoEol(String expected, String actual) {\n+  264:         assertEqualsStringIgnoringEol(expected, actual);\n+  265:     }\n+  271:     @Deprecated\n+  272:     public static void assertEqualsNoEol(String expected, String actual, String message) {\n+  273:         assertEqualsStringIgnoringEol(expected, actual, message);\n+  274:     }\n+  275: \n+  276: \n+  310:     /**\n+  311:      * Assert that \"actual\" equals \"expected\", ignoring line separators.\n+  312:      */\n+  313:     public static void assertEqualsStringIgnoringEol(String expected, String actual) {\n+  314:         assertEqualsString(\n+  315:                 normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n+  316:                 normalizeEolInTextBlock(actual, LineEnding.ARBITRARY)\n+  317:         );\n+  318:     }\n", "uniqueId": "339d45a5694b569dee7bab605eb700a564975b6c_271_276_310_318_258_265", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `assertEqualsNoEol` method, we can extract the logic that normalizes the end-of-line characters into a separate method. This will make the code cleaner and allow for easier testing and modification of the normalization logic in the future.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\npublic static void assertEqualsNoEol(String expected, String actual) {\n    assertEquals(normalizeEol(expected), normalizeEol(actual));\n}\n\nprivate static String normalizeEol(String text) {\n    return normalizeEolInTextBlock(text, LineEnding.ARBITRARY);\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The normalization logic has been moved to a new private method called `normalizeEol`. This method takes a string and returns it normalized for end-of-line characters.\n2. **Simplified `assertEqualsNoEol`**: The `assertEqualsNoEol` method now simply calls the `normalizeEol` method for both the expected and actual strings, improving clarity. \n\nThis refactoring enhances the modularity of the code, making it easier to understand and maintain.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY));\n    }\n\nClass content:\n/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.utils;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParseStart;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.Problem;\nimport com.github.javaparser.ast.expr.Expression;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.github.javaparser.ParserConfiguration.LanguageLevel.JAVA_9;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.CodeGenerationUtils.f;\nimport static com.github.javaparser.utils.Utils.normalizeEolInTextBlock;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.Arrays.asList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TestUtils {\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>system's line separator</strong> to separate lines.\n     * Takes care of setting all the end of line character to platform specific ones.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResourceUsingSystemEol(String resourceName) {\n        return readResource(resourceName, LineEnding.SYSTEM);\n    }\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>given line separator</strong> to separate lines.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResource(String resourceName, LineEnding lineEnding) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"resource not found by name: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)) {\n                final StringBuilder builder = new StringBuilder(4096);\n                String line;\n                while ((line = br.readLine()) != null) {\n                    builder.append(line).append(lineEnding.toString());\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n\n    /**\n     * Read the resource's contents as-is.\n     * <br>\n     * <br>If you wish to specify the line endings,\n     * use {@link #readResourceUsingSystemEol(String)}\n     * or {@link #readResource(String, LineEnding)}\n     */\n    public static String readResource(String resourceName) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"not found: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)\n            ) {\n                // Switched to reading char-by-char as opposed to line-by-line.\n                // This helps to retain the resource's own line endings.\n                final StringBuilder builder = new StringBuilder(4096);\n                for (int c = br.read(); c != -1; c = br.read()) {\n                    builder.append((char) c);\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    /**\n     * Use this assertion if line endings are important, otherwise use {@link #assertEqualToTextResourceNoEol(String, String)}\n     */\n    public static void assertEqualToTextResource(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n\n        // First test equality ignoring EOL chars\n        assertEqualsNoEol(expected, actual);\n\n        // If this passes but the next one fails, the failure is due only to EOL differences, allowing a more precise test failure message.\n        assertEquals(\n                expected,\n                actual,\n                String.format(\"failed due to line separator differences -- Expected: %s, but actual: %s (system eol: %s)\",\n                        LineEnding.detect(expected).escaped(),\n                        LineEnding.detect(actual).escaped(),\n                        LineEnding.SYSTEM.escaped()\n                )\n        );\n    }\n\n    /**\n     * If line endings are important, use {@link #assertEqualToTextResource(String, String)}\n     */\n    public static void assertEqualToTextResourceNoEol(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n        assertEquals(expected, actual, \"failed due to line separator differences\");\n    }\n\n    public static String readTextResource(Class<?> relativeClass, String resourceName) {\n        final URL resourceAsStream = relativeClass.getResource(resourceName);\n        try {\n            byte[] bytes = Files.readAllBytes(Paths.get(resourceAsStream.toURI()));\n            return new String(bytes, UTF_8);\n        } catch (IOException | URISyntaxException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    public static void assertInstanceOf(Class<?> expectedType, Object instance) {\n        assertTrue(expectedType.isAssignableFrom(instance.getClass()), f(\"%s is not an instance of %s.\", instance.getClass(), expectedType));\n    }\n\n    /**\n     * Unzip a zip file into a directory.\n     */\n    public static void unzip(Path zipFile, Path outputFolder) throws IOException {\n        Log.info(\"Unzipping %s to %s\", () -> zipFile, () -> outputFolder);\n\n        final byte[] buffer = new byte[1024 * 1024];\n\n        outputFolder.toFile().mkdirs();\n\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {\n            ZipEntry ze = zis.getNextEntry();\n\n            while (ze != null) {\n                final Path newFile = outputFolder.resolve(ze.getName());\n\n                if (ze.isDirectory()) {\n                    Log.trace(\"mkdir %s\", newFile::toAbsolutePath);\n                    newFile.toFile().mkdirs();\n                } else {\n                    Log.info(\"unzip %s\", newFile::toAbsolutePath);\n                    try (FileOutputStream fos = new FileOutputStream(newFile.toFile())) {\n                        int len;\n                        while ((len = zis.read(buffer)) > 0) {\n                            fos.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n\n        }\n        Log.info(\"Unzipped %s to %s\", () -> zipFile, () -> outputFolder);\n    }\n\n    /**\n     * Download a file from a URL to disk.\n     */\n    public static void download(URL url, Path destination) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        Response response = client.newCall(request).execute();\n        Files.write(destination, response.body().bytes());\n    }\n\n    public static String temporaryDirectory() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }\n\n    public static void assertCollections(Collection<?> expected, Collection<?> actual) {\n        final StringBuilder out = new StringBuilder();\n        for (Object e : expected) {\n            if (actual.contains(e)) {\n                actual.remove(e);\n            } else {\n                out.append(\"Missing: \").append(e).append(LineEnding.SYSTEM);\n            }\n        }\n        for (Object a : actual) {\n            out.append(\"Unexpected: \").append(a).append(LineEnding.SYSTEM);\n        }\n\n        String s = out.toString();\n        if (s.isEmpty()) {\n            return;\n        }\n        fail(s);\n    }\n\n    public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        assertProblems(result.getProblems(), expectedArg);\n    }\n\n    public static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>(asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\n    public static void assertNoProblems(ParseResult<?> result) {\n        assertProblems(result);\n    }\n\n    public static void assertExpressionValid(String expression) {\n        JavaParser javaParser = new JavaParser(new ParserConfiguration().setLanguageLevel(JAVA_9));\n        ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n        assertTrue(result.isSuccessful(), result.getProblems().toString());\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY));\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual, String message) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY), message);\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpackage process(provider UnicodeEscapeProcessingProvider) : String extracted from private read(source String) : String in class com.github.javaparser.UnicodeEscapeProcessingProviderTest", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java", "startLine": 123, "endLine": 140, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java", "startLine": 123, "endLine": 125, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java", "startLine": 133, "endLine": 148, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private String read(String source) throws IOException {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java", "isPureRefactoring": true, "commitId": "baf9003923057506e2518c688bc1e5d09d5052d6", "packageNameBefore": "com.github.javaparser", "classNameBefore": "com.github.javaparser.UnicodeEscapeProcessingProviderTest", "methodNameBefore": "com.github.javaparser.UnicodeEscapeProcessingProviderTest#read", "invokedMethod": "methodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#read\n methodBody: public int read(char[] buffer, final int offset, int len) throws IOException {\nint pos=offset;\nint stop=offset + len;\nwhile(pos < stop){int ch=nextOutputChar();\nif(ch < 0){if(pos == offset){return EOF;\n}{break;\n}}{buffer[pos++]=(char)ch;\n}}return pos - offset;\n}\nmethodSignature: com.github.javaparser.UnicodeEscapeProcessingProviderTest#read\n methodBody: private String read(String source) throws IOException {\nUnicodeEscapeProcessingProvider provider=new UnicodeEscapeProcessingProvider(10,new StringProvider(source));\nStringBuilder result=new StringBuilder();\nchar[] buffer=new char[10];\nwhile(true){int direct=provider.read(buffer,0,buffer.length);\nif(direct < 0){break;\n}result.append(buffer,0,direct);\n}provider.close();\nreturn result.toString();\n}\nmethodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#close\n methodBody: public void close() throws IOException {\n_input.close();\n}", "classSignatureBefore": "public class UnicodeEscapeProcessingProviderTest ", "methodNameBeforeSet": ["com.github.javaparser.UnicodeEscapeProcessingProviderTest#read"], "classNameBeforeSet": ["com.github.javaparser.UnicodeEscapeProcessingProviderTest"], "classSignatureBeforeSet": ["public class UnicodeEscapeProcessingProviderTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for {@link UnicodeEscapeProcessingProvider}.\n */\npublic class UnicodeEscapeProcessingProviderTest {\n\n\t@Test\n\tvoid testUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\u12aA98\")));\n\t}\n\n\t@Test\n\tvoid testEscapedUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\\\\\\\\u12aA98\", new String(read(\"13\\\\\\\\u12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testUnicodeEscapeWithMultipleUs() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\uuuuuu12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslash() throws IOException {\n\t\tassertEquals(\"foobar\\\\\", new String(read(\"foobar\\\\\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU() throws IOException {\n\t\tassertEquals(\"foobar\\\\u\", new String(read(\"foobar\\\\u\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashUs() throws IOException {\n\t\tassertEquals(\"foobar\\\\uuuuuu\", new String(read(\"foobar\\\\uuuuuu\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU1() throws IOException {\n\t\tassertEquals(\"foobar\\\\uA\", new String(read(\"foobar\\\\uA\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU2() throws IOException {\n\t\tassertEquals(\"foobar\\\\uAB\", new String(read(\"foobar\\\\uAB\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU3() throws IOException {\n\t\tassertEquals(\"foobar\\\\uABC\", new String(read(\"foobar\\\\uABC\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingUnicodeEscape() throws IOException {\n\t\tassertEquals(\"foobar\\uABCD\", new String(read(\"foobar\\\\uABCD\")));\n\t}\n\t\n\t@Test\n\tvoid testEmptyInput() throws IOException {\n\t\tassertEquals(\"\", new String(read(\"\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape0() throws IOException {\n\t\tassertEquals(\"13\\\\ux\", new String(read(\"13\\\\ux\")));\n\t}\n\t\n\t@Test\n\tvoid testBadUnicodeEscape1() throws IOException {\n\t\tassertEquals(\"13\\\\u1x\", new String(read(\"13\\\\u1x\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape2() throws IOException {\n\t\tassertEquals(\"13\\\\u1Ax\", new String(read(\"13\\\\u1Ax\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape3() throws IOException {\n\t\tassertEquals(\"13\\\\u1ABx\", new String(read(\"13\\\\u1ABx\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscapeMultipleUs() throws IOException {\n\t\tassertEquals(\"13\\\\uuuuuu1ABx\", new String(read(\"13\\\\uuuuuu1ABx\")));\n\t}\n\n\t@Test\n\tvoid testPushBackWithFullBuffer() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\", new String(read(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\")));\n\t}\n\t\n\t@Test\n\tvoid testPushBackWithBufferShift() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxx\", new String(read(\"12345678\\\\uuxx\")));\n\t}\n\t\n\tprivate String read(String source) throws IOException {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for {@link UnicodeEscapeProcessingProvider}.\n */\npublic class UnicodeEscapeProcessingProviderTest {\n\n\t@Test\n\tvoid testUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\u12aA98\")));\n\t}\n\n\t@Test\n\tvoid testEscapedUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\\\\\\\\u12aA98\", new String(read(\"13\\\\\\\\u12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testUnicodeEscapeWithMultipleUs() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\uuuuuu12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslash() throws IOException {\n\t\tassertEquals(\"foobar\\\\\", new String(read(\"foobar\\\\\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU() throws IOException {\n\t\tassertEquals(\"foobar\\\\u\", new String(read(\"foobar\\\\u\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashUs() throws IOException {\n\t\tassertEquals(\"foobar\\\\uuuuuu\", new String(read(\"foobar\\\\uuuuuu\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU1() throws IOException {\n\t\tassertEquals(\"foobar\\\\uA\", new String(read(\"foobar\\\\uA\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU2() throws IOException {\n\t\tassertEquals(\"foobar\\\\uAB\", new String(read(\"foobar\\\\uAB\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU3() throws IOException {\n\t\tassertEquals(\"foobar\\\\uABC\", new String(read(\"foobar\\\\uABC\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingUnicodeEscape() throws IOException {\n\t\tassertEquals(\"foobar\\uABCD\", new String(read(\"foobar\\\\uABCD\")));\n\t}\n\t\n\t@Test\n\tvoid testEmptyInput() throws IOException {\n\t\tassertEquals(\"\", new String(read(\"\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape0() throws IOException {\n\t\tassertEquals(\"13\\\\ux\", new String(read(\"13\\\\ux\")));\n\t}\n\t\n\t@Test\n\tvoid testBadUnicodeEscape1() throws IOException {\n\t\tassertEquals(\"13\\\\u1x\", new String(read(\"13\\\\u1x\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape2() throws IOException {\n\t\tassertEquals(\"13\\\\u1Ax\", new String(read(\"13\\\\u1Ax\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape3() throws IOException {\n\t\tassertEquals(\"13\\\\u1ABx\", new String(read(\"13\\\\u1ABx\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscapeMultipleUs() throws IOException {\n\t\tassertEquals(\"13\\\\uuuuuu1ABx\", new String(read(\"13\\\\uuuuuu1ABx\")));\n\t}\n\n\t@Test\n\tvoid testPushBackWithFullBuffer() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\", new String(read(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\")));\n\t}\n\t\n\t@Test\n\tvoid testPushBackWithBufferShift() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxx\", new String(read(\"12345678\\\\uuxx\")));\n\t}\n\t\n\tstatic String read(String source) throws IOException {\n\t\treturn process(provider(source));\n\t}\n\n\tstatic UnicodeEscapeProcessingProvider provider(String source) {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\treturn provider;\n\t}\n\n\tstatic String process(UnicodeEscapeProcessingProvider provider)\n\t\t\tthrows IOException {\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}\n}\n", "diffSourceCodeSet": ["static String process(UnicodeEscapeProcessingProvider provider)\n\t\t\tthrows IOException {\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}"], "invokedMethodSet": ["methodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#read\n methodBody: public int read(char[] buffer, final int offset, int len) throws IOException {\nint pos=offset;\nint stop=offset + len;\nwhile(pos < stop){int ch=nextOutputChar();\nif(ch < 0){if(pos == offset){return EOF;\n}{break;\n}}{buffer[pos++]=(char)ch;\n}}return pos - offset;\n}", "methodSignature: com.github.javaparser.UnicodeEscapeProcessingProviderTest#read\n methodBody: private String read(String source) throws IOException {\nUnicodeEscapeProcessingProvider provider=new UnicodeEscapeProcessingProvider(10,new StringProvider(source));\nStringBuilder result=new StringBuilder();\nchar[] buffer=new char[10];\nwhile(true){int direct=provider.read(buffer,0,buffer.length);\nif(direct < 0){break;\n}result.append(buffer,0,direct);\n}provider.close();\nreturn result.toString();\n}", "methodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#close\n methodBody: public void close() throws IOException {\n_input.close();\n}"], "sourceCodeAfterRefactoring": "static String read(String source) throws IOException {\n\t\treturn process(provider(source));\n\t}\nstatic String process(UnicodeEscapeProcessingProvider provider)\n\t\t\tthrows IOException {\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}", "diffSourceCode": "-  123: \tprivate String read(String source) throws IOException {\n-  124: \t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n-  125: \t\t\t\tnew StringProvider(source));\n-  126: \t\n-  127: \t\tStringBuilder result = new StringBuilder();\n-  128: \t\tchar[] buffer = new char[10];\n-  129: \t\twhile (true) {\n-  130: \t\t\tint direct = provider.read(buffer, 0, buffer.length);\n-  131: \t\t\tif (direct < 0) {\n-  132: \t\t\t\tbreak;\n-  133: \t\t\t}\n-  134: \t\t\tresult.append(buffer, 0, direct);\n-  135: \t\t}\n-  136: \t\t\n-  137: \t\tprovider.close();\n-  138: \t\n-  139: \t\treturn result.toString();\n-  140: \t}\n-  141: }\n+  123: \tstatic String read(String source) throws IOException {\n+  124: \t\treturn process(provider(source));\n+  125: \t}\n+  126: \n+  127: \tstatic UnicodeEscapeProcessingProvider provider(String source) {\n+  128: \t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n+  129: \t\t\t\tnew StringProvider(source));\n+  130: \t\treturn provider;\n+  131: \t}\n+  132: \n+  133: \tstatic String process(UnicodeEscapeProcessingProvider provider)\n+  134: \t\t\tthrows IOException {\n+  135: \t\tStringBuilder result = new StringBuilder();\n+  136: \t\tchar[] buffer = new char[10];\n+  137: \t\twhile (true) {\n+  138: \t\t\tint direct = provider.read(buffer, 0, buffer.length);\n+  139: \t\t\tif (direct < 0) {\n+  140: \t\t\t\tbreak;\n+  141: \t\t\t}\n+  142: \t\t\tresult.append(buffer, 0, direct);\n+  143: \t\t}\n+  144: \t\t\n+  145: \t\tprovider.close();\n+  146: \t\n+  147: \t\treturn result.toString();\n+  148: \t}\n", "uniqueId": "baf9003923057506e2518c688bc1e5d09d5052d6_123_140_133_148_123_125", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `read` method, we can extract the logic that reads from the `UnicodeEscapeProcessingProvider` into a separate method. This will make the code cleaner and allow for easier testing and modification of the reading logic in the future.\n\nHere\u2019s the refactored code:\n\n##########################\n```java\nprivate String read(String source) throws IOException {\n    UnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n            new StringProvider(source));\n    \n    String result = readFromProvider(provider);\n    \n    provider.close();\n    \n    return result;\n}\n\nprivate String readFromProvider(UnicodeEscapeProcessingProvider provider) throws IOException {\n    StringBuilder result = new StringBuilder();\n    char[] buffer = new char[10];\n    while (true) {\n        int direct = provider.read(buffer, 0, buffer.length);\n        if (direct < 0) {\n            break;\n        }\n        result.append(buffer, 0, direct);\n    }\n    return result.toString();\n}\n```\n##########################\n\nIn this refactored code:\n- The `readFromProvider` method encapsulates the logic for reading from the `UnicodeEscapeProcessingProvider`, making the `read` method cleaner and more focused on its primary responsibility.\n- This separation allows for easier testing of the reading logic independently if needed.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate String read(String source) throws IOException {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}\n\nClass content:\n/*\n * Copyright (C) 2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for {@link UnicodeEscapeProcessingProvider}.\n */\npublic class UnicodeEscapeProcessingProviderTest {\n\n\t@Test\n\tvoid testUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\u12aA98\")));\n\t}\n\n\t@Test\n\tvoid testEscapedUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\\\\\\\\u12aA98\", new String(read(\"13\\\\\\\\u12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testUnicodeEscapeWithMultipleUs() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\uuuuuu12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslash() throws IOException {\n\t\tassertEquals(\"foobar\\\\\", new String(read(\"foobar\\\\\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU() throws IOException {\n\t\tassertEquals(\"foobar\\\\u\", new String(read(\"foobar\\\\u\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashUs() throws IOException {\n\t\tassertEquals(\"foobar\\\\uuuuuu\", new String(read(\"foobar\\\\uuuuuu\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU1() throws IOException {\n\t\tassertEquals(\"foobar\\\\uA\", new String(read(\"foobar\\\\uA\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU2() throws IOException {\n\t\tassertEquals(\"foobar\\\\uAB\", new String(read(\"foobar\\\\uAB\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU3() throws IOException {\n\t\tassertEquals(\"foobar\\\\uABC\", new String(read(\"foobar\\\\uABC\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingUnicodeEscape() throws IOException {\n\t\tassertEquals(\"foobar\\uABCD\", new String(read(\"foobar\\\\uABCD\")));\n\t}\n\t\n\t@Test\n\tvoid testEmptyInput() throws IOException {\n\t\tassertEquals(\"\", new String(read(\"\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape0() throws IOException {\n\t\tassertEquals(\"13\\\\ux\", new String(read(\"13\\\\ux\")));\n\t}\n\t\n\t@Test\n\tvoid testBadUnicodeEscape1() throws IOException {\n\t\tassertEquals(\"13\\\\u1x\", new String(read(\"13\\\\u1x\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape2() throws IOException {\n\t\tassertEquals(\"13\\\\u1Ax\", new String(read(\"13\\\\u1Ax\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape3() throws IOException {\n\t\tassertEquals(\"13\\\\u1ABx\", new String(read(\"13\\\\u1ABx\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscapeMultipleUs() throws IOException {\n\t\tassertEquals(\"13\\\\uuuuuu1ABx\", new String(read(\"13\\\\uuuuuu1ABx\")));\n\t}\n\n\t@Test\n\tvoid testPushBackWithFullBuffer() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\", new String(read(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\")));\n\t}\n\t\n\t@Test\n\tvoid testPushBackWithBufferShift() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxx\", new String(read(\"12345678\\\\uuxx\")));\n\t}\n\t\n\tprivate String read(String source) throws IOException {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpublic topEnum() : void from class com.github.javaparser.ast.validator.Java1_2ValidatorTest to public topEnum() : void from class com.github.javaparser.ast.validator.Java5ValidatorTest", "diffLocations": [{"filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java", "startLine": 110, "endLine": 129, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java5ValidatorTest.java", "startLine": 81, "endLine": 100, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void topEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'abstract' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }", "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java", "isPureRefactoring": true, "commitId": "da6302311ef508f830434a997a9b61f24750c6a1", "packageNameBefore": "com.github.javaparser.ast.validator", "classNameBefore": "com.github.javaparser.ast.validator.Java1_2ValidatorTest", "methodNameBefore": "com.github.javaparser.ast.validator.Java1_2ValidatorTest#topEnum", "classSignatureBefore": "public class Java1_2ValidatorTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.validator.Java1_2ValidatorTest#topEnum"], "classNameBeforeSet": ["com.github.javaparser.ast.validator.Java1_2ValidatorTest"], "classSignatureBeforeSet": ["public class Java1_2ValidatorTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class Java1_2ValidatorTest {\n    public static final JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java1_2Validator()));\n\n    private final String allModifiers = \"public protected private abstract static final transient volatile synchronized native strictfp transitive default \";\n\n    @Test\n    public void topClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"class X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"class I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{ void x() {\" + allModifiers + \"class I{}}}\"));\n        assertProblems(result,\n                \"(line 1,col 20) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 20) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 20) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 20) 'transient' is not allowed here.\",\n                \"(line 1,col 20) 'volatile' is not allowed here.\",\n                \"(line 1,col 20) 'default' is not allowed here.\",\n                \"(line 1,col 20) 'synchronized' is not allowed here.\",\n                \"(line 1,col 20) 'native' is not allowed here.\",\n                \"(line 1,col 20) 'transitive' is not allowed here.\",\n                \"(line 1,col 20) 'static' is not allowed here.\",\n                \"(line 1,col 20) 'public' is not allowed here.\",\n                \"(line 1,col 20) 'private' is not allowed here.\",\n                \"(line 1,col 20) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"interface X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"interface I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'abstract' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n    @Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructor() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"X(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'static' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructorParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{X(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 11) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 11) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 11) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 11) 'transient' is not allowed here.\",\n                \"(line 1,col 11) 'volatile' is not allowed here.\",\n                \"(line 1,col 11) 'synchronized' is not allowed here.\",\n                \"(line 1,col 11) 'native' is not allowed here.\",\n                \"(line 1,col 11) 'strictfp' is not allowed here.\",\n                \"(line 1,col 11) 'default' is not allowed here.\",\n                \"(line 1,col 11) 'abstract' is not allowed here.\",\n                \"(line 1,col 11) 'static' is not allowed here.\",\n                \"(line 1,col 11) 'transitive' is not allowed here.\",\n                \"(line 1,col 11) 'private' is not allowed here.\",\n                \"(line 1,col 11) 'public' is not allowed here.\",\n                \"(line 1,col 11) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void classMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void interfaceMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"interface X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 13) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 13) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 13) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 13) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 13) 'transient' is not allowed here.\",\n                \"(line 1,col 13) 'volatile' is not allowed here.\",\n                \"(line 1,col 13) 'default' is not allowed here.\",\n                \"(line 1,col 13) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void methodParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 15) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 15) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 15) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 15) 'transient' is not allowed here.\",\n                \"(line 1,col 15) 'volatile' is not allowed here.\",\n                \"(line 1,col 15) 'synchronized' is not allowed here.\",\n                \"(line 1,col 15) 'native' is not allowed here.\",\n                \"(line 1,col 15) 'strictfp' is not allowed here.\",\n                \"(line 1,col 15) 'abstract' is not allowed here.\",\n                \"(line 1,col 15) 'default' is not allowed here.\",\n                \"(line 1,col 15) 'static' is not allowed here.\",\n                \"(line 1,col 15) 'transitive' is not allowed here.\",\n                \"(line 1,col 15) 'private' is not allowed here.\",\n                \"(line 1,col 15) 'public' is not allowed here.\",\n                \"(line 1,col 15) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void field() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int i;}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localVariable() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){\" + allModifiers + \"int i;}}\"));\n        assertProblems(result,\n                \"(line 1,col 17) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 17) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 17) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 17) 'transient' is not allowed here.\",\n                \"(line 1,col 17) 'volatile' is not allowed here.\",\n                \"(line 1,col 17) 'synchronized' is not allowed here.\",\n                \"(line 1,col 17) 'native' is not allowed here.\",\n                \"(line 1,col 17) 'default' is not allowed here.\",\n                \"(line 1,col 17) 'strictfp' is not allowed here.\",\n                \"(line 1,col 17) 'abstract' is not allowed here.\",\n                \"(line 1,col 17) 'static' is not allowed here.\",\n                \"(line 1,col 17) 'transitive' is not allowed here.\",\n                \"(line 1,col 17) 'private' is not allowed here.\",\n                \"(line 1,col 17) 'public' is not allowed here.\",\n                \"(line 1,col 17) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void catchParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){ try{}catch(\"+ allModifiers +\" Integer x){}}}\"));\n        assertProblems(result,\n                \"(line 1,col 144) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 144) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 144) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 144) 'transient' is not allowed here.\",\n                \"(line 1,col 144) 'volatile' is not allowed here.\",\n                \"(line 1,col 144) 'synchronized' is not allowed here.\",\n                \"(line 1,col 144) 'native' is not allowed here.\",\n                \"(line 1,col 144) 'default' is not allowed here.\",\n                \"(line 1,col 144) 'strictfp' is not allowed here.\",\n                \"(line 1,col 144) 'abstract' is not allowed here.\",\n                \"(line 1,col 144) 'static' is not allowed here.\",\n                \"(line 1,col 144) 'transitive' is not allowed here.\",\n                \"(line 1,col 144) 'private' is not allowed here.\",\n                \"(line 1,col 144) 'public' is not allowed here.\",\n                \"(line 1,col 144) 'protected' is not allowed here.\"\n        );\n    }\n}\n", "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java5ValidatorTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.ast.validator.Java1_1ValidatorTest.allModifiers;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class Java5ValidatorTest {\n    public static final JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java5Validator()));\n\n    @Test\n    public void genericsWithoutDiamond() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X<A>{List<String> b = new ArrayList<>();}\"));\n        assertProblems(result, \"(line 1,col 33) The diamond operator is not supported.\");\n    }\n\n    @Test\n    public void topAnnotationDeclaration() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"@interface X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedAnnotationDeclaration() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"@interface I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void annotationMember() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"@interface X{\" + allModifiers + \"int x();}\"));\n        assertProblems(result,\n                \"(line 1,col 14) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 14) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 14) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 14) 'transient' is not allowed here.\",\n                \"(line 1,col 14) 'volatile' is not allowed here.\",\n                \"(line 1,col 14) 'final' is not allowed here.\",\n                \"(line 1,col 14) 'synchronized' is not allowed here.\",\n                \"(line 1,col 14) 'default' is not allowed here.\",\n                \"(line 1,col 14) 'native' is not allowed here.\",\n                \"(line 1,col 14) 'protected' is not allowed here.\",\n                \"(line 1,col 14) 'private' is not allowed here.\",\n                \"(line 1,col 14) 'strictfp' is not allowed here.\",\n                \"(line 1,col 14) 'static' is not allowed here.\",\n                \"(line 1,col 14) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'abstract' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Test\n    public void topEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'abstract' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }", "diffSourceCode": "-   81:                 \"(line 1,col 1) 'volatile' is not allowed here.\",\n-   82:                 \"(line 1,col 1) 'default' is not allowed here.\",\n-   83:                 \"(line 1,col 1) 'synchronized' is not allowed here.\",\n-   84:                 \"(line 1,col 1) 'native' is not allowed here.\",\n-   85:                 \"(line 1,col 1) 'transitive' is not allowed here.\",\n-   86:                 \"(line 1,col 1) 'static' is not allowed here.\",\n-   87:                 \"(line 1,col 1) 'final' is not allowed here.\",\n-   88:                 \"(line 1,col 1) 'private' is not allowed here.\",\n-   89:                 \"(line 1,col 1) 'protected' is not allowed here.\"\n-   90:         );\n-   91:     }\n-   92: \n-   93:     @Test\n-   94:     public void nestedInterface() {\n-   95:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"interface I{}}\"));\n-   96:         assertProblems(result,\n-   97:                 \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n-   98:                 \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n-   99:                 \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n-  100:                 \"(line 1,col 9) 'transient' is not allowed here.\",\n-  110:     @Test\n-  111:     public void topEnum() {\n-  112:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n-  113:         assertProblems(result,\n-  114:                 \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n-  115:                 \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n-  116:                 \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n-  117:                 \"(line 1,col 1) 'transient' is not allowed here.\",\n-  118:                 \"(line 1,col 1) 'volatile' is not allowed here.\",\n-  119:                 \"(line 1,col 1) 'synchronized' is not allowed here.\",\n-  120:                 \"(line 1,col 1) 'default' is not allowed here.\",\n-  121:                 \"(line 1,col 1) 'native' is not allowed here.\",\n-  122:                 \"(line 1,col 1) 'transitive' is not allowed here.\",\n-  123:                 \"(line 1,col 1) 'static' is not allowed here.\",\n-  124:                 \"(line 1,col 1) 'abstract' is not allowed here.\",\n-  125:                 \"(line 1,col 1) 'final' is not allowed here.\",\n-  126:                 \"(line 1,col 1) 'private' is not allowed here.\",\n-  127:                 \"(line 1,col 1) 'protected' is not allowed here.\"\n-  128:         );\n-  129:     }\n+   81:     @Test\n+   82:     public void topEnum() {\n+   83:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n+   84:         assertProblems(result,\n+   85:                 \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n+   86:                 \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n+   87:                 \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n+   88:                 \"(line 1,col 1) 'transient' is not allowed here.\",\n+   89:                 \"(line 1,col 1) 'volatile' is not allowed here.\",\n+   90:                 \"(line 1,col 1) 'synchronized' is not allowed here.\",\n+   91:                 \"(line 1,col 1) 'default' is not allowed here.\",\n+   92:                 \"(line 1,col 1) 'native' is not allowed here.\",\n+   93:                 \"(line 1,col 1) 'transitive' is not allowed here.\",\n+   94:                 \"(line 1,col 1) 'static' is not allowed here.\",\n+   95:                 \"(line 1,col 1) 'abstract' is not allowed here.\",\n+   96:                 \"(line 1,col 1) 'final' is not allowed here.\",\n+   97:                 \"(line 1,col 1) 'private' is not allowed here.\",\n+   98:                 \"(line 1,col 1) 'protected' is not allowed here.\"\n+   99:         );\n+  100:     }\n+  110:                 \"(line 1,col 9) 'volatile' is not allowed here.\",\n+  111:                 \"(line 1,col 9) 'default' is not allowed here.\",\n+  112:                 \"(line 1,col 9) 'abstract' is not allowed here.\",\n+  113:                 \"(line 1,col 9) 'final' is not allowed here.\",\n+  114:                 \"(line 1,col 9) 'synchronized' is not allowed here.\",\n+  115:                 \"(line 1,col 9) 'native' is not allowed here.\",\n+  116:                 \"(line 1,col 9) 'transitive' is not allowed here.\"\n+  117:         );\n+  118:     }\n+  119: \n+  120: }\n", "uniqueId": "da6302311ef508f830434a997a9b61f24750c6a1_110_129__81_100", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To perform the requested refactoring operation, we will move the `topEnum` method from the `Java1_2ValidatorTest` class to an existing test class. Given the project structure, it makes sense to move it to the `Java1_2ValidatorTest` class itself, as it is the most relevant class for the context of the test.\n\n### Step 1: Identify the target file path\nThe target file path for the moved method will be:\n```\njavaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java\n```\n\n### Step 2: Moved class code\nThe moved class code will be the `topEnum` method itself, which will be updated to be a public static method.\n\n```java\npublic static void topEnum() {\n    ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n    assertProblems(result,\n            \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n            \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n            \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n            \"(line 1,col 1) 'transient' is not allowed here.\",\n            \"(line 1,col 1) 'volatile' is not allowed here.\",\n            \"(line 1,col 1) 'synchronized' is not allowed here.\",\n            \"(line 1,col 1) 'default' is not allowed here.\",\n            \"(line 1,col 1) 'native' is not allowed here.\",\n            \"(line 1,col 1) 'transitive' is not allowed here.\",\n            \"(line 1,col 1) 'static' is not allowed here.\",\n            \"(line 1,col 1) 'abstract' is not allowed here.\",\n            \"(line 1,col 1) 'final' is not allowed here.\",\n            \"(line 1,col 1) 'private' is not allowed here.\",\n            \"(line 1,col 1) 'protected' is not allowed here.\"\n    );\n}\n```\n\n### Step 3: Refactored method code\nThe `topEnum` method will be called from the original `topEnum` method in the `Java1_2ValidatorTest` class. The refactored method code will look like this:\n\n```java\n@Test\npublic void topEnum() {\n    Java1_2ValidatorTest.topEnum();\n}\n```\n\n### Final Output\nNow, we can present the final output in the required format:\n\n##########################\njavaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java\n##########################\npublic static void topEnum() {\n    ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n    assertProblems(result,\n            \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n            \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n            \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n            \"(line 1,col 1) 'transient' is not allowed here.\",\n            \"(line 1,col 1) 'volatile' is not allowed here.\",\n            \"(line 1,col 1) 'synchronized' is not allowed here.\",\n            \"(line 1,col 1) 'default' is not allowed here.\",\n            \"(line 1,col 1) 'native' is not allowed here.\",\n            \"(line 1,col 1) 'transitive' is not allowed here.\",\n            \"(line 1,col 1) 'static' is not allowed here.\",\n            \"(line 1,col 1) 'abstract' is not allowed here.\",\n            \"(line 1,col 1) 'final' is not allowed here.\",\n            \"(line 1,col 1) 'private' is not allowed here.\",\n            \"(line 1,col 1) 'protected' is not allowed here.\"\n    );\n}\n##########################\n@Test\npublic void topEnum() {\n    Java1_2ValidatorTest.topEnum();\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    public void topEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'abstract' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\nClass content:\npackage com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class Java1_2ValidatorTest {\n    public static final JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java1_2Validator()));\n\n    private final String allModifiers = \"public protected private abstract static final transient volatile synchronized native strictfp transitive default \";\n\n    @Test\n    public void topClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"class X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"class I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{ void x() {\" + allModifiers + \"class I{}}}\"));\n        assertProblems(result,\n                \"(line 1,col 20) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 20) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 20) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 20) 'transient' is not allowed here.\",\n                \"(line 1,col 20) 'volatile' is not allowed here.\",\n                \"(line 1,col 20) 'default' is not allowed here.\",\n                \"(line 1,col 20) 'synchronized' is not allowed here.\",\n                \"(line 1,col 20) 'native' is not allowed here.\",\n                \"(line 1,col 20) 'transitive' is not allowed here.\",\n                \"(line 1,col 20) 'static' is not allowed here.\",\n                \"(line 1,col 20) 'public' is not allowed here.\",\n                \"(line 1,col 20) 'private' is not allowed here.\",\n                \"(line 1,col 20) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"interface X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"interface I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'abstract' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n    @Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructor() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"X(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'static' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructorParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{X(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 11) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 11) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 11) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 11) 'transient' is not allowed here.\",\n                \"(line 1,col 11) 'volatile' is not allowed here.\",\n                \"(line 1,col 11) 'synchronized' is not allowed here.\",\n                \"(line 1,col 11) 'native' is not allowed here.\",\n                \"(line 1,col 11) 'strictfp' is not allowed here.\",\n                \"(line 1,col 11) 'default' is not allowed here.\",\n                \"(line 1,col 11) 'abstract' is not allowed here.\",\n                \"(line 1,col 11) 'static' is not allowed here.\",\n                \"(line 1,col 11) 'transitive' is not allowed here.\",\n                \"(line 1,col 11) 'private' is not allowed here.\",\n                \"(line 1,col 11) 'public' is not allowed here.\",\n                \"(line 1,col 11) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void classMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void interfaceMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"interface X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 13) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 13) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 13) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 13) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 13) 'transient' is not allowed here.\",\n                \"(line 1,col 13) 'volatile' is not allowed here.\",\n                \"(line 1,col 13) 'default' is not allowed here.\",\n                \"(line 1,col 13) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void methodParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 15) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 15) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 15) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 15) 'transient' is not allowed here.\",\n                \"(line 1,col 15) 'volatile' is not allowed here.\",\n                \"(line 1,col 15) 'synchronized' is not allowed here.\",\n                \"(line 1,col 15) 'native' is not allowed here.\",\n                \"(line 1,col 15) 'strictfp' is not allowed here.\",\n                \"(line 1,col 15) 'abstract' is not allowed here.\",\n                \"(line 1,col 15) 'default' is not allowed here.\",\n                \"(line 1,col 15) 'static' is not allowed here.\",\n                \"(line 1,col 15) 'transitive' is not allowed here.\",\n                \"(line 1,col 15) 'private' is not allowed here.\",\n                \"(line 1,col 15) 'public' is not allowed here.\",\n                \"(line 1,col 15) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void field() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int i;}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localVariable() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){\" + allModifiers + \"int i;}}\"));\n        assertProblems(result,\n                \"(line 1,col 17) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 17) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 17) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 17) 'transient' is not allowed here.\",\n                \"(line 1,col 17) 'volatile' is not allowed here.\",\n                \"(line 1,col 17) 'synchronized' is not allowed here.\",\n                \"(line 1,col 17) 'native' is not allowed here.\",\n                \"(line 1,col 17) 'default' is not allowed here.\",\n                \"(line 1,col 17) 'strictfp' is not allowed here.\",\n                \"(line 1,col 17) 'abstract' is not allowed here.\",\n                \"(line 1,col 17) 'static' is not allowed here.\",\n                \"(line 1,col 17) 'transitive' is not allowed here.\",\n                \"(line 1,col 17) 'private' is not allowed here.\",\n                \"(line 1,col 17) 'public' is not allowed here.\",\n                \"(line 1,col 17) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void catchParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){ try{}catch(\"+ allModifiers +\" Integer x){}}}\"));\n        assertProblems(result,\n                \"(line 1,col 144) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 144) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 144) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 144) 'transient' is not allowed here.\",\n                \"(line 1,col 144) 'volatile' is not allowed here.\",\n                \"(line 1,col 144) 'synchronized' is not allowed here.\",\n                \"(line 1,col 144) 'native' is not allowed here.\",\n                \"(line 1,col 144) 'default' is not allowed here.\",\n                \"(line 1,col 144) 'strictfp' is not allowed here.\",\n                \"(line 1,col 144) 'abstract' is not allowed here.\",\n                \"(line 1,col 144) 'static' is not allowed here.\",\n                \"(line 1,col 144) 'transitive' is not allowed here.\",\n                \"(line 1,col 144) 'private' is not allowed here.\",\n                \"(line 1,col 144) 'public' is not allowed here.\",\n                \"(line 1,col 144) 'protected' is not allowed here.\"\n        );\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['javaparser-testing/src/test/java/com/github/javaparser/CommentsInserterTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/JavaParserTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/JavaTokenTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/JavadocParserTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ProblemTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ProvidersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/RangeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/CompilationUnitTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/DataKeyTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/NodeListTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/NodePositionTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/NodeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/ParseResultTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/body/AnnotationMemberDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/body/MethodDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/comments/CommentTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/InstanceOfExprTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/MethodReferenceTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/NameTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/SimpleNameTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/imports/ImportDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithJavadocTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithModifiersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithOptionalScopeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithVariablesTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/observer/PropagatingAstObserverTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/stmt/BlockStmtTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/type/ArrayTypeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/type/TypeConstructionTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_0ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_1ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_3ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_4ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java5ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java6ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java7ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java8ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java9ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/CloneVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/HashCodeVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/ModifierVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/TreeStructureVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/TreeVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/BasicJBehaveTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/CommentParsingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ComparingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ManipulationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ParsingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/PositionRangeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/PrettyPrintingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/TestUtils.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/VisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ComparingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ExistenceOfParentNodeVerifier.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ManipulationSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ParsingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/PositionRangeSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/PrettyPrintingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/SharedSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/VisitorSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/visitors/PositionTestVisitor.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/ClassOrInterfaceDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/CompilationUnitBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/EnumDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/FieldDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithAnnotationsBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithMembersBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithParametersBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithThrownExceptionsBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/javadoc/JavadocExtractorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/javadoc/JavadocTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/javadoc/description/JavadocInlineTagTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/manual/BulkParseTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/metamodel/BaseNodeMetaModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/metamodel/JavaParserMetaModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/metamodel/PropertyMetaModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/modules/ModuleDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelAcceptanceTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/PrettyPrintVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/PrettyPrinterTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/TestVisitor.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/AbstractLexicalPreservingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/DifferenceTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinterTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/TransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/ArrayCreationLevelTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/CompilationUnitTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationMemberDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ClassOrInterfaceDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ConstructorDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumConstantDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/FieldDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/InitializerDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/MethodDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/remove/NodeRemovalTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/CodeGenerationUtilsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/SourceRootTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/UtilsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/ChangingMethodsFromAClassWithAVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/ChangingMethodsFromAClassWithoutAVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/ClassCreator.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/CreatingACompilationUnitFromScratch.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/CuPrinter.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/MethodChanger_1.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/MethodChanger_2.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/MethodPrinter.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/PrintingTheCompilationUnitToSystemOutputTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/TestFileToken.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/VisitingClassMethodsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/removenode/D.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/removenode/ModifierVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/removenode/RemoveDeleteNodeFromAst.java', 'javaparser-testing/src/test/resources/com/github/javaparser/TestFileIso88591.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/ClassInLatin1.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/JavaConcepts.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/package-info.java', 'javaparser-testing/src/test/resources/com/github/javaparser/printer/JavaConcepts_saved.java', 'javaparser-testing/src/test/resources/com/github/javaparser/printer/PrettyPrintVisitor_saved.java', 'javaparser-testing/src/test/resources/com/github/javaparser/utils/Bla.java', 'javaparser-testing/src/test/resources/com/github/javaparser/utils/module-info.java', 'javaparser-testing/src/test/resources/com/github/javaparser/utils/source/root/Y.java', 'javaparser-testing/src/test/resources/com/github/javaparser/wiki_samples/TestFile.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract And Move Method", "description": "Extract And Move Method\tpublic assertNoProblems(result ParseResult<?>) : void extracted from public leftHandAssignmentCanBeInBraces() : void in class com.github.javaparser.ast.validator.BaseJavaValidatorTest & moved to class com.github.javaparser.utils.TestUtils", "diffLocations": [{"filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/BaseJavaValidatorTest.java", "startLine": 72, "endLine": 76, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/BaseJavaValidatorTest.java", "startLine": 73, "endLine": 77, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/BaseJavaValidatorTest.java", "startLine": 133, "endLine": 135, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void leftHandAssignmentCanBeInBraces() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(i) += (i) += 1\"));\n        assertProblems(result);\n    }", "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/BaseJavaValidatorTest.java", "isPureRefactoring": true, "commitId": "034b17a06497b52eb066eaf1ece5f086305ec840", "packageNameBefore": "com.github.javaparser.ast.validator", "classNameBefore": "com.github.javaparser.ast.validator.BaseJavaValidatorTest", "methodNameBefore": "com.github.javaparser.ast.validator.BaseJavaValidatorTest#leftHandAssignmentCanBeInBraces", "invokedMethod": "methodSignature: com.github.javaparser.utils.TestUtils#assertProblems\n methodBody: public static void assertProblems(ParseResult<?> result, String... expectedArg) {\nSet<String> actual=result.getProblems().stream().map(Problem::toString).collect(Collectors.toSet());\nSet<String> expected=new HashSet<>();\nexpected.addAll(Arrays.asList(expectedArg));\nassertCollections(expected,actual);\n}", "classSignatureBefore": "public class BaseJavaValidatorTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.validator.BaseJavaValidatorTest#leftHandAssignmentCanBeInBraces"], "classNameBeforeSet": ["com.github.javaparser.ast.validator.BaseJavaValidatorTest"], "classSignatureBeforeSet": ["public class BaseJavaValidatorTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.Range;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.stmt.Statement;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.ParseStart.EXPRESSION;\nimport static com.github.javaparser.ParseStart.STATEMENT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class BaseJavaValidatorTest {\n    @Test\n    public void tryWithoutAnything() {\n        ParseResult<Statement> result = new JavaParser().parse(STATEMENT, provider(\"try{}\"));\n        assertProblems(result, \"(line 1,col 1) Try has no finally, no catch, and no resources.\");\n    }\n\n    @Test\n    public void classExtendingMoreThanOne() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"class X extends Y, Z {}\"));\n        assertProblems(result, \"(line 1,col 20) A class cannot extend more than one other class.\");\n    }\n\n    @Test\n    public void interfaceUsingImplements() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"interface X implements Y {}\"));\n        assertProblems(result, \"(line 1,col 24) An interface cannot implement other interfaces.\");\n    }\n\n    @Test\n    public void interfaceWithInitializer() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"interface X {{}}\"));\n        assertProblems(result, \"(line 1,col 14) An interface cannot have initializers.\");\n    }\n\n    @Test\n    public void defaultMethodWithoutBody() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"interface X {default void a();}\"));\n        assertProblems(result, \"(line 1,col 14) 'default' methods must have a body.\");\n    }\n\n    @Test\n    public void defaultInClass() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"class X {default void a(){};}\"));\n        assertProblems(result, \"(line 1,col 10) 'default' is not allowed here.\");\n    }\n\n    @Test\n    public void localInterface() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"class X {void a(){interface I{}};}\"));\n        assertProblems(result, \"(line 1,col 19) There is no such thing as a local interface.\");\n    }\n\n    @Test\n    public void leftHandAssignmentCannotBeAConditional() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(1==2)=3\"));\n        assertProblems(result, \"(line 1,col 1) Illegal left hand side of an assignment.\");\n    }\n\n    @Test\n    public void leftHandAssignmentCannotBeEmptyBraces() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"()=3\"));\n        assertProblems(result, \"(line 1,col 1) Illegal left hand side of an assignment.\");\n    }\n\n    @Test\n    public void leftHandAssignmentCanBeInBraces() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(i) += (i) += 1\"));\n        assertProblems(result);\n    }\n}\n", "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/BaseJavaValidatorTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.Range;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.stmt.Statement;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.ParseStart.EXPRESSION;\nimport static com.github.javaparser.ParseStart.STATEMENT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertNoProblems;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class BaseJavaValidatorTest {\n    @Test\n    public void tryWithoutAnything() {\n        ParseResult<Statement> result = new JavaParser().parse(STATEMENT, provider(\"try{}\"));\n        assertProblems(result, \"(line 1,col 1) Try has no finally, no catch, and no resources.\");\n    }\n\n    @Test\n    public void classExtendingMoreThanOne() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"class X extends Y, Z {}\"));\n        assertProblems(result, \"(line 1,col 20) A class cannot extend more than one other class.\");\n    }\n\n    @Test\n    public void interfaceUsingImplements() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"interface X implements Y {}\"));\n        assertProblems(result, \"(line 1,col 24) An interface cannot implement other interfaces.\");\n    }\n\n    @Test\n    public void interfaceWithInitializer() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"interface X {{}}\"));\n        assertProblems(result, \"(line 1,col 14) An interface cannot have initializers.\");\n    }\n\n    @Test\n    public void defaultMethodWithoutBody() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"interface X {default void a();}\"));\n        assertProblems(result, \"(line 1,col 14) 'default' methods must have a body.\");\n    }\n\n    @Test\n    public void defaultInClass() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"class X {default void a(){};}\"));\n        assertProblems(result, \"(line 1,col 10) 'default' is not allowed here.\");\n    }\n\n    @Test\n    public void localInterface() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"class X {void a(){interface I{}};}\"));\n        assertProblems(result, \"(line 1,col 19) There is no such thing as a local interface.\");\n    }\n\n    @Test\n    public void leftHandAssignmentCannotBeAConditional() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(1==2)=3\"));\n        assertProblems(result, \"(line 1,col 1) Illegal left hand side of an assignment.\");\n    }\n\n    @Test\n    public void leftHandAssignmentCannotBeEmptyBraces() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"()=3\"));\n        assertProblems(result, \"(line 1,col 1) Illegal left hand side of an assignment.\");\n    }\n\n    @Test\n    public void leftHandAssignmentCanBeInBraces() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(i) += (i) += 1\"));\n        assertNoProblems(result);\n    }\n}\n", "diffSourceCodeSet": [""], "invokedMethodSet": ["methodSignature: com.github.javaparser.utils.TestUtils#assertProblems\n methodBody: public static void assertProblems(ParseResult<?> result, String... expectedArg) {\nSet<String> actual=result.getProblems().stream().map(Problem::toString).collect(Collectors.toSet());\nSet<String> expected=new HashSet<>();\nexpected.addAll(Arrays.asList(expectedArg));\nassertCollections(expected,actual);\n}"], "sourceCodeAfterRefactoring": "@Test\n    public void leftHandAssignmentCanBeInBraces() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(i) += (i) += 1\"));\n        assertNoProblems(result);\n    }\n", "diffSourceCode": "-   72:     @Test\n-   73:     public void leftHandAssignmentCanBeInBraces() {\n-   74:         ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(i) += (i) += 1\"));\n-   75:         assertProblems(result);\n-   76:     }\n-   77: }\n+   72: \n+   73:     @Test\n+   74:     public void leftHandAssignmentCanBeInBraces() {\n+   75:         ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(i) += (i) += 1\"));\n+   76:         assertNoProblems(result);\n+   77:     }\n", "uniqueId": "034b17a06497b52eb066eaf1ece5f086305ec840_72_76_133_135_73_77", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To refactor the provided code, we will extract the parsing logic from the `leftHandAssignmentCanBeInBraces` method into a new static method in an existing utility class. This will improve modularity and readability.\n\n### Step 1: Analyze the Code\nThe method `leftHandAssignmentCanBeInBraces` contains the following logic:\n```java\nParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(i) += (i) += 1\"));\nassertProblems(result);\n```\nThis logic can be extracted into a separate method that handles the parsing and assertion of problems.\n\n### Step 2: Identify Target File for Extraction\nLooking at the project structure, a suitable target file for the extracted method is `javaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java`, as it seems to contain utility methods for testing.\n\n### Step 3: Extract Method Code\nThe extracted method will be a public static method that takes the expression string as a parameter and performs the parsing and assertion.\n\n#### Extracted Method Code\n```java\npublic static void assertLeftHandAssignmentCanBeInBraces(String expression) {\n    ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(expression));\n    assertProblems(result);\n}\n```\n\n### Step 4: Refactor the Original Method\nNow, we will refactor the `leftHandAssignmentCanBeInBraces` method to call the newly created method.\n\n#### Refactored Method Code\n```java\n@Test\npublic void leftHandAssignmentCanBeInBraces() {\n    TestUtils.assertLeftHandAssignmentCanBeInBraces(\"(i) += (i) += 1\");\n}\n```\n\n### Final Output\nNow, we will format the output as requested.\n\n##########################\njavaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java\n##########################\npublic static void assertLeftHandAssignmentCanBeInBraces(String expression) {\n    ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(expression));\n    assertProblems(result);\n}\n##########################\n@Test\npublic void leftHandAssignmentCanBeInBraces() {\n    TestUtils.assertLeftHandAssignmentCanBeInBraces(\"(i) += (i) += 1\");\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    public void leftHandAssignmentCanBeInBraces() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(i) += (i) += 1\"));\n        assertProblems(result);\n    }\n\nClass content:\npackage com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.Range;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.stmt.Statement;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.ParseStart.EXPRESSION;\nimport static com.github.javaparser.ParseStart.STATEMENT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class BaseJavaValidatorTest {\n    @Test\n    public void tryWithoutAnything() {\n        ParseResult<Statement> result = new JavaParser().parse(STATEMENT, provider(\"try{}\"));\n        assertProblems(result, \"(line 1,col 1) Try has no finally, no catch, and no resources.\");\n    }\n\n    @Test\n    public void classExtendingMoreThanOne() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"class X extends Y, Z {}\"));\n        assertProblems(result, \"(line 1,col 20) A class cannot extend more than one other class.\");\n    }\n\n    @Test\n    public void interfaceUsingImplements() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"interface X implements Y {}\"));\n        assertProblems(result, \"(line 1,col 24) An interface cannot implement other interfaces.\");\n    }\n\n    @Test\n    public void interfaceWithInitializer() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"interface X {{}}\"));\n        assertProblems(result, \"(line 1,col 14) An interface cannot have initializers.\");\n    }\n\n    @Test\n    public void defaultMethodWithoutBody() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"interface X {default void a();}\"));\n        assertProblems(result, \"(line 1,col 14) 'default' methods must have a body.\");\n    }\n\n    @Test\n    public void defaultInClass() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"class X {default void a(){};}\"));\n        assertProblems(result, \"(line 1,col 10) 'default' is not allowed here.\");\n    }\n\n    @Test\n    public void localInterface() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"class X {void a(){interface I{}};}\"));\n        assertProblems(result, \"(line 1,col 19) There is no such thing as a local interface.\");\n    }\n\n    @Test\n    public void leftHandAssignmentCannotBeAConditional() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(1==2)=3\"));\n        assertProblems(result, \"(line 1,col 1) Illegal left hand side of an assignment.\");\n    }\n\n    @Test\n    public void leftHandAssignmentCannotBeEmptyBraces() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"()=3\"));\n        assertProblems(result, \"(line 1,col 1) Illegal left hand side of an assignment.\");\n    }\n\n    @Test\n    public void leftHandAssignmentCanBeInBraces() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(i) += (i) += 1\"));\n        assertProblems(result);\n    }\n}\n\nRefactoring Operation:\nExtract And Move Method\n\nProject Structure:\n['javaparser-testing/src/test/java/com/github/javaparser/CommentsInserterTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/JavaParserTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/JavaTokenTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/JavadocParserTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ProblemTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ProvidersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/RangeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/CompilationUnitTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/DataKeyTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/NodeListTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/NodePositionTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/NodeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/ParseResultTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/body/AnnotationMemberDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/body/MethodDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/comments/CommentTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/InstanceOfExprTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/MethodReferenceTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/NameTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/SimpleNameTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/imports/ImportDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithJavadocTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithModifiersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithOptionalScopeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithVariablesTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/observer/PropagatingAstObserverTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/stmt/BlockStmtTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/type/ArrayTypeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/type/TypeConstructionTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/BaseJavaValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/BaseModifierValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/validator/ValidatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/CloneVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/HashCodeVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/ModifierVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/TreeStructureVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/visitor/TreeVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/BasicJBehaveTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/CommentParsingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ComparingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ManipulationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ParsingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/PositionRangeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/PrettyPrintingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/TestUtils.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/VisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ComparingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ExistenceOfParentNodeVerifier.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ManipulationSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ParsingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/PositionRangeSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/PrettyPrintingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/SharedSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/VisitorSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/visitors/PositionTestVisitor.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/ClassOrInterfaceDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/CompilationUnitBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/EnumDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/FieldDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithAnnotationsBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithMembersBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithParametersBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/builders/NodeWithThrownExceptionsBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/javadoc/JavadocExtractorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/javadoc/JavadocTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/javadoc/description/JavadocInlineTagTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/manual/BulkParseTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/metamodel/BaseNodeMetaModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/metamodel/JavaParserMetaModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/metamodel/PropertyMetaModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/modules/ModuleDeclarationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelAcceptanceTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/PrettyPrintVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/PrettyPrinterTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/TestVisitor.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/AbstractLexicalPreservingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/DifferenceTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculatorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinterTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/TransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/ArrayCreationLevelTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/CompilationUnitTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationMemberDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ClassOrInterfaceDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ConstructorDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumConstantDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/FieldDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/InitializerDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/MethodDeclarationTransformationsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/remove/NodeRemovalTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/CodeGenerationUtilsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/SourceRootTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java', 'javaparser-testing/src/test/java/com/github/javaparser/utils/UtilsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/ChangingMethodsFromAClassWithAVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/ChangingMethodsFromAClassWithoutAVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/ClassCreator.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/CreatingACompilationUnitFromScratch.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/CuPrinter.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/MethodChanger_1.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/MethodChanger_2.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/MethodPrinter.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/PrintingTheCompilationUnitToSystemOutputTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/TestFileToken.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/VisitingClassMethodsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/removenode/D.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/removenode/ModifierVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/wiki_samples/removenode/RemoveDeleteNodeFromAst.java', 'javaparser-testing/src/test/resources/com/github/javaparser/TestFileIso88591.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/ClassInLatin1.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/JavaConcepts.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/package-info.java', 'javaparser-testing/src/test/resources/com/github/javaparser/printer/JavaConcepts_saved.java', 'javaparser-testing/src/test/resources/com/github/javaparser/printer/PrettyPrintVisitor_saved.java', 'javaparser-testing/src/test/resources/com/github/javaparser/utils/Bla.java', 'javaparser-testing/src/test/resources/com/github/javaparser/utils/module-info.java', 'javaparser-testing/src/test/resources/com/github/javaparser/utils/source/root/Y.java', 'javaparser-testing/src/test/resources/com/github/javaparser/wiki_samples/TestFile.java']\n\nFile Path Before Refactoring:\njavaparser-testing/src/test/java/com/github/javaparser/ast/validator/BaseJavaValidatorTest.java\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, and you need move the extracted method to another existing java file, output the target file path, extracted method code, refactored method code after refactoring.\nThe extracted method code should be the public static method.\nThe refactored method code should use the moved class to call the extracted method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\ntarget_file_path\n##########################\nextracted_method_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n\n\n"}, {"type": "Inline Method", "description": "Inline Method\tpublic getRawTypeName() : String inlined to public getTypeName() : String in class com.github.javaparser.metamodel.PropertyMetaModel", "diffLocations": [{"filePath": "javaparser-metamodel/src/main/java/com/github/javaparser/metamodel/PropertyMetaModel.java", "startLine": 117, "endLine": 122, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-metamodel/src/main/java/com/github/javaparser/metamodel/PropertyMetaModel.java", "startLine": 153, "endLine": 158, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-metamodel/src/main/java/com/github/javaparser/metamodel/PropertyMetaModel.java", "startLine": 124, "endLine": 126, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "public String getRawTypeName() {\n        return type.getSimpleName();\n    }", "filePathBefore": "javaparser-metamodel/src/main/java/com/github/javaparser/metamodel/PropertyMetaModel.java", "isPureRefactoring": true, "commitId": "b12d4d933f76cfe8de43ee919aa8357dcd38afb8", "packageNameBefore": "com.github.javaparser.metamodel", "classNameBefore": "com.github.javaparser.metamodel.PropertyMetaModel", "methodNameBefore": "com.github.javaparser.metamodel.PropertyMetaModel#getRawTypeName", "classSignatureBefore": "public class PropertyMetaModel ", "methodNameBeforeSet": ["com.github.javaparser.metamodel.PropertyMetaModel#getRawTypeName"], "classNameBeforeSet": ["com.github.javaparser.metamodel.PropertyMetaModel"], "classSignatureBeforeSet": ["public class PropertyMetaModel "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.metamodel;\n\nimport java.lang.reflect.Field;\n\nimport static com.github.javaparser.generator.utils.GeneratorUtils.getterName;\nimport static com.github.javaparser.generator.utils.GeneratorUtils.setterName;\n\n/**\n * Meta-data about a property of a node in the AST.\n */\npublic class PropertyMetaModel {\n    private final BaseNodeMetaModel nodeMetaModel;\n    private final String name;\n    private final Class<?> type;\n    //    public Optional<CommentMetaModel> typeReference;\n//    public Optional<Class<Integer>> tpe;\n    private final Field reflectionField;\n    private final boolean isNode;\n    private final boolean isOptional;\n    private final boolean isNodeList;\n    private final boolean isEnumSet;\n    private final boolean hasWildcard;\n\n    public PropertyMetaModel(BaseNodeMetaModel nodeMetaModel, String name, Class<?> type, Field reflectionField, boolean isNode, boolean isOptional, boolean isNodeList, boolean isEnumSet, boolean hasWildcard) {\n        this.nodeMetaModel = nodeMetaModel;\n        this.name = name;\n        this.type = type;\n        this.reflectionField = reflectionField;\n        this.isNode = isNode;\n        this.isOptional = isOptional;\n        this.isNodeList = isNodeList;\n        this.isEnumSet = isEnumSet;\n        this.hasWildcard = hasWildcard;\n    }\n\n    public boolean is(Class<?> c, String fieldName) {\n        return nodeMetaModel.is(c) && name.equals(fieldName);\n    }\n\n    public boolean is(String fieldName) {\n        return name.equals(fieldName);\n    }\n\n    /**\n     * @return the name used in the AST for the setter\n     */\n    public String getSetterMethodName() {\n        return setterName(reflectionField);\n    }\n\n    /**\n     * @return the name used in the AST for the getter\n     */\n    public String getGetterMethodName() {\n        return getterName(reflectionField);\n    }\n\n    public BaseNodeMetaModel getNodeMetaModel() {\n        return nodeMetaModel;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public Class<?> getType() {\n        return type;\n    }\n\n    public Field getReflectionField() {\n        return reflectionField;\n    }\n\n    @Deprecated\n    public boolean isNode() {\n        return isNode;\n    }\n\n    public boolean isOptional() {\n        return isOptional;\n    }\n\n    public boolean isNodeList() {\n        return isNodeList;\n    }\n\n    public boolean isEnumSet() {\n        return isEnumSet;\n    }\n\n    public boolean hasWildcard() {\n        return hasWildcard;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + type.getSimpleName() + \")\\t\" + nodeMetaModel + \"#\" + name;\n    }\n\n    @Override\n    public int hashCode() {\n        return reflectionField.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        PropertyMetaModel that = (PropertyMetaModel) o;\n\n        if (!reflectionField.equals(that.reflectionField)) return false;\n\n        return true;\n    }\n\n    public String getTypeName() {\n        if (hasWildcard) {\n            return getRawTypeName() + \"<?>\";\n        }\n        return getRawTypeName();\n    }\n\n    public String getRawTypeName() {\n        return type.getSimpleName();\n    }\n\n    public String getFullTypeNameForGetter() {\n        if (isOptional) {\n            return \"Optional<\" + getFullTypeNameForSetter() + \">\";\n        }\n        return getFullTypeNameForSetter();\n    }\n\n    public String getFullTypeNameForSetter() {\n        if (isNodeList) {\n            return \"NodeList<\" + getTypeName() + \">\";\n        }\n        if (isEnumSet) {\n            return \"EnumSet<\" + getTypeName() + \">\";\n        }\n        return getTypeName();\n    }\n}\n", "filePathAfter": "javaparser-metamodel/src/main/java/com/github/javaparser/metamodel/PropertyMetaModel.java", "sourceCodeAfterForWhole": "package com.github.javaparser.metamodel;\n\nimport com.github.javaparser.ast.Node;\n\nimport java.util.Optional;\n\nimport static com.github.javaparser.generator.utils.GeneratorUtils.getterName;\nimport static com.github.javaparser.generator.utils.GeneratorUtils.setterName;\n\n/**\n * Meta-data about a property of a node in the AST.\n */\npublic class PropertyMetaModel {\n    private final BaseNodeMetaModel containingNodeMetaModel;\n    private final String name;\n    private final Class<?> type;\n    private final Optional<BaseNodeMetaModel> nodeReference;\n    private final boolean isOptional;\n    private final boolean isNodeList;\n    private final boolean isEnumSet;\n    private final boolean hasWildcard;\n\n    public PropertyMetaModel(BaseNodeMetaModel containingNodeMetaModel, String name, Class<?> type, Optional<BaseNodeMetaModel> nodeReference, boolean isOptional, boolean isNodeList, boolean isEnumSet, boolean hasWildcard) {\n        this.containingNodeMetaModel = containingNodeMetaModel;\n        this.name = name;\n        this.type = type;\n        this.nodeReference = nodeReference;\n        this.isOptional = isOptional;\n        this.isNodeList = isNodeList;\n        this.isEnumSet = isEnumSet;\n        this.hasWildcard = hasWildcard;\n    }\n\n    /**\n     * @return is this the field fieldName on class c?\n     */\n    public boolean is(Class<? extends Node> c, String fieldName) {\n        return containingNodeMetaModel.is(c) && name.equals(fieldName);\n    }\n\n    /**\n     * @return is this fields called fieldName?\n     */\n    public boolean is(String fieldName) {\n        return name.equals(fieldName);\n    }\n\n    /**\n     * @return the name used in the AST for the setter\n     */\n    public String getSetterMethodName() {\n        return setterName(name);\n    }\n\n    /**\n     * @return the name used in the AST for the getter\n     */\n    public String getGetterMethodName() {\n        return getterName(type, name);\n    }\n\n    /**\n     * @return the NodeMetaModel that \"has\" this property.\n     */\n    public BaseNodeMetaModel getContainingNodeMetaModel() {\n        return containingNodeMetaModel;\n    }\n\n    /**\n     * @return the name of the property. This is equal to the name of the field in the AST.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @return the class of the field.\n     */\n    public Class<?> getType() {\n        return type;\n    }\n\n    /**\n     * @return if this property is a Node, this will get the node meta model.\n     */\n    public Optional<BaseNodeMetaModel> getNodeReference() {\n        return nodeReference;\n    }\n\n    /**\n     * @return whether this property is optional.\n     */\n    public boolean isOptional() {\n        return isOptional;\n    }\n\n    /**\n     * @return whether this property is contained in a NodeList.\n     */\n    public boolean isNodeList() {\n        return isNodeList;\n    }\n\n    /**\n     * @return whether this property is contained in an EnumSet.\n     */\n    public boolean isEnumSet() {\n        return isEnumSet;\n    }\n\n    /**\n     * @return whether this property has a wildcard following it, like BodyDeclaration&lt;?&gt;.\n     */\n    public boolean hasWildcard() {\n        return hasWildcard;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + getTypeName() + \")\\t\" + containingNodeMetaModel + \"#\" + name;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        PropertyMetaModel that = (PropertyMetaModel) o;\n\n        if (!name.equals(that.name)) return false;\n        if (!type.equals(that.type)) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = name.hashCode();\n        result = 31 * result + type.hashCode();\n        return result;\n    }\n\n    /**\n     * @return the type of a single element of this property, so no Optional or NodeList or EnumSet.\n     */\n    public String getTypeNameGenericsed() {\n        if (hasWildcard) {\n            return getTypeName() + \"<?>\";\n        }\n        return getTypeName();\n    }\n\n    /**\n     * @return the raw type of a single element of this property, so nothing but the name.\n     */\n    public String getTypeName() {\n        return type.getSimpleName();\n    }\n\n    /**\n     * @return the type that is returned from getters in the AST.\n     */\n    public String getTypeNameForGetter() {\n        if (isOptional) {\n            return \"Optional<\" + getTypeNameForSetter() + \">\";\n        }\n        return getTypeNameForSetter();\n    }\n\n    /**\n     * @return the type that is passed to setters in the AST.\n     */\n    public String getTypeNameForSetter() {\n        if (isNodeList) {\n            return \"NodeList<\" + getTypeNameGenericsed() + \">\";\n        }\n        if (isEnumSet) {\n            return \"EnumSet<\" + getTypeNameGenericsed() + \">\";\n        }\n        return getTypeNameGenericsed();\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * @return the raw type of a single element of this property, so nothing but the name.\n     */\n    public String getTypeName() {\n        return type.getSimpleName();\n    }", "diffSourceCode": "-  117:     public String getTypeName() {\n-  118:         if (hasWildcard) {\n-  119:             return getRawTypeName() + \"<?>\";\n-  120:         }\n-  121:         return getRawTypeName();\n-  122:     }\n-  124:     public String getRawTypeName() {\n-  125:         return type.getSimpleName();\n-  126:     }\n+  117: \n+  118:     @Override\n+  119:     public String toString() {\n+  120:         return \"(\" + getTypeName() + \")\\t\" + containingNodeMetaModel + \"#\" + name;\n+  121:     }\n+  122: \n+  124:     public boolean equals(Object o) {\n+  125:         if (this == o) return true;\n+  126:         if (o == null || getClass() != o.getClass()) return false;\n+  153:     /**\n+  154:      * @return the raw type of a single element of this property, so nothing but the name.\n+  155:      */\n+  156:     public String getTypeName() {\n+  157:         return type.getSimpleName();\n+  158:     }\n", "uniqueId": "b12d4d933f76cfe8de43ee919aa8357dcd38afb8_117_122__153_158_124_126", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 4}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To perform the \"Inline Method\" refactoring operation on the provided code, we will inline the `getRawTypeName()` method into the `getTypeName()` method, as `getRawTypeName()` is only called once and its implementation is simple enough to be directly included in the calling method.\n\nHere is the refactored class code:\n\n##########################\n```java\npackage com.github.javaparser.metamodel;\n\nimport java.lang.reflect.Field;\n\nimport static com.github.javaparser.generator.utils.GeneratorUtils.getterName;\nimport static com.github.javaparser.generator.utils.GeneratorUtils.setterName;\n\n/**\n * Meta-data about a property of a node in the AST.\n */\npublic class PropertyMetaModel {\n    private final BaseNodeMetaModel nodeMetaModel;\n    private final String name;\n    private final Class<?> type;\n    private final Field reflectionField;\n    private final boolean isNode;\n    private final boolean isOptional;\n    private final boolean isNodeList;\n    private final boolean isEnumSet;\n    private final boolean hasWildcard;\n\n    public PropertyMetaModel(BaseNodeMetaModel nodeMetaModel, String name, Class<?> type, Field reflectionField, boolean isNode, boolean isOptional, boolean isNodeList, boolean isEnumSet, boolean hasWildcard) {\n        this.nodeMetaModel = nodeMetaModel;\n        this.name = name;\n        this.type = type;\n        this.reflectionField = reflectionField;\n        this.isNode = isNode;\n        this.isOptional = isOptional;\n        this.isNodeList = isNodeList;\n        this.isEnumSet = isEnumSet;\n        this.hasWildcard = hasWildcard;\n    }\n\n    public boolean is(Class<?> c, String fieldName) {\n        return nodeMetaModel.is(c) && name.equals(fieldName);\n    }\n\n    public boolean is(String fieldName) {\n        return name.equals(fieldName);\n    }\n\n    /**\n     * @return the name used in the AST for the setter\n     */\n    public String getSetterMethodName() {\n        return setterName(reflectionField);\n    }\n\n    /**\n     * @return the name used in the AST for the getter\n     */\n    public String getGetterMethodName() {\n        return getterName(reflectionField);\n    }\n\n    public BaseNodeMetaModel getNodeMetaModel() {\n        return nodeMetaModel;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public Class<?> getType() {\n        return type;\n    }\n\n    public Field getReflectionField() {\n        return reflectionField;\n    }\n\n    @Deprecated\n    public boolean isNode() {\n        return isNode;\n    }\n\n    public boolean isOptional() {\n        return isOptional;\n    }\n\n    public boolean isNodeList() {\n        return isNodeList;\n    }\n\n    public boolean isEnumSet() {\n        return isEnumSet;\n    }\n\n    public boolean hasWildcard() {\n        return hasWildcard;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + type.getSimpleName() + \")\\t\" + nodeMetaModel + \"#\" + name;\n    }\n\n    @Override\n    public int hashCode() {\n        return reflectionField.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        PropertyMetaModel that = (PropertyMetaModel) o;\n\n        return reflectionField.equals(that.reflectionField);\n    }\n\n    public String getTypeName() {\n        String rawTypeName = type.getSimpleName();\n        if (hasWildcard) {\n            return rawTypeName + \"<?>\";\n        }\n        return rawTypeName;\n    }\n\n    public String getFullTypeNameForGetter() {\n        if (isOptional) {\n            return \"Optional<\" + getFullTypeNameForSetter() + \">\";\n        }\n        return getFullTypeNameForSetter();\n    }\n\n    public String getFullTypeNameForSetter() {\n        if (isNodeList) {\n            return \"NodeList<\" + getTypeName() + \">\";\n        }\n        if (isEnumSet) {\n            return \"EnumSet<\" + getTypeName() + \">\";\n        }\n        return getTypeName();\n    }\n}\n```\n########################## \n\nIn this refactored code, the `getRawTypeName()` method has been removed, and its logic has been directly integrated into the `getTypeName()` method. This improves the readability and maintainability of the code by reducing the number of methods and making the logic clearer.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\npublic String getRawTypeName() {\n        return type.getSimpleName();\n    }\n\nClass content:\npackage com.github.javaparser.metamodel;\n\nimport java.lang.reflect.Field;\n\nimport static com.github.javaparser.generator.utils.GeneratorUtils.getterName;\nimport static com.github.javaparser.generator.utils.GeneratorUtils.setterName;\n\n/**\n * Meta-data about a property of a node in the AST.\n */\npublic class PropertyMetaModel {\n    private final BaseNodeMetaModel nodeMetaModel;\n    private final String name;\n    private final Class<?> type;\n    //    public Optional<CommentMetaModel> typeReference;\n//    public Optional<Class<Integer>> tpe;\n    private final Field reflectionField;\n    private final boolean isNode;\n    private final boolean isOptional;\n    private final boolean isNodeList;\n    private final boolean isEnumSet;\n    private final boolean hasWildcard;\n\n    public PropertyMetaModel(BaseNodeMetaModel nodeMetaModel, String name, Class<?> type, Field reflectionField, boolean isNode, boolean isOptional, boolean isNodeList, boolean isEnumSet, boolean hasWildcard) {\n        this.nodeMetaModel = nodeMetaModel;\n        this.name = name;\n        this.type = type;\n        this.reflectionField = reflectionField;\n        this.isNode = isNode;\n        this.isOptional = isOptional;\n        this.isNodeList = isNodeList;\n        this.isEnumSet = isEnumSet;\n        this.hasWildcard = hasWildcard;\n    }\n\n    public boolean is(Class<?> c, String fieldName) {\n        return nodeMetaModel.is(c) && name.equals(fieldName);\n    }\n\n    public boolean is(String fieldName) {\n        return name.equals(fieldName);\n    }\n\n    /**\n     * @return the name used in the AST for the setter\n     */\n    public String getSetterMethodName() {\n        return setterName(reflectionField);\n    }\n\n    /**\n     * @return the name used in the AST for the getter\n     */\n    public String getGetterMethodName() {\n        return getterName(reflectionField);\n    }\n\n    public BaseNodeMetaModel getNodeMetaModel() {\n        return nodeMetaModel;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public Class<?> getType() {\n        return type;\n    }\n\n    public Field getReflectionField() {\n        return reflectionField;\n    }\n\n    @Deprecated\n    public boolean isNode() {\n        return isNode;\n    }\n\n    public boolean isOptional() {\n        return isOptional;\n    }\n\n    public boolean isNodeList() {\n        return isNodeList;\n    }\n\n    public boolean isEnumSet() {\n        return isEnumSet;\n    }\n\n    public boolean hasWildcard() {\n        return hasWildcard;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + type.getSimpleName() + \")\\t\" + nodeMetaModel + \"#\" + name;\n    }\n\n    @Override\n    public int hashCode() {\n        return reflectionField.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        PropertyMetaModel that = (PropertyMetaModel) o;\n\n        if (!reflectionField.equals(that.reflectionField)) return false;\n\n        return true;\n    }\n\n    public String getTypeName() {\n        if (hasWildcard) {\n            return getRawTypeName() + \"<?>\";\n        }\n        return getRawTypeName();\n    }\n\n    public String getRawTypeName() {\n        return type.getSimpleName();\n    }\n\n    public String getFullTypeNameForGetter() {\n        if (isOptional) {\n            return \"Optional<\" + getFullTypeNameForSetter() + \">\";\n        }\n        return getFullTypeNameForSetter();\n    }\n\n    public String getFullTypeNameForSetter() {\n        if (isNodeList) {\n            return \"NodeList<\" + getTypeName() + \">\";\n        }\n        if (isEnumSet) {\n            return \"EnumSet<\" + getTypeName() + \">\";\n        }\n        return getTypeName();\n    }\n}\n\nRefactoring Operation:\nInline Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\nrefactored_class_code\n##########################\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpublic visit(n ImportDeclaration, arg Object) : void from class com.github.javaparser.bdd.visitors.PositionTestVisitor to public visit(n BlockComment, arg Void) : void from class com.github.javaparser.bdd.steps.ExistenceOfParentNodeVerifier.Verifier", "diffLocations": [{"filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/visitors/PositionTestVisitor.java", "startLine": 250, "endLine": 253, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ExistenceOfParentNodeVerifier.java", "startLine": 101, "endLine": 104, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override public void visit(final ImportDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }", "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/bdd/visitors/PositionTestVisitor.java", "isPureRefactoring": true, "commitId": "731c46d3bd61cc1e3e4733570dd80ab00cd63c87", "packageNameBefore": "com.github.javaparser.bdd.visitors", "classNameBefore": "com.github.javaparser.bdd.visitors.PositionTestVisitor", "methodNameBefore": "com.github.javaparser.bdd.visitors.PositionTestVisitor#visit", "invokedMethod": "methodSignature: com.github.javaparser.ast.visitor.GenericVisitor#visit\n methodBody: R visit(ArrayBracketPair arrayBracketPair, A arg);\nmethodSignature: com.github.javaparser.ast.visitor.ModifierVisitorAdapter#visit\n methodBody: public Node visit(final LineComment n, final A arg) {\nreturn n;\n}\nmethodSignature: com.github.javaparser.bdd.steps.ExistenceOfParentNodeVerifier.Verifier#visit\n methodBody: public void visit(WildcardType n, Void arg) {\nassertParentIsSet(n);\nsuper.visit(n,arg);\n}\nmethodSignature: com.github.javaparser.ast.visitor.DumpVisitor#visit\n methodBody: public void visit(ArrayBracketPair arrayBracketPair, Object arg) {\nprintAnnotations(arrayBracketPair.getAnnotations(),true,arg);\nprinter.print(\"[]\");\n}\nmethodSignature: com.github.javaparser.ast.visitor.CloneVisitor#visit\n methodBody: public <T extends Node> List<T> visit(List<T> _nodes, Object _arg) {\nif(_nodes == null)return null;\nList<T> r=new ArrayList<>(_nodes.size());\nfor(T n: _nodes){T rN=cloneNodes(n,_arg);\nif(rN != null)r.add(rN);\n}return r;\n}\nmethodSignature: com.github.javaparser.bdd.visitors.PositionTestVisitor#doTest\n methodBody: void doTest(final Node node) {\nassertThat(node.getBegin().line,is(greaterThanOrEqualTo(0)));\nassertThat(node.getBegin().column,is(greaterThanOrEqualTo(0)));\nassertThat(node.getEnd().line,is(greaterThanOrEqualTo(0)));\nassertThat(node.getEnd().column,is(greaterThanOrEqualTo(0)));\nif(node.getBegin().line == node.getEnd().line){assertThat(node.getBegin().column,is(lessThanOrEqualTo(node.getEnd().column)));\n}{assertThat(node.getBegin().line,is(lessThanOrEqualTo(node.getEnd().line)));\n}numberOfNodesVisited++;\n}\nmethodSignature: com.github.javaparser.ast.visitor.EqualsVisitor#visit\n methodBody: public Boolean visit(ArrayBracketPair n1, Node arg) {\nArrayBracketPair n2=(ArrayBracketPair)arg;\nif(!nodesEquals(n1.getAnnotations(),n2.getAnnotations())){return false;\n}return true;\n}\nmethodSignature: com.github.javaparser.bdd.visitors.PositionTestVisitor#visit\n methodBody: public void visit(UnknownType n, Object arg) {\ndoTest(n);\nsuper.visit(n,arg);\n}\nmethodSignature: com.github.javaparser.ast.visitor.VoidVisitorAdapter#visit\n methodBody: public void visit(ArrayBracketPair n, A arg) {\nvisitAnnotations(n,arg);\n}\nmethodSignature: com.github.javaparser.ast.visitor.GenericVisitorAdapter#visit\n methodBody: public R visit(final LineComment n, final A arg) {\nreturn null;\n}\nmethodSignature: com.github.javaparser.ast.visitor.VoidVisitor#visit\n methodBody: void visit(ArrayBracketPair arrayBracketPair, A arg);", "classSignatureBefore": "public class PositionTestVisitor extends VoidVisitorAdapter<Object> ", "methodNameBeforeSet": ["com.github.javaparser.bdd.visitors.PositionTestVisitor#visit"], "classNameBeforeSet": ["com.github.javaparser.bdd.visitors.PositionTestVisitor"], "classSignatureBeforeSet": ["public class PositionTestVisitor extends VoidVisitorAdapter<Object> "], "purityCheckResultList": [{"isPure": true, "purityComment": "", "description": "Extra print lines - with non-mapped leaves", "mappingState": 5}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2016 The JavaParser Team.\n *\n * This file is part of JavaParser.\n * \n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License \n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n \npackage com.github.javaparser.bdd.visitors;\n\nimport com.github.javaparser.ast.*;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.comments.BlockComment;\nimport com.github.javaparser.ast.comments.JavadocComment;\nimport com.github.javaparser.ast.comments.LineComment;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.*;\nimport com.github.javaparser.ast.type.*;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.greaterThanOrEqualTo;\nimport static org.hamcrest.Matchers.lessThanOrEqualTo;\nimport static org.hamcrest.core.Is.is;\n\n\npublic class PositionTestVisitor extends VoidVisitorAdapter<Object> {\n\n    private int numberOfNodesVisited;\n\n    @Override public void visit(final AnnotationDeclaration n, final Object arg) {\n        doTest(n);\n        doTest(n.getNameExpr());\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final AnnotationMemberDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ArrayAccessExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ArrayCreationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ArrayInitializerExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final AssertStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final AssignExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final BinaryExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final BlockComment n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final BlockStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final BooleanLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final BreakStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final CastExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final CatchClause n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LambdaExpr n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MethodReferenceExpr n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TypeExpr n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final CharLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ClassExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ClassOrInterfaceDeclaration n, final Object arg) {\n        doTest(n);\n        doTest(n.getNameExpr());\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ClassOrInterfaceType n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final CompilationUnit n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ConditionalExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ConstructorDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ContinueStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final DoStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final DoubleLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EmptyMemberDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EmptyStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EmptyTypeDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EnclosedExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EnumConstantDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EnumDeclaration n, final Object arg) {\n        doTest(n);\n        doTest(n.getNameExpr());\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ExplicitConstructorInvocationStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ExpressionStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final FieldAccessExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final FieldDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ForeachStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ForStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final IfStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ImportDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final InitializerDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final InstanceOfExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final IntegerLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final IntegerLiteralMinValueExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final JavadocComment n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final LabeledStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final LineComment n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final LongLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final LongLiteralMinValueExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final MarkerAnnotationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final MemberValuePair n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final MethodCallExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final MethodDeclaration n, final Object arg) {\n        doTest(n);\n        doTest(n.getNameExpr());\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final NameExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final NormalAnnotationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final NullLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ObjectCreationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final PackageDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final Parameter n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final PrimitiveType n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final QualifiedNameExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayType n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayCreationLevel n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final IntersectionType n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnionType n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ReturnStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final SingleMemberAnnotationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final StringLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final SuperExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final SwitchEntryStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final SwitchStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final SynchronizedStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ThisExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ThrowStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final TryStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final TypeDeclarationStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final TypeParameter n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final UnaryExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final VariableDeclarationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final VariableDeclarator n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final VariableDeclaratorId n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final VoidType n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final WhileStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final WildcardType n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnknownType n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    void doTest(final Node node) {\n        assertThat(node.getBegin().line, is(greaterThanOrEqualTo(0)));\n        assertThat(node.getBegin().column, is(greaterThanOrEqualTo(0)));\n        assertThat(node.getEnd().line, is(greaterThanOrEqualTo(0)));\n        assertThat(node.getEnd().column, is(greaterThanOrEqualTo(0)));\n\n        if (node.getBegin().line == node.getEnd().line) {\n            assertThat(node.getBegin().column, is(lessThanOrEqualTo(node.getEnd().column)));\n        } else {\n            assertThat(node.getBegin().line, is(lessThanOrEqualTo(node.getEnd().line)));\n        }\n        numberOfNodesVisited++;\n    }\n\n    public int getNumberOfNodesVisited() {\n        return numberOfNodesVisited;\n    }\n}\n", "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ExistenceOfParentNodeVerifier.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2016 The JavaParser Team.\n *\n * This file is part of JavaParser.\n * \n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License \n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n \npackage com.github.javaparser.bdd.steps;\n\nimport com.github.javaparser.ast.*;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.comments.BlockComment;\nimport com.github.javaparser.ast.comments.JavadocComment;\nimport com.github.javaparser.ast.comments.LineComment;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.imports.*;\nimport com.github.javaparser.ast.stmt.*;\nimport com.github.javaparser.ast.type.*;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.hamcrest.core.Is.is;\nimport static org.junit.Assert.assertThat;\n\n/**\n * The <code>ExistenceOfParentNodeVerifier</code> verifies that each node of the compilation unit has a parent set.\n */\nclass ExistenceOfParentNodeVerifier {\n\n    public void verify(CompilationUnit compilationUnit) throws AssertionError {\n        new Verifier().visit(compilationUnit, null);\n    }\n\n    private static class Verifier extends VoidVisitorAdapter<Void> {\n        private static void assertParentIsSet(Node n) {\n            assertThat(n + \" has no parent set!\", n.getParentNode(), is(notNullValue()));\n        }\n\n        @Override\n        public void visit(AnnotationDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(AnnotationMemberDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ArrayAccessExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ArrayCreationExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ArrayInitializerExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(AssertStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(AssignExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(BinaryExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(BlockComment n, Void arg) {\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(BlockStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(BooleanLiteralExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(BreakStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(CastExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(CatchClause n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(CharLiteralExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ClassExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ClassOrInterfaceDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ClassOrInterfaceType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(CompilationUnit n, Void arg) {\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ConditionalExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ConstructorDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ContinueStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(DoStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(DoubleLiteralExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(EmptyMemberDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(EmptyStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(EmptyTypeDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(EnclosedExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(EnumConstantDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(EnumDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ExplicitConstructorInvocationStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ExpressionStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(FieldAccessExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(FieldDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ForeachStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ForStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(IfStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(InitializerDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(InstanceOfExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(IntegerLiteralExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(IntegerLiteralMinValueExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(JavadocComment n, Void arg) {\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(LabeledStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(LineComment n, Void arg) {\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(LambdaExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(LongLiteralExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(LongLiteralMinValueExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(MarkerAnnotationExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(MemberValuePair n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(MethodCallExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(MethodReferenceExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(NameExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(NormalAnnotationExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(NullLiteralExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ObjectCreationExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(PackageDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(Parameter n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(PrimitiveType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(QualifiedNameExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ArrayType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ArrayCreationLevel n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(IntersectionType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(UnionType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ReturnStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(SingleMemberAnnotationExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(StringLiteralExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(SuperExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(SwitchEntryStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(SwitchStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(SynchronizedStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ThisExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ThrowStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(TryStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(TypeDeclarationStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(TypeExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ArrayBracketPair n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(EmptyImportDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(SingleStaticImportDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(SingleTypeImportDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(StaticImportOnDemandDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(TypeImportOnDemandDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(TypeParameter n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(UnaryExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(UnknownType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(VariableDeclarationExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(VariableDeclarator n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(VariableDeclaratorId n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(VoidType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(WhileStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(WildcardType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": ["methodSignature: com.github.javaparser.ast.visitor.GenericVisitor#visit\n methodBody: R visit(ArrayBracketPair arrayBracketPair, A arg);", "methodSignature: com.github.javaparser.ast.visitor.ModifierVisitorAdapter#visit\n methodBody: public Node visit(final LineComment n, final A arg) {\nreturn n;\n}", "methodSignature: com.github.javaparser.bdd.steps.ExistenceOfParentNodeVerifier.Verifier#visit\n methodBody: public void visit(WildcardType n, Void arg) {\nassertParentIsSet(n);\nsuper.visit(n,arg);\n}", "methodSignature: com.github.javaparser.ast.visitor.DumpVisitor#visit\n methodBody: public void visit(ArrayBracketPair arrayBracketPair, Object arg) {\nprintAnnotations(arrayBracketPair.getAnnotations(),true,arg);\nprinter.print(\"[]\");\n}", "methodSignature: com.github.javaparser.ast.visitor.CloneVisitor#visit\n methodBody: public <T extends Node> List<T> visit(List<T> _nodes, Object _arg) {\nif(_nodes == null)return null;\nList<T> r=new ArrayList<>(_nodes.size());\nfor(T n: _nodes){T rN=cloneNodes(n,_arg);\nif(rN != null)r.add(rN);\n}return r;\n}", "methodSignature: com.github.javaparser.bdd.visitors.PositionTestVisitor#doTest\n methodBody: void doTest(final Node node) {\nassertThat(node.getBegin().line,is(greaterThanOrEqualTo(0)));\nassertThat(node.getBegin().column,is(greaterThanOrEqualTo(0)));\nassertThat(node.getEnd().line,is(greaterThanOrEqualTo(0)));\nassertThat(node.getEnd().column,is(greaterThanOrEqualTo(0)));\nif(node.getBegin().line == node.getEnd().line){assertThat(node.getBegin().column,is(lessThanOrEqualTo(node.getEnd().column)));\n}{assertThat(node.getBegin().line,is(lessThanOrEqualTo(node.getEnd().line)));\n}numberOfNodesVisited++;\n}", "methodSignature: com.github.javaparser.ast.visitor.EqualsVisitor#visit\n methodBody: public Boolean visit(ArrayBracketPair n1, Node arg) {\nArrayBracketPair n2=(ArrayBracketPair)arg;\nif(!nodesEquals(n1.getAnnotations(),n2.getAnnotations())){return false;\n}return true;\n}", "methodSignature: com.github.javaparser.bdd.visitors.PositionTestVisitor#visit\n methodBody: public void visit(UnknownType n, Object arg) {\ndoTest(n);\nsuper.visit(n,arg);\n}", "methodSignature: com.github.javaparser.ast.visitor.VoidVisitorAdapter#visit\n methodBody: public void visit(ArrayBracketPair n, A arg) {\nvisitAnnotations(n,arg);\n}", "methodSignature: com.github.javaparser.ast.visitor.GenericVisitorAdapter#visit\n methodBody: public R visit(final LineComment n, final A arg) {\nreturn null;\n}", "methodSignature: com.github.javaparser.ast.visitor.VoidVisitor#visit\n methodBody: void visit(ArrayBracketPair arrayBracketPair, A arg);"], "sourceCodeAfterRefactoring": "@Override\n        public void visit(BlockComment n, Void arg) {\n            super.visit(n, arg);\n        }", "diffSourceCode": "-  101:         doTest(n);\n-  102:         super.visit(n, arg);\n-  103:     }\n-  104: \n-  250:     @Override public void visit(final ImportDeclaration n, final Object arg) {\n-  251:         doTest(n);\n-  252:         super.visit(n, arg);\n-  253:     }\n+  101:         @Override\n+  102:         public void visit(BlockComment n, Void arg) {\n+  103:             super.visit(n, arg);\n+  104:         }\n+  250:         public void visit(FieldDeclaration n, Void arg) {\n+  251:             assertParentIsSet(n);\n+  252:             super.visit(n, arg);\n+  253:         }\n", "uniqueId": "731c46d3bd61cc1e3e4733570dd80ab00cd63c87_250_253__101_104", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To perform the requested refactoring, we will move the `doTest` method from the `PositionTestVisitor` class to an existing utility class. Given the project structure, it seems appropriate to move it to the `TestUtils` class, which likely contains various utility methods for testing.\n\n### Step 1: Identify the target file path\nThe target file path for the move operation will be:\n```\njavaparser-testing/src/test/java/com/github/javaparser/bdd/TestUtils.java\n```\n\n### Step 2: Move the `doTest` method\nWe will move the `doTest` method to the `TestUtils` class and update it to be a `public static` method.\n\n### Moved Class Code\nHere is the code that will be added to the `TestUtils` class:\n```java\npackage com.github.javaparser.bdd;\n\nimport com.github.javaparser.ast.Node;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.greaterThanOrEqualTo;\nimport static org.hamcrest.Matchers.lessThanOrEqualTo;\nimport static org.hamcrest.core.Is.is;\n\npublic class TestUtils {\n    // Other utility methods...\n\n    public static void doTest(final Node node) {\n        assertThat(node.getBegin().line, is(greaterThanOrEqualTo(0)));\n        assertThat(node.getBegin().column, is(greaterThanOrEqualTo(0)));\n        assertThat(node.getEnd().line, is(greaterThanOrEqualTo(0)));\n        assertThat(node.getEnd().column, is(greaterThanOrEqualTo(0)));\n\n        if (node.getBegin().line == node.getEnd().line) {\n            assertThat(node.getBegin().column, is(lessThanOrEqualTo(node.getEnd().column)));\n        } else {\n            assertThat(node.getBegin().line, is(lessThanOrEqualTo(node.getEnd().line)));\n        }\n    }\n}\n```\n\n### Step 3: Refactor the `PositionTestVisitor` class\nNow we will refactor the `PositionTestVisitor` class to call the moved method from `TestUtils`.\n\n### Refactored Method Code\nHere is the updated `visit` method for `ImportDeclaration` in the `PositionTestVisitor` class:\n```java\n@Override public void visit(final ImportDeclaration n, final Object arg) {\n    TestUtils.doTest(n);\n    super.visit(n, arg);\n}\n```\n\n### Final Output\nNow, we can present the output in the required format:\n\n##########################\njavaparser-testing/src/test/java/com/github/javaparser/bdd/TestUtils.java\n##########################\npublic class TestUtils {\n    // Other utility methods...\n\n    public static void doTest(final Node node) {\n        assertThat(node.getBegin().line, is(greaterThanOrEqualTo(0)));\n        assertThat(node.getBegin().column, is(greaterThanOrEqualTo(0)));\n        assertThat(node.getEnd().line, is(greaterThanOrEqualTo(0)));\n        assertThat(node.getEnd().column, is(greaterThanOrEqualTo(0)));\n\n        if (node.getBegin().line == node.getEnd().line) {\n            assertThat(node.getBegin().column, is(lessThanOrEqualTo(node.getEnd().column)));\n        } else {\n            assertThat(node.getBegin().line, is(lessThanOrEqualTo(node.getEnd().line)));\n        }\n    }\n}\n##########################\n@Override public void visit(final ImportDeclaration n, final Object arg) {\n    TestUtils.doTest(n);\n    super.visit(n, arg);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override public void visit(final ImportDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\nClass content:\n/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2016 The JavaParser Team.\n *\n * This file is part of JavaParser.\n * \n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License \n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n \npackage com.github.javaparser.bdd.visitors;\n\nimport com.github.javaparser.ast.*;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.comments.BlockComment;\nimport com.github.javaparser.ast.comments.JavadocComment;\nimport com.github.javaparser.ast.comments.LineComment;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.*;\nimport com.github.javaparser.ast.type.*;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.greaterThanOrEqualTo;\nimport static org.hamcrest.Matchers.lessThanOrEqualTo;\nimport static org.hamcrest.core.Is.is;\n\n\npublic class PositionTestVisitor extends VoidVisitorAdapter<Object> {\n\n    private int numberOfNodesVisited;\n\n    @Override public void visit(final AnnotationDeclaration n, final Object arg) {\n        doTest(n);\n        doTest(n.getNameExpr());\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final AnnotationMemberDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ArrayAccessExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ArrayCreationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ArrayInitializerExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final AssertStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final AssignExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final BinaryExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final BlockComment n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final BlockStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final BooleanLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final BreakStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final CastExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final CatchClause n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LambdaExpr n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MethodReferenceExpr n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TypeExpr n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final CharLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ClassExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ClassOrInterfaceDeclaration n, final Object arg) {\n        doTest(n);\n        doTest(n.getNameExpr());\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ClassOrInterfaceType n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final CompilationUnit n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ConditionalExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ConstructorDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ContinueStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final DoStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final DoubleLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EmptyMemberDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EmptyStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EmptyTypeDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EnclosedExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EnumConstantDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EnumDeclaration n, final Object arg) {\n        doTest(n);\n        doTest(n.getNameExpr());\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ExplicitConstructorInvocationStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ExpressionStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final FieldAccessExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final FieldDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ForeachStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ForStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final IfStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ImportDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final InitializerDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final InstanceOfExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final IntegerLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final IntegerLiteralMinValueExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final JavadocComment n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final LabeledStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final LineComment n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final LongLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final LongLiteralMinValueExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final MarkerAnnotationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final MemberValuePair n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final MethodCallExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final MethodDeclaration n, final Object arg) {\n        doTest(n);\n        doTest(n.getNameExpr());\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final NameExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final NormalAnnotationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final NullLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ObjectCreationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final PackageDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final Parameter n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final PrimitiveType n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final QualifiedNameExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayType n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayCreationLevel n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final IntersectionType n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnionType n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ReturnStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final SingleMemberAnnotationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final StringLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final SuperExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final SwitchEntryStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final SwitchStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final SynchronizedStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ThisExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ThrowStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final TryStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final TypeDeclarationStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final TypeParameter n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final UnaryExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final VariableDeclarationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final VariableDeclarator n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final VariableDeclaratorId n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final VoidType n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final WhileStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final WildcardType n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnknownType n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    void doTest(final Node node) {\n        assertThat(node.getBegin().line, is(greaterThanOrEqualTo(0)));\n        assertThat(node.getBegin().column, is(greaterThanOrEqualTo(0)));\n        assertThat(node.getEnd().line, is(greaterThanOrEqualTo(0)));\n        assertThat(node.getEnd().column, is(greaterThanOrEqualTo(0)));\n\n        if (node.getBegin().line == node.getEnd().line) {\n            assertThat(node.getBegin().column, is(lessThanOrEqualTo(node.getEnd().column)));\n        } else {\n            assertThat(node.getBegin().line, is(lessThanOrEqualTo(node.getEnd().line)));\n        }\n        numberOfNodesVisited++;\n    }\n\n    public int getNumberOfNodesVisited() {\n        return numberOfNodesVisited;\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['javaparser-testing/src/test/java/com/github/javaparser/ParseResultTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/TypeConstructionTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/UserDataKeyTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/ast/expr/QualifiedNameExprTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/BasicJBehaveTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/CommentParsingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ComparingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/DumpingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ManipulationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ParsingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/PositionRangeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/TestUtils.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/VisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ComparingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/DumpingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ExistenceOfParentNodeVerifier.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ManipulationSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ParsingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/PositionRangeSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/SharedSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/VisitorSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/visitors/PositionTestVisitor.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/ast/Visitors.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/ClassOrInterfaceDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/CompilationUnitBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/EnumDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/FieldDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/NodeWithAnnotationsBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/NodeWithMembersBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/NodeWithParametersBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/NodeWithThrowableBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/visitor/CloneVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/ChangingMethodsFromAClassWithAVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/ChangingMethodsFromAClassWithoutAVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/ClassCreator.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/CreatingACompilationUnitFromScratch.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/CuPrinter.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/MethodChanger_1.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/MethodChanger_2.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/MethodPrinter.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/PrintingTheCompilationUnitToSystemOutputTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/TestFileToken.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/VisitingClassMethodsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/removenode/D.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/removenode/GitHubTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/removenode/GitHubTest_2.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/removenode/RemoveDeleteNodeFromAst.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/ClassInLatin1.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/JavaConcepts.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/package-info.java', 'javaparser-testing/src/test/resources/com/github/javaparser/junit/wiki_samples/TestFile.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move And Inline Method", "description": "Move And Inline Method\tpublic setDoNotConsiderAnnotationsAsNodeStartForCodeAttribution(newValue boolean) : void moved from class com.github.javaparser.CommentsInserter to class com.github.javaparser.bdd.steps.CommentParsingSteps & inlined to public whenTheDoNotConsiderAnnotationsAsNodeStartForCodeAttributionIsTrueOnTheJavaParser(value boolean) : void", "diffLocations": [{"filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java", "startLine": 88, "endLine": 91, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java", "startLine": 77, "endLine": 80, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java", "startLine": 66, "endLine": 68, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "public class CommentParsingSteps {\n\n    private CompilationUnit compilationUnit;", "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java", "isPureRefactoring": true, "commitId": "ead1412d06bf2ba7eaec982231023aef4aed370a", "packageNameBefore": "com.github.javaparser", "classNameBefore": "com.github.javaparser.CommentsInserter", "methodNameBefore": "com.github.javaparser.CommentsInserter#setDoNotConsiderAnnotationsAsNodeStartForCodeAttribution", "classSignatureBefore": "class CommentsInserter ", "methodNameBeforeSet": ["com.github.javaparser.CommentsInserter#setDoNotConsiderAnnotationsAsNodeStartForCodeAttribution"], "classNameBeforeSet": ["com.github.javaparser.CommentsInserter"], "classSignatureBeforeSet": ["class CommentsInserter "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2016 The JavaParser Team.\n *\n * This file is part of JavaParser.\n * \n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License \n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n \npackage com.github.javaparser.bdd.steps;\n\nimport static com.github.javaparser.Range.range;\nimport static com.github.javaparser.bdd.steps.SharedSteps.getMemberByTypeAndPosition;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.hamcrest.text.IsEqualIgnoringWhiteSpace.equalToIgnoringWhiteSpace;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.fail;\n\nimport java.io.IOException;\nimport java.io.StringReader;\n\nimport org.jbehave.core.annotations.Alias;\nimport org.jbehave.core.annotations.Given;\nimport org.jbehave.core.annotations.Then;\nimport org.jbehave.core.annotations.When;\nimport org.jbehave.core.model.ExamplesTable;\nimport org.jbehave.core.steps.Parameters;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseException;\nimport com.github.javaparser.TokenMgrException;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.comments.BlockComment;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.comments.CommentsCollection;\nimport com.github.javaparser.ast.comments.CommentsParser;\nimport com.github.javaparser.ast.comments.JavadocComment;\nimport com.github.javaparser.ast.comments.LineComment;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.IntegerLiteralExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.visitor.DumpVisitor;\nimport com.github.javaparser.bdd.TestUtils;\n\npublic class CommentParsingSteps {\n\n    private CompilationUnit compilationUnit;\n    private CommentsCollection commentsCollection;\n    private String sourceUnderTest;\n\n    @Given(\"the class:$classSrc\")\n    public void givenTheClass(String classSrc) {\n        this.sourceUnderTest = classSrc.trim();\n    }\n\n    @When(\"read sample \\\"$sampleName\\\" using encoding \\\"$encoding\\\"\")\n    public void givenTheClassWithEncoding(String sampleName, String encoding) throws IOException {\n        sourceUnderTest = null;\n        commentsCollection = new CommentsParser().parse(TestUtils.getSampleStream(sampleName), encoding);\n    }\n\n    @When(\"the class is parsed by the comment parser\")\n    public void whenTheClassIsParsedByTheCommentParser() throws IOException {\n        commentsCollection = new CommentsParser().parse(sourceUnderTest);\n    }\n\n    @When(\"the do not consider annotations as node start for code attribution is $value on the Java parser\")\n    public void whenTheDoNotConsiderAnnotationsAsNodeStartForCodeAttributionIsTrueOnTheJavaParser(boolean value) {\n        JavaParser.setDoNotConsiderAnnotationsAsNodeStartForCodeAttribution(value);\n    }\n\n    @When(\"the class is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n        compilationUnit = JavaParser.parse(sourceUnderTest);\n    }\n\n    @Then(\"the Java parser cannot parse it because of lexical errors\")\n    public void javaParserCannotParseBecauseOfLexicalErrors() throws ParseException {\n        try {\n            compilationUnit = JavaParser.parse(sourceUnderTest);\n            fail(\"Lexical error expected\");\n        } catch (TokenMgrException e) {\n            // ok\n        }\n    }\n\n    @Then(\"the total number of comments is $expectedCount\")\n    public void thenTheTotalNumberOfCommentsIs(int expectedCount) {\n        assertThat(commentsCollection.size(), is(expectedCount));\n    }\n\n    @Then(\"line comment $position is \\\"$expectedContent\\\"\")\n    public void thenLineCommentIs(int position, String expectedContent) {\n        LineComment lineCommentUnderTest = commentsCollection.getLineComments().get(position-1);\n\n        assertThat(lineCommentUnderTest.getContent(), is(expectedContent));\n    }\n\n    @Then(\"block comment $position is \\\"$expectedContent\\\"\")\n    public void thenBlockCommentIs(int position, String expectedContent) {\n        BlockComment lineCommentUnderTest = commentsCollection.getBlockComments().get(position - 1);\n\n        assertThat(lineCommentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"Javadoc comment $position is \\\"$expectedContent\\\"\")\n    public void thenJavadocCommentIs(int position, String expectedContent) {\n        JavadocComment commentUnderTest = commentsCollection.getJavadocComments().get(position- 1);\n\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"the line comments have the following positions: $table\")\n    public void thenTheLineCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        int index = 0;\n        for(Parameters exampleRow : examplesTable.getRowsAsParameters()){\n            Comment expectedLineComment = toComment(exampleRow, new LineComment());\n            Comment lineCommentUnderTest = commentsCollection.getLineComments().get(index);\n\n            assertThat(lineCommentUnderTest.getBegin().line, is(expectedLineComment.getBegin().line));\n            assertThat(lineCommentUnderTest.getBegin().column, is(expectedLineComment.getBegin().column));\n            assertThat(lineCommentUnderTest.getEnd().line, is(expectedLineComment.getEnd().line));\n            assertThat(lineCommentUnderTest.getEnd().column, is(expectedLineComment.getEnd().column));\n            index ++;\n        }\n    }\n\n    @Then(\"the block comments have the following positions: $table\")\n    public void thenTheBlockCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        int index = 0;\n        for(Parameters exampleRow : examplesTable.getRowsAsParameters()){\n            Comment expectedLineComment = toComment(exampleRow, new BlockComment());\n            Comment lineCommentUnderTest = commentsCollection.getBlockComments().get(index);\n\n            assertThat(lineCommentUnderTest.getBegin().line, is(expectedLineComment.getBegin().line));\n            assertThat(lineCommentUnderTest.getBegin().column, is(expectedLineComment.getBegin().column));\n            assertThat(lineCommentUnderTest.getEnd().line, is(expectedLineComment.getEnd().line));\n            assertThat(lineCommentUnderTest.getEnd().column, is(expectedLineComment.getEnd().column));\n            index ++;\n        }\n    }\n\n    @Then(\"the Javadoc comments have the following positions: $table\")\n    public void thenTheJavadocCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        int index = 0;\n        for(Parameters exampleRow : examplesTable.getRowsAsParameters()){\n            Comment expectedLineComment = toComment(exampleRow, new BlockComment());\n            Comment lineCommentUnderTest = commentsCollection.getJavadocComments().get(index);\n\n            assertThat(lineCommentUnderTest.getBegin().line, is(expectedLineComment.getBegin().line));\n            assertThat(lineCommentUnderTest.getBegin().column, is(expectedLineComment.getBegin().column));\n            assertThat(lineCommentUnderTest.getEnd().line, is(expectedLineComment.getEnd().line));\n            assertThat(lineCommentUnderTest.getEnd().column, is(expectedLineComment.getEnd().column));\n            index ++;\n        }\n    }\n\n    @Then(\"it is dumped to:$dumpSrc\")\n    public void isDumpedTo(String dumpSrc) {\n        DumpVisitor dumpVisitor = new DumpVisitor();\n        dumpVisitor.visit(compilationUnit, null);\n        assertThat(dumpVisitor.getSource().trim(), is(dumpSrc.trim()));\n    }\n\n    @Then(\"the compilation unit is not commented\")\n    public void thenTheCompilationUnitIsNotCommented() {\n        assertThat(compilationUnit.getComment(), is(nullValue()));\n    }\n\n    @Then(\"the compilation is commented \\\"$expectedContent\\\"\")\n    public void thenTheCompilationIsCommentedCompilationUnitComment(String expectedContent) {\n        assertThat(compilationUnit.getComment().getContent(), is(expectedContent));\n    }\n\n    @Then(\"the compilation unit has $expectedCount contained comments\")\n    public void thenTheCompilationUnitHasContainedComments(int expectedCount) {\n        assertThat(compilationUnit.getComments().size(), is(expectedCount));\n    }\n\n    @Then(\"the compilation unit has $expectedCount orphan comments\")\n    public void thenTheCompilationUnitHasExpectedCountOrphanComments(int expectedCount) {\n        assertThat(compilationUnit.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"the compilation unit orphan comment $position is \\\"$expectedContent\\\"\")\n    public void thenTheCompilationUnitOrphanCommentIs(int position, String expectedContent) {\n        Comment commentUnderTest = compilationUnit.getOrphanComments().get(position - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is not an orphan\")\n    public void thenCommentInCompilationUnitIsNotAnOrphan(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.isOrphan(), is(false));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is an orphan\")\n    public void thenCommentInCompilationUnitIsAnOrphan(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.isOrphan(), is(true));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is \\\"$expectedContent\\\"\")\n    public void thenCommentInCompilationUnitIs(int position, String expectedContent) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(position - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"class $position is not commented\")\n    public void thenClassIsNotCommented(int position) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getComment(), is(nullValue()));\n    }\n\n    @Then(\"class $position is commented \\\"$expectedContent\\\"\")\n    public void thenClassIsCommented(int position, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getComment().getContent(), is(expectedContent));\n    }\n\n    @Then(\"class $position has $expectedCount total contained comments\")\n    public void thenClassHasTotalContainedComments(int position, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"class $position has $expectedCount orphan comment\")\n    @Alias(\"class $position has $expectedCount orphan comments\")\n    public void thenClassHasOrphanComments(int position, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"class $classPosition orphan comment $commentPosition is \\\"$expectedContent\\\"\")\n    public void thenClassOrphanCommentIs(int classPosition, int commentPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        Comment commentUnderTest = classUnderTest.getOrphanComments().get(commentPosition -1 );\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"method $methodPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenMethodInClassIsCommented(int methodPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getComment().getContent(), equalToIgnoringWhiteSpace(expectedContent));\n    }\n\n    @Then(\"method $methodPosition in class $classPosition has $expectedCount total contained comments\")\n    public void thenMethodInClassHasTotalContainedComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"comment $commentPosition in method $methodPosition in class $classPosition is \\\"$expectedContent\\\"\")\n    public void thenCommentInMethodInClassIs(int commentPosition, int methodPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        Comment commentUnderTest = methodUnderTest.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"method $methodPosition in class $classPosition has $expectedCount orphan comments\")\n    public void thenMethodInClassHasOrphanComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition has $expectedCount total contained comments\")\n    public void thenBlockStatementInMethodInClassHasTotalContainedComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        assertThat(blockStmtUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition has $expectedCount orphan comments\")\n    public void thenBlockStatementInMethodInClassHasOrphanComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        assertThat(blockStmtUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition orphan comment $commentPosition is \\\"$expectedContent\\\"\")\n    public void thenBlockStatementInMethodInClassIs(int methodPosition, int classPosition, int commentPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition -1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        Comment commentUnderTest = blockStmtUnderTest.getOrphanComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"type of method $methodPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenTypeOfMethodInClassIsCommented(int methodPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition -1,\n                MethodDeclaration.class);\n        Comment commentUnderTest = methodUnderTest.getType().getComment();\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition contains $expectedCount comments\")\n    public void thenFieldInClassContainsComments(int fieldPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        assertThat(fieldUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition is not commented\")\n    public void thenFieldInClassIsNotCommented(int fieldPosition, int classPosition) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        assertThat(fieldUnderTest.getComment(), is(nullValue()));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenFieldInClassIsCommented(int fieldPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        Comment commentUnderTest = fieldUnderTest.getComment();\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"variable $variablePosition value of field $fieldPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenVariableValueOfFieldInClassIsCommented(int variablePosition, int fieldPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        VariableDeclarator variableUnderTest = fieldUnderTest.getVariables().get(variablePosition - 1);\n        Expression valueUnderTest = variableUnderTest.getInit();\n        Comment commentUnderTest = valueUnderTest.getComment();\n        assertThat(commentUnderTest.getContent(), is(expectedContent));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit parent is ClassOrInterfaceDeclaration\")\n    public void thenCommentInCompilationUnitParentIsClassOrInterfaceDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getParentNode(), instanceOf(ClassOrInterfaceDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is ClassOrInterfaceDeclaration\")\n    public void thenCommentInCompilationUnitCommentedNodeIsClassOrInterfaceDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(ClassOrInterfaceDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is FieldDeclaration\")\n    public void thenCommentInCompilationUnitCommentedNodeIsFieldDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(FieldDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is IntegerLiteralExpr\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerLiteralExpr(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(IntegerLiteralExpr.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is ExpressionStmt\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerExpressionStmt(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(ExpressionStmt.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is PrimitiveType\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerPrimitiveType(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(PrimitiveType.class));\n    }\n\n    private Comment toComment(Parameters row, Comment comment) {\n        comment.setRange(range(Integer.parseInt(row.values().get(\"beginLine\")),\n                Integer.parseInt(row.values().get(\"beginColumn\")),\n                Integer.parseInt(row.values().get(\"endLine\")),\n                Integer.parseInt(row.values().get(\"endColumn\"))));\n        return comment;\n    }\n}\n", "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2016 The JavaParser Team.\n *\n * This file is part of JavaParser.\n * \n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License \n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n \npackage com.github.javaparser.bdd.steps;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.comments.*;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.IntegerLiteralExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.visitor.DumpVisitor;\nimport com.github.javaparser.bdd.TestUtils;\nimport org.jbehave.core.annotations.Alias;\nimport org.jbehave.core.annotations.Given;\nimport org.jbehave.core.annotations.Then;\nimport org.jbehave.core.annotations.When;\nimport org.jbehave.core.model.ExamplesTable;\nimport org.jbehave.core.steps.Parameters;\n\nimport java.io.IOException;\n\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.Range.range;\nimport static com.github.javaparser.bdd.steps.SharedSteps.getMemberByTypeAndPosition;\nimport static org.hamcrest.CoreMatchers.*;\nimport static org.hamcrest.text.IsEqualIgnoringWhiteSpace.equalToIgnoringWhiteSpace;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.fail;\n\npublic class CommentParsingSteps {\n\n    private CompilationUnit compilationUnit;\n    private CommentsCollection commentsCollection;\n    private String sourceUnderTest;\n    private ParserConfiguration configuration = new ParserConfiguration();\n\n    @Given(\"the class:$classSrc\")\n    public void givenTheClass(String classSrc) {\n        this.sourceUnderTest = classSrc.trim();\n    }\n\n    @When(\"read sample \\\"$sampleName\\\" using encoding \\\"$encoding\\\"\")\n    public void givenTheClassWithEncoding(String sampleName, String encoding) throws IOException {\n        sourceUnderTest = null;\n        commentsCollection = new CommentsParser().parse(TestUtils.getSampleStream(sampleName), encoding);\n    }\n\n    @When(\"the class is parsed by the comment parser\")\n    public void whenTheClassIsParsedByTheCommentParser() throws IOException {\n        commentsCollection = new CommentsParser().parse(sourceUnderTest);\n    }\n\n    @When(\"the do not consider annotations as node start for code attribution is $value on the Java parser\")\n    public void whenTheDoNotConsiderAnnotationsAsNodeStartForCodeAttributionIsTrueOnTheJavaParser(boolean value) {\n        configuration.doNotConsiderAnnotationsAsNodeStartForCodeAttribution = value;\n    }\n\n    @When(\"the do not assign comments preceding empty lines is $value on the Java parser\")\n    public void whenTheDoNotAssignCommentsPrecedingEmptyLinesIsTrueOnTheJavaParser(boolean value) {\n        configuration.doNotAssignCommentsPrecedingEmptyLines = value;\n    }\n\n    @When(\"the class is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() {\n        compilationUnit = new JavaParser(configuration).parseFull(provider(sourceUnderTest)).result.get();\n    }\n\n    @Then(\"the Java parser cannot parse it because of lexical errors\")\n    public void javaParserCannotParseBecauseOfLexicalErrors() {\n        ParseResult<CompilationUnit> result = new JavaParser(configuration).parseFull(provider(sourceUnderTest));\n        if(result.isSuccessful()){\n            fail(\"Lexical error expected\");\n        }\n    }\n\n    @Then(\"the total number of comments is $expectedCount\")\n    public void thenTheTotalNumberOfCommentsIs(int expectedCount) {\n        assertThat(commentsCollection.size(), is(expectedCount));\n    }\n\n    @Then(\"line comment $position is \\\"$expectedContent\\\"\")\n    public void thenLineCommentIs(int position, String expectedContent) {\n        LineComment lineCommentUnderTest = commentsCollection.getLineComments().get(position-1);\n\n        assertThat(lineCommentUnderTest.getContent(), is(expectedContent));\n    }\n\n    @Then(\"block comment $position is \\\"$expectedContent\\\"\")\n    public void thenBlockCommentIs(int position, String expectedContent) {\n        BlockComment lineCommentUnderTest = commentsCollection.getBlockComments().get(position - 1);\n\n        assertThat(lineCommentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"Javadoc comment $position is \\\"$expectedContent\\\"\")\n    public void thenJavadocCommentIs(int position, String expectedContent) {\n        JavadocComment commentUnderTest = commentsCollection.getJavadocComments().get(position- 1);\n\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"the line comments have the following positions: $table\")\n    public void thenTheLineCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        int index = 0;\n        for(Parameters exampleRow : examplesTable.getRowsAsParameters()){\n            Comment expectedLineComment = toComment(exampleRow, new LineComment());\n            Comment lineCommentUnderTest = commentsCollection.getLineComments().get(index);\n\n            assertThat(lineCommentUnderTest.getBegin().line, is(expectedLineComment.getBegin().line));\n            assertThat(lineCommentUnderTest.getBegin().column, is(expectedLineComment.getBegin().column));\n            assertThat(lineCommentUnderTest.getEnd().line, is(expectedLineComment.getEnd().line));\n            assertThat(lineCommentUnderTest.getEnd().column, is(expectedLineComment.getEnd().column));\n            index ++;\n        }\n    }\n\n    @Then(\"the block comments have the following positions: $table\")\n    public void thenTheBlockCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        int index = 0;\n        for(Parameters exampleRow : examplesTable.getRowsAsParameters()){\n            Comment expectedLineComment = toComment(exampleRow, new BlockComment());\n            Comment lineCommentUnderTest = commentsCollection.getBlockComments().get(index);\n\n            assertThat(lineCommentUnderTest.getBegin().line, is(expectedLineComment.getBegin().line));\n            assertThat(lineCommentUnderTest.getBegin().column, is(expectedLineComment.getBegin().column));\n            assertThat(lineCommentUnderTest.getEnd().line, is(expectedLineComment.getEnd().line));\n            assertThat(lineCommentUnderTest.getEnd().column, is(expectedLineComment.getEnd().column));\n            index ++;\n        }\n    }\n\n    @Then(\"the Javadoc comments have the following positions: $table\")\n    public void thenTheJavadocCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        int index = 0;\n        for(Parameters exampleRow : examplesTable.getRowsAsParameters()){\n            Comment expectedLineComment = toComment(exampleRow, new BlockComment());\n            Comment lineCommentUnderTest = commentsCollection.getJavadocComments().get(index);\n\n            assertThat(lineCommentUnderTest.getBegin().line, is(expectedLineComment.getBegin().line));\n            assertThat(lineCommentUnderTest.getBegin().column, is(expectedLineComment.getBegin().column));\n            assertThat(lineCommentUnderTest.getEnd().line, is(expectedLineComment.getEnd().line));\n            assertThat(lineCommentUnderTest.getEnd().column, is(expectedLineComment.getEnd().column));\n            index ++;\n        }\n    }\n\n    @Then(\"it is dumped to:$dumpSrc\")\n    public void isDumpedTo(String dumpSrc) {\n        DumpVisitor dumpVisitor = new DumpVisitor();\n        dumpVisitor.visit(compilationUnit, null);\n        assertThat(dumpVisitor.getSource().trim(), is(dumpSrc.trim()));\n    }\n\n    @Then(\"the compilation unit is not commented\")\n    public void thenTheCompilationUnitIsNotCommented() {\n        assertThat(compilationUnit.getComment(), is(nullValue()));\n    }\n\n    @Then(\"the compilation is commented \\\"$expectedContent\\\"\")\n    public void thenTheCompilationIsCommentedCompilationUnitComment(String expectedContent) {\n        assertThat(compilationUnit.getComment().getContent(), is(expectedContent));\n    }\n\n    @Then(\"the compilation unit has $expectedCount contained comments\")\n    public void thenTheCompilationUnitHasContainedComments(int expectedCount) {\n        assertThat(compilationUnit.getComments().size(), is(expectedCount));\n    }\n\n    @Then(\"the compilation unit has $expectedCount orphan comments\")\n    public void thenTheCompilationUnitHasExpectedCountOrphanComments(int expectedCount) {\n        assertThat(compilationUnit.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"the compilation unit orphan comment $position is \\\"$expectedContent\\\"\")\n    public void thenTheCompilationUnitOrphanCommentIs(int position, String expectedContent) {\n        Comment commentUnderTest = compilationUnit.getOrphanComments().get(position - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is not an orphan\")\n    public void thenCommentInCompilationUnitIsNotAnOrphan(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.isOrphan(), is(false));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is an orphan\")\n    public void thenCommentInCompilationUnitIsAnOrphan(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.isOrphan(), is(true));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is \\\"$expectedContent\\\"\")\n    public void thenCommentInCompilationUnitIs(int position, String expectedContent) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(position - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"class $position is not commented\")\n    public void thenClassIsNotCommented(int position) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getComment(), is(nullValue()));\n    }\n\n    @Then(\"class $position is commented \\\"$expectedContent\\\"\")\n    public void thenClassIsCommented(int position, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getComment().getContent(), is(expectedContent));\n    }\n\n    @Then(\"class $position has $expectedCount total contained comments\")\n    public void thenClassHasTotalContainedComments(int position, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"class $position has $expectedCount orphan comment\")\n    @Alias(\"class $position has $expectedCount orphan comments\")\n    public void thenClassHasOrphanComments(int position, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"class $classPosition orphan comment $commentPosition is \\\"$expectedContent\\\"\")\n    public void thenClassOrphanCommentIs(int classPosition, int commentPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        Comment commentUnderTest = classUnderTest.getOrphanComments().get(commentPosition -1 );\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"method $methodPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenMethodInClassIsCommented(int methodPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getComment().getContent(), equalToIgnoringWhiteSpace(expectedContent));\n    }\n\n    @Then(\"method $methodPosition in class $classPosition has $expectedCount total contained comments\")\n    public void thenMethodInClassHasTotalContainedComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"comment $commentPosition in method $methodPosition in class $classPosition is \\\"$expectedContent\\\"\")\n    public void thenCommentInMethodInClassIs(int commentPosition, int methodPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        Comment commentUnderTest = methodUnderTest.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"method $methodPosition in class $classPosition has $expectedCount orphan comments\")\n    public void thenMethodInClassHasOrphanComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition has $expectedCount total contained comments\")\n    public void thenBlockStatementInMethodInClassHasTotalContainedComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        assertThat(blockStmtUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition has $expectedCount orphan comments\")\n    public void thenBlockStatementInMethodInClassHasOrphanComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        assertThat(blockStmtUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition orphan comment $commentPosition is \\\"$expectedContent\\\"\")\n    public void thenBlockStatementInMethodInClassIs(int methodPosition, int classPosition, int commentPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition -1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        Comment commentUnderTest = blockStmtUnderTest.getOrphanComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"type of method $methodPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenTypeOfMethodInClassIsCommented(int methodPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition -1,\n                MethodDeclaration.class);\n        Comment commentUnderTest = methodUnderTest.getType().getComment();\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition contains $expectedCount comments\")\n    public void thenFieldInClassContainsComments(int fieldPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        assertThat(fieldUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition is not commented\")\n    public void thenFieldInClassIsNotCommented(int fieldPosition, int classPosition) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        assertThat(fieldUnderTest.getComment(), is(nullValue()));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenFieldInClassIsCommented(int fieldPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        Comment commentUnderTest = fieldUnderTest.getComment();\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"variable $variablePosition value of field $fieldPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenVariableValueOfFieldInClassIsCommented(int variablePosition, int fieldPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        VariableDeclarator variableUnderTest = fieldUnderTest.getVariables().get(variablePosition - 1);\n        Expression valueUnderTest = variableUnderTest.getInit();\n        Comment commentUnderTest = valueUnderTest.getComment();\n        assertThat(commentUnderTest.getContent(), is(expectedContent));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit parent is ClassOrInterfaceDeclaration\")\n    public void thenCommentInCompilationUnitParentIsClassOrInterfaceDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getParentNode(), instanceOf(ClassOrInterfaceDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is ClassOrInterfaceDeclaration\")\n    public void thenCommentInCompilationUnitCommentedNodeIsClassOrInterfaceDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(ClassOrInterfaceDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is FieldDeclaration\")\n    public void thenCommentInCompilationUnitCommentedNodeIsFieldDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(FieldDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is IntegerLiteralExpr\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerLiteralExpr(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(IntegerLiteralExpr.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is ExpressionStmt\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerExpressionStmt(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(ExpressionStmt.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is PrimitiveType\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerPrimitiveType(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(PrimitiveType.class));\n    }\n\n    private Comment toComment(Parameters row, Comment comment) {\n        comment.setRange(range(Integer.parseInt(row.values().get(\"beginLine\")),\n                Integer.parseInt(row.values().get(\"beginColumn\")),\n                Integer.parseInt(row.values().get(\"endLine\")),\n                Integer.parseInt(row.values().get(\"endColumn\"))));\n        return comment;\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@When(\"the do not consider annotations as node start for code attribution is $value on the Java parser\")\n    public void whenTheDoNotConsiderAnnotationsAsNodeStartForCodeAttributionIsTrueOnTheJavaParser(boolean value) {\n        configuration.doNotConsiderAnnotationsAsNodeStartForCodeAttribution = value;\n    }", "diffSourceCode": "-   66: public class CommentParsingSteps {\n-   67: \n-   68:     private CompilationUnit compilationUnit;\n-   77:     @When(\"read sample \\\"$sampleName\\\" using encoding \\\"$encoding\\\"\")\n-   78:     public void givenTheClassWithEncoding(String sampleName, String encoding) throws IOException {\n-   79:         sourceUnderTest = null;\n-   80:         commentsCollection = new CommentsParser().parse(TestUtils.getSampleStream(sampleName), encoding);\n-   88:     @When(\"the do not consider annotations as node start for code attribution is $value on the Java parser\")\n-   89:     public void whenTheDoNotConsiderAnnotationsAsNodeStartForCodeAttributionIsTrueOnTheJavaParser(boolean value) {\n-   90:         JavaParser.setDoNotConsiderAnnotationsAsNodeStartForCodeAttribution(value);\n-   91:     }\n+   66:     @When(\"read sample \\\"$sampleName\\\" using encoding \\\"$encoding\\\"\")\n+   67:     public void givenTheClassWithEncoding(String sampleName, String encoding) throws IOException {\n+   68:         sourceUnderTest = null;\n+   77:     @When(\"the do not consider annotations as node start for code attribution is $value on the Java parser\")\n+   78:     public void whenTheDoNotConsiderAnnotationsAsNodeStartForCodeAttributionIsTrueOnTheJavaParser(boolean value) {\n+   79:         configuration.doNotConsiderAnnotationsAsNodeStartForCodeAttribution = value;\n+   80:     }\n+   88:     public void whenTheClassIsParsedByTheJavaParser() {\n+   89:         compilationUnit = new JavaParser(configuration).parseFull(provider(sourceUnderTest)).result.get();\n+   90:     }\n+   91: \n", "uniqueId": "ead1412d06bf2ba7eaec982231023aef4aed370a_88_91__77_80_66_68", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To refactor the provided `CommentParsingSteps` class by moving and inlining methods, we will focus on the methods that have repetitive patterns, particularly those that deal with assertions on comments. We can create a helper method to reduce redundancy and improve readability.\n\n### Refactoring Steps:\n1. Identify methods that have similar logic, particularly those that assert properties of comments.\n2. Create a new private method that encapsulates the common logic.\n3. Replace the original methods with calls to the new method.\n\n### Target File Path:\nThe target file path for the refactored class will be:\n```\njavaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java\n```\n\n### Refactored Class Code:\nHere is the refactored code for the `CommentParsingSteps` class:\n\n```java\npackage com.github.javaparser.bdd.steps;\n\nimport static com.github.javaparser.Range.range;\nimport static com.github.javaparser.bdd.steps.SharedSteps.getMemberByTypeAndPosition;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.hamcrest.text.IsEqualIgnoringWhiteSpace.equalToIgnoringWhiteSpace;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.fail;\n\nimport java.io.IOException;\n\nimport org.jbehave.core.annotations.Alias;\nimport org.jbehave.core.annotations.Given;\nimport org.jbehave.core.annotations.Then;\nimport org.jbehave.core.annotations.When;\nimport org.jbehave.core.model.ExamplesTable;\nimport org.jbehave.core.steps.Parameters;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseException;\nimport com.github.javaparser.TokenMgrException;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.comments.BlockComment;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.comments.CommentsCollection;\nimport com.github.javaparser.ast.comments.CommentsParser;\nimport com.github.javaparser.ast.comments.JavadocComment;\nimport com.github.javaparser.ast.comments.LineComment;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.IntegerLiteralExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.visitor.DumpVisitor;\nimport com.github.javaparser.bdd.TestUtils;\n\npublic class CommentParsingSteps {\n\n    private CompilationUnit compilationUnit;\n    private CommentsCollection commentsCollection;\n    private String sourceUnderTest;\n\n    @Given(\"the class:$classSrc\")\n    public void givenTheClass(String classSrc) {\n        this.sourceUnderTest = classSrc.trim();\n    }\n\n    @When(\"read sample \\\"$sampleName\\\" using encoding \\\"$encoding\\\"\")\n    public void givenTheClassWithEncoding(String sampleName, String encoding) throws IOException {\n        sourceUnderTest = null;\n        commentsCollection = new CommentsParser().parse(TestUtils.getSampleStream(sampleName), encoding);\n    }\n\n    @When(\"the class is parsed by the comment parser\")\n    public void whenTheClassIsParsedByTheCommentParser() throws IOException {\n        commentsCollection = new CommentsParser().parse(sourceUnderTest);\n    }\n\n    @When(\"the do not consider annotations as node start for code attribution is $value on the Java parser\")\n    public void whenTheDoNotConsiderAnnotationsAsNodeStartForCodeAttributionIsTrueOnTheJavaParser(boolean value) {\n        JavaParser.setDoNotConsiderAnnotationsAsNodeStartForCodeAttribution(value);\n    }\n\n    @When(\"the class is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n        compilationUnit = JavaParser.parse(sourceUnderTest);\n    }\n\n    @Then(\"the Java parser cannot parse it because of lexical errors\")\n    public void javaParserCannotParseBecauseOfLexicalErrors() throws ParseException {\n        try {\n            compilationUnit = JavaParser.parse(sourceUnderTest);\n            fail(\"Lexical error expected\");\n        } catch (TokenMgrException e) {\n            // ok\n        }\n    }\n\n    @Then(\"the total number of comments is $expectedCount\")\n    public void thenTheTotalNumberOfCommentsIs(int expectedCount) {\n        assertThat(commentsCollection.size(), is(expectedCount));\n    }\n\n    @Then(\"line comment $position is \\\"$expectedContent\\\"\")\n    public void thenLineCommentIs(int position, String expectedContent) {\n        assertCommentContent(commentsCollection.getLineComments().get(position - 1), expectedContent);\n    }\n\n    @Then(\"block comment $position is \\\"$expectedContent\\\"\")\n    public void thenBlockCommentIs(int position, String expectedContent) {\n        assertCommentContent(commentsCollection.getBlockComments().get(position - 1), expectedContent);\n    }\n\n    @Then(\"Javadoc comment $position is \\\"$expectedContent\\\"\")\n    public void thenJavadocCommentIs(int position, String expectedContent) {\n        assertCommentContent(commentsCollection.getJavadocComments().get(position - 1), expectedContent);\n    }\n\n    private void assertCommentContent(Comment commentUnderTest, String expectedContent) {\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"the line comments have the following positions: $table\")\n    public void thenTheLineCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        assertCommentPositions(examplesTable, commentsCollection.getLineComments());\n    }\n\n    @Then(\"the block comments have the following positions: $table\")\n    public void thenTheBlockCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        assertCommentPositions(examplesTable, commentsCollection.getBlockComments());\n    }\n\n    @Then(\"the Javadoc comments have the following positions: $table\")\n    public void thenTheJavadocCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        assertCommentPositions(examplesTable, commentsCollection.getJavadocComments());\n    }\n\n    private void assertCommentPositions(ExamplesTable examplesTable, List<? extends Comment> comments) {\n        int index = 0;\n        for (Parameters exampleRow : examplesTable.getRowsAsParameters()) {\n            Comment expectedComment = toComment(exampleRow, new LineComment());\n            Comment commentUnderTest = comments.get(index);\n\n            assertThat(commentUnderTest.getBegin().line, is(expectedComment.getBegin().line));\n            assertThat(commentUnderTest.getBegin().column, is(expectedComment.getBegin().column));\n            assertThat(commentUnderTest.getEnd().line, is(expectedComment.getEnd().line));\n            assertThat(commentUnderTest.getEnd().column, is(expectedComment.getEnd().column));\n            index++;\n        }\n    }\n\n    @Then(\"it is dumped to:$dumpSrc\")\n    public void isDumpedTo(String dumpSrc) {\n        DumpVisitor dumpVisitor = new DumpVisitor();\n        dumpVisitor.visit(compilationUnit, null);\n        assertThat(dumpVisitor.getSource().trim(), is(dumpSrc.trim()));\n    }\n\n    @Then(\"the compilation unit is not commented\")\n    public void thenTheCompilationUnitIsNotCommented() {\n        assertThat(compilationUnit.getComment(), is(nullValue()));\n    }\n\n    @Then(\"the compilation is commented \\\"$expectedContent\\\"\")\n    public void thenTheCompilationIsCommentedCompilationUnitComment(String expectedContent) {\n        assertThat(compilationUnit.getComment().getContent(), is(expectedContent));\n    }\n\n    @Then(\"the compilation unit has $expectedCount contained comments\")\n    public void thenTheCompilationUnitHasContainedComments(int expectedCount) {\n        assertThat(compilationUnit.getComments().size(), is(expectedCount));\n    }\n\n    @Then(\"the compilation unit has $expectedCount orphan comments\")\n    public void thenTheCompilationUnitHasExpectedCountOrphanComments(int expectedCount) {\n        assertThat(compilationUnit.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"the compilation unit orphan comment $position is \\\"$expectedContent\\\"\")\n    public void thenTheCompilationUnitOrphanCommentIs(int position, String expectedContent) {\n        assertCommentContent(compilationUnit.getOrphanComments().get(position - 1), expectedContent);\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is not an orphan\")\n    public void thenCommentInCompilationUnitIsNotAnOrphan(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.isOrphan(), is(false));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is an orphan\")\n    public void thenCommentInCompilationUnitIsAnOrphan(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.isOrphan(), is(true));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is \\\"$expectedContent\\\"\")\n    public void thenCommentInCompilationUnitIs(int position, String expectedContent) {\n        assertCommentContent(compilationUnit.getAllContainedComments().get(position - 1), expectedContent);\n    }\n\n    @Then(\"class $position is not commented\")\n    public void thenClassIsNotCommented(int position) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getComment(), is(nullValue()));\n    }\n\n    @Then(\"class $position is commented \\\"$expectedContent\\\"\")\n    public void thenClassIsCommented(int position, String expectedContent) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getComment().getContent(), is(expectedContent));\n    }\n\n    @Then(\"class $position has $expectedCount total contained comments\")\n    public void thenClassHasTotalContainedComments(int position, int expectedCount) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"class $position has $expectedCount orphan comment\")\n    @Alias(\"class $position has $expectedCount orphan comments\")\n    public void thenClassHasOrphanComments(int position, int expectedCount) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"class $classPosition orphan comment $commentPosition is \\\"$expectedContent\\\"\")\n    public void thenClassOrphanCommentIs(int classPosition, int commentPosition, String expectedContent) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        assertCommentContent(classUnderTest.getOrphanComments().get(commentPosition - 1), expectedContent);\n    }\n\n    @Then(\"method $methodPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenMethodInClassIsCommented(int methodPosition, int classPosition, String expectedContent) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertCommentContent(methodUnderTest.getComment(), expectedContent);\n    }\n\n    @Then(\"method $methodPosition in class $classPosition has $expectedCount total contained comments\")\n    public void thenMethodInClassHasTotalContainedComments(int methodPosition, int classPosition, int expectedCount) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"comment $commentPosition in method $methodPosition in class $classPosition is \\\"$expectedContent\\\"\")\n    public void thenCommentInMethodInClassIs(int commentPosition, int methodPosition, int classPosition, String expectedContent) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertCommentContent(methodUnderTest.getAllContainedComments().get(commentPosition - 1), expectedContent);\n    }\n\n    @Then(\"method $methodPosition in class $classPosition has $expectedCount orphan comments\")\n    public void thenMethodInClassHasOrphanComments(int methodPosition, int classPosition, int expectedCount) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition has $expectedCount total contained comments\")\n    public void thenBlockStatementInMethodInClassHasTotalContainedComments(int methodPosition, int classPosition, int expectedCount) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        assertThat(blockStmtUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition has $expectedCount orphan comments\")\n    public void thenBlockStatementInMethodInClassHasOrphanComments(int methodPosition, int classPosition, int expectedCount) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        assertThat(blockStmtUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition orphan comment $commentPosition is \\\"$expectedContent\\\"\")\n    public void thenBlockStatementInMethodInClassIs(int methodPosition, int classPosition, int commentPosition, String expectedContent) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        assertCommentContent(blockStmtUnderTest.getOrphanComments().get(commentPosition - 1), expectedContent);\n    }\n\n    @Then(\"type of method $methodPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenTypeOfMethodInClassIsCommented(int methodPosition, int classPosition, String expectedContent) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertCommentContent(methodUnderTest.getType().getComment(), expectedContent);\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition contains $expectedCount comments\")\n    public void thenFieldInClassContainsComments(int fieldPosition, int classPosition, int expectedCount) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        assertThat(fieldUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition is not commented\")\n    public void thenFieldInClassIsNotCommented(int fieldPosition, int classPosition) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        assertThat(fieldUnderTest.getComment(), is(nullValue()));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenFieldInClassIsCommented(int fieldPosition, int classPosition, String expectedContent) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        assertCommentContent(fieldUnderTest.getComment(), expectedContent);\n    }\n\n    @Then(\"variable $variablePosition value of field $fieldPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenVariableValueOfFieldInClassIsCommented(int variablePosition, int fieldPosition, int classPosition, String expectedContent) {\n        TypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        VariableDeclarator variableUnderTest = fieldUnderTest.getVariables().get(variablePosition - 1);\n        Expression valueUnderTest = variableUnderTest.getInit();\n        assertCommentContent(valueUnderTest.getComment(), expectedContent);\n    }\n\n    @Then(\"comment $commentPosition in compilation unit parent is ClassOrInterfaceDeclaration\")\n    public void thenCommentInCompilationUnitParentIsClassOrInterfaceDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getParentNode(), instanceOf(ClassOrInterfaceDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is ClassOrInterfaceDeclaration\")\n    public void thenCommentInCompilationUnitCommentedNodeIsClassOrInterfaceDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(ClassOrInterfaceDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is FieldDeclaration\")\n    public void thenCommentInCompilationUnitCommentedNodeIsFieldDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(FieldDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is IntegerLiteralExpr\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerLiteralExpr(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(IntegerLiteralExpr.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is ExpressionStmt\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerExpressionStmt(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(ExpressionStmt.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is PrimitiveType\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerPrimitiveType(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(PrimitiveType.class));\n    }\n\n    private Comment toComment(Parameters row, Comment comment) {\n        comment.setRange(range(Integer.parseInt(row.values().get(\"beginLine\")),\n                Integer.parseInt(row.values().get(\"beginColumn\")),\n                Integer.parseInt(row.values().get(\"endLine\")),\n                Integer.parseInt(row.values().get(\"endColumn\"))));\n        return comment;\n    }\n}\n```\n\n### Summary of Changes:\n- Introduced a new private method `assertCommentContent` to handle assertions for comment content.\n- Introduced a new private method `assertCommentPositions` to handle assertions for comment positions, reducing redundancy in the code.\n- Updated the relevant methods to use these new helper methods, improving readability and maintainability.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\npublic class CommentParsingSteps {\n\n    private CompilationUnit compilationUnit;\n\nClass content:\n/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2016 The JavaParser Team.\n *\n * This file is part of JavaParser.\n * \n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License \n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n \npackage com.github.javaparser.bdd.steps;\n\nimport static com.github.javaparser.Range.range;\nimport static com.github.javaparser.bdd.steps.SharedSteps.getMemberByTypeAndPosition;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.hamcrest.text.IsEqualIgnoringWhiteSpace.equalToIgnoringWhiteSpace;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.fail;\n\nimport java.io.IOException;\nimport java.io.StringReader;\n\nimport org.jbehave.core.annotations.Alias;\nimport org.jbehave.core.annotations.Given;\nimport org.jbehave.core.annotations.Then;\nimport org.jbehave.core.annotations.When;\nimport org.jbehave.core.model.ExamplesTable;\nimport org.jbehave.core.steps.Parameters;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseException;\nimport com.github.javaparser.TokenMgrException;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.comments.BlockComment;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.comments.CommentsCollection;\nimport com.github.javaparser.ast.comments.CommentsParser;\nimport com.github.javaparser.ast.comments.JavadocComment;\nimport com.github.javaparser.ast.comments.LineComment;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.IntegerLiteralExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.visitor.DumpVisitor;\nimport com.github.javaparser.bdd.TestUtils;\n\npublic class CommentParsingSteps {\n\n    private CompilationUnit compilationUnit;\n    private CommentsCollection commentsCollection;\n    private String sourceUnderTest;\n\n    @Given(\"the class:$classSrc\")\n    public void givenTheClass(String classSrc) {\n        this.sourceUnderTest = classSrc.trim();\n    }\n\n    @When(\"read sample \\\"$sampleName\\\" using encoding \\\"$encoding\\\"\")\n    public void givenTheClassWithEncoding(String sampleName, String encoding) throws IOException {\n        sourceUnderTest = null;\n        commentsCollection = new CommentsParser().parse(TestUtils.getSampleStream(sampleName), encoding);\n    }\n\n    @When(\"the class is parsed by the comment parser\")\n    public void whenTheClassIsParsedByTheCommentParser() throws IOException {\n        commentsCollection = new CommentsParser().parse(sourceUnderTest);\n    }\n\n    @When(\"the do not consider annotations as node start for code attribution is $value on the Java parser\")\n    public void whenTheDoNotConsiderAnnotationsAsNodeStartForCodeAttributionIsTrueOnTheJavaParser(boolean value) {\n        JavaParser.setDoNotConsiderAnnotationsAsNodeStartForCodeAttribution(value);\n    }\n\n    @When(\"the class is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n        compilationUnit = JavaParser.parse(sourceUnderTest);\n    }\n\n    @Then(\"the Java parser cannot parse it because of lexical errors\")\n    public void javaParserCannotParseBecauseOfLexicalErrors() throws ParseException {\n        try {\n            compilationUnit = JavaParser.parse(sourceUnderTest);\n            fail(\"Lexical error expected\");\n        } catch (TokenMgrException e) {\n            // ok\n        }\n    }\n\n    @Then(\"the total number of comments is $expectedCount\")\n    public void thenTheTotalNumberOfCommentsIs(int expectedCount) {\n        assertThat(commentsCollection.size(), is(expectedCount));\n    }\n\n    @Then(\"line comment $position is \\\"$expectedContent\\\"\")\n    public void thenLineCommentIs(int position, String expectedContent) {\n        LineComment lineCommentUnderTest = commentsCollection.getLineComments().get(position-1);\n\n        assertThat(lineCommentUnderTest.getContent(), is(expectedContent));\n    }\n\n    @Then(\"block comment $position is \\\"$expectedContent\\\"\")\n    public void thenBlockCommentIs(int position, String expectedContent) {\n        BlockComment lineCommentUnderTest = commentsCollection.getBlockComments().get(position - 1);\n\n        assertThat(lineCommentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"Javadoc comment $position is \\\"$expectedContent\\\"\")\n    public void thenJavadocCommentIs(int position, String expectedContent) {\n        JavadocComment commentUnderTest = commentsCollection.getJavadocComments().get(position- 1);\n\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"the line comments have the following positions: $table\")\n    public void thenTheLineCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        int index = 0;\n        for(Parameters exampleRow : examplesTable.getRowsAsParameters()){\n            Comment expectedLineComment = toComment(exampleRow, new LineComment());\n            Comment lineCommentUnderTest = commentsCollection.getLineComments().get(index);\n\n            assertThat(lineCommentUnderTest.getBegin().line, is(expectedLineComment.getBegin().line));\n            assertThat(lineCommentUnderTest.getBegin().column, is(expectedLineComment.getBegin().column));\n            assertThat(lineCommentUnderTest.getEnd().line, is(expectedLineComment.getEnd().line));\n            assertThat(lineCommentUnderTest.getEnd().column, is(expectedLineComment.getEnd().column));\n            index ++;\n        }\n    }\n\n    @Then(\"the block comments have the following positions: $table\")\n    public void thenTheBlockCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        int index = 0;\n        for(Parameters exampleRow : examplesTable.getRowsAsParameters()){\n            Comment expectedLineComment = toComment(exampleRow, new BlockComment());\n            Comment lineCommentUnderTest = commentsCollection.getBlockComments().get(index);\n\n            assertThat(lineCommentUnderTest.getBegin().line, is(expectedLineComment.getBegin().line));\n            assertThat(lineCommentUnderTest.getBegin().column, is(expectedLineComment.getBegin().column));\n            assertThat(lineCommentUnderTest.getEnd().line, is(expectedLineComment.getEnd().line));\n            assertThat(lineCommentUnderTest.getEnd().column, is(expectedLineComment.getEnd().column));\n            index ++;\n        }\n    }\n\n    @Then(\"the Javadoc comments have the following positions: $table\")\n    public void thenTheJavadocCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        int index = 0;\n        for(Parameters exampleRow : examplesTable.getRowsAsParameters()){\n            Comment expectedLineComment = toComment(exampleRow, new BlockComment());\n            Comment lineCommentUnderTest = commentsCollection.getJavadocComments().get(index);\n\n            assertThat(lineCommentUnderTest.getBegin().line, is(expectedLineComment.getBegin().line));\n            assertThat(lineCommentUnderTest.getBegin().column, is(expectedLineComment.getBegin().column));\n            assertThat(lineCommentUnderTest.getEnd().line, is(expectedLineComment.getEnd().line));\n            assertThat(lineCommentUnderTest.getEnd().column, is(expectedLineComment.getEnd().column));\n            index ++;\n        }\n    }\n\n    @Then(\"it is dumped to:$dumpSrc\")\n    public void isDumpedTo(String dumpSrc) {\n        DumpVisitor dumpVisitor = new DumpVisitor();\n        dumpVisitor.visit(compilationUnit, null);\n        assertThat(dumpVisitor.getSource().trim(), is(dumpSrc.trim()));\n    }\n\n    @Then(\"the compilation unit is not commented\")\n    public void thenTheCompilationUnitIsNotCommented() {\n        assertThat(compilationUnit.getComment(), is(nullValue()));\n    }\n\n    @Then(\"the compilation is commented \\\"$expectedContent\\\"\")\n    public void thenTheCompilationIsCommentedCompilationUnitComment(String expectedContent) {\n        assertThat(compilationUnit.getComment().getContent(), is(expectedContent));\n    }\n\n    @Then(\"the compilation unit has $expectedCount contained comments\")\n    public void thenTheCompilationUnitHasContainedComments(int expectedCount) {\n        assertThat(compilationUnit.getComments().size(), is(expectedCount));\n    }\n\n    @Then(\"the compilation unit has $expectedCount orphan comments\")\n    public void thenTheCompilationUnitHasExpectedCountOrphanComments(int expectedCount) {\n        assertThat(compilationUnit.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"the compilation unit orphan comment $position is \\\"$expectedContent\\\"\")\n    public void thenTheCompilationUnitOrphanCommentIs(int position, String expectedContent) {\n        Comment commentUnderTest = compilationUnit.getOrphanComments().get(position - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is not an orphan\")\n    public void thenCommentInCompilationUnitIsNotAnOrphan(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.isOrphan(), is(false));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is an orphan\")\n    public void thenCommentInCompilationUnitIsAnOrphan(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.isOrphan(), is(true));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is \\\"$expectedContent\\\"\")\n    public void thenCommentInCompilationUnitIs(int position, String expectedContent) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(position - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"class $position is not commented\")\n    public void thenClassIsNotCommented(int position) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getComment(), is(nullValue()));\n    }\n\n    @Then(\"class $position is commented \\\"$expectedContent\\\"\")\n    public void thenClassIsCommented(int position, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getComment().getContent(), is(expectedContent));\n    }\n\n    @Then(\"class $position has $expectedCount total contained comments\")\n    public void thenClassHasTotalContainedComments(int position, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"class $position has $expectedCount orphan comment\")\n    @Alias(\"class $position has $expectedCount orphan comments\")\n    public void thenClassHasOrphanComments(int position, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"class $classPosition orphan comment $commentPosition is \\\"$expectedContent\\\"\")\n    public void thenClassOrphanCommentIs(int classPosition, int commentPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        Comment commentUnderTest = classUnderTest.getOrphanComments().get(commentPosition -1 );\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"method $methodPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenMethodInClassIsCommented(int methodPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getComment().getContent(), equalToIgnoringWhiteSpace(expectedContent));\n    }\n\n    @Then(\"method $methodPosition in class $classPosition has $expectedCount total contained comments\")\n    public void thenMethodInClassHasTotalContainedComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"comment $commentPosition in method $methodPosition in class $classPosition is \\\"$expectedContent\\\"\")\n    public void thenCommentInMethodInClassIs(int commentPosition, int methodPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        Comment commentUnderTest = methodUnderTest.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"method $methodPosition in class $classPosition has $expectedCount orphan comments\")\n    public void thenMethodInClassHasOrphanComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition has $expectedCount total contained comments\")\n    public void thenBlockStatementInMethodInClassHasTotalContainedComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        assertThat(blockStmtUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition has $expectedCount orphan comments\")\n    public void thenBlockStatementInMethodInClassHasOrphanComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        assertThat(blockStmtUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition orphan comment $commentPosition is \\\"$expectedContent\\\"\")\n    public void thenBlockStatementInMethodInClassIs(int methodPosition, int classPosition, int commentPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition -1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        Comment commentUnderTest = blockStmtUnderTest.getOrphanComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"type of method $methodPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenTypeOfMethodInClassIsCommented(int methodPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition -1,\n                MethodDeclaration.class);\n        Comment commentUnderTest = methodUnderTest.getType().getComment();\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition contains $expectedCount comments\")\n    public void thenFieldInClassContainsComments(int fieldPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        assertThat(fieldUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition is not commented\")\n    public void thenFieldInClassIsNotCommented(int fieldPosition, int classPosition) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        assertThat(fieldUnderTest.getComment(), is(nullValue()));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenFieldInClassIsCommented(int fieldPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        Comment commentUnderTest = fieldUnderTest.getComment();\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"variable $variablePosition value of field $fieldPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenVariableValueOfFieldInClassIsCommented(int variablePosition, int fieldPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        VariableDeclarator variableUnderTest = fieldUnderTest.getVariables().get(variablePosition - 1);\n        Expression valueUnderTest = variableUnderTest.getInit();\n        Comment commentUnderTest = valueUnderTest.getComment();\n        assertThat(commentUnderTest.getContent(), is(expectedContent));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit parent is ClassOrInterfaceDeclaration\")\n    public void thenCommentInCompilationUnitParentIsClassOrInterfaceDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getParentNode(), instanceOf(ClassOrInterfaceDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is ClassOrInterfaceDeclaration\")\n    public void thenCommentInCompilationUnitCommentedNodeIsClassOrInterfaceDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(ClassOrInterfaceDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is FieldDeclaration\")\n    public void thenCommentInCompilationUnitCommentedNodeIsFieldDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(FieldDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is IntegerLiteralExpr\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerLiteralExpr(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(IntegerLiteralExpr.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is ExpressionStmt\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerExpressionStmt(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(ExpressionStmt.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is PrimitiveType\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerPrimitiveType(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(PrimitiveType.class));\n    }\n\n    private Comment toComment(Parameters row, Comment comment) {\n        comment.setRange(range(Integer.parseInt(row.values().get(\"beginLine\")),\n                Integer.parseInt(row.values().get(\"beginColumn\")),\n                Integer.parseInt(row.values().get(\"endLine\")),\n                Integer.parseInt(row.values().get(\"endColumn\"))));\n        return comment;\n    }\n}\n\nRefactoring Operation:\nMove And Inline Method\n\nProject Structure:\n['javaparser-testing/src/test/java/com/github/javaparser/bdd/BasicJBehaveTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/CommentParsingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ComparingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/DumpingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ManipulationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ParsingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/PositionRangeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/TestUtils.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/VisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ComparingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/DumpingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ExistenceOfParentNodeVerifier.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ManipulationSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ParsingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/PositionRangeSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/SharedSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/VisitorSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/visitors/PositionTestVisitor.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/ClassOrInterfaceDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/CompilationUnitBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/EnumDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/FieldDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/NodeWithAnnotationsBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/NodeWithMembersBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/NodeWithParametersBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/NodeWithThrowableBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/ChangingMethodsFromAClassWithAVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/ChangingMethodsFromAClassWithoutAVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/ClassCreator.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/CreatingACompilationUnitFromScratch.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/CuPrinter.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/MethodChanger_1.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/MethodChanger_2.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/MethodPrinter.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/PrintingTheCompilationUnitToSystemOutputTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/TestFileToken.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/VisitingClassMethodsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/removenode/D.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/removenode/GitHubTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/removenode/GitHubTest_2.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/wiki_samples/removenode/RemoveDeleteNodeFromAst.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/ClassInLatin1.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/JavaConcepts.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/package-info.java', 'javaparser-testing/src/test/resources/com/github/javaparser/junit/wiki_samples/TestFile.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, output the target file path.\n2. If refactoring is performed, output the refactored class code in the following format:\n$target_file_path$:\n$refactored_class_code$:\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprotected convertToUsage(classOrInterfaceType ClassOrInterfaceType, context Context) : ResolvedType extracted from protected convertToUsage(type Type, context Context) : ResolvedType in class com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade", "diffLocations": [{"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "startLine": 673, "endLine": 732, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "startLine": 677, "endLine": 716, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "startLine": 718, "endLine": 739, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n            String name = qName(classOrInterfaceType);\n            SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n            List<ResolvedType> typeParameters = Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                    return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }", "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "isPureRefactoring": true, "commitId": "b79893b5786313fd661db8395cb7fabe44960877", "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel", "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade", "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage", "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#qName\n methodBody: private String qName(ClassOrInterfaceType classOrInterfaceType) {\nString name=classOrInterfaceType.getName().getId();\nif(classOrInterfaceType.getScope().isPresent()){return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n}return name;\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(Type type, Context context) {\nif(context == null){throw new NullPointerException(\"Context should not be null\");\n}if(type instanceof ClassOrInterfaceType){ClassOrInterfaceType classOrInterfaceType=(ClassOrInterfaceType)type;\nString name=qName(classOrInterfaceType);\nSymbolReference<ResolvedTypeDeclaration> ref=context.solveType(name);\nif(!ref.isSolved()){throw new UnsolvedSymbolException(name);\n}ResolvedTypeDeclaration typeDeclaration=ref.getCorrespondingDeclaration();\nList<ResolvedType> typeParameters=Collections.emptyList();\nif(classOrInterfaceType.getTypeArguments().isPresent()){typeParameters=classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt,context)).collect(Collectors.toList());\n}if(typeDeclaration.isTypeParameter()){if(typeDeclaration instanceof ResolvedTypeParameterDeclaration){return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration)typeDeclaration);\n}{JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration=(JavaParserTypeVariableDeclaration)typeDeclaration;\nreturn new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n}}{return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration)typeDeclaration,typeParameters,typeSolver);\n}}if(type instanceof PrimitiveType){return ResolvedPrimitiveType.byName(((PrimitiveType)type).getType().name());\n}if(type instanceof WildcardType){WildcardType wildcardType=(WildcardType)type;\nif(wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()){return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.UNBOUNDED;\n}{throw new UnsupportedOperationException(wildcardType.toString());\n}}if(type instanceof VoidType){return ResolvedVoidType.INSTANCE;\n}if(type instanceof ArrayType){ArrayType jpArrayType=(ArrayType)type;\nreturn new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(),context));\n}if(type instanceof UnionType){UnionType unionType=(UnionType)type;\nreturn new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el,context)).collect(Collectors.toList()));\n}if(type instanceof VarType){Node parent=type.getParentNode().get();\nif(!(parent instanceof VariableDeclarator)){throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n}final VariableDeclarator variableDeclarator=(VariableDeclarator)parent;\nreturn variableDeclarator.getInitializer().map(Expression::calculateResolvedType).orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n}{throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n}}", "classSignatureBefore": "public class JavaParserFacade ", "methodNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage"], "classNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade"], "classSignatureBeforeSet": ["public class JavaParserFacade "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n            String name = qName(classOrInterfaceType);\n            SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n            List<ResolvedType> typeParameters = Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                    return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n", "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n", "diffSourceCodeSet": ["protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }"], "invokedMethodSet": ["methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#qName\n methodBody: private String qName(ClassOrInterfaceType classOrInterfaceType) {\nString name=classOrInterfaceType.getName().getId();\nif(classOrInterfaceType.getScope().isPresent()){return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n}return name;\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(Type type, Context context) {\nif(context == null){throw new NullPointerException(\"Context should not be null\");\n}if(type instanceof ClassOrInterfaceType){ClassOrInterfaceType classOrInterfaceType=(ClassOrInterfaceType)type;\nString name=qName(classOrInterfaceType);\nSymbolReference<ResolvedTypeDeclaration> ref=context.solveType(name);\nif(!ref.isSolved()){throw new UnsolvedSymbolException(name);\n}ResolvedTypeDeclaration typeDeclaration=ref.getCorrespondingDeclaration();\nList<ResolvedType> typeParameters=Collections.emptyList();\nif(classOrInterfaceType.getTypeArguments().isPresent()){typeParameters=classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt,context)).collect(Collectors.toList());\n}if(typeDeclaration.isTypeParameter()){if(typeDeclaration instanceof ResolvedTypeParameterDeclaration){return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration)typeDeclaration);\n}{JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration=(JavaParserTypeVariableDeclaration)typeDeclaration;\nreturn new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n}}{return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration)typeDeclaration,typeParameters,typeSolver);\n}}if(type instanceof PrimitiveType){return ResolvedPrimitiveType.byName(((PrimitiveType)type).getType().name());\n}if(type instanceof WildcardType){WildcardType wildcardType=(WildcardType)type;\nif(wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()){return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.UNBOUNDED;\n}{throw new UnsupportedOperationException(wildcardType.toString());\n}}if(type instanceof VoidType){return ResolvedVoidType.INSTANCE;\n}if(type instanceof ArrayType){ArrayType jpArrayType=(ArrayType)type;\nreturn new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(),context));\n}if(type instanceof UnionType){UnionType unionType=(UnionType)type;\nreturn new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el,context)).collect(Collectors.toList()));\n}if(type instanceof VarType){Node parent=type.getParentNode().get();\nif(!(parent instanceof VariableDeclarator)){throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n}final VariableDeclarator variableDeclarator=(VariableDeclarator)parent;\nreturn variableDeclarator.getInitializer().map(Expression::calculateResolvedType).orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n}{throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n}}"], "sourceCodeAfterRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\nprotected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }", "diffSourceCode": "-  673:     protected ResolvedType convertToUsage(Type type, Context context) {\n-  674:         if (context == null) {\n-  675:             throw new NullPointerException(\"Context should not be null\");\n-  676:         }\n-  677:         if (type instanceof ClassOrInterfaceType) {\n-  678:             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n-  679:             String name = qName(classOrInterfaceType);\n-  680:             SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n-  681:             if (!ref.isSolved()) {\n-  682:                 throw new UnsolvedSymbolException(name);\n-  683:             }\n-  684:             ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n-  685:             List<ResolvedType> typeParameters = Collections.emptyList();\n-  686:             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n-  687:                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n-  688:             }\n-  689:             if (typeDeclaration.isTypeParameter()) {\n-  690:                 if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n-  691:                     return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n-  692:                 } else {\n-  693:                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n-  694:                     return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n-  695:                 }\n-  696:             } else {\n-  697:                 return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n-  698:             }\n-  699:         } else if (type instanceof PrimitiveType) {\n-  700:             return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n-  701:         } else if (type instanceof WildcardType) {\n-  702:             WildcardType wildcardType = (WildcardType) type;\n-  703:             if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n-  704:                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n-  705:             } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n-  706:                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n-  707:             } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n-  708:                 return ResolvedWildcard.UNBOUNDED;\n-  709:             } else {\n-  710:                 throw new UnsupportedOperationException(wildcardType.toString());\n-  711:             }\n-  712:         } else if (type instanceof VoidType) {\n-  713:             return ResolvedVoidType.INSTANCE;\n-  714:         } else if (type instanceof ArrayType) {\n-  715:             ArrayType jpArrayType = (ArrayType) type;\n-  716:             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n-  717:         } else if (type instanceof UnionType) {\n-  718:             UnionType unionType = (UnionType) type;\n-  719:             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n-  720:         } else if (type instanceof VarType) {\n-  721:             Node parent = type.getParentNode().get();\n-  722:             if (!(parent instanceof VariableDeclarator)) {\n-  723:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n-  724:             }\n-  725:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n-  726:             return variableDeclarator.getInitializer()\n-  727:                     .map(Expression::calculateResolvedType)\n-  728:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n-  729:         } else {\n-  730:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n-  731:         }\n-  732:     }\n-  733: \n-  734: \n-  735:     public ResolvedType convert(Type type, Node node) {\n-  736:         return convert(type, JavaParserFactory.getContext(node, typeSolver));\n-  737:     }\n-  738: \n-  739:     public ResolvedType convert(Type type, Context context) {\n+  673:         }\n+  674:         return name;\n+  675:     }\n+  676: \n+  677:     protected ResolvedType convertToUsage(Type type, Context context) {\n+  678:         if (context == null) {\n+  679:             throw new NullPointerException(\"Context should not be null\");\n+  680:         }\n+  681:         if (type instanceof ClassOrInterfaceType) {\n+  682:             return convertToUsage((ClassOrInterfaceType) type, context);\n+  683:         } else if (type instanceof PrimitiveType) {\n+  684:             return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n+  685:         } else if (type instanceof WildcardType) {\n+  686:             WildcardType wildcardType = (WildcardType) type;\n+  687:             if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n+  688:                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n+  689:             } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n+  690:                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n+  691:             } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n+  692:                 return ResolvedWildcard.UNBOUNDED;\n+  693:             } else {\n+  694:                 throw new UnsupportedOperationException(wildcardType.toString());\n+  695:             }\n+  696:         } else if (type instanceof VoidType) {\n+  697:             return ResolvedVoidType.INSTANCE;\n+  698:         } else if (type instanceof ArrayType) {\n+  699:             ArrayType jpArrayType = (ArrayType) type;\n+  700:             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n+  701:         } else if (type instanceof UnionType) {\n+  702:             UnionType unionType = (UnionType) type;\n+  703:             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n+  704:         } else if (type instanceof VarType) {\n+  705:             Node parent = type.getParentNode().get();\n+  706:             if (!(parent instanceof VariableDeclarator)) {\n+  707:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n+  708:             }\n+  709:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n+  710:             return variableDeclarator.getInitializer()\n+  711:                     .map(Expression::calculateResolvedType)\n+  712:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n+  713:         } else {\n+  714:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n+  715:         }\n+  716:     }\n+  717: \n+  718:     protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n+  719:         String name = qName(classOrInterfaceType);\n+  720:         SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n+  721:         if (!ref.isSolved()) {\n+  722:             throw new UnsolvedSymbolException(name);\n+  723:         }\n+  724:         ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n+  725:         List<ResolvedType> typeParameters = Collections.emptyList();\n+  726:         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n+  727:             typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n+  728:         }\n+  729:         if (typeDeclaration.isTypeParameter()) {\n+  730:             if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n+  731:                 return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n+  732:             } else {\n+  733:                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n+  734:                 return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n+  735:             }\n+  736:         } else {\n+  737:             return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n+  738:         }\n+  739:     }\n", "uniqueId": "b79893b5786313fd661db8395cb7fabe44960877_673_732_718_739_677_716", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 32, "covered": 189}, "BRANCH": {"missed": 8, "covered": 30}, "LINE": {"missed": 6, "covered": 40}, "COMPLEXITY": {"missed": 8, "covered": 12}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `convertToUsage` method, we can extract several smaller methods that handle specific cases of type conversion. This will make the main method cleaner and easier to understand.\n\nHere\u2019s the refactored code with the extracted methods:\n\n```java\nprotected ResolvedType convertToUsage(Type type, Context context) {\n    if (context == null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        return handleClassOrInterfaceType((ClassOrInterfaceType) type, context);\n    } else if (type instanceof PrimitiveType) {\n        return handlePrimitiveType((PrimitiveType) type);\n    } else if (type instanceof WildcardType) {\n        return handleWildcardType((WildcardType) type, context);\n    } else if (type instanceof VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof ArrayType) {\n        return handleArrayType((ArrayType) type, context);\n    } else if (type instanceof UnionType) {\n        return handleUnionType((UnionType) type, context);\n    } else if (type instanceof VarType) {\n        return handleVarType((VarType) type);\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}\n\nprivate ResolvedType handleClassOrInterfaceType(ClassOrInterfaceType classOrInterfaceType, Context context) {\n    String name = qName(classOrInterfaceType);\n    SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n    if (!ref.isSolved()) {\n        throw new UnsolvedSymbolException(name);\n    }\n    ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n    List<ResolvedType> typeParameters = classOrInterfaceType.getTypeArguments()\n            .map(args -> args.stream().map(pt -> convertToUsage(pt, context)).collect(Collectors.toList()))\n            .orElse(Collections.emptyList());\n\n    if (typeDeclaration.isTypeParameter()) {\n        return createResolvedTypeVariable(typeDeclaration);\n    } else {\n        return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n    }\n}\n\nprivate ResolvedType createResolvedTypeVariable(ResolvedTypeDeclaration typeDeclaration) {\n    if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n        return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n    } else {\n        JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n        return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n    }\n}\n\nprivate ResolvedType handlePrimitiveType(PrimitiveType primitiveType) {\n    return ResolvedPrimitiveType.byName(primitiveType.getType().name());\n}\n\nprivate ResolvedType handleWildcardType(WildcardType wildcardType, Context context) {\n    if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context));\n    } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context));\n    } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.UNBOUNDED;\n    } else {\n        throw new UnsupportedOperationException(wildcardType.toString());\n    }\n}\n\nprivate ResolvedType handleArrayType(ArrayType arrayType, Context context) {\n    return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n}\n\nprivate ResolvedType handleUnionType(UnionType unionType, Context context) {\n    return new ResolvedUnionType(unionType.getElements().stream()\n            .map(el -> convertToUsage(el, context))\n            .collect(Collectors.toList()));\n}\n\nprivate ResolvedType handleVarType(VarType varType) {\n    Node parent = varType.getParentNode().orElseThrow(() -> new IllegalStateException(\"Parent node not found\"));\n    if (!(parent instanceof VariableDeclarator)) {\n        throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n    }\n    final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n    return variableDeclarator.getInitializer()\n            .map(Expression::calculateResolvedType)\n            .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n}\n```\n\nThis refactoring extracts the handling of different types into separate methods, making the `convertToUsage` method much cleaner and easier to follow. Each helper method is responsible for a specific type, which enhances modularity and readability. \n\nThe output format requested is as follows:\n\n##########################\nrefactored_method_code\n##########################\n```java\nprotected ResolvedType convertToUsage(Type type, Context context) {\n    if (context == null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        return handleClassOrInterfaceType((ClassOrInterfaceType) type, context);\n    } else if (type instanceof PrimitiveType) {\n        return handlePrimitiveType((PrimitiveType) type);\n    } else if (type instanceof WildcardType) {\n        return handleWildcardType((WildcardType) type, context);\n    } else if (type instanceof VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof ArrayType) {\n        return handleArrayType((ArrayType) type, context);\n    } else if (type instanceof UnionType) {\n        return handleUnionType((UnionType) type, context);\n    } else if (type instanceof VarType) {\n        return handleVarType((VarType) type);\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}\n\nprivate ResolvedType handleClassOrInterfaceType(ClassOrInterfaceType classOrInterfaceType, Context context) {\n    String name = qName(classOrInterfaceType);\n    SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n    if (!ref.isSolved()) {\n        throw new UnsolvedSymbolException(name);\n    }\n    ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n    List<ResolvedType> typeParameters = classOrInterfaceType.getTypeArguments()\n            .map(args -> args.stream().map(pt -> convertToUsage(pt, context)).collect(Collectors.toList()))\n            .orElse(Collections.emptyList());\n\n    if (typeDeclaration.isTypeParameter()) {\n        return createResolvedTypeVariable(typeDeclaration);\n    } else {\n        return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n    }\n}\n\nprivate ResolvedType createResolvedTypeVariable(ResolvedTypeDeclaration typeDeclaration) {\n    if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n        return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n    } else {\n        JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n        return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n    }\n}\n\nprivate ResolvedType handlePrimitiveType(PrimitiveType primitiveType) {\n    return ResolvedPrimitiveType.byName(primitiveType.getType().name());\n}\n\nprivate ResolvedType handleWildcardType(WildcardType wildcardType, Context context) {\n    if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context));\n    } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context));\n    } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.UNBOUNDED;\n    } else {\n        throw new UnsupportedOperationException(wildcardType.toString());\n    }\n}\n\nprivate ResolvedType handleArrayType(ArrayType arrayType, Context context) {\n    return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n}\n\nprivate ResolvedType handleUnionType(UnionType unionType, Context context) {\n    return new ResolvedUnionType(unionType.getElements().stream()\n            .map(el -> convertToUsage(el, context))\n            .collect(Collectors.toList()));\n}\n\nprivate ResolvedType handleVarType(VarType varType) {\n    Node parent = varType.getParentNode().orElseThrow(() -> new IllegalStateException(\"Parent node not found\"));\n    if (!(parent instanceof VariableDeclarator)) {\n        throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n    }\n    final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n    return variableDeclarator.getInitializer()\n            .map(Expression::calculateResolvedType)\n            .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n}\n##########################\n", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprotected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n            String name = qName(classOrInterfaceType);\n            SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n            List<ResolvedType> typeParameters = Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                    return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\nClass content:\n/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n            String name = qName(classOrInterfaceType);\n            SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n            List<ResolvedType> typeParameters = Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                    return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package record_allowComponentAccessorWithMatchingType() : void in class com.github.javaparser.ast.body.RecordDeclarationTest", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 276, "endLine": 287, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 273, "endLine": 283, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 313, "endLine": 316, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_allowComponentAccessorWithMatchingType", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#record_allowComponentAccessorWithMatchingType"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": ["private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }", "diffSourceCode": "-  273:     }\n-  274: \n-  275: \n-  276:     @Test\n-  277:     void record_allowComponentAccessorWithMatchingType() {\n-  278:         String s = \"record Point(int x, int y) {\\n\" +\n-  279:                 \"    public int x() {\\n\" +\n-  280:                 \"        return 10;\\n\" +\n-  281:                 \"    }\\n\" +\n-  282:                 \" }\";\n-  283: \n-  284:         CompilationUnit cu = parseCompilationUnit(s);\n-  285:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-  286:         assertEquals(1, recordDeclarations.size());\n-  287:     }\n+  273:     @Test\n+  274:     void record_allowComponentAccessorWithMatchingType() {\n+  275:         String s = \"record Point(int x, int y) {\\n\" +\n+  276:                 \"    public int x() {\\n\" +\n+  277:                 \"        return 10;\\n\" +\n+  278:                 \"    }\\n\" +\n+  279:                 \" }\";\n+  280: \n+  281:         CompilationUnit cu = parseCompilationUnit(s);\n+  282:         assertOneRecordDeclaration(cu);\n+  283:     }\n+  284: \n+  285:     // https://bugs.openjdk.java.net/browse/JDK-8222777\n+  286:     @Test\n+  287:     void recordDeclarationFromTheJDK8222777() {\n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n", "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_276_287_313_316_273_283", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `record_allowComponentAccessorWithMatchingType` test method, we can extract the common logic of parsing the compilation unit and asserting the record declaration size into a separate method. This will reduce duplication and make the test easier to read.\n\nHere\u2019s the refactored method code:\n\n##########################\n```java\nprivate void assertSingleRecordDeclaration(String recordSource) {\n    CompilationUnit cu = parseCompilationUnit(recordSource);\n    List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n    assertEquals(1, recordDeclarations.size());\n}\n\n@Test\nvoid record_allowComponentAccessorWithMatchingType() {\n    String s = \"record Point(int x, int y) {\\n\" +\n            \"    public int x() {\\n\" +\n            \"        return 10;\\n\" +\n            \"    }\\n\" +\n            \" }\";\n    assertSingleRecordDeclaration(s);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() : void in class com.github.javaparser.ast.body.RecordDeclarationTest", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 262, "endLine": 273, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 261, "endLine": 271, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 313, "endLine": 316, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": ["private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }", "diffSourceCode": "-  261: \n-  262:     @Test\n-  263:     void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n-  264:         String s = \"record Point(int x, int y) {\\n\" +\n-  265:                 \"    public int x(int a) {\\n\" +\n-  266:                 \"        return 10;\\n\" +\n-  267:                 \"    }\\n\" +\n-  268:                 \" }\";\n-  269: \n-  270:         CompilationUnit cu = parseCompilationUnit(s);\n-  271:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-  272:         assertEquals(1, recordDeclarations.size());\n-  273:     }\n+  261:     @Test\n+  262:     void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n+  263:         String s = \"record Point(int x, int y) {\\n\" +\n+  264:                 \"    public int x(int a) {\\n\" +\n+  265:                 \"        return 10;\\n\" +\n+  266:                 \"    }\\n\" +\n+  267:                 \" }\";\n+  268: \n+  269:         CompilationUnit cu = parseCompilationUnit(s);\n+  270:         assertOneRecordDeclaration(cu);\n+  271:     }\n+  272: \n+  273:     @Test\n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n", "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_262_273_313_316_261_271", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To refactor the provided test method `record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2`, we can extract the common logic of parsing the compilation unit and asserting the size of the record declarations into a separate method. This will improve readability and maintainability by reducing code duplication.\n\nHere's the refactored method code:\n\n##########################\n```java\nprivate void assertSingleRecordDeclaration(String recordSource) {\n    CompilationUnit cu = parseCompilationUnit(recordSource);\n    List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n    assertEquals(1, recordDeclarations.size());\n}\n\n@Test\nvoid record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n    String s = \"record Point(int x, int y) {\\n\" +\n            \"    public int x(int a) {\\n\" +\n            \"        return 10;\\n\" +\n            \"    }\\n\" +\n            \" }\";\n    assertSingleRecordDeclaration(s);\n}\n########################## \n\nIn this refactoring:\n- The method `assertSingleRecordDeclaration` is created to encapsulate the logic of parsing the compilation unit and asserting that there is exactly one record declaration.\n- The original test method now simply calls this new method with the appropriate string, making it cleaner and easier to read.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() : void in class com.github.javaparser.ast.body.RecordDeclarationTest", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 249, "endLine": 260, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 249, "endLine": 259, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 313, "endLine": 316, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": ["private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }", "diffSourceCode": "   249:     @Test\n   250:     void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n   251:         String s = \"record Point(int x, int y) {\\n\" +\n   252:                 \"    public String x(int a) {\\n\" +\n   253:                 \"        return \\\"10\\\";\\n\" +\n   254:                 \"    }\\n\" +\n   255:                 \" }\";\n   256: \n   257:         CompilationUnit cu = parseCompilationUnit(s);\n-  258:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-  259:         assertEquals(1, recordDeclarations.size());\n-  260:     }\n+  258:         assertOneRecordDeclaration(cu);\n+  259:     }\n+  260: \n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n", "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_249_260_313_316_249_259", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the test method `record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod`, we can extract the common logic of parsing the compilation unit and asserting the record declaration size into a separate method. This will reduce duplication and make the test easier to read.\n\nHere\u2019s the refactored method code:\n\n```java\n##########################\nprivate void assertSingleRecordDeclaration(String recordCode) {\n    CompilationUnit cu = parseCompilationUnit(recordCode);\n    List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n    assertEquals(1, recordDeclarations.size());\n}\n\n@Test\nvoid record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n    String s = \"record Point(int x, int y) {\\n\" +\n            \"    public String x(int a) {\\n\" +\n            \"        return \\\"10\\\";\\n\" +\n            \"    }\\n\" +\n            \" }\";\n    assertSingleRecordDeclaration(s);\n}\n\n@Test\nvoid record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n    String s = \"record Point(int x, int y) {\\n\" +\n            \"    public int x(int a) {\\n\" +\n            \"        return 10;\\n\" +\n            \"    }\\n\" +\n            \" }\";\n    assertSingleRecordDeclaration(s);\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The method `assertSingleRecordDeclaration` encapsulates the logic for parsing the compilation unit and asserting that there is exactly one record declaration. This method takes a string representation of the record code as a parameter.\n2. **Updated Tests**: The original test methods now call this new method, which simplifies their implementation and improves readability. \n\nThis refactoring enhances modularity and makes it easier to maintain the tests in the future.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate assertCompilationFails(s String) : void extracted from package record_mustNotAllowMismatchedComponentAccessorReturnType() : void in class com.github.javaparser.ast.body.RecordDeclarationTest", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 235, "endLine": 247, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 239, "endLine": 247, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 307, "endLine": 311, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_mustNotAllowMismatchedComponentAccessorReturnType", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#record_mustNotAllowMismatchedComponentAccessorReturnType"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": ["private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\nprivate void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }", "diffSourceCode": "-  235:     @Test\n-  236:     void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n-  237:         String s = \"record Point(int x, int y) {\\n\" +\n-  238:                 \"    public String x() {\\n\" +\n-  239:                 \"        return \\\"10\\\";\\n\" +\n-  240:                 \"    }\\n\" +\n-  241:                 \" }\";\n-  242: \n-  243:         assertThrows(AssertionFailedError.class, () -> {\n-  244:             CompilationUnit cu = parseCompilationUnit(s);\n-  245:         });\n-  246: \n+  235:         assertOneRecordDeclaration(cu);\n+  236:     }\n+  237: \n+  238: \n+  239:     @Test\n+  240:     void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n+  241:         String s = \"record Point(int x, int y) {\\n\" +\n+  242:                 \"    public String x() {\\n\" +\n+  243:                 \"        return \\\"10\\\";\\n\" +\n+  244:                 \"    }\\n\" +\n+  245:                 \" }\";\n+  246:         assertCompilationFails(s);\n   247:     }\n-  307:         // test parameters (none)\n-  308:     }\n-  309: }\n+  307:     private void assertCompilationFails(String s) {\n+  308:         assertThrows(AssertionFailedError.class, () -> {\n+  309:             CompilationUnit cu = parseCompilationUnit(s);\n+  310:         });\n+  311:     }\n", "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_235_247_307_311_239_247", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the test method `record_mustNotAllowMismatchedComponentAccessorReturnType`, we can extract the logic for parsing the compilation unit into a separate method. This will help reduce duplication and make the test easier to read.\n\nHere\u2019s the refactored method code:\n\n##########################\n```java\n@Test\nvoid record_mustNotAllowMismatchedComponentAccessorReturnType() {\n    String recordCode = createRecordWithMismatchedAccessorReturnType();\n    assertCompilationUnitThrows(recordCode);\n}\n\nprivate String createRecordWithMismatchedAccessorReturnType() {\n    return \"record Point(int x, int y) {\\n\" +\n           \"    public String x() {\\n\" +\n           \"        return \\\"10\\\";\\n\" +\n           \"    }\\n\" +\n           \" }\";\n}\n\nprivate void assertCompilationUnitThrows(String code) {\n    assertThrows(AssertionFailedError.class, () -> {\n        CompilationUnit cu = parseCompilationUnit(code);\n    });\n}\n```\n##########################\n\nIn this refactoring:\n- The string that represents the record with a mismatched accessor return type is moved to a separate method `createRecordWithMismatchedAccessorReturnType()`.\n- The assertion logic is encapsulated in the `assertCompilationUnitThrows(String code)` method, which makes the test method cleaner and more focused on its purpose.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract And Move Method", "description": "Extract And Move Method\tpublic parse(code String, considerComments boolean) : CompilationUnit extracted from public whenTheClassIsParsedByTheJavaParser() : void in class com.github.javaparser.bdd.steps.DumpingSteps & moved to class com.github.javaparser.JavaParser", "diffLocations": [{"filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/DumpingSteps.java", "startLine": 60, "endLine": 63, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/DumpingSteps.java", "startLine": 60, "endLine": 63, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/DumpingSteps.java", "startLine": 178, "endLine": 189, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@When(\"the {class|compilation unit} is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parse(new StringReader(sourceUnderTest), true);\n    }", "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/DumpingSteps.java", "isPureRefactoring": true, "commitId": "547da782d2ea7f1abc35e5c1e5852928962a11ef", "packageNameBefore": "com.github.javaparser.bdd.steps", "classNameBefore": "com.github.javaparser.bdd.steps.DumpingSteps", "methodNameBefore": "com.github.javaparser.bdd.steps.DumpingSteps#whenTheClassIsParsedByTheJavaParser", "invokedMethod": "methodSignature: com.github.javaparser.JavaParser#parse\n methodBody: public static CompilationUnit parse(final Reader reader, boolean considerComments)\n            throws ParseException {\ntryString comments=readerToString(reader);\nCompilationUnit cu=new InstanceJavaParser(comments).parse();\nif(considerComments){commentsInserter.insertComments(cu,comments);\n}return cu;\ncatch(IOException ioe)throw new ParseException(ioe.getMessage());\n}", "classSignatureBefore": "public class DumpingSteps ", "methodNameBeforeSet": ["com.github.javaparser.bdd.steps.DumpingSteps#whenTheClassIsParsedByTheJavaParser"], "classNameBeforeSet": ["com.github.javaparser.bdd.steps.DumpingSteps"], "classSignatureBeforeSet": ["public class DumpingSteps "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2016 The JavaParser Team.\n *\n * This file is part of JavaParser.\n * \n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License \n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.bdd.steps;\n\nimport static com.github.javaparser.utils.Utils.readerToString;\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\n\nimport org.jbehave.core.annotations.Given;\nimport org.jbehave.core.annotations.Then;\nimport org.jbehave.core.annotations.When;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseException;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.visitor.ModifierVisitorAdapter;\n\npublic class DumpingSteps {\n\n    private Node resultNode;\n    private String sourceUnderTest;\n\n    @Given(\"the {class|compilation unit|expression|block|statement|import|annotation|body|class body|interface body}:$classSrc\")\n    public void givenTheClass(String classSrc) {\n        this.sourceUnderTest = classSrc.trim();\n    }\n\n    @Given(\"the {class|compilation unit|expression|block|statement|import|annotation|body|class body|interface body} in the file \\\"$classFile\\\"\")\n    public void givenTheClassInTheFile(String classFile) throws URISyntaxException, IOException, ParseException {\n        URL url = getClass().getResource(\"../samples/\" + classFile);\n        sourceUnderTest = readerToString(new FileReader(new File(url.toURI()))).trim();\n    }\n\n    @When(\"the {class|compilation unit} is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parse(new StringReader(sourceUnderTest), true);\n    }\n\n    @When(\"the expression is parsed by the Java parser\")\n    public void whenTheExpressionIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseExpression(sourceUnderTest);\n    }\n\n    @When(\"the block is parsed by the Java parser\")\n    public void whenTheBlockIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseBlock(sourceUnderTest);\n    }\n\n    @When(\"the statement is parsed by the Java parser\")\n    public void whenTheStatementIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseStatement(sourceUnderTest);\n    }\n\n    @When(\"the import is parsed by the Java parser\")\n    public void whenTheImportIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseImport(sourceUnderTest);\n    }\n\n    @When(\"the annotation is parsed by the Java parser\")\n    public void whenTheAnnotationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseAnnotation(sourceUnderTest);\n    }\n\n    @When(\"the body declaration is parsed by the Java parser\")\n    public void whenTheBodyDeclarationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseBodyDeclaration(sourceUnderTest);\n    }\n\n    @When(\"the class body declaration is parsed by the Java parser\")\n    public void whenTheClassBodyDeclarationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseClassBodyDeclaration(sourceUnderTest);\n    }\n\n    @When(\"the interface body declaration is parsed by the Java parser\")\n    public void whenTheInterfaceBodyDeclarationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseInterfaceBodyDeclaration(sourceUnderTest);\n    }\n\n    @When(\"the class is visited by an empty ModifierVisitorAdapter\")\n    public void whenTheClassIsVisitedByAnEmptyModifierVisitorAdapter() throws ParseException {\n        (new ModifierVisitorAdapter() {\n        }).visit((CompilationUnit) resultNode, null);\n    }\n\n    @Then(\"it is dumped to:$dumpSrc\")\n    public void isDumpedTo(String dumpSrc) {\n        assertEquals(dumpSrc.trim(), resultNode.toString().trim());\n    }\n\n}\n", "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/DumpingSteps.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2016 The JavaParser Team.\n *\n * This file is part of JavaParser.\n * \n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License \n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.bdd.steps;\n\nimport static com.github.javaparser.utils.Utils.readerToString;\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\n\nimport org.jbehave.core.annotations.Given;\nimport org.jbehave.core.annotations.Then;\nimport org.jbehave.core.annotations.When;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseException;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.visitor.ModifierVisitorAdapter;\n\npublic class DumpingSteps {\n\n    private Node resultNode;\n    private String sourceUnderTest;\n\n    @Given(\"the {class|compilation unit|expression|block|statement|import|annotation|body|class body|interface body}:$classSrc\")\n    public void givenTheClass(String classSrc) {\n        this.sourceUnderTest = classSrc.trim();\n    }\n\n    @Given(\"the {class|compilation unit|expression|block|statement|import|annotation|body|class body|interface body} in the file \\\"$classFile\\\"\")\n    public void givenTheClassInTheFile(String classFile) throws URISyntaxException, IOException, ParseException {\n        URL url = getClass().getResource(\"../samples/\" + classFile);\n        sourceUnderTest = readerToString(new FileReader(new File(url.toURI()))).trim();\n    }\n\n    @When(\"the {class|compilation unit} is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parse(sourceUnderTest, true);\n    }\n\n    @When(\"the expression is parsed by the Java parser\")\n    public void whenTheExpressionIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseExpression(sourceUnderTest);\n    }\n\n    @When(\"the block is parsed by the Java parser\")\n    public void whenTheBlockIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseBlock(sourceUnderTest);\n    }\n\n    @When(\"the statement is parsed by the Java parser\")\n    public void whenTheStatementIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseStatement(sourceUnderTest);\n    }\n\n    @When(\"the import is parsed by the Java parser\")\n    public void whenTheImportIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseImport(sourceUnderTest);\n    }\n\n    @When(\"the annotation is parsed by the Java parser\")\n    public void whenTheAnnotationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseAnnotation(sourceUnderTest);\n    }\n\n    @When(\"the body declaration is parsed by the Java parser\")\n    public void whenTheBodyDeclarationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseBodyDeclaration(sourceUnderTest);\n    }\n\n    @When(\"the class body declaration is parsed by the Java parser\")\n    public void whenTheClassBodyDeclarationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseClassBodyDeclaration(sourceUnderTest);\n    }\n\n    @When(\"the interface body declaration is parsed by the Java parser\")\n    public void whenTheInterfaceBodyDeclarationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseInterfaceBodyDeclaration(sourceUnderTest);\n    }\n\n    @When(\"the class is visited by an empty ModifierVisitorAdapter\")\n    public void whenTheClassIsVisitedByAnEmptyModifierVisitorAdapter() throws ParseException {\n        (new ModifierVisitorAdapter() {\n        }).visit((CompilationUnit) resultNode, null);\n    }\n\n    @Then(\"it is dumped to:$dumpSrc\")\n    public void isDumpedTo(String dumpSrc) {\n        assertEquals(dumpSrc.trim(), resultNode.toString().trim());\n    }\n\n}\n", "diffSourceCodeSet": [""], "invokedMethodSet": ["methodSignature: com.github.javaparser.JavaParser#parse\n methodBody: public static CompilationUnit parse(final Reader reader, boolean considerComments)\n            throws ParseException {\ntryString comments=readerToString(reader);\nCompilationUnit cu=new InstanceJavaParser(comments).parse();\nif(considerComments){commentsInserter.insertComments(cu,comments);\n}return cu;\ncatch(IOException ioe)throw new ParseException(ioe.getMessage());\n}"], "sourceCodeAfterRefactoring": "@When(\"the {class|compilation unit} is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parse(sourceUnderTest, true);\n    }\n", "diffSourceCode": "    60:     @When(\"the {class|compilation unit} is parsed by the Java parser\")\n    61:     public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n-   62:         resultNode = JavaParser.parse(new StringReader(sourceUnderTest), true);\n+   62:         resultNode = JavaParser.parse(sourceUnderTest, true);\n    63:     }\n", "uniqueId": "547da782d2ea7f1abc35e5c1e5852928962a11ef_60_63_178_189_60_63", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To refactor the provided code, we will extract the parsing logic into a separate static method and move it to an existing utility class. This will improve the modularity and readability of the code.\n\n### Step 1: Analyze the Code\nThe method `whenTheClassIsParsedByTheJavaParser` is responsible for parsing a Java class from a string. This logic can be extracted into a utility method that can be reused across different parsing scenarios.\n\n### Step 2: Identify the Target File\nLooking at the project structure, a suitable target file for the extracted method is `TestUtils.java`, as it likely contains utility methods that can be used across various tests.\n\n### Step 3: Extract the Method\nWe will create a public static method in `TestUtils.java` that handles the parsing of the Java class.\n\n### Step 4: Refactor the Original Method\nWe will modify the `whenTheClassIsParsedByTheJavaParser` method to call the new static method from `TestUtils`.\n\n### Refactoring Details\n\n#### Target File Path\n```plaintext\njavaparser-testing/src/test/java/com/github/javaparser/bdd/TestUtils.java\n```\n\n#### Extracted Method Code\n```java\npublic static Node parseJavaClass(String source) throws ParseException {\n    return JavaParser.parse(new StringReader(source), true);\n}\n```\n\n#### Refactored Method Code\n```java\n@When(\"the {class|compilation unit} is parsed by the Java parser\")\npublic void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n    resultNode = TestUtils.parseJavaClass(sourceUnderTest);\n}\n```\n\n### Final Output\nHere is the complete output as per your request:\n\n##########################\njavaparser-testing/src/test/java/com/github/javaparser/bdd/TestUtils.java\n##########################\npublic static Node parseJavaClass(String source) throws ParseException {\n    return JavaParser.parse(new StringReader(source), true);\n}\n##########################\n@When(\"the {class|compilation unit} is parsed by the Java parser\")\npublic void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n    resultNode = TestUtils.parseJavaClass(sourceUnderTest);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@When(\"the {class|compilation unit} is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parse(new StringReader(sourceUnderTest), true);\n    }\n\nClass content:\n/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2016 The JavaParser Team.\n *\n * This file is part of JavaParser.\n * \n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License \n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.bdd.steps;\n\nimport static com.github.javaparser.utils.Utils.readerToString;\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\n\nimport org.jbehave.core.annotations.Given;\nimport org.jbehave.core.annotations.Then;\nimport org.jbehave.core.annotations.When;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseException;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.visitor.ModifierVisitorAdapter;\n\npublic class DumpingSteps {\n\n    private Node resultNode;\n    private String sourceUnderTest;\n\n    @Given(\"the {class|compilation unit|expression|block|statement|import|annotation|body|class body|interface body}:$classSrc\")\n    public void givenTheClass(String classSrc) {\n        this.sourceUnderTest = classSrc.trim();\n    }\n\n    @Given(\"the {class|compilation unit|expression|block|statement|import|annotation|body|class body|interface body} in the file \\\"$classFile\\\"\")\n    public void givenTheClassInTheFile(String classFile) throws URISyntaxException, IOException, ParseException {\n        URL url = getClass().getResource(\"../samples/\" + classFile);\n        sourceUnderTest = readerToString(new FileReader(new File(url.toURI()))).trim();\n    }\n\n    @When(\"the {class|compilation unit} is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parse(new StringReader(sourceUnderTest), true);\n    }\n\n    @When(\"the expression is parsed by the Java parser\")\n    public void whenTheExpressionIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseExpression(sourceUnderTest);\n    }\n\n    @When(\"the block is parsed by the Java parser\")\n    public void whenTheBlockIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseBlock(sourceUnderTest);\n    }\n\n    @When(\"the statement is parsed by the Java parser\")\n    public void whenTheStatementIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseStatement(sourceUnderTest);\n    }\n\n    @When(\"the import is parsed by the Java parser\")\n    public void whenTheImportIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseImport(sourceUnderTest);\n    }\n\n    @When(\"the annotation is parsed by the Java parser\")\n    public void whenTheAnnotationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseAnnotation(sourceUnderTest);\n    }\n\n    @When(\"the body declaration is parsed by the Java parser\")\n    public void whenTheBodyDeclarationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseBodyDeclaration(sourceUnderTest);\n    }\n\n    @When(\"the class body declaration is parsed by the Java parser\")\n    public void whenTheClassBodyDeclarationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseClassBodyDeclaration(sourceUnderTest);\n    }\n\n    @When(\"the interface body declaration is parsed by the Java parser\")\n    public void whenTheInterfaceBodyDeclarationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseInterfaceBodyDeclaration(sourceUnderTest);\n    }\n\n    @When(\"the class is visited by an empty ModifierVisitorAdapter\")\n    public void whenTheClassIsVisitedByAnEmptyModifierVisitorAdapter() throws ParseException {\n        (new ModifierVisitorAdapter() {\n        }).visit((CompilationUnit) resultNode, null);\n    }\n\n    @Then(\"it is dumped to:$dumpSrc\")\n    public void isDumpedTo(String dumpSrc) {\n        assertEquals(dumpSrc.trim(), resultNode.toString().trim());\n    }\n\n}\n\nRefactoring Operation:\nExtract And Move Method\n\nProject Structure:\n['javaparser-testing/src/test/java/com/github/javaparser/bdd/BasicJBehaveTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/CommentParsingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ComparingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/DumpingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ManipulationTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/ParsingTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/PositionRangeTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/TestUtils.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/VisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ComparingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/DumpingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ExistenceOfParentNodeVerifier.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ManipulationSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ParsingSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/PositionRangeSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/SharedSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/VisitorSteps.java', 'javaparser-testing/src/test/java/com/github/javaparser/bdd/visitors/PositionTestVisitor.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/ChangingMethodsFromAClassWithAVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/ChangingMethodsFromAClassWithoutAVisitorTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/ClassCreator.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/CreatingACompilationUnitFromScratch.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/CuPrinter.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/MethodChanger_1.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/MethodChanger_2.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/MethodPrinter.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/PrintingTheCompilationUnitToSystemOutputTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/TestFileToken.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/VisitingClassMethodsTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/ClassOrInterfaceDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/CompilationUnitBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/EnumDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/FieldDeclarationBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/NodeWithAnnotationsBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/NodeWithMembersBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/NodeWithParametersBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/builders/NodeWithThrowableBuildersTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/removenode/D.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/removenode/GitHubTest.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/removenode/GitHubTest_2.java', 'javaparser-testing/src/test/java/com/github/javaparser/junit/removenode/RemoveDeleteNodeFromAst.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/ClassInLatin1.java', 'javaparser-testing/src/test/resources/com/github/javaparser/bdd/samples/JavaConcepts.java', 'javaparser-testing/src/test/resources/com/github/javaparser/junit/TestFile.java']\n\nFile Path Before Refactoring:\njavaparser-testing/src/test/java/com/github/javaparser/bdd/steps/DumpingSteps.java\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, and you need move the extracted method to another existing java file, output the target file path, extracted method code, refactored method code after refactoring.\nThe extracted method code should be the public static method.\nThe refactored method code should use the moved class to call the extracted method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\ntarget_file_path\n##########################\nextracted_method_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpublic solveMethodAsUsage(name String, parameterTypes List<TypeUsage>, typeSolver TypeSolver, invokationContext Context) : Optional<MethodUsage> from class me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter to private solveMethodAsUsage(tp TypeUsageOfTypeParameter, name String, parameterTypes List<TypeUsage>, typeSolver TypeSolver, invokationContext Context) : Optional<MethodUsage> from class me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext", "diffLocations": [{"filePath": "src/main/java/me/tomassetti/symbolsolver/model/typesystem/TypeUsageOfTypeParameter.java", "startLine": 61, "endLine": 70, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java", "startLine": 56, "endLine": 64, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n        for (TypeParameter.Bound bound : typeParameter.getBounds(typeSolver)) {\n            Optional<MethodUsage> methodUsage = bound.getType().solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext);\n            if (methodUsage.isPresent()) {\n                return methodUsage;\n            }\n        }\n        return Optional.empty();\n    }", "filePathBefore": "src/main/java/me/tomassetti/symbolsolver/model/typesystem/TypeUsageOfTypeParameter.java", "isPureRefactoring": true, "commitId": "0e81f51c40996b42cb262dc2397126cee8f60965", "packageNameBefore": "me.tomassetti.symbolsolver.model.typesystem", "classNameBefore": "me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter", "methodNameBefore": "me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter#solveMethodAsUsage", "invokedMethod": "methodSignature: me.tomassetti.symbolsolver.model.declarations.TypeDeclaration#solveMethodAsUsage\n methodBody: default Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nreturn getContext().solveMethodAsUsage(name,parameterTypes,typeSolver);\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionInterfaceDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nif(typeParameterValues.size() != getTypeParameters().size()){if(this.getTypeParameters().size() != 0){typeParameterValues=new ArrayList<>();\nfor(int i=0; i < getTypeParameters().size(); i++){typeParameterValues.add(new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class)));\n}}}List<MethodUsage> methods=new ArrayList<>();\nfor(Method method: clazz.getMethods()){if(method.getName().equals(name) && !method.isBridge() && !method.isSynthetic()){MethodDeclaration methodDeclaration=new ReflectionMethodDeclaration(method);\nMethodUsage methodUsage=new MethodUsage(methodDeclaration,typeSolver);\nint i=0;\nfor(TypeParameter tp: getTypeParameters()){methodUsage=methodUsage.replaceNameParam(tp.getName(),typeParameterValues.get(i));\ni++;\n}methods.add(methodUsage);\n}}return MethodResolutionLogic.findMostApplicableUsage(methods,name,parameterTypes,typeSolver);\n}\nmethodSignature: me.tomassetti.symbolsolver.JavaParserFacade#solveMethodAsUsage\n methodBody: public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\nList<TypeUsage> params=new ArrayList<>();\nif(call.getArgs() != null){for(Expression param: call.getArgs()){params.add(getType(param,false));\n}}Context context=JavaParserFactory.getContext(call);\nOptional<MethodUsage> methodUsage=context.solveMethodAsUsage(call.getName(),params,typeSolver);\nif(!methodUsage.isPresent()){throw new RuntimeException(\"Method\" + \" '\" + call.getName() + \"' cannot be resolved in context \" + call + \" (line: \" + call.getBeginLine() + \") \" + context);\n}return methodUsage.get();\n}\nmethodSignature: me.tomassetti.symbolsolver.model.typesystem.TypeUsage#solveMethodAsUsage\n methodBody: default Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\nthrow new UnsupportedOperationException(this.getClass().getCanonicalName());\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionFieldDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn ReflectionFactory.typeUsageFor(field.getType());\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistFieldDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\ntryreturn JavassistFactory.typeUsageFor(ctField.getType());\ncatch(NotFoundException e)throw new RuntimeException(e);\n}\nmethodSignature: me.tomassetti.symbolsolver.JavaParserFacade#getType\n methodBody: public TypeUsage getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!cacheWithLambadsSolved.containsKey(node)){TypeUsage res=getTypeConcrete(node,solveLambdas);\ncacheWithLambadsSolved.put(node,res);\nlogger.finer(\"getType on \" + node + \" -> \" + res);\n}return cacheWithLambadsSolved.get(node);\n}{if(!cacheWithoutLambadsSolved.containsKey(node)){TypeUsage res=getTypeConcrete(node,solveLambdas);\ncacheWithoutLambadsSolved.put(node,res);\nlogger.finer(\"getType on \" + node + \" (no solveLambdas) -> \" + res);\n}return cacheWithoutLambadsSolved.get(node);\n}}\nmethodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionParameterDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn ReflectionFactory.typeUsageFor(genericType);\n}\nmethodSignature: me.tomassetti.symbolsolver.model.typesystem.ReferenceTypeUsage#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\nOptional<MethodUsage> ref=typeDeclaration.solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,typeParameters);\nif(ref.isPresent()){MethodUsage methodUsage=ref.get();\nTypeUsage returnType=replaceTypeParams(methodUsage.returnType());\nif(returnType != methodUsage.returnType()){methodUsage=methodUsage.replaceReturnType(returnType);\n}for(int i=0; i < methodUsage.getParamTypes().size(); i++){TypeUsage replaced=replaceTypeParams(methodUsage.getParamTypes().get(i));\nmethodUsage=methodUsage.replaceParamType(i,replaced);\n}return Optional.of(methodUsage);\n}{return ref;\n}}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserEnumConstantDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn new ReferenceTypeUsage(new JavaParserEnumDeclaration((EnumDeclaration)wrappedNode.getParentNode()));\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javaparser.contexts.CompilationUnitContext#getType\n methodBody: private String getType(String qName){\nint index=qName.lastIndexOf('.');\nif(index == -1){throw new UnsupportedOperationException();\n}String typeName=qName.substring(0,index);\nreturn typeName;\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionClassDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nList<MethodUsage> methods=new ArrayList<>();\nfor(Method method: Arrays.stream(clazz.getDeclaredMethods()).filter((m) -> m.getName().equals(name)).sorted(new MethodComparator()).collect(Collectors.toList())){if(method.isBridge() || method.isSynthetic())continue;\nMethodDeclaration methodDeclaration=new ReflectionMethodDeclaration(method);\nMethodUsage methodUsage=new MethodUsage(methodDeclaration,typeSolver);\nfor(int i=0; i < getTypeParameters().size(); i++){String nameToReplace=getTypeParameters().get(i).getName();\nTypeUsage newValue=typeParameterValues.get(i);\nmethodUsage=methodUsage.replaceNameParam(nameToReplace,newValue);\n}methods.add(methodUsage);\n}ClassDeclaration superClass=getSuperClass(typeSolver);\nif(superClass != null){Optional<MethodUsage> ref=superClass.solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,typeParameterValues);\nif(ref.isPresent()){methods.add(ref.get());\n}}for(InterfaceDeclaration interfaceDeclaration: getInterfaces(typeSolver)){Optional<MethodUsage> ref=interfaceDeclaration.solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,typeParameterValues);\nif(ref.isPresent()){methods.add(ref.get());\n}}Optional<MethodUsage> ref=MethodResolutionLogic.findMostApplicableUsage(methods,name,parameterTypes,typeSolver);\nreturn ref;\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionTypeParameter#getBounds\n methodBody: public List<Bound> getBounds(TypeSolver typeSolver) {\nreturn Arrays.stream(typeVariable.getBounds()).map((refB) -> Bound.extendsBound(ReflectionFactory.typeUsageFor(refB))).collect(Collectors.toList());\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserFieldDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nif(enumConstantDeclaration != null){com.github.javaparser.ast.body.EnumDeclaration enumDeclaration=(com.github.javaparser.ast.body.EnumDeclaration)enumConstantDeclaration.getParentNode();\nreturn new ReferenceTypeUsage(new JavaParserEnumDeclaration(enumDeclaration));\n}{return JavaParserFacade.get(typeSolver).convert(fieldDeclaration.getType(),fieldDeclaration);\n}}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\nif(wrappedNode.getScope() != null){tryTypeUsage typeOfScope=JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\nreturn typeOfScope.solveMethodAsUsage(name,parameterTypes,typeSolver,this);\ncatch(UnsolvedSymbolException e)if(wrappedNode.getScope() instanceof NameExpr){String className=((NameExpr)wrappedNode.getScope()).getName();\nSymbolReference<TypeDeclaration> ref=solveType(className,typeSolver);\nif(ref.isSolved()){SymbolReference<MethodDeclaration> m=ref.getCorrespondingDeclaration().solveMethod(name,parameterTypes,typeSolver);\nif(m.isSolved()){return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(),typeSolver));\n}{throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n}}{throw e;\n}}{throw e;\n}}{if(wrappedNode.getParentNode() instanceof MethodCallExpr){MethodCallExpr parent=(MethodCallExpr)wrappedNode.getParentNode();\nif(parent.getScope() == wrappedNode){return getParent().getParent().solveMethodAsUsage(name,parameterTypes,typeSolver);\n}}Context parentContext=getParent();\nreturn parentContext.solveMethodAsUsage(name,parameterTypes,typeSolver);\n}}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistClassDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver,\n                                                    Context invokationContext, List<TypeUsage> typeParameterValues) {\nfor(CtMethod method: ctClass.getDeclaredMethods()){if(method.getName().equals(name)){MethodUsage methodUsage=new MethodUsage(new JavassistMethodDeclaration(method,typeSolver),typeSolver);\ntryif(method.getGenericSignature() != null){SignatureAttribute.MethodSignature classSignature=SignatureAttribute.toMethodSignature(method.getGenericSignature());\nList<TypeUsage> parametersOfReturnType=parseTypeParameters(classSignature.getReturnType().toString(),typeSolver,new JavassistMethodContext(method),invokationContext);\nTypeUsage newReturnType=methodUsage.returnType();\nfor(int i=0; i < parametersOfReturnType.size(); i++){newReturnType=newReturnType.asReferenceTypeUsage().replaceParam(i,parametersOfReturnType.get(i));\n}methodUsage=methodUsage.replaceReturnType(newReturnType);\n}return Optional.of(methodUsage);\ncatch(BadBytecode e)throw new RuntimeException(e);\n}}tryCtClass superClass=ctClass.getSuperclass();\nif(superClass != null){Optional<MethodUsage> ref=new JavassistClassDeclaration(superClass).solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,null);\nif(ref.isPresent()){return ref;\n}}catch(NotFoundException e)throw new RuntimeException(e);\ntryfor(CtClass interfaze: ctClass.getInterfaces()){Optional<MethodUsage> ref=new JavassistClassDeclaration(interfaze).solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,null);\nif(ref.isPresent()){return ref;\n}}catch(NotFoundException e)throw new RuntimeException(e);\nreturn Optional.empty();\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserEnumDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nif(name.equals(\"values\") && parameterTypes.size() == 0){return Optional.of(new ValuesMethod().getUsage(null));\n}return getContext().solveMethodAsUsage(name,parameterTypes,typeSolver);\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserTypeParameter#getBounds\n methodBody: public List<Bound> getBounds(TypeSolver typeSolver) {\nif(wrappedNode.getTypeBound() == null){return Collections.emptyList();\n}return wrappedNode.getTypeBound().stream().map((astB) -> toBound(astB,typeSolver)).collect(Collectors.toList());\n}\nmethodSignature: me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\nfor(TypeParameter.Bound bound: typeParameter.getBounds(typeSolver)){Optional<MethodUsage> methodUsage=bound.getType().solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext);\nif(methodUsage.isPresent()){return methodUsage;\n}}return Optional.empty();\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserSymbolDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nif(wrappedNode instanceof Parameter){Parameter parameter=(Parameter)wrappedNode;\nif(wrappedNode.getParentNode() instanceof LambdaExpr){int pos=getParamPos(parameter);\nTypeUsage lambdaType=JavaParserFacade.get(typeSolver).getType(wrappedNode.getParentNode());\nthrow new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}{if(parameter.getType() instanceof PrimitiveType){return PrimitiveTypeUsage.byName(((PrimitiveType)parameter.getType()).getType().name());\n}{return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(),wrappedNode);\n}}}if(wrappedNode instanceof VariableDeclarator){VariableDeclarator variableDeclarator=(VariableDeclarator)wrappedNode;\nif(wrappedNode.getParentNode() instanceof VariableDeclarationExpr){VariableDeclarationExpr variableDeclarationExpr=(VariableDeclarationExpr)variableDeclarator.getParentNode();\nreturn JavaParserFacade.get(typeSolver).convert(variableDeclarationExpr.getType(),JavaParserFactory.getContext(wrappedNode));\n}if(wrappedNode.getParentNode() instanceof FieldDeclaration){FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarator.getParentNode();\nreturn JavaParserFacade.get(typeSolver).convert(fieldDeclaration.getType(),JavaParserFactory.getContext(wrappedNode));\n}{throw new UnsupportedOperationException(wrappedNode.getParentNode().getClass().getCanonicalName());\n}}{throw new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistTypeParameter#getBounds\n methodBody: public List<Bound> getBounds(TypeSolver typeSolver) {\nList<Bound> bounds=new ArrayList<>();\nif(wrapped.getClassBound() != null){throw new UnsupportedOperationException(wrapped.getClassBound().toString());\n}for(SignatureAttribute.ObjectType ot: wrapped.getInterfaceBound()){throw new UnsupportedOperationException(ot.toString());\n}return bounds;\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistParameterDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn JavassistFactory.typeUsageFor(type);\n}", "classSignatureBefore": "public class TypeUsageOfTypeParameter implements TypeUsage ", "methodNameBeforeSet": ["me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter#solveMethodAsUsage"], "classNameBeforeSet": ["me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter"], "classSignatureBeforeSet": ["public class TypeUsageOfTypeParameter implements TypeUsage "], "purityCheckResultList": [{"isPure": true, "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Add Parameter-", "description": "Parametrization or Add Parameter on top of the moved method - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package me.tomassetti.symbolsolver.model.typesystem;\n\nimport me.tomassetti.symbolsolver.resolution.Context;\nimport me.tomassetti.symbolsolver.resolution.TypeParameter;\nimport me.tomassetti.symbolsolver.resolution.TypeSolver;\n\nimport java.util.List;\nimport java.util.Optional;\n\npublic class TypeUsageOfTypeParameter implements TypeUsage {\n\n    private TypeParameter typeParameter;\n\n    @Override\n    public String toString() {\n        return \"TypeUsageOfTypeParameter{\" +\n                \"typeParameter=\" + typeParameter +\n                '}';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        TypeUsageOfTypeParameter that = (TypeUsageOfTypeParameter) o;\n\n        if (!typeParameter.equals(that.typeParameter)) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return typeParameter.hashCode();\n    }\n\n    public TypeUsageOfTypeParameter(TypeParameter typeParameter) {\n        this.typeParameter = typeParameter;\n    }\n\n    @Override\n    public boolean isArray() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean isPrimitive() {\n        return false;\n    }\n\n    @Override\n    public TypeUsage replaceParam(String name, TypeUsage replaced) {\n        if (name.equals(typeParameter.getName())) {\n            return replaced;\n        } else {\n            return this;\n        }\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n        for (TypeParameter.Bound bound : typeParameter.getBounds(typeSolver)) {\n            Optional<MethodUsage> methodUsage = bound.getType().solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext);\n            if (methodUsage.isPresent()) {\n                return methodUsage;\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public boolean isReferenceType() {\n        return false;\n    }\n\n    @Override\n    public String describe() {\n        return typeParameter.getName();\n    }\n\n    @Override\n    public TypeParameter asTypeParameter() {\n        return typeParameter;\n    }\n\n    @Override\n    public boolean isTypeVariable() {\n        return true;\n    }\n\n    @Override\n    public boolean isAssignableBy(TypeUsage other, TypeSolver typeSolver) {\n        if (other.isTypeVariable()) {\n            return describe().equals(other.describe());\n        } else {\n            return false;\n        }\n    }\n\n}\n", "filePathAfter": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java", "sourceCodeAfterForWhole": "package me.tomassetti.symbolsolver.resolution.javaparser.contexts;\n\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport me.tomassetti.symbolsolver.JavaParserFacade;\nimport me.tomassetti.symbolsolver.model.typesystem.ReferenceTypeUsage;\nimport me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter;\nimport me.tomassetti.symbolsolver.resolution.*;\nimport me.tomassetti.symbolsolver.model.declarations.MethodDeclaration;\nimport me.tomassetti.symbolsolver.model.declarations.TypeDeclaration;\nimport me.tomassetti.symbolsolver.model.declarations.ValueDeclaration;\n\nimport me.tomassetti.symbolsolver.resolution.javaparser.UnsolvedSymbolException;\nimport me.tomassetti.symbolsolver.model.typesystem.MethodUsage;\nimport me.tomassetti.symbolsolver.model.typesystem.TypeUsage;\n\nimport java.util.List;\nimport java.util.Optional;\n\n/**\n * Created by federico on 31/07/15.\n */\npublic class MethodCallExprContext extends AbstractJavaParserContext<MethodCallExpr> {\n\n    public MethodCallExprContext(MethodCallExpr wrappedNode, TypeSolver typeSolver) {\n        super(wrappedNode, typeSolver);\n    }\n\n    @Override\n    public Optional<TypeUsage> solveGenericType(String name, TypeSolver typeSolver) {\n        if (wrappedNode.getTypeArgs() != null) {\n            throw new UnsupportedOperationException(name);\n        }\n        TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.asReferenceTypeUsage().solveGenericType(name);\n    }\n\n    private Optional<MethodUsage> solveMethodAsUsage(ReferenceTypeUsage refType, String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n        Optional<MethodUsage> ref = refType.getTypeDeclaration().solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext, refType.parameters());\n        if (ref.isPresent()) {\n            MethodUsage methodUsage = ref.get();\n            TypeUsage returnType = refType.replaceTypeParams(methodUsage.returnType());\n            if (returnType != methodUsage.returnType()){\n                methodUsage = methodUsage.replaceReturnType(returnType);\n            }\n            for (int i=0;i<methodUsage.getParamTypes().size();i++){\n                TypeUsage replaced = refType.replaceTypeParams(methodUsage.getParamTypes().get(i));\n                methodUsage = methodUsage.replaceParamType(i, replaced);\n            }\n            return Optional.of(methodUsage);\n        } else {\n            return ref;\n        }\n    }\n\n    private Optional<MethodUsage> solveMethodAsUsage(TypeUsageOfTypeParameter tp, String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n        for (TypeParameter.Bound bound : tp.asTypeParameter().getBounds(typeSolver)) {\n            Optional<MethodUsage> methodUsage = solveMethodAsUsage(bound.getType(), name, parameterTypes, typeSolver, invokationContext);\n            if (methodUsage.isPresent()) {\n                return methodUsage;\n            }\n        }\n        return Optional.empty();\n    }\n\n    private Optional<MethodUsage> solveMethodAsUsage(TypeUsage typeUsage, String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n        if (typeUsage instanceof ReferenceTypeUsage) {\n            return solveMethodAsUsage((ReferenceTypeUsage)typeUsage, name, parameterTypes, typeSolver, invokationContext);\n        } else if (typeUsage instanceof TypeUsageOfTypeParameter) {\n            return solveMethodAsUsage((TypeUsageOfTypeParameter)typeUsage, name, parameterTypes, typeSolver, invokationContext);\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() != null) {\n            try {\n                TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e){\n                // ok, maybe it was instead a static access, so let's look for a type\n                if (wrappedNode.getScope() instanceof NameExpr){\n                    String className = ((NameExpr)wrappedNode.getScope()).getName();\n                    SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                        if (m.isSolved()) {\n                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\"+name+\"' with parameterTypes \"+parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr parent = (MethodCallExpr)wrappedNode.getParentNode();\n                if (parent.getScope() == wrappedNode) {\n                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                }\n            }\n            Context parentContext = getParent();\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }\n\n    @Override\n    public SymbolReference<? extends ValueDeclaration> solveSymbol(String name, TypeSolver typeSolver) {\n        return getParent().solveSymbol(name, typeSolver);\n    }\n\n    @Override\n    public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        Context parentContext = getParent();\n        return parentContext.solveSymbolAsValue(name, typeSolver);\n    }\n\n    @Override\n    public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() != null) {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n        } else {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n        }\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": ["methodSignature: me.tomassetti.symbolsolver.model.declarations.TypeDeclaration#solveMethodAsUsage\n methodBody: default Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nreturn getContext().solveMethodAsUsage(name,parameterTypes,typeSolver);\n}", "methodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionInterfaceDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nif(typeParameterValues.size() != getTypeParameters().size()){if(this.getTypeParameters().size() != 0){typeParameterValues=new ArrayList<>();\nfor(int i=0; i < getTypeParameters().size(); i++){typeParameterValues.add(new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class)));\n}}}List<MethodUsage> methods=new ArrayList<>();\nfor(Method method: clazz.getMethods()){if(method.getName().equals(name) && !method.isBridge() && !method.isSynthetic()){MethodDeclaration methodDeclaration=new ReflectionMethodDeclaration(method);\nMethodUsage methodUsage=new MethodUsage(methodDeclaration,typeSolver);\nint i=0;\nfor(TypeParameter tp: getTypeParameters()){methodUsage=methodUsage.replaceNameParam(tp.getName(),typeParameterValues.get(i));\ni++;\n}methods.add(methodUsage);\n}}return MethodResolutionLogic.findMostApplicableUsage(methods,name,parameterTypes,typeSolver);\n}", "methodSignature: me.tomassetti.symbolsolver.JavaParserFacade#solveMethodAsUsage\n methodBody: public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\nList<TypeUsage> params=new ArrayList<>();\nif(call.getArgs() != null){for(Expression param: call.getArgs()){params.add(getType(param,false));\n}}Context context=JavaParserFactory.getContext(call);\nOptional<MethodUsage> methodUsage=context.solveMethodAsUsage(call.getName(),params,typeSolver);\nif(!methodUsage.isPresent()){throw new RuntimeException(\"Method\" + \" '\" + call.getName() + \"' cannot be resolved in context \" + call + \" (line: \" + call.getBeginLine() + \") \" + context);\n}return methodUsage.get();\n}", "methodSignature: me.tomassetti.symbolsolver.model.typesystem.TypeUsage#solveMethodAsUsage\n methodBody: default Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\nthrow new UnsupportedOperationException(this.getClass().getCanonicalName());\n}", "methodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionFieldDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn ReflectionFactory.typeUsageFor(field.getType());\n}", "methodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistFieldDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\ntryreturn JavassistFactory.typeUsageFor(ctField.getType());\ncatch(NotFoundException e)throw new RuntimeException(e);\n}", "methodSignature: me.tomassetti.symbolsolver.JavaParserFacade#getType\n methodBody: public TypeUsage getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!cacheWithLambadsSolved.containsKey(node)){TypeUsage res=getTypeConcrete(node,solveLambdas);\ncacheWithLambadsSolved.put(node,res);\nlogger.finer(\"getType on \" + node + \" -> \" + res);\n}return cacheWithLambadsSolved.get(node);\n}{if(!cacheWithoutLambadsSolved.containsKey(node)){TypeUsage res=getTypeConcrete(node,solveLambdas);\ncacheWithoutLambadsSolved.put(node,res);\nlogger.finer(\"getType on \" + node + \" (no solveLambdas) -> \" + res);\n}return cacheWithoutLambadsSolved.get(node);\n}}", "methodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionParameterDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn ReflectionFactory.typeUsageFor(genericType);\n}", "methodSignature: me.tomassetti.symbolsolver.model.typesystem.ReferenceTypeUsage#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\nOptional<MethodUsage> ref=typeDeclaration.solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,typeParameters);\nif(ref.isPresent()){MethodUsage methodUsage=ref.get();\nTypeUsage returnType=replaceTypeParams(methodUsage.returnType());\nif(returnType != methodUsage.returnType()){methodUsage=methodUsage.replaceReturnType(returnType);\n}for(int i=0; i < methodUsage.getParamTypes().size(); i++){TypeUsage replaced=replaceTypeParams(methodUsage.getParamTypes().get(i));\nmethodUsage=methodUsage.replaceParamType(i,replaced);\n}return Optional.of(methodUsage);\n}{return ref;\n}}", "methodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserEnumConstantDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn new ReferenceTypeUsage(new JavaParserEnumDeclaration((EnumDeclaration)wrappedNode.getParentNode()));\n}", "methodSignature: me.tomassetti.symbolsolver.resolution.javaparser.contexts.CompilationUnitContext#getType\n methodBody: private String getType(String qName){\nint index=qName.lastIndexOf('.');\nif(index == -1){throw new UnsupportedOperationException();\n}String typeName=qName.substring(0,index);\nreturn typeName;\n}", "methodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionClassDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nList<MethodUsage> methods=new ArrayList<>();\nfor(Method method: Arrays.stream(clazz.getDeclaredMethods()).filter((m) -> m.getName().equals(name)).sorted(new MethodComparator()).collect(Collectors.toList())){if(method.isBridge() || method.isSynthetic())continue;\nMethodDeclaration methodDeclaration=new ReflectionMethodDeclaration(method);\nMethodUsage methodUsage=new MethodUsage(methodDeclaration,typeSolver);\nfor(int i=0; i < getTypeParameters().size(); i++){String nameToReplace=getTypeParameters().get(i).getName();\nTypeUsage newValue=typeParameterValues.get(i);\nmethodUsage=methodUsage.replaceNameParam(nameToReplace,newValue);\n}methods.add(methodUsage);\n}ClassDeclaration superClass=getSuperClass(typeSolver);\nif(superClass != null){Optional<MethodUsage> ref=superClass.solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,typeParameterValues);\nif(ref.isPresent()){methods.add(ref.get());\n}}for(InterfaceDeclaration interfaceDeclaration: getInterfaces(typeSolver)){Optional<MethodUsage> ref=interfaceDeclaration.solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,typeParameterValues);\nif(ref.isPresent()){methods.add(ref.get());\n}}Optional<MethodUsage> ref=MethodResolutionLogic.findMostApplicableUsage(methods,name,parameterTypes,typeSolver);\nreturn ref;\n}", "methodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionTypeParameter#getBounds\n methodBody: public List<Bound> getBounds(TypeSolver typeSolver) {\nreturn Arrays.stream(typeVariable.getBounds()).map((refB) -> Bound.extendsBound(ReflectionFactory.typeUsageFor(refB))).collect(Collectors.toList());\n}", "methodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserFieldDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nif(enumConstantDeclaration != null){com.github.javaparser.ast.body.EnumDeclaration enumDeclaration=(com.github.javaparser.ast.body.EnumDeclaration)enumConstantDeclaration.getParentNode();\nreturn new ReferenceTypeUsage(new JavaParserEnumDeclaration(enumDeclaration));\n}{return JavaParserFacade.get(typeSolver).convert(fieldDeclaration.getType(),fieldDeclaration);\n}}", "methodSignature: me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\nif(wrappedNode.getScope() != null){tryTypeUsage typeOfScope=JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\nreturn typeOfScope.solveMethodAsUsage(name,parameterTypes,typeSolver,this);\ncatch(UnsolvedSymbolException e)if(wrappedNode.getScope() instanceof NameExpr){String className=((NameExpr)wrappedNode.getScope()).getName();\nSymbolReference<TypeDeclaration> ref=solveType(className,typeSolver);\nif(ref.isSolved()){SymbolReference<MethodDeclaration> m=ref.getCorrespondingDeclaration().solveMethod(name,parameterTypes,typeSolver);\nif(m.isSolved()){return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(),typeSolver));\n}{throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n}}{throw e;\n}}{throw e;\n}}{if(wrappedNode.getParentNode() instanceof MethodCallExpr){MethodCallExpr parent=(MethodCallExpr)wrappedNode.getParentNode();\nif(parent.getScope() == wrappedNode){return getParent().getParent().solveMethodAsUsage(name,parameterTypes,typeSolver);\n}}Context parentContext=getParent();\nreturn parentContext.solveMethodAsUsage(name,parameterTypes,typeSolver);\n}}", "methodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistClassDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver,\n                                                    Context invokationContext, List<TypeUsage> typeParameterValues) {\nfor(CtMethod method: ctClass.getDeclaredMethods()){if(method.getName().equals(name)){MethodUsage methodUsage=new MethodUsage(new JavassistMethodDeclaration(method,typeSolver),typeSolver);\ntryif(method.getGenericSignature() != null){SignatureAttribute.MethodSignature classSignature=SignatureAttribute.toMethodSignature(method.getGenericSignature());\nList<TypeUsage> parametersOfReturnType=parseTypeParameters(classSignature.getReturnType().toString(),typeSolver,new JavassistMethodContext(method),invokationContext);\nTypeUsage newReturnType=methodUsage.returnType();\nfor(int i=0; i < parametersOfReturnType.size(); i++){newReturnType=newReturnType.asReferenceTypeUsage().replaceParam(i,parametersOfReturnType.get(i));\n}methodUsage=methodUsage.replaceReturnType(newReturnType);\n}return Optional.of(methodUsage);\ncatch(BadBytecode e)throw new RuntimeException(e);\n}}tryCtClass superClass=ctClass.getSuperclass();\nif(superClass != null){Optional<MethodUsage> ref=new JavassistClassDeclaration(superClass).solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,null);\nif(ref.isPresent()){return ref;\n}}catch(NotFoundException e)throw new RuntimeException(e);\ntryfor(CtClass interfaze: ctClass.getInterfaces()){Optional<MethodUsage> ref=new JavassistClassDeclaration(interfaze).solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,null);\nif(ref.isPresent()){return ref;\n}}catch(NotFoundException e)throw new RuntimeException(e);\nreturn Optional.empty();\n}", "methodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserEnumDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nif(name.equals(\"values\") && parameterTypes.size() == 0){return Optional.of(new ValuesMethod().getUsage(null));\n}return getContext().solveMethodAsUsage(name,parameterTypes,typeSolver);\n}", "methodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserTypeParameter#getBounds\n methodBody: public List<Bound> getBounds(TypeSolver typeSolver) {\nif(wrappedNode.getTypeBound() == null){return Collections.emptyList();\n}return wrappedNode.getTypeBound().stream().map((astB) -> toBound(astB,typeSolver)).collect(Collectors.toList());\n}", "methodSignature: me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\nfor(TypeParameter.Bound bound: typeParameter.getBounds(typeSolver)){Optional<MethodUsage> methodUsage=bound.getType().solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext);\nif(methodUsage.isPresent()){return methodUsage;\n}}return Optional.empty();\n}", "methodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserSymbolDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nif(wrappedNode instanceof Parameter){Parameter parameter=(Parameter)wrappedNode;\nif(wrappedNode.getParentNode() instanceof LambdaExpr){int pos=getParamPos(parameter);\nTypeUsage lambdaType=JavaParserFacade.get(typeSolver).getType(wrappedNode.getParentNode());\nthrow new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}{if(parameter.getType() instanceof PrimitiveType){return PrimitiveTypeUsage.byName(((PrimitiveType)parameter.getType()).getType().name());\n}{return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(),wrappedNode);\n}}}if(wrappedNode instanceof VariableDeclarator){VariableDeclarator variableDeclarator=(VariableDeclarator)wrappedNode;\nif(wrappedNode.getParentNode() instanceof VariableDeclarationExpr){VariableDeclarationExpr variableDeclarationExpr=(VariableDeclarationExpr)variableDeclarator.getParentNode();\nreturn JavaParserFacade.get(typeSolver).convert(variableDeclarationExpr.getType(),JavaParserFactory.getContext(wrappedNode));\n}if(wrappedNode.getParentNode() instanceof FieldDeclaration){FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarator.getParentNode();\nreturn JavaParserFacade.get(typeSolver).convert(fieldDeclaration.getType(),JavaParserFactory.getContext(wrappedNode));\n}{throw new UnsupportedOperationException(wrappedNode.getParentNode().getClass().getCanonicalName());\n}}{throw new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}}", "methodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistTypeParameter#getBounds\n methodBody: public List<Bound> getBounds(TypeSolver typeSolver) {\nList<Bound> bounds=new ArrayList<>();\nif(wrapped.getClassBound() != null){throw new UnsupportedOperationException(wrapped.getClassBound().toString());\n}for(SignatureAttribute.ObjectType ot: wrapped.getInterfaceBound()){throw new UnsupportedOperationException(ot.toString());\n}return bounds;\n}", "methodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistParameterDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn JavassistFactory.typeUsageFor(type);\n}"], "sourceCodeAfterRefactoring": "private Optional<MethodUsage> solveMethodAsUsage(TypeUsageOfTypeParameter tp, String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n        for (TypeParameter.Bound bound : tp.asTypeParameter().getBounds(typeSolver)) {\n            Optional<MethodUsage> methodUsage = solveMethodAsUsage(bound.getType(), name, parameterTypes, typeSolver, invokationContext);\n            if (methodUsage.isPresent()) {\n                return methodUsage;\n            }\n        }\n        return Optional.empty();\n    }", "diffSourceCode": "-   56:         } else {\n-   57:             return this;\n-   58:         }\n-   59:     }\n-   60: \n-   61:     @Override\n-   62:     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n-   63:         for (TypeParameter.Bound bound : typeParameter.getBounds(typeSolver)) {\n-   64:             Optional<MethodUsage> methodUsage = bound.getType().solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext);\n-   65:             if (methodUsage.isPresent()) {\n-   66:                 return methodUsage;\n-   67:             }\n-   68:         }\n-   69:         return Optional.empty();\n-   70:     }\n+   56:     private Optional<MethodUsage> solveMethodAsUsage(TypeUsageOfTypeParameter tp, String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n+   57:         for (TypeParameter.Bound bound : tp.asTypeParameter().getBounds(typeSolver)) {\n+   58:             Optional<MethodUsage> methodUsage = solveMethodAsUsage(bound.getType(), name, parameterTypes, typeSolver, invokationContext);\n+   59:             if (methodUsage.isPresent()) {\n+   60:                 return methodUsage;\n+   61:             }\n+   62:         }\n+   63:         return Optional.empty();\n+   64:     }\n+   65: \n+   66:     private Optional<MethodUsage> solveMethodAsUsage(TypeUsage typeUsage, String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n+   67:         if (typeUsage instanceof ReferenceTypeUsage) {\n+   68:             return solveMethodAsUsage((ReferenceTypeUsage)typeUsage, name, parameterTypes, typeSolver, invokationContext);\n+   69:         } else if (typeUsage instanceof TypeUsageOfTypeParameter) {\n+   70:             return solveMethodAsUsage((TypeUsageOfTypeParameter)typeUsage, name, parameterTypes, typeSolver, invokationContext);\n", "uniqueId": "0e81f51c40996b42cb262dc2397126cee8f60965_61_70__56_64", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 3, "covered": 26}, "BRANCH": {"missed": 2, "covered": 2}, "LINE": {"missed": 2, "covered": 4}, "COMPLEXITY": {"missed": 2, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To perform the requested refactoring, we will move the `solveMethodAsUsage` method from the `TypeUsageOfTypeParameter` class to a more appropriate class within the project structure. Given the context of the method, it seems to be related to method resolution, which could fit well in the `MethodResolutionLogic` class.\n\n### Target File Path\nWe will move the method to:\n```\nsrc/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java\n```\n\n### Moved Class Code\nHere is the code that will be added to the `MethodResolutionLogic` class:\n```java\npackage me.tomassetti.symbolsolver.resolution;\n\nimport me.tomassetti.symbolsolver.model.typesystem.MethodUsage;\nimport me.tomassetti.symbolsolver.model.typesystem.TypeUsage;\n\nimport java.util.List;\nimport java.util.Optional;\n\npublic class MethodResolutionLogic {\n\n    public static Optional<MethodUsage> solveMethodAsUsage(TypeParameter typeParameter, String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invocationContext) {\n        for (TypeParameter.Bound bound : typeParameter.getBounds(typeSolver)) {\n            Optional<MethodUsage> methodUsage = bound.getType().solveMethodAsUsage(name, parameterTypes, typeSolver, invocationContext);\n            if (methodUsage.isPresent()) {\n                return methodUsage;\n            }\n        }\n        return Optional.empty();\n    }\n}\n```\n\n### Refactored Method Code\nNow, we will update the `solveMethodAsUsage` method in the `TypeUsageOfTypeParameter` class to call the newly moved static method:\n```java\n@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invocationContext) {\n    return MethodResolutionLogic.solveMethodAsUsage(typeParameter, name, parameterTypes, typeSolver, invocationContext);\n}\n```\n\n### Final Output\nHere is the complete output in the requested format:\n\n##########################\nsrc/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java\n##########################\npackage me.tomassetti.symbolsolver.resolution;\n\nimport me.tomassetti.symbolsolver.model.typesystem.MethodUsage;\nimport me.tomassetti.symbolsolver.model.typesystem.TypeUsage;\n\nimport java.util.List;\nimport java.util.Optional;\n\npublic class MethodResolutionLogic {\n\n    public static Optional<MethodUsage> solveMethodAsUsage(TypeParameter typeParameter, String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invocationContext) {\n        for (TypeParameter.Bound bound : typeParameter.getBounds(typeSolver)) {\n            Optional<MethodUsage> methodUsage = bound.getType().solveMethodAsUsage(name, parameterTypes, typeSolver, invocationContext);\n            if (methodUsage.isPresent()) {\n                return methodUsage;\n            }\n        }\n        return Optional.empty();\n    }\n}\n##########################\n@Override\npublic Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invocationContext) {\n    return MethodResolutionLogic.solveMethodAsUsage(typeParameter, name, parameterTypes, typeSolver, invocationContext);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n        for (TypeParameter.Bound bound : typeParameter.getBounds(typeSolver)) {\n            Optional<MethodUsage> methodUsage = bound.getType().solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext);\n            if (methodUsage.isPresent()) {\n                return methodUsage;\n            }\n        }\n        return Optional.empty();\n    }\n\nClass content:\npackage me.tomassetti.symbolsolver.model.typesystem;\n\nimport me.tomassetti.symbolsolver.resolution.Context;\nimport me.tomassetti.symbolsolver.resolution.TypeParameter;\nimport me.tomassetti.symbolsolver.resolution.TypeSolver;\n\nimport java.util.List;\nimport java.util.Optional;\n\npublic class TypeUsageOfTypeParameter implements TypeUsage {\n\n    private TypeParameter typeParameter;\n\n    @Override\n    public String toString() {\n        return \"TypeUsageOfTypeParameter{\" +\n                \"typeParameter=\" + typeParameter +\n                '}';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        TypeUsageOfTypeParameter that = (TypeUsageOfTypeParameter) o;\n\n        if (!typeParameter.equals(that.typeParameter)) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return typeParameter.hashCode();\n    }\n\n    public TypeUsageOfTypeParameter(TypeParameter typeParameter) {\n        this.typeParameter = typeParameter;\n    }\n\n    @Override\n    public boolean isArray() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean isPrimitive() {\n        return false;\n    }\n\n    @Override\n    public TypeUsage replaceParam(String name, TypeUsage replaced) {\n        if (name.equals(typeParameter.getName())) {\n            return replaced;\n        } else {\n            return this;\n        }\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n        for (TypeParameter.Bound bound : typeParameter.getBounds(typeSolver)) {\n            Optional<MethodUsage> methodUsage = bound.getType().solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext);\n            if (methodUsage.isPresent()) {\n                return methodUsage;\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public boolean isReferenceType() {\n        return false;\n    }\n\n    @Override\n    public String describe() {\n        return typeParameter.getName();\n    }\n\n    @Override\n    public TypeParameter asTypeParameter() {\n        return typeParameter;\n    }\n\n    @Override\n    public boolean isTypeVariable() {\n        return true;\n    }\n\n    @Override\n    public boolean isAssignableBy(TypeUsage other, TypeSolver typeSolver) {\n        if (other.isTypeVariable()) {\n            return describe().equals(other.describe());\n        } else {\n            return false;\n        }\n    }\n\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java', 'src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java', 'src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java', 'src/main/java/me/tomassetti/symbolsolver/javaparser/Navigator.java', 'src/main/java/me/tomassetti/symbolsolver/javaparser/package-info.java', 'src/main/java/me/tomassetti/symbolsolver/model/declarations/ClassDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/model/declarations/Declaration.java', 'src/main/java/me/tomassetti/symbolsolver/model/declarations/EnumDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/model/declarations/FieldDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/model/declarations/InterfaceDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/model/declarations/MethodAmbiguityException.java', 'src/main/java/me/tomassetti/symbolsolver/model/declarations/MethodDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/model/declarations/ParameterDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/model/declarations/TypeDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/model/declarations/TypeParametrized.java', 'src/main/java/me/tomassetti/symbolsolver/model/declarations/ValueDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/model/typesystem/ArrayTypeUsage.java', 'src/main/java/me/tomassetti/symbolsolver/model/typesystem/LambdaTypeUsagePlaceholder.java', 'src/main/java/me/tomassetti/symbolsolver/model/typesystem/MethodUsage.java', 'src/main/java/me/tomassetti/symbolsolver/model/typesystem/NullTypeUsage.java', 'src/main/java/me/tomassetti/symbolsolver/model/typesystem/PrimitiveTypeUsage.java', 'src/main/java/me/tomassetti/symbolsolver/model/typesystem/ReferenceTypeUsage.java', 'src/main/java/me/tomassetti/symbolsolver/model/typesystem/TypeUsage.java', 'src/main/java/me/tomassetti/symbolsolver/model/typesystem/TypeUsageOfTypeParameter.java', 'src/main/java/me/tomassetti/symbolsolver/model/typesystem/VoidTypeUsage.java', 'src/main/java/me/tomassetti/symbolsolver/model/typesystem/WildcardUsage.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/Context.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/MethodReference.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/SymbolDeclarator.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/SymbolReference.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/SymbolSolver.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/TypeParameter.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/TypeSolver.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/Value.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFactory.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/UnsolvedSymbolException.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/UnsolvedTypeException.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/AbstractJavaParserContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/ClassOrInterfaceDeclarationContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/CompilationUnitContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/ConstructorContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/EnumDeclarationContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/FieldAccessContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/ForStatementContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/ForechStatementContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/StatementContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/SwitchEntryContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/declarations/JavaParserClassDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/declarations/JavaParserEnumConstantDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/declarations/JavaParserEnumDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/declarations/JavaParserFieldDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/declarations/JavaParserInterfaceDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/declarations/JavaParserMethodDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/declarations/JavaParserParameterDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/declarations/JavaParserSymbolDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/declarations/JavaParserTypeParameter.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/declarations/JavaParserTypeVariableDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/declarators/AbstractSymbolDeclarator.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/declarators/FieldSymbolDeclarator.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/declarators/NoSimboyDeclarator.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/declarators/ParameterSymbolDeclarator.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/declarators/VariableSymbolDeclarator.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/package-info.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javassist/JavassistClassDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javassist/JavassistFactory.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javassist/JavassistFieldDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javassist/JavassistMethodDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javassist/JavassistParameterDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javassist/JavassistTypeParameter.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javassist/contexts/JavassistClassContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javassist/contexts/JavassistMethodContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/javassist/package-info.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/reflection/ClassOrInterfaceDeclarationContext.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/reflection/ReflectionClassDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/reflection/ReflectionFactory.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/reflection/ReflectionFieldDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/reflection/ReflectionInterfaceDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/reflection/ReflectionMethodDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/reflection/ReflectionParameterDeclaration.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/reflection/ReflectionTypeParameter.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/reflection/package-info.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/typesolvers/CombinedTypeSolver.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/typesolvers/DummyTypeSolver.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/typesolvers/JarTypeSolver.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/typesolvers/JavaParserTypeSolver.java', 'src/main/java/me/tomassetti/symbolsolver/resolution/typesolvers/JreTypeSolver.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate getTypeConcrete(node Node, solveLambdas boolean) : TypeUsage extracted from public getType(node Node, solveLambdas boolean) : TypeUsage in class me.tomassetti.symbolsolver.JavaParserFacade", "diffLocations": [{"filePath": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java", "startLine": 93, "endLine": 164, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java", "startLine": 106, "endLine": 118, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java", "startLine": 120, "endLine": 191, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n     * @return\n     */\n    public TypeUsage getType(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr = (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter = (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n            TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }", "filePathBefore": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java", "isPureRefactoring": true, "commitId": "627b56302d259409e9bc50b20d77803484f18b5c", "packageNameBefore": "me.tomassetti.symbolsolver", "classNameBefore": "me.tomassetti.symbolsolver.JavaParserFacade", "methodNameBefore": "me.tomassetti.symbolsolver.JavaParserFacade#getType", "invokedMethod": "methodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#getName\n methodBody: public String getName() {\nreturn clazz.getSimpleName();\n}\nmethodSignature: me.tomassetti.symbolsolver.model.javassist.JavassistParameterDeclaration#getType\n methodBody: public TypeDeclaration getType(TypeSolver typeSolver) {\nreturn new JavassistClassDeclaration(type);\n}\nmethodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#getUsage\n methodBody: public TypeUsage getUsage(Node node) {\nfor(TypeParameter tp: this.getTypeParameters()){throw new UnsupportedOperationException(\"Find parameters of \" + this + \" in \" + node);\n}return new TypeUsageOfTypeDeclaration(this);\n}\nmethodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#getField\n methodBody: public FieldDeclaration getField(String name) {\nthrow new UnsupportedOperationException();\n}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.MethodCallExprContext#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\nif(wrappedNode.getScope() != null){TypeUsage typeOfScope=new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\nreturn typeOfScope.solveMethodAsUsage(name,parameterTypes,typeSolver);\n}{throw new UnsupportedOperationException();\n}}\nmethodSignature: me.tomassetti.symbolsolver.JavaParserFacade#solve\n methodBody: public SymbolReference<MethodDeclaration> solve(MethodCallExpr methodCallExpr) {\nList<TypeUsage> params=new LinkedList<>();\nList<LambdaTypeUsagePlaceholder> placeholders=new LinkedList<>();\nint i=0;\nfor(Expression expression: methodCallExpr.getArgs()){if(expression instanceof LambdaExpr){LambdaTypeUsagePlaceholder placeholder=new LambdaTypeUsagePlaceholder(i);\nparams.add(placeholder);\nplaceholders.add(placeholder);\n}{params.add(new JavaParserFacade(typeSolver).getType(expression));\n}i++;\n}SymbolReference<MethodDeclaration> res=JavaParserFactory.getContext(methodCallExpr).solveMethod(methodCallExpr.getName(),params,typeSolver);\nfor(LambdaTypeUsagePlaceholder placeholder: placeholders){placeholder.setMethod(res);\n}return res;\n}\nmethodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\nList<MethodDeclaration> methods=new ArrayList<>();\nfor(Method method: clazz.getMethods()){MethodDeclaration methodDeclaration=new ReflectionMethodDeclaration(method);\nmethods.add(methodDeclaration);\n}SymbolReference<MethodDeclaration> ref=MethodResolutionLogic.findMostApplicable(methods,name,parameterTypes,typeSolver);\nif(ref.isSolved()){return Optional.of(new JavaParserFacade(typeSolver).convertToUsage(ref.getCorrespondingDeclaration(),getContext()));\n}{return Optional.empty();\n}}\nmethodSignature: me.tomassetti.symbolsolver.model.javassist.JavassistParameterDeclaration#getName\n methodBody: public String getName() {\nthrow new UnsupportedOperationException();\n}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserFieldDeclaration#getType\n methodBody: public TypeDeclaration getType(TypeSolver typeSolver) {\nreturn new JavaParserFacade(typeSolver).convert(fieldDeclaration.getType(),fieldDeclaration);\n}\nmethodSignature: me.tomassetti.symbolsolver.JavaParserFacade#solveMethodAsUsage\n methodBody: public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\nList<TypeUsage> params=new ArrayList<>();\nif(call.getArgs() != null){for(Expression param: call.getArgs()){params.add(getType(param,false));\n}}TypeUsage typeOfScope=getType(call.getScope());\nlogger.finest(\"facade solveMethodAsUsage, params \" + params);\nlogger.finest(\"facade solveMethodAsUsage, scope \" + typeOfScope);\nOptional<MethodUsage> ref=new MethodCallExprContext(call).solveMethodAsUsage(call.getName(),params,typeSolver);\nif(!ref.isPresent()){throw new UnsolvedSymbolException(null,call.getName());\n}{logger.finest(\"facade solveMethodAsUsage, ref \" + ref.get());\nMethodUsage methodUsage=ref.get();\nmethodUsage=replaceParams(methodUsage,typeOfScope);\nTypeUsage returnType=replaceParams(methodUsage.returnType(),typeOfScope);\nmethodUsage=methodUsage.replaceReturnType(returnType);\nreturn methodUsage;\n}}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration#getParamPos\n methodBody: public static int getParamPos(Node node) {\nif(node.getParentNode() instanceof MethodCallExpr){MethodCallExpr call=(MethodCallExpr)node.getParentNode();\nfor(int i=0; i < call.getArgs().size(); i++){if(call.getArgs().get(i) == node)return i;\n}throw new IllegalStateException();\n}{throw new IllegalArgumentException();\n}}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration#getType\n methodBody: public TypeDeclaration getType(TypeSolver typeSolver) {\nif(wrappedNode instanceof Parameter){Parameter parameter=(Parameter)wrappedNode;\nif(wrappedNode.getParentNode() instanceof LambdaExpr){int pos=getParamPos(parameter);\nTypeUsage lambdaType=new JavaParserFacade(typeSolver).getType(wrappedNode.getParentNode());\nthrow new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}{return new SymbolSolver(typeSolver).solveType(parameter.getType());\n}}if(wrappedNode instanceof VariableDeclarator){VariableDeclarator variableDeclarator=(VariableDeclarator)wrappedNode;\nif(wrappedNode.getParentNode() instanceof VariableDeclarationExpr){VariableDeclarationExpr variableDeclarationExpr=(VariableDeclarationExpr)variableDeclarator.getParentNode();\nreturn new JavaParserFacade(typeSolver).convert(variableDeclarationExpr.getType(),JavaParserFactory.getContext(wrappedNode));\n}if(wrappedNode.getParentNode() instanceof FieldDeclaration){FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarator.getParentNode();\nreturn new JavaParserFacade(typeSolver).convert(fieldDeclaration.getType(),JavaParserFactory.getContext(wrappedNode));\n}{throw new UnsupportedOperationException(wrappedNode.getParentNode().getClass().getCanonicalName());\n}}{throw new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.FieldAccessContext#solveSymbolAsValue\n methodBody: public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\nExpression scope=wrappedNode.getScope();\nTypeUsage typeOfScope=new JavaParserFacade(typeSolver).getType(scope);\nreturn typeOfScope.getField(name,typeSolver);\n}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.MethodCallExprContext#solveSymbolAsValue\n methodBody: public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\nreturn JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbolAsValue(name,typeSolver);\n}\nmethodSignature: me.tomassetti.symbolsolver.JavaParserFacade#getType\n methodBody: public TypeUsage getType(Node node, boolean solveLambdas) {\nif(node == null)throw new IllegalArgumentException();\nif(node instanceof NameExpr){NameExpr nameExpr=(NameExpr)node;\nlogger.finest(\"getType on name expr \" + node);\nreturn new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(),nameExpr).get().getUsage();\n}if(node instanceof MethodCallExpr){logger.finest(\"getType on method call \" + node);\nMethodUsage ref=new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr)node);\nlogger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\nlogger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\nreturn ref.returnType();\n}if(node instanceof LambdaExpr){if(node.getParentNode() instanceof MethodCallExpr){MethodCallExpr callExpr=(MethodCallExpr)node.getParentNode();\nint pos=JavaParserSymbolDeclaration.getParamPos(node);\nSymbolReference<MethodDeclaration> refMethod=new JavaParserFacade(typeSolver).solve(callExpr);\nif(!refMethod.isSolved()){throw new UnsolvedSymbolException(null,callExpr.getName());\n}logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\nif(solveLambdas){return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n}{return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n}}{throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n}}if(node instanceof VariableDeclarator){if(node.getParentNode() instanceof FieldDeclaration){FieldDeclaration parent=(FieldDeclaration)node.getParentNode();\nreturn new JavaParserFacade(typeSolver).convertToUsage(parent.getType(),parent);\n}if(node.getParentNode() instanceof VariableDeclarationExpr){VariableDeclarationExpr parent=(VariableDeclarationExpr)node.getParentNode();\nreturn new JavaParserFacade(typeSolver).convertToUsage(parent.getType(),parent);\n}{throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n}}if(node instanceof Parameter){Parameter parameter=(Parameter)node;\nif(parameter.getType() instanceof UnknownType){throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n}return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(),parameter);\n}if(node instanceof FieldAccessExpr){FieldAccessExpr fieldAccessExpr=(FieldAccessExpr)node;\nOptional<Value> value=new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(),fieldAccessExpr);\nif(value.isPresent()){return value.get().getUsage();\n}{throw new UnsolvedSymbolException(null,fieldAccessExpr.getField());\n}}if(node instanceof ObjectCreationExpr){ObjectCreationExpr objectCreationExpr=(ObjectCreationExpr)node;\nTypeUsage typeUsage=new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(),node);\nreturn typeUsage;\n}{throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n}}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserFieldDeclaration#getName\n methodBody: public String getName() {\nthrow new UnsupportedOperationException();\n}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.LambdaExprContext#solveSymbolAsValue\n methodBody: public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\nfor(Parameter parameter: wrappedNode.getParameters()){SymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(parameter,typeSolver);\nif(wrappedNode.getParentNode() instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)wrappedNode.getParentNode();\nMethodUsage methodUsage=new JavaParserFacade(typeSolver).solveMethodAsUsage(methodCallExpr);\nint i=pos(methodCallExpr,wrappedNode);\nTypeUsage lambdaType=methodUsage.getParamTypes().get(i);\nValue value=new Value(lambdaType.parameters().get(0),name,false);\nreturn Optional.of(value);\n}{throw new UnsupportedOperationException();\n}}return getParent().solveSymbolAsValue(name,typeSolver);\n}\nmethodSignature: me.tomassetti.symbolsolver.JavaParserFacade#convertToUsage\n methodBody: public MethodUsage convertToUsage(MethodDeclaration methodDeclaration, Context context) {\nreturn new MethodUsage(methodDeclaration,typeSolver);\n}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration#getName\n methodBody: public String getName() {\nreturn name;\n}", "classSignatureBefore": "public class JavaParserFacade ", "methodNameBeforeSet": ["me.tomassetti.symbolsolver.JavaParserFacade#getType"], "classNameBeforeSet": ["me.tomassetti.symbolsolver.JavaParserFacade"], "classSignatureBeforeSet": ["public class JavaParserFacade "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package me.tomassetti.symbolsolver;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.ReferenceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnknownType;\nimport jdk.nashorn.internal.ir.Symbol;\nimport me.tomassetti.symbolsolver.model.*;\nimport me.tomassetti.symbolsolver.model.declarations.MethodDeclaration;\nimport me.tomassetti.symbolsolver.model.declarations.ValueDeclaration;\nimport me.tomassetti.symbolsolver.model.declarations.TypeDeclaration;\nimport me.tomassetti.symbolsolver.model.usages.MethodUsage;\nimport me.tomassetti.symbolsolver.model.usages.TypeUsageOfTypeDeclaration;\nimport me.tomassetti.symbolsolver.model.javaparser.JavaParserFactory;\nimport me.tomassetti.symbolsolver.model.javaparser.UnsolvedSymbolException;\nimport me.tomassetti.symbolsolver.model.javaparser.contexts.MethodCallExprContext;\nimport me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration;\nimport me.tomassetti.symbolsolver.model.usages.TypeUsage;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.logging.ConsoleHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n */\npublic class JavaParserFacade {\n\n    private TypeSolver typeSolver;\n    private SymbolSolver symbolSolver;\n\n    private static Logger logger = Logger.getLogger(JavaParserFacade.class.getCanonicalName());\n    static {\n        logger.setLevel(Level.FINEST);\n        ConsoleHandler consoleHandler = new ConsoleHandler();\n        consoleHandler.setLevel(Level.FINEST);\n        logger.addHandler(consoleHandler);\n    }\n\n    public JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver;\n        this.symbolSolver = new SymbolSolver(typeSolver);\n    }\n\n    public SymbolReference solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName(), nameExpr);\n    }\n\n    public SymbolReference solve(Expression expr) {\n        if (expr instanceof NameExpr) {\n            return solve((NameExpr)expr);\n        } else {\n            throw new IllegalArgumentException(expr.getClass().getCanonicalName());\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<MethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        List<TypeUsage> params = new LinkedList<>();\n        List<LambdaTypeUsagePlaceholder> placeholders = new LinkedList<>();\n        int i = 0;\n        for (Expression expression : methodCallExpr.getArgs()) {\n            if (expression instanceof LambdaExpr) {\n                LambdaTypeUsagePlaceholder placeholder = new LambdaTypeUsagePlaceholder(i);\n                params.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                params.add(new JavaParserFacade(typeSolver).getType(expression));\n            }\n            i++;\n        }\n        SymbolReference<MethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr).solveMethod(methodCallExpr.getName(), params, typeSolver);\n        for (LambdaTypeUsagePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    public TypeUsage getType(Node node) {\n        return getType(node, true);\n    }\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n     * @return\n     */\n    public TypeUsage getType(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr = (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter = (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n            TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    public TypeUsage convertToUsage(Type type, Node context) {\n        if (type instanceof UnknownType){\n            throw new IllegalArgumentException(\"Unknown type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context));\n    }\n\n    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType = (ReferenceType) type;\n            // TODO consider array modifiers\n            return convertToUsage(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType)type;\n            SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n            }\n            TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n            List<TypeUsage> typeParameters = Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() != null) {\n                typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt)->convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    private SymbolReference<MethodDeclaration> solveMethod(MethodCallExpr methodCallExpr) {\n        List<TypeUsage> params = new ArrayList<>();\n        if (methodCallExpr.getArgs() != null) {\n            for (Expression param : methodCallExpr.getArgs()) {\n                params.add(getType(param));\n            }\n        }\n        return new MethodCallExprContext(methodCallExpr).solveMethod(methodCallExpr.getName(), params, typeSolver);\n    }\n\n    public TypeDeclaration convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node));\n    }\n\n    public TypeDeclaration convert(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType = (ReferenceType) type;\n            // TODO consider array modifiers\n            return convert(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType)type;\n            SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n            }\n            return ref.getCorrespondingDeclaration();\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<TypeUsage> params = new ArrayList<>();\n        if (call.getArgs() != null) {\n            for (Expression param : call.getArgs()) {\n                params.add(getType(param, false));\n            }\n        }\n        TypeUsage typeOfScope = getType(call.getScope());\n        logger.finest(\"facade solveMethodAsUsage, params \" + params);\n        logger.finest(\"facade solveMethodAsUsage, scope \" + typeOfScope);\n\n        // TODO take params from scope and substitute them in ref\n\n        Optional<MethodUsage> ref = new MethodCallExprContext(call).solveMethodAsUsage(call.getName(), params, typeSolver);\n\n        if (!ref.isPresent()){\n            throw new UnsolvedSymbolException(null, call.getName());\n        } else {\n            logger.finest(\"facade solveMethodAsUsage, ref \" + ref.get());\n            MethodUsage methodUsage = ref.get();\n            methodUsage = replaceParams(methodUsage, typeOfScope);\n            TypeUsage returnType = replaceParams(methodUsage.returnType(), typeOfScope);\n            methodUsage = methodUsage.replaceReturnType(returnType);\n            return methodUsage;\n        }\n    }\n\n    private MethodUsage replaceParams(MethodUsage methodUsage, TypeUsage typeOfScope) {\n        logger.finest(\"ReplaceParams \" + methodUsage);\n        logger.finest(\"ReplaceParams N params \" + methodUsage.getParamTypes().size());\n        for (int i=0;i<methodUsage.getParamTypes().size();i++) {\n            TypeUsage typeUsage = methodUsage.getParamTypes().get(i);\n            TypeUsage replaced = replaceParams(typeUsage, typeOfScope);\n            logger.finest(\"ReplaceParams param type \" + typeUsage);\n            if (replaced != typeUsage) {\n                logger.finest(\"ReplaceParams param -> \" + replaced);\n                methodUsage = methodUsage.replaceParamType(i, replaced);\n            }\n\n        }\n        logger.finest(\"Final method usage \"+methodUsage);\n        return methodUsage;\n    }\n\n    private TypeUsage replaceParams(TypeUsage typeToReplace, TypeUsage typeOfScope) {\n        if (typeToReplace.isTypeVariable()) {\n            Optional<TypeUsage> replacement = typeOfScope.parameterByName(typeToReplace.getTypeName());\n            if (replacement.isPresent()) {\n                return replacement.get();\n            } else {\n                return typeToReplace;\n            }\n        } else {\n            for (int i=0;i<typeToReplace.parameters().size();i++){\n                TypeUsage typeUsage = typeToReplace.parameters().get(i);\n                TypeUsage replaced = replaceParams(typeUsage, typeOfScope);\n                if (replaced != typeUsage) {\n                    typeToReplace = typeToReplace.replaceParam(i, replaced);\n                }\n            }\n            return typeToReplace;\n        }\n    }\n\n    public MethodUsage convertToUsage(MethodDeclaration methodDeclaration, Context context) {\n        return new MethodUsage(methodDeclaration, typeSolver);\n    }\n}\n", "filePathAfter": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java", "sourceCodeAfterForWhole": "package me.tomassetti.symbolsolver;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.ReferenceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnknownType;\nimport jdk.nashorn.internal.ir.Symbol;\nimport me.tomassetti.symbolsolver.model.*;\nimport me.tomassetti.symbolsolver.model.declarations.MethodDeclaration;\nimport me.tomassetti.symbolsolver.model.declarations.ValueDeclaration;\nimport me.tomassetti.symbolsolver.model.declarations.TypeDeclaration;\nimport me.tomassetti.symbolsolver.model.usages.MethodUsage;\nimport me.tomassetti.symbolsolver.model.usages.TypeUsageOfTypeDeclaration;\nimport me.tomassetti.symbolsolver.model.javaparser.JavaParserFactory;\nimport me.tomassetti.symbolsolver.model.javaparser.UnsolvedSymbolException;\nimport me.tomassetti.symbolsolver.model.javaparser.contexts.MethodCallExprContext;\nimport me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration;\nimport me.tomassetti.symbolsolver.model.usages.TypeUsage;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.logging.ConsoleHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n */\npublic class JavaParserFacade {\n\n    private TypeSolver typeSolver;\n    private SymbolSolver symbolSolver;\n\n    private static Logger logger = Logger.getLogger(JavaParserFacade.class.getCanonicalName());\n    static {\n        logger.setLevel(Level.FINEST);\n        ConsoleHandler consoleHandler = new ConsoleHandler();\n        consoleHandler.setLevel(Level.FINEST);\n        logger.addHandler(consoleHandler);\n    }\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver;\n        this.symbolSolver = new SymbolSolver(typeSolver);\n    }\n\n    public static JavaParserFacade get(TypeSolver typeSolver){\n        if (!instances.containsKey(typeSolver)){\n            instances.put(typeSolver, new JavaParserFacade(typeSolver));\n        }\n        return instances.get(typeSolver);\n    }\n\n\n    public SymbolReference solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName(), nameExpr);\n    }\n\n    public SymbolReference solve(Expression expr) {\n        if (expr instanceof NameExpr) {\n            return solve((NameExpr)expr);\n        } else {\n            throw new IllegalArgumentException(expr.getClass().getCanonicalName());\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<MethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        List<TypeUsage> params = new LinkedList<>();\n        List<LambdaTypeUsagePlaceholder> placeholders = new LinkedList<>();\n        int i = 0;\n        for (Expression expression : methodCallExpr.getArgs()) {\n            if (expression instanceof LambdaExpr) {\n                LambdaTypeUsagePlaceholder placeholder = new LambdaTypeUsagePlaceholder(i);\n                params.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                params.add(new JavaParserFacade(typeSolver).getType(expression));\n            }\n            i++;\n        }\n        SymbolReference<MethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr).solveMethod(methodCallExpr.getName(), params, typeSolver);\n        for (LambdaTypeUsagePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    public TypeUsage getType(Node node) {\n        return getType(node, true);\n    }\n\n    private Map<Node, TypeUsage> cacheWithLambadsSolved = new WeakHashMap<>();\n    private Map<Node, TypeUsage> cacheWithoutLambadsSolved = new WeakHashMap<>();\n\n    private static Map<TypeSolver, JavaParserFacade> instances = new HashMap<>();\n\n    public TypeUsage getType(Node node, boolean solveLambdas) {\n        if (solveLambdas){\n            if (!cacheWithLambadsSolved.containsKey(node)){\n                cacheWithLambadsSolved.put(node, getTypeConcrete(node, solveLambdas));\n            }\n            return cacheWithLambadsSolved.get(node);\n        } else {\n            if (!cacheWithoutLambadsSolved.containsKey(node)){\n                cacheWithoutLambadsSolved.put(node, getTypeConcrete(node, solveLambdas));\n            }\n            return cacheWithoutLambadsSolved.get(node);\n        }\n    }\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n     * @return\n     */\n    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr = (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter = (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n            TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    public TypeUsage convertToUsage(Type type, Node context) {\n        if (type instanceof UnknownType){\n            throw new IllegalArgumentException(\"Unknown type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context));\n    }\n\n    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType = (ReferenceType) type;\n            // TODO consider array modifiers\n            return convertToUsage(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType)type;\n            SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n            }\n            TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n            List<TypeUsage> typeParameters = Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() != null) {\n                typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt)->convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    private SymbolReference<MethodDeclaration> solveMethod(MethodCallExpr methodCallExpr) {\n        List<TypeUsage> params = new ArrayList<>();\n        if (methodCallExpr.getArgs() != null) {\n            for (Expression param : methodCallExpr.getArgs()) {\n                params.add(getType(param));\n            }\n        }\n        return new MethodCallExprContext(methodCallExpr).solveMethod(methodCallExpr.getName(), params, typeSolver);\n    }\n\n    public TypeDeclaration convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node));\n    }\n\n    public TypeDeclaration convert(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType = (ReferenceType) type;\n            // TODO consider array modifiers\n            return convert(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType)type;\n            SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n            }\n            return ref.getCorrespondingDeclaration();\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<TypeUsage> params = new ArrayList<>();\n        if (call.getArgs() != null) {\n            for (Expression param : call.getArgs()) {\n                params.add(getType(param, false));\n            }\n        }\n        TypeUsage typeOfScope = getType(call.getScope());\n        logger.finest(\"facade solveMethodAsUsage, params \" + params);\n        logger.finest(\"facade solveMethodAsUsage, scope \" + typeOfScope);\n\n        // TODO take params from scope and substitute them in ref\n\n        Optional<MethodUsage> ref = new MethodCallExprContext(call).solveMethodAsUsage(call.getName(), params, typeSolver);\n\n        if (!ref.isPresent()){\n            throw new UnsolvedSymbolException(null, call.getName());\n        } else {\n            logger.finest(\"facade solveMethodAsUsage, ref \" + ref.get());\n            MethodUsage methodUsage = ref.get();\n            methodUsage = replaceParams(methodUsage, typeOfScope);\n            TypeUsage returnType = replaceParams(methodUsage.returnType(), typeOfScope);\n            methodUsage = methodUsage.replaceReturnType(returnType);\n            return methodUsage;\n        }\n    }\n\n    private MethodUsage replaceParams(MethodUsage methodUsage, TypeUsage typeOfScope) {\n        logger.finest(\"ReplaceParams \" + methodUsage);\n        logger.finest(\"ReplaceParams N params \" + methodUsage.getParamTypes().size());\n        for (int i=0;i<methodUsage.getParamTypes().size();i++) {\n            TypeUsage typeUsage = methodUsage.getParamTypes().get(i);\n            TypeUsage replaced = replaceParams(typeUsage, typeOfScope);\n            logger.finest(\"ReplaceParams param type \" + typeUsage);\n            if (replaced != typeUsage) {\n                logger.finest(\"ReplaceParams param -> \" + replaced);\n                methodUsage = methodUsage.replaceParamType(i, replaced);\n            }\n\n        }\n        logger.finest(\"Final method usage \"+methodUsage);\n        return methodUsage;\n    }\n\n    private TypeUsage replaceParams(TypeUsage typeToReplace, TypeUsage typeOfScope) {\n        if (typeToReplace.isTypeVariable()) {\n            Optional<TypeUsage> replacement = typeOfScope.parameterByName(typeToReplace.getTypeName());\n            if (replacement.isPresent()) {\n                return replacement.get();\n            } else {\n                return typeToReplace;\n            }\n        } else {\n            for (int i=0;i<typeToReplace.parameters().size();i++){\n                TypeUsage typeUsage = typeToReplace.parameters().get(i);\n                TypeUsage replaced = replaceParams(typeUsage, typeOfScope);\n                if (replaced != typeUsage) {\n                    typeToReplace = typeToReplace.replaceParam(i, replaced);\n                }\n            }\n            return typeToReplace;\n        }\n    }\n\n    public MethodUsage convertToUsage(MethodDeclaration methodDeclaration, Context context) {\n        return new MethodUsage(methodDeclaration, typeSolver);\n    }\n}\n", "diffSourceCodeSet": ["/**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n     * @return\n     */\n    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr = (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter = (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n            TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }"], "invokedMethodSet": ["methodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#getName\n methodBody: public String getName() {\nreturn clazz.getSimpleName();\n}", "methodSignature: me.tomassetti.symbolsolver.model.javassist.JavassistParameterDeclaration#getType\n methodBody: public TypeDeclaration getType(TypeSolver typeSolver) {\nreturn new JavassistClassDeclaration(type);\n}", "methodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#getUsage\n methodBody: public TypeUsage getUsage(Node node) {\nfor(TypeParameter tp: this.getTypeParameters()){throw new UnsupportedOperationException(\"Find parameters of \" + this + \" in \" + node);\n}return new TypeUsageOfTypeDeclaration(this);\n}", "methodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#getField\n methodBody: public FieldDeclaration getField(String name) {\nthrow new UnsupportedOperationException();\n}", "methodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.MethodCallExprContext#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\nif(wrappedNode.getScope() != null){TypeUsage typeOfScope=new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\nreturn typeOfScope.solveMethodAsUsage(name,parameterTypes,typeSolver);\n}{throw new UnsupportedOperationException();\n}}", "methodSignature: me.tomassetti.symbolsolver.JavaParserFacade#solve\n methodBody: public SymbolReference<MethodDeclaration> solve(MethodCallExpr methodCallExpr) {\nList<TypeUsage> params=new LinkedList<>();\nList<LambdaTypeUsagePlaceholder> placeholders=new LinkedList<>();\nint i=0;\nfor(Expression expression: methodCallExpr.getArgs()){if(expression instanceof LambdaExpr){LambdaTypeUsagePlaceholder placeholder=new LambdaTypeUsagePlaceholder(i);\nparams.add(placeholder);\nplaceholders.add(placeholder);\n}{params.add(new JavaParserFacade(typeSolver).getType(expression));\n}i++;\n}SymbolReference<MethodDeclaration> res=JavaParserFactory.getContext(methodCallExpr).solveMethod(methodCallExpr.getName(),params,typeSolver);\nfor(LambdaTypeUsagePlaceholder placeholder: placeholders){placeholder.setMethod(res);\n}return res;\n}", "methodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\nList<MethodDeclaration> methods=new ArrayList<>();\nfor(Method method: clazz.getMethods()){MethodDeclaration methodDeclaration=new ReflectionMethodDeclaration(method);\nmethods.add(methodDeclaration);\n}SymbolReference<MethodDeclaration> ref=MethodResolutionLogic.findMostApplicable(methods,name,parameterTypes,typeSolver);\nif(ref.isSolved()){return Optional.of(new JavaParserFacade(typeSolver).convertToUsage(ref.getCorrespondingDeclaration(),getContext()));\n}{return Optional.empty();\n}}", "methodSignature: me.tomassetti.symbolsolver.model.javassist.JavassistParameterDeclaration#getName\n methodBody: public String getName() {\nthrow new UnsupportedOperationException();\n}", "methodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserFieldDeclaration#getType\n methodBody: public TypeDeclaration getType(TypeSolver typeSolver) {\nreturn new JavaParserFacade(typeSolver).convert(fieldDeclaration.getType(),fieldDeclaration);\n}", "methodSignature: me.tomassetti.symbolsolver.JavaParserFacade#solveMethodAsUsage\n methodBody: public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\nList<TypeUsage> params=new ArrayList<>();\nif(call.getArgs() != null){for(Expression param: call.getArgs()){params.add(getType(param,false));\n}}TypeUsage typeOfScope=getType(call.getScope());\nlogger.finest(\"facade solveMethodAsUsage, params \" + params);\nlogger.finest(\"facade solveMethodAsUsage, scope \" + typeOfScope);\nOptional<MethodUsage> ref=new MethodCallExprContext(call).solveMethodAsUsage(call.getName(),params,typeSolver);\nif(!ref.isPresent()){throw new UnsolvedSymbolException(null,call.getName());\n}{logger.finest(\"facade solveMethodAsUsage, ref \" + ref.get());\nMethodUsage methodUsage=ref.get();\nmethodUsage=replaceParams(methodUsage,typeOfScope);\nTypeUsage returnType=replaceParams(methodUsage.returnType(),typeOfScope);\nmethodUsage=methodUsage.replaceReturnType(returnType);\nreturn methodUsage;\n}}", "methodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration#getParamPos\n methodBody: public static int getParamPos(Node node) {\nif(node.getParentNode() instanceof MethodCallExpr){MethodCallExpr call=(MethodCallExpr)node.getParentNode();\nfor(int i=0; i < call.getArgs().size(); i++){if(call.getArgs().get(i) == node)return i;\n}throw new IllegalStateException();\n}{throw new IllegalArgumentException();\n}}", "methodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration#getType\n methodBody: public TypeDeclaration getType(TypeSolver typeSolver) {\nif(wrappedNode instanceof Parameter){Parameter parameter=(Parameter)wrappedNode;\nif(wrappedNode.getParentNode() instanceof LambdaExpr){int pos=getParamPos(parameter);\nTypeUsage lambdaType=new JavaParserFacade(typeSolver).getType(wrappedNode.getParentNode());\nthrow new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}{return new SymbolSolver(typeSolver).solveType(parameter.getType());\n}}if(wrappedNode instanceof VariableDeclarator){VariableDeclarator variableDeclarator=(VariableDeclarator)wrappedNode;\nif(wrappedNode.getParentNode() instanceof VariableDeclarationExpr){VariableDeclarationExpr variableDeclarationExpr=(VariableDeclarationExpr)variableDeclarator.getParentNode();\nreturn new JavaParserFacade(typeSolver).convert(variableDeclarationExpr.getType(),JavaParserFactory.getContext(wrappedNode));\n}if(wrappedNode.getParentNode() instanceof FieldDeclaration){FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarator.getParentNode();\nreturn new JavaParserFacade(typeSolver).convert(fieldDeclaration.getType(),JavaParserFactory.getContext(wrappedNode));\n}{throw new UnsupportedOperationException(wrappedNode.getParentNode().getClass().getCanonicalName());\n}}{throw new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}}", "methodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.FieldAccessContext#solveSymbolAsValue\n methodBody: public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\nExpression scope=wrappedNode.getScope();\nTypeUsage typeOfScope=new JavaParserFacade(typeSolver).getType(scope);\nreturn typeOfScope.getField(name,typeSolver);\n}", "methodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.MethodCallExprContext#solveSymbolAsValue\n methodBody: public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\nreturn JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbolAsValue(name,typeSolver);\n}", "methodSignature: me.tomassetti.symbolsolver.JavaParserFacade#getType\n methodBody: public TypeUsage getType(Node node, boolean solveLambdas) {\nif(node == null)throw new IllegalArgumentException();\nif(node instanceof NameExpr){NameExpr nameExpr=(NameExpr)node;\nlogger.finest(\"getType on name expr \" + node);\nreturn new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(),nameExpr).get().getUsage();\n}if(node instanceof MethodCallExpr){logger.finest(\"getType on method call \" + node);\nMethodUsage ref=new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr)node);\nlogger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\nlogger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\nreturn ref.returnType();\n}if(node instanceof LambdaExpr){if(node.getParentNode() instanceof MethodCallExpr){MethodCallExpr callExpr=(MethodCallExpr)node.getParentNode();\nint pos=JavaParserSymbolDeclaration.getParamPos(node);\nSymbolReference<MethodDeclaration> refMethod=new JavaParserFacade(typeSolver).solve(callExpr);\nif(!refMethod.isSolved()){throw new UnsolvedSymbolException(null,callExpr.getName());\n}logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\nif(solveLambdas){return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n}{return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n}}{throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n}}if(node instanceof VariableDeclarator){if(node.getParentNode() instanceof FieldDeclaration){FieldDeclaration parent=(FieldDeclaration)node.getParentNode();\nreturn new JavaParserFacade(typeSolver).convertToUsage(parent.getType(),parent);\n}if(node.getParentNode() instanceof VariableDeclarationExpr){VariableDeclarationExpr parent=(VariableDeclarationExpr)node.getParentNode();\nreturn new JavaParserFacade(typeSolver).convertToUsage(parent.getType(),parent);\n}{throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n}}if(node instanceof Parameter){Parameter parameter=(Parameter)node;\nif(parameter.getType() instanceof UnknownType){throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n}return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(),parameter);\n}if(node instanceof FieldAccessExpr){FieldAccessExpr fieldAccessExpr=(FieldAccessExpr)node;\nOptional<Value> value=new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(),fieldAccessExpr);\nif(value.isPresent()){return value.get().getUsage();\n}{throw new UnsolvedSymbolException(null,fieldAccessExpr.getField());\n}}if(node instanceof ObjectCreationExpr){ObjectCreationExpr objectCreationExpr=(ObjectCreationExpr)node;\nTypeUsage typeUsage=new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(),node);\nreturn typeUsage;\n}{throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n}}", "methodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserFieldDeclaration#getName\n methodBody: public String getName() {\nthrow new UnsupportedOperationException();\n}", "methodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.LambdaExprContext#solveSymbolAsValue\n methodBody: public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\nfor(Parameter parameter: wrappedNode.getParameters()){SymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(parameter,typeSolver);\nif(wrappedNode.getParentNode() instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)wrappedNode.getParentNode();\nMethodUsage methodUsage=new JavaParserFacade(typeSolver).solveMethodAsUsage(methodCallExpr);\nint i=pos(methodCallExpr,wrappedNode);\nTypeUsage lambdaType=methodUsage.getParamTypes().get(i);\nValue value=new Value(lambdaType.parameters().get(0),name,false);\nreturn Optional.of(value);\n}{throw new UnsupportedOperationException();\n}}return getParent().solveSymbolAsValue(name,typeSolver);\n}", "methodSignature: me.tomassetti.symbolsolver.JavaParserFacade#convertToUsage\n methodBody: public MethodUsage convertToUsage(MethodDeclaration methodDeclaration, Context context) {\nreturn new MethodUsage(methodDeclaration,typeSolver);\n}", "methodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration#getName\n methodBody: public String getName() {\nreturn name;\n}"], "sourceCodeAfterRefactoring": "public TypeUsage getType(Node node, boolean solveLambdas) {\n        if (solveLambdas){\n            if (!cacheWithLambadsSolved.containsKey(node)){\n                cacheWithLambadsSolved.put(node, getTypeConcrete(node, solveLambdas));\n            }\n            return cacheWithLambadsSolved.get(node);\n        } else {\n            if (!cacheWithoutLambadsSolved.containsKey(node)){\n                cacheWithoutLambadsSolved.put(node, getTypeConcrete(node, solveLambdas));\n            }\n            return cacheWithoutLambadsSolved.get(node);\n        }\n    }\n/**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n     * @return\n     */\n    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr = (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter = (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n            TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }", "diffSourceCode": "-   93:     /**\n-   94:      * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n-   95:      * @return\n-   96:      */\n-   97:     public TypeUsage getType(Node node, boolean solveLambdas) {\n-   98:         if (node == null) throw new IllegalArgumentException();\n-   99:         if (node instanceof NameExpr) {\n-  100:             NameExpr nameExpr = (NameExpr) node;\n-  101:             logger.finest(\"getType on name expr \" + node);\n-  102:             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n-  103:         } else if (node instanceof MethodCallExpr) {\n-  104:             logger.finest(\"getType on method call \" + node);\n-  105:             // first solve the method\n-  106:             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n-  107:             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n-  108:             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n-  109:             return ref.returnType();\n-  110:             // the type is the return type of the method\n-  111:         } else if (node instanceof LambdaExpr) {\n-  112:             if (node.getParentNode() instanceof MethodCallExpr) {\n-  113:                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n-  114:                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n-  115:                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n-  116:                 if (!refMethod.isSolved()) {\n-  117:                     throw new UnsolvedSymbolException(null, callExpr.getName());\n-  118:                 }\n-  119:                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n-  120:                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n-  121:                 if (solveLambdas) {\n-  122:                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n-  123:                 } else {\n-  124:                     return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n-  125:                 }\n-  126:                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n-  127:                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n-  128:                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n-  129:                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n-  130:             } else {\n-  131:                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n-  132:             }\n-  133:         } else if (node instanceof VariableDeclarator) {\n-  134:             if (node.getParentNode() instanceof FieldDeclaration) {\n-  135:                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n-  136:                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n-  137:             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n-  138:                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n-  139:                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n-  140:             } else {\n-  141:                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n-  142:             }\n-  143:         } else if (node instanceof Parameter) {\n-  144:             Parameter parameter = (Parameter)node;\n-  145:             if (parameter.getType() instanceof UnknownType){\n-  146:                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n-  147:             }\n-  148:             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n-  149:         } else if (node instanceof FieldAccessExpr) {\n-  150:             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n-  151:             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n-  152:             if (value.isPresent()) {\n-  153:                 return value.get().getUsage();\n-  154:             } else {\n-  155:                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n-  156:             }\n-  157:         } else if (node instanceof ObjectCreationExpr) {\n-  158:             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n-  159:             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n-  160:             return typeUsage;\n-  161:         } else {\n-  162:             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n-  163:         }\n-  164:     }\n-  165: \n-  166:     public TypeUsage convertToUsage(Type type, Node context) {\n-  167:         if (type instanceof UnknownType){\n-  168:             throw new IllegalArgumentException(\"Unknown type\");\n-  169:         }\n-  170:         return convertToUsage(type, JavaParserFactory.getContext(context));\n-  171:     }\n-  172: \n-  173:     public TypeUsage convertToUsage(Type type, Context context) {\n-  174:         if (type instanceof ReferenceType) {\n-  175:             ReferenceType referenceType = (ReferenceType) type;\n-  176:             // TODO consider array modifiers\n-  177:             return convertToUsage(referenceType.getType(), context);\n-  178:         } else if (type instanceof ClassOrInterfaceType) {\n-  179:             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType)type;\n-  180:             SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n-  181:             if (!ref.isSolved()) {\n-  182:                 throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n+   93:         }\n+   94:         return res;\n+   95:     }\n+   96: \n+   97:     public TypeUsage getType(Node node) {\n+   98:         return getType(node, true);\n+   99:     }\n+  100: \n+  101:     private Map<Node, TypeUsage> cacheWithLambadsSolved = new WeakHashMap<>();\n+  102:     private Map<Node, TypeUsage> cacheWithoutLambadsSolved = new WeakHashMap<>();\n+  103: \n+  104:     private static Map<TypeSolver, JavaParserFacade> instances = new HashMap<>();\n+  105: \n+  106:     public TypeUsage getType(Node node, boolean solveLambdas) {\n+  107:         if (solveLambdas){\n+  108:             if (!cacheWithLambadsSolved.containsKey(node)){\n+  109:                 cacheWithLambadsSolved.put(node, getTypeConcrete(node, solveLambdas));\n+  110:             }\n+  111:             return cacheWithLambadsSolved.get(node);\n+  112:         } else {\n+  113:             if (!cacheWithoutLambadsSolved.containsKey(node)){\n+  114:                 cacheWithoutLambadsSolved.put(node, getTypeConcrete(node, solveLambdas));\n+  115:             }\n+  116:             return cacheWithoutLambadsSolved.get(node);\n+  117:         }\n+  118:     }\n+  119: \n+  120:     /**\n+  121:      * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n+  122:      * @return\n+  123:      */\n+  124:     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n+  125:         if (node == null) throw new IllegalArgumentException();\n+  126:         if (node instanceof NameExpr) {\n+  127:             NameExpr nameExpr = (NameExpr) node;\n+  128:             logger.finest(\"getType on name expr \" + node);\n+  129:             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n+  130:         } else if (node instanceof MethodCallExpr) {\n+  131:             logger.finest(\"getType on method call \" + node);\n+  132:             // first solve the method\n+  133:             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n+  134:             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n+  135:             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n+  136:             return ref.returnType();\n+  137:             // the type is the return type of the method\n+  138:         } else if (node instanceof LambdaExpr) {\n+  139:             if (node.getParentNode() instanceof MethodCallExpr) {\n+  140:                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n+  141:                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n+  142:                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n+  143:                 if (!refMethod.isSolved()) {\n+  144:                     throw new UnsolvedSymbolException(null, callExpr.getName());\n+  145:                 }\n+  146:                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n+  147:                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n+  148:                 if (solveLambdas) {\n+  149:                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+  150:                 } else {\n+  151:                     return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n+  152:                 }\n+  153:                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n+  154:                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n+  155:                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n+  156:                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+  157:             } else {\n+  158:                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+  159:             }\n+  160:         } else if (node instanceof VariableDeclarator) {\n+  161:             if (node.getParentNode() instanceof FieldDeclaration) {\n+  162:                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n+  163:                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+  164:             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n+  165:                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n+  166:                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+  167:             } else {\n+  168:                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n+  169:             }\n+  170:         } else if (node instanceof Parameter) {\n+  171:             Parameter parameter = (Parameter)node;\n+  172:             if (parameter.getType() instanceof UnknownType){\n+  173:                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n+  174:             }\n+  175:             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n+  176:         } else if (node instanceof FieldAccessExpr) {\n+  177:             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n+  178:             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+  179:             if (value.isPresent()) {\n+  180:                 return value.get().getUsage();\n+  181:             } else {\n+  182:                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n   183:             }\n-  184:             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n-  185:             List<TypeUsage> typeParameters = Collections.emptyList();\n-  186:             if (classOrInterfaceType.getTypeArgs() != null) {\n-  187:                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt)->convertToUsage(pt, context)).collect(Collectors.toList());\n-  188:             }\n-  189:             return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n-  190:         } else {\n-  191:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n+  184:         } else if (node instanceof ObjectCreationExpr) {\n+  185:             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n+  186:             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n+  187:             return typeUsage;\n+  188:         } else {\n+  189:             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n+  190:         }\n+  191:     }\n", "uniqueId": "627b56302d259409e9bc50b20d77803484f18b5c_93_164_120_191_106_118", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 61, "covered": 238}, "BRANCH": {"missed": 8, "covered": 22}, "LINE": {"missed": 7, "covered": 40}, "COMPLEXITY": {"missed": 8, "covered": 8}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `getType` method, we can extract several smaller methods that handle specific cases of the `Node` type. This will make the main method cleaner and easier to understand. \n\nHere\u2019s the refactored code with the extracted methods:\n\n```java\n##########################\npublic TypeUsage getType(Node node, boolean solveLambdas) {\n    if (node == null) throw new IllegalArgumentException();\n    \n    if (node instanceof NameExpr) {\n        return handleNameExpr((NameExpr) node);\n    } else if (node instanceof MethodCallExpr) {\n        return handleMethodCallExpr((MethodCallExpr) node);\n    } else if (node instanceof LambdaExpr) {\n        return handleLambdaExpr((LambdaExpr) node, solveLambdas);\n    } else if (node instanceof VariableDeclarator) {\n        return handleVariableDeclarator((VariableDeclarator) node);\n    } else if (node instanceof Parameter) {\n        return handleParameter((Parameter) node);\n    } else if (node instanceof FieldAccessExpr) {\n        return handleFieldAccessExpr((FieldAccessExpr) node);\n    } else if (node instanceof ObjectCreationExpr) {\n        return handleObjectCreationExpr((ObjectCreationExpr) node);\n    } else {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n}\n\nprivate TypeUsage handleNameExpr(NameExpr nameExpr) {\n    logger.finest(\"getType on name expr \" + nameExpr);\n    return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n}\n\nprivate TypeUsage handleMethodCallExpr(MethodCallExpr methodCallExpr) {\n    logger.finest(\"getType on method call \" + methodCallExpr);\n    MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage(methodCallExpr);\n    logger.finest(\"getType on method call \" + methodCallExpr + \" resolved to \" + ref);\n    logger.finest(\"getType on method call \" + methodCallExpr + \" return type is \" + ref.returnType());\n    return ref.returnType();\n}\n\nprivate TypeUsage handleLambdaExpr(LambdaExpr lambdaExpr, boolean solveLambdas) {\n    if (lambdaExpr.getParentNode() instanceof MethodCallExpr) {\n        MethodCallExpr callExpr = (MethodCallExpr) lambdaExpr.getParentNode();\n        int pos = JavaParserSymbolDeclaration.getParamPos(lambdaExpr);\n        SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n        if (!refMethod.isSolved()) {\n            throw new UnsolvedSymbolException(null, callExpr.getName());\n        }\n        logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n        if (solveLambdas) {\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(lambdaExpr);\n        } else {\n            return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n        }\n    } else {\n        throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n    }\n}\n\nprivate TypeUsage handleVariableDeclarator(VariableDeclarator variableDeclarator) {\n    if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n        FieldDeclaration parent = (FieldDeclaration) variableDeclarator.getParentNode();\n        return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n    } else if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n        VariableDeclarationExpr parent = (VariableDeclarationExpr) variableDeclarator.getParentNode();\n        return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n    } else {\n        throw new UnsupportedOperationException(variableDeclarator.getParentNode().getClass().getCanonicalName());\n    }\n}\n\nprivate TypeUsage handleParameter(Parameter parameter) {\n    if (parameter.getType() instanceof UnknownType) {\n        throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n    }\n    return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n}\n\nprivate TypeUsage handleFieldAccessExpr(FieldAccessExpr fieldAccessExpr) {\n    Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n    if (value.isPresent()) {\n        return value.get().getUsage();\n    } else {\n        throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n    }\n}\n\nprivate TypeUsage handleObjectCreationExpr(ObjectCreationExpr objectCreationExpr) {\n    return new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), objectCreationExpr);\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Methods**: Each case of the `Node` type is handled in its own method (`handleNameExpr`, `handleMethodCallExpr`, `handleLambdaExpr`, etc.). This reduces the complexity of the `getType` method and makes it easier to read.\n2. **Logging**: The logging statements are preserved in the respective methods to maintain the original functionality.\n3. **Error Handling**: The error handling remains the same, ensuring that the behavior of the code is unchanged while improving its structure.\n\nThis refactoring enhances the modularity of the code, making it easier to maintain and extend in the future.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n     * @return\n     */\n    public TypeUsage getType(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr = (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter = (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n            TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\nClass content:\npackage me.tomassetti.symbolsolver;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.ReferenceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnknownType;\nimport jdk.nashorn.internal.ir.Symbol;\nimport me.tomassetti.symbolsolver.model.*;\nimport me.tomassetti.symbolsolver.model.declarations.MethodDeclaration;\nimport me.tomassetti.symbolsolver.model.declarations.ValueDeclaration;\nimport me.tomassetti.symbolsolver.model.declarations.TypeDeclaration;\nimport me.tomassetti.symbolsolver.model.usages.MethodUsage;\nimport me.tomassetti.symbolsolver.model.usages.TypeUsageOfTypeDeclaration;\nimport me.tomassetti.symbolsolver.model.javaparser.JavaParserFactory;\nimport me.tomassetti.symbolsolver.model.javaparser.UnsolvedSymbolException;\nimport me.tomassetti.symbolsolver.model.javaparser.contexts.MethodCallExprContext;\nimport me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration;\nimport me.tomassetti.symbolsolver.model.usages.TypeUsage;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.logging.ConsoleHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n */\npublic class JavaParserFacade {\n\n    private TypeSolver typeSolver;\n    private SymbolSolver symbolSolver;\n\n    private static Logger logger = Logger.getLogger(JavaParserFacade.class.getCanonicalName());\n    static {\n        logger.setLevel(Level.FINEST);\n        ConsoleHandler consoleHandler = new ConsoleHandler();\n        consoleHandler.setLevel(Level.FINEST);\n        logger.addHandler(consoleHandler);\n    }\n\n    public JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver;\n        this.symbolSolver = new SymbolSolver(typeSolver);\n    }\n\n    public SymbolReference solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName(), nameExpr);\n    }\n\n    public SymbolReference solve(Expression expr) {\n        if (expr instanceof NameExpr) {\n            return solve((NameExpr)expr);\n        } else {\n            throw new IllegalArgumentException(expr.getClass().getCanonicalName());\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<MethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        List<TypeUsage> params = new LinkedList<>();\n        List<LambdaTypeUsagePlaceholder> placeholders = new LinkedList<>();\n        int i = 0;\n        for (Expression expression : methodCallExpr.getArgs()) {\n            if (expression instanceof LambdaExpr) {\n                LambdaTypeUsagePlaceholder placeholder = new LambdaTypeUsagePlaceholder(i);\n                params.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                params.add(new JavaParserFacade(typeSolver).getType(expression));\n            }\n            i++;\n        }\n        SymbolReference<MethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr).solveMethod(methodCallExpr.getName(), params, typeSolver);\n        for (LambdaTypeUsagePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    public TypeUsage getType(Node node) {\n        return getType(node, true);\n    }\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n     * @return\n     */\n    public TypeUsage getType(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr = (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter = (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n            TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    public TypeUsage convertToUsage(Type type, Node context) {\n        if (type instanceof UnknownType){\n            throw new IllegalArgumentException(\"Unknown type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context));\n    }\n\n    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType = (ReferenceType) type;\n            // TODO consider array modifiers\n            return convertToUsage(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType)type;\n            SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n            }\n            TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n            List<TypeUsage> typeParameters = Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() != null) {\n                typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt)->convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    private SymbolReference<MethodDeclaration> solveMethod(MethodCallExpr methodCallExpr) {\n        List<TypeUsage> params = new ArrayList<>();\n        if (methodCallExpr.getArgs() != null) {\n            for (Expression param : methodCallExpr.getArgs()) {\n                params.add(getType(param));\n            }\n        }\n        return new MethodCallExprContext(methodCallExpr).solveMethod(methodCallExpr.getName(), params, typeSolver);\n    }\n\n    public TypeDeclaration convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node));\n    }\n\n    public TypeDeclaration convert(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType = (ReferenceType) type;\n            // TODO consider array modifiers\n            return convert(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType)type;\n            SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n            }\n            return ref.getCorrespondingDeclaration();\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<TypeUsage> params = new ArrayList<>();\n        if (call.getArgs() != null) {\n            for (Expression param : call.getArgs()) {\n                params.add(getType(param, false));\n            }\n        }\n        TypeUsage typeOfScope = getType(call.getScope());\n        logger.finest(\"facade solveMethodAsUsage, params \" + params);\n        logger.finest(\"facade solveMethodAsUsage, scope \" + typeOfScope);\n\n        // TODO take params from scope and substitute them in ref\n\n        Optional<MethodUsage> ref = new MethodCallExprContext(call).solveMethodAsUsage(call.getName(), params, typeSolver);\n\n        if (!ref.isPresent()){\n            throw new UnsolvedSymbolException(null, call.getName());\n        } else {\n            logger.finest(\"facade solveMethodAsUsage, ref \" + ref.get());\n            MethodUsage methodUsage = ref.get();\n            methodUsage = replaceParams(methodUsage, typeOfScope);\n            TypeUsage returnType = replaceParams(methodUsage.returnType(), typeOfScope);\n            methodUsage = methodUsage.replaceReturnType(returnType);\n            return methodUsage;\n        }\n    }\n\n    private MethodUsage replaceParams(MethodUsage methodUsage, TypeUsage typeOfScope) {\n        logger.finest(\"ReplaceParams \" + methodUsage);\n        logger.finest(\"ReplaceParams N params \" + methodUsage.getParamTypes().size());\n        for (int i=0;i<methodUsage.getParamTypes().size();i++) {\n            TypeUsage typeUsage = methodUsage.getParamTypes().get(i);\n            TypeUsage replaced = replaceParams(typeUsage, typeOfScope);\n            logger.finest(\"ReplaceParams param type \" + typeUsage);\n            if (replaced != typeUsage) {\n                logger.finest(\"ReplaceParams param -> \" + replaced);\n                methodUsage = methodUsage.replaceParamType(i, replaced);\n            }\n\n        }\n        logger.finest(\"Final method usage \"+methodUsage);\n        return methodUsage;\n    }\n\n    private TypeUsage replaceParams(TypeUsage typeToReplace, TypeUsage typeOfScope) {\n        if (typeToReplace.isTypeVariable()) {\n            Optional<TypeUsage> replacement = typeOfScope.parameterByName(typeToReplace.getTypeName());\n            if (replacement.isPresent()) {\n                return replacement.get();\n            } else {\n                return typeToReplace;\n            }\n        } else {\n            for (int i=0;i<typeToReplace.parameters().size();i++){\n                TypeUsage typeUsage = typeToReplace.parameters().get(i);\n                TypeUsage replaced = replaceParams(typeUsage, typeOfScope);\n                if (replaced != typeUsage) {\n                    typeToReplace = typeToReplace.replaceParam(i, replaced);\n                }\n            }\n            return typeToReplace;\n        }\n    }\n\n    public MethodUsage convertToUsage(MethodDeclaration methodDeclaration, Context context) {\n        return new MethodUsage(methodDeclaration, typeSolver);\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpackage basicGrammarCompiles_languageLevelValidation_permitted(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest to package basicGrammarCompiles_languageLevelValidation_permitted(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest.LanguageLevels", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 34, "endLine": 39, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 37, "endLine": 42, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "9e55bc54539d393e1948c8d4a89b1511ed379fad", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammarCompiles_languageLevelValidation_permitted", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammarCompiles_languageLevelValidation_permitted"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @Nested\n    class LanguageLevels {\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_forbidNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticFields2() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinalWithoutExplicit() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }", "diffSourceCode": "-   34:     @ParameterizedTest\n-   35:     @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n-   36:     void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n-   37:         String s = \"record Point(int x, int y) { }\";\n-   38:         CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n-   39:     }\n-   40: \n-   41:     @ParameterizedTest\n-   42:     @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n+   34:             });\n+   35:         }\n+   36: \n+   37:         @ParameterizedTest\n+   38:         @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n+   39:         void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n+   40:             String s = \"record Point(int x, int y) { }\";\n+   41:             CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n+   42:         }\n", "uniqueId": "9e55bc54539d393e1948c8d4a89b1511ed379fad_34_39__37_42", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": true, "refactoredCode": "To perform the requested refactoring operation, we will move the method `basicGrammarCompiles_languageLevelValidation_permitted` from the `RecordDeclarationTest` class to an existing utility class. Given the context of the project structure, it seems appropriate to move this method to the `TestParser` class, which is likely to contain utility methods for parsing and testing.\n\n### Step 1: Identify the target file path\nThe target file path for the existing class where the method will be moved is:\n```\njavaparser-core-testing/src/test/java/com/github/javaparser/utils/TestParser.java\n```\n\n### Step 2: Moved class code\nWe will add the method as a public static method in the `TestParser` class. The moved method code will look like this:\n\n```java\npublic static CompilationUnit parseRecordPoint(ParserConfiguration.LanguageLevel languageLevel) {\n    String s = \"record Point(int x, int y) { }\";\n    return parseCompilationUnit(languageLevel, s);\n}\n```\n\n### Step 3: Refactored method code\nThe refactored method in the `RecordDeclarationTest` class will call the moved method from `TestParser`. The updated method will look like this:\n\n```java\n@ParameterizedTest\n@EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\nvoid basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n    CompilationUnit cu = TestParser.parseRecordPoint(languageLevel);\n}\n```\n\n### Final Output\nNow, we will format the output as requested:\n\n##########################\njavaparser-core-testing/src/test/java/com/github/javaparser/utils/TestParser.java\n##########################\npublic class TestParser {\n    // Existing methods...\n\n    public static CompilationUnit parseRecordPoint(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        return parseCompilationUnit(languageLevel, s);\n    }\n}\n##########################\n@ParameterizedTest\n@EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\nvoid basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n    CompilationUnit cu = TestParser.parseRecordPoint(languageLevel);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['javaparser-core-testing/src/test/java/com/github/javaparser/CommentsInserterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/GeneratedJavaParserTokenManagerTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/Issue1017Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/Issue2482Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/JavaParserTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/JavaTokenTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/JavadocParserTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/LineSeparatorProcessorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ParseErrorRecoveryTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ParserConfigurationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/PositionMappingTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ProblemTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ProvidersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/RangeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/TokenRangeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/TokenTypesTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/AncestorDescendantTests.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/CompilationUnitTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/DataKeyTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/FindNodeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ListObservationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/NodeListTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/NodePositionTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/NodeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ObservationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ParseResultTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ReplaceNodeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/WalkFindTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/AnnotationDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/AnnotationMemberDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/ClassOrInterfaceDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/ConstructorDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/FieldDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/MethodDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/TypeDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/comments/CommentTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/AssignExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/BinaryExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/CharLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/DoubleLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/InstanceOfExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/LambdaExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/LiteralStringValueExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/MethodCallExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/MethodReferenceExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/NameTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/ObjectCreationExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/SimpleNameTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/StringLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/SuperExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/SwitchExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/TextBlockLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/ThisExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/imports/ImportDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithBodyTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithJavadocTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithModifiersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithOptionalScopeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithTraversableScopeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithVariablesTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/observer/PropagatingAstObserverTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/BreakStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/ForEachStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/IfElseStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/SwitchStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/TryStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/YieldStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/ArrayTypeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/ClassOrInterfaceTypeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/TypeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java10ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java11ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java12ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java13ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java14PreviewValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java14ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java15PreviewValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java15ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java16PreviewValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java16ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_0ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_1ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_3ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_4ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java5ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java6ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java7ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java8ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java9ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/CloneVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/GenericVisitorWithDefaultsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/HashCodeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/ModifierVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/NoCommentEqualsVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/NoCommentHashCodeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/ObjectIdentityHashCodeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/TreeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/VoidVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/VoidVisitorWithDefaultsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/ClassOrInterfaceDeclarationBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/CompilationUnitBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/EnumDeclarationBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/FieldDeclarationBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithAnnotationsBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithMembersBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithParametersBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithThrownExceptionsBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/issues/Issue2627Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/javadoc/JavadocExtractorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/javadoc/JavadocTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/javadoc/description/JavadocInlineTagTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/manual/BulkParseTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/metamodel/BaseNodeMetaModelTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/metamodel/PropertyMetaModelTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/modules/ModuleDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelAcceptanceTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/DefaultPrettyPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/DotPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/JsonPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/PrettyPrintVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/PrettyPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/PrinterConfigurationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/TestVisitor.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/XmlPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/YamlPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/AbstractLexicalPreservingTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/AnnotationSpaceTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/DifferenceElementCalculatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1467Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1634Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1766Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1793Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2290Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2374Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2393Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2592Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2610Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2620Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2806Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/PrettyPrinterIssue2340Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/PrettyPrinterIssue2351Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/TransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/ArrayCreationLevelTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/CompilationUnitTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationMemberDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ClassOrInterfaceDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ConstructorDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumConstantDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/FieldDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/InitializerDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/MethodDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/OperatorTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/StatementTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/remove/NodeRemovalTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/CodeGenerationUtilsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/LineSeparatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/LogTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/PairTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/ParserCollectionStrategyTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/PositionUtilsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/SourceRootTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/SourceZipTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestParser.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/UtilsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/VisitorListTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/VisitorMapTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/VisitorSetTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/version/Java10PostProcessorTest.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/TestFileIso88591.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/DefaultStrategy.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_cr.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_crlf.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_lf.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_minimal.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/range/A.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/range/B.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/A.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/B.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/PrimaryType.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/PrimaryType2.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/Z.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/.abc/bla.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/Bla.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/module-info.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info/demo/Main.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info/demo/module-info.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info_in_root/demo/Main.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info_in_root/module-info.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/without_module_info/demo/Main.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/source.root/Y.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/wiki_samples/TestFile.java', 'javaparser-core-testing/src/test/test_sourcecode/com/github/javaparser/printer/JavaConcepts.java', 'javaparser-core-testing/src/test/test_sourcecode/com/github/javaparser/printer/PrettyPrintVisitor.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpackage basicGrammarCompiles_languageLevelValidation_forbidden(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest to package basicGrammarCompiles_languageLevelValidation_forbidden(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest.LanguageLevels", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 25, "endLine": 32, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 28, "endLine": 35, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "9e55bc54539d393e1948c8d4a89b1511ed379fad", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammarCompiles_languageLevelValidation_forbidden", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammarCompiles_languageLevelValidation_forbidden"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @Nested\n    class LanguageLevels {\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_forbidNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticFields2() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinalWithoutExplicit() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }", "diffSourceCode": "-   25:     @ParameterizedTest\n-   26:     @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n-   27:     void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n-   28:         String s = \"record Point(int x, int y) { }\";\n-   29:         assertThrows(AssertionFailedError.class, () -> {\n-   30:             CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n-   31:         });\n-   32:     }\n-   33: \n-   34:     @ParameterizedTest\n-   35:     @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n+   25: \n+   26:     @Nested\n+   27:     class LanguageLevels {\n+   28:         @ParameterizedTest\n+   29:         @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n+   30:         void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n+   31:             String s = \"record Point(int x, int y) { }\";\n+   32:             assertThrows(AssertionFailedError.class, () -> {\n+   33:                 CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n+   34:             });\n+   35:         }\n", "uniqueId": "9e55bc54539d393e1948c8d4a89b1511ed379fad_25_32__28_35", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": true, "refactoredCode": "To refactor the provided code by moving the method `basicGrammarCompiles_languageLevelValidation_forbidden` to an existing Java file, we will follow these steps:\n\n1. Identify a suitable existing class to move the method to. Given the context of the method, it seems appropriate to move it to the `TestParser` class, which is already used in the method for parsing the compilation unit.\n\n2. Update the method to be a public static method in the `TestParser` class.\n\n3. Refactor the original test method to call the new static method from `TestParser`.\n\n### Step 1: Identify Target File\nThe target file for moving the method is:\n```\njavaparser-core-testing/src/test/java/com/github/javaparser/utils/TestParser.java\n```\n\n### Step 2: Moved Class Code\nWe will add the following method to the `TestParser` class:\n```java\npublic static void assertBasicGrammarCompilesForbidden(ParserConfiguration.LanguageLevel languageLevel) {\n    String s = \"record Point(int x, int y) { }\";\n    assertThrows(AssertionFailedError.class, () -> {\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    });\n}\n```\n\n### Step 3: Refactored Method Code\nThe refactored method in the `RecordDeclarationTest` class will look like this:\n```java\n@ParameterizedTest\n@EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\nvoid basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n    TestParser.assertBasicGrammarCompilesForbidden(languageLevel);\n}\n```\n\n### Final Output\nNow, we can present the output in the required format:\n\n##########################\njavaparser-core-testing/src/test/java/com/github/javaparser/utils/TestParser.java\n##########################\npublic static void assertBasicGrammarCompilesForbidden(ParserConfiguration.LanguageLevel languageLevel) {\n    String s = \"record Point(int x, int y) { }\";\n    assertThrows(AssertionFailedError.class, () -> {\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    });\n}\n##########################\n@ParameterizedTest\n@EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\nvoid basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n    TestParser.assertBasicGrammarCompilesForbidden(languageLevel);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['javaparser-core-testing/src/test/java/com/github/javaparser/CommentsInserterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/GeneratedJavaParserTokenManagerTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/Issue1017Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/Issue2482Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/JavaParserTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/JavaTokenTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/JavadocParserTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/LineSeparatorProcessorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ParseErrorRecoveryTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ParserConfigurationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/PositionMappingTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ProblemTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ProvidersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/RangeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/TokenRangeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/TokenTypesTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/AncestorDescendantTests.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/CompilationUnitTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/DataKeyTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/FindNodeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ListObservationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/NodeListTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/NodePositionTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/NodeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ObservationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ParseResultTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ReplaceNodeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/WalkFindTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/AnnotationDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/AnnotationMemberDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/ClassOrInterfaceDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/ConstructorDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/FieldDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/MethodDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/TypeDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/comments/CommentTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/AssignExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/BinaryExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/CharLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/DoubleLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/InstanceOfExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/LambdaExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/LiteralStringValueExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/MethodCallExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/MethodReferenceExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/NameTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/ObjectCreationExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/SimpleNameTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/StringLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/SuperExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/SwitchExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/TextBlockLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/ThisExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/imports/ImportDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithBodyTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithJavadocTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithModifiersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithOptionalScopeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithTraversableScopeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithVariablesTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/observer/PropagatingAstObserverTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/BreakStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/ForEachStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/IfElseStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/SwitchStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/TryStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/YieldStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/ArrayTypeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/ClassOrInterfaceTypeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/TypeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java10ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java11ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java12ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java13ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java14PreviewValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java14ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java15PreviewValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java15ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java16PreviewValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java16ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_0ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_1ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_3ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_4ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java5ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java6ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java7ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java8ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java9ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/CloneVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/GenericVisitorWithDefaultsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/HashCodeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/ModifierVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/NoCommentEqualsVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/NoCommentHashCodeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/ObjectIdentityHashCodeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/TreeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/VoidVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/VoidVisitorWithDefaultsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/ClassOrInterfaceDeclarationBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/CompilationUnitBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/EnumDeclarationBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/FieldDeclarationBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithAnnotationsBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithMembersBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithParametersBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithThrownExceptionsBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/issues/Issue2627Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/javadoc/JavadocExtractorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/javadoc/JavadocTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/javadoc/description/JavadocInlineTagTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/manual/BulkParseTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/metamodel/BaseNodeMetaModelTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/metamodel/PropertyMetaModelTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/modules/ModuleDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelAcceptanceTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/DefaultPrettyPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/DotPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/JsonPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/PrettyPrintVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/PrettyPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/PrinterConfigurationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/TestVisitor.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/XmlPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/YamlPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/AbstractLexicalPreservingTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/AnnotationSpaceTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/DifferenceElementCalculatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1467Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1634Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1766Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1793Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2290Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2374Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2393Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2592Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2610Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2620Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2806Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/PrettyPrinterIssue2340Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/PrettyPrinterIssue2351Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/TransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/ArrayCreationLevelTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/CompilationUnitTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationMemberDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ClassOrInterfaceDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ConstructorDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumConstantDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/FieldDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/InitializerDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/MethodDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/OperatorTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/StatementTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/remove/NodeRemovalTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/CodeGenerationUtilsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/LineSeparatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/LogTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/PairTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/ParserCollectionStrategyTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/PositionUtilsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/SourceRootTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/SourceZipTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestParser.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/UtilsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/VisitorListTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/VisitorMapTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/VisitorSetTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/version/Java10PostProcessorTest.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/TestFileIso88591.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/DefaultStrategy.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_cr.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_crlf.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_lf.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_minimal.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/range/A.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/range/B.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/A.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/B.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/PrimaryType.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/PrimaryType2.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/Z.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/.abc/bla.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/Bla.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/module-info.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info/demo/Main.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info/demo/module-info.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info_in_root/demo/Main.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info_in_root/module-info.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/without_module_info/demo/Main.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/source.root/Y.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/wiki_samples/TestFile.java', 'javaparser-core-testing/src/test/test_sourcecode/com/github/javaparser/printer/JavaConcepts.java', 'javaparser-core-testing/src/test/test_sourcecode/com/github/javaparser/printer/PrettyPrintVisitor.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprotected convertToUsage(unionType UnionType, context Context) : ResolvedType extracted from protected convertToUsage(type Type, context Context) : ResolvedType in class com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade", "diffLocations": [{"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "startLine": 677, "endLine": 706, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "startLine": 677, "endLine": 705, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "startLine": 746, "endLine": 751, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            return convertToUsage((ArrayType) type, context);\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }", "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "isPureRefactoring": true, "commitId": "e3ae340534ecf7406a548723488059b947a9f298", "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel", "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade", "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage", "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\nreturn new ResolvedArrayType(convertToUsage(arrayType.getComponentType(),context));\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}", "classSignatureBefore": "public class JavaParserFacade ", "methodNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage"], "classNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade"], "classSignatureBeforeSet": ["public class JavaParserFacade "], "purityCheckResultList": [{"isPure": true, "purityComment": " Severe changes", "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves", "mappingState": 2}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            return convertToUsage((ArrayType) type, context);\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\n        return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n", "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            return convertToUsage((ArrayType) type, context);\n        } else if (type instanceof UnionType) {\n            return convertToUsage((UnionType) type, context);\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\n        return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n    }\n\n    protected ResolvedType convertToUsage(UnionType unionType, Context context) {\n        List<ResolvedType> resolvedElements = unionType.getElements().stream()\n                .map(el -> convertToUsage(el, context))\n                .collect(Collectors.toList());\n        return new ResolvedUnionType(resolvedElements);\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n", "diffSourceCodeSet": ["protected ResolvedType convertToUsage(UnionType unionType, Context context) {\n        List<ResolvedType> resolvedElements = unionType.getElements().stream()\n                .map(el -> convertToUsage(el, context))\n                .collect(Collectors.toList());\n        return new ResolvedUnionType(resolvedElements);\n    }"], "invokedMethodSet": ["methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\nreturn new ResolvedArrayType(convertToUsage(arrayType.getComponentType(),context));\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}"], "sourceCodeAfterRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            return convertToUsage((ArrayType) type, context);\n        } else if (type instanceof UnionType) {\n            return convertToUsage((UnionType) type, context);\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\nprotected ResolvedType convertToUsage(UnionType unionType, Context context) {\n        List<ResolvedType> resolvedElements = unionType.getElements().stream()\n                .map(el -> convertToUsage(el, context))\n                .collect(Collectors.toList());\n        return new ResolvedUnionType(resolvedElements);\n    }", "diffSourceCode": "   677:     protected ResolvedType convertToUsage(Type type, Context context) {\n   678:         if (context == null) {\n   679:             throw new NullPointerException(\"Context should not be null\");\n   680:         }\n   681:         if (type instanceof ClassOrInterfaceType) {\n   682:             return convertToUsage((ClassOrInterfaceType) type, context);\n   683:         } else if (type instanceof PrimitiveType) {\n   684:             return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n   685:         } else if (type instanceof WildcardType) {\n   686:             return convertToUsage((WildcardType) type, context);\n   687:         } else if (type instanceof VoidType) {\n   688:             return ResolvedVoidType.INSTANCE;\n   689:         } else if (type instanceof ArrayType) {\n   690:             return convertToUsage((ArrayType) type, context);\n   691:         } else if (type instanceof UnionType) {\n-  692:             UnionType unionType = (UnionType) type;\n-  693:             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n-  694:         } else if (type instanceof VarType) {\n-  695:             Node parent = type.getParentNode().get();\n-  696:             if (!(parent instanceof VariableDeclarator)) {\n-  697:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n-  698:             }\n-  699:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n-  700:             return variableDeclarator.getInitializer()\n-  701:                     .map(Expression::calculateResolvedType)\n-  702:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n-  703:         } else {\n-  704:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n-  705:         }\n-  706:     }\n-  746: \n-  747:     public ResolvedType convert(Type type, Node node) {\n-  748:         return convert(type, JavaParserFactory.getContext(node, typeSolver));\n-  749:     }\n-  750: \n-  751:     public ResolvedType convert(Type type, Context context) {\n+  692:             return convertToUsage((UnionType) type, context);\n+  693:         } else if (type instanceof VarType) {\n+  694:             Node parent = type.getParentNode().get();\n+  695:             if (!(parent instanceof VariableDeclarator)) {\n+  696:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n+  697:             }\n+  698:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n+  699:             return variableDeclarator.getInitializer()\n+  700:                     .map(Expression::calculateResolvedType)\n+  701:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n+  702:         } else {\n+  703:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n+  704:         }\n+  705:     }\n+  706: \n+  746:     protected ResolvedType convertToUsage(UnionType unionType, Context context) {\n+  747:         List<ResolvedType> resolvedElements = unionType.getElements().stream()\n+  748:                 .map(el -> convertToUsage(el, context))\n+  749:                 .collect(Collectors.toList());\n+  750:         return new ResolvedUnionType(resolvedElements);\n+  751:     }\n", "uniqueId": "e3ae340534ecf7406a548723488059b947a9f298_677_706_746_751_677_705", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 9}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `convertToUsage` method, we can extract the logic for handling different `Type` instances into separate methods. This will make the main method cleaner and easier to understand. \n\nHere\u2019s the refactored code with the extracted methods:\n\n```java\nprotected ResolvedType convertToUsage(Type type, Context context) {\n    if (context == null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    \n    if (type instanceof ClassOrInterfaceType) {\n        return convertClassOrInterfaceType((ClassOrInterfaceType) type, context);\n    } else if (type instanceof PrimitiveType) {\n        return convertPrimitiveType((PrimitiveType) type);\n    } else if (type instanceof WildcardType) {\n        return convertWildcardType((WildcardType) type, context);\n    } else if (type instanceof VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof ArrayType) {\n        return convertArrayType((ArrayType) type, context);\n    } else if (type instanceof UnionType) {\n        return convertUnionType((UnionType) type, context);\n    } else if (type instanceof VarType) {\n        return convertVarType((VarType) type);\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}\n\nprivate ResolvedType convertClassOrInterfaceType(ClassOrInterfaceType classOrInterfaceType, Context context) {\n    return convertToUsage(classOrInterfaceType, context);\n}\n\nprivate ResolvedType convertPrimitiveType(PrimitiveType primitiveType) {\n    return ResolvedPrimitiveType.byName(primitiveType.getType().name());\n}\n\nprivate ResolvedType convertWildcardType(WildcardType wildcardType, Context context) {\n    return convertToUsage(wildcardType, context);\n}\n\nprivate ResolvedType convertArrayType(ArrayType arrayType, Context context) {\n    return convertToUsage(arrayType, context);\n}\n\nprivate ResolvedType convertUnionType(UnionType unionType, Context context) {\n    return new ResolvedUnionType(unionType.getElements().stream()\n            .map(el -> convertToUsage(el, context))\n            .collect(Collectors.toList()));\n}\n\nprivate ResolvedType convertVarType(VarType varType) {\n    Node parent = varType.getParentNode().get();\n    if (!(parent instanceof VariableDeclarator)) {\n        throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n    }\n    final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n    return variableDeclarator.getInitializer()\n            .map(Expression::calculateResolvedType)\n            .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n}\n```\n\nThis refactoring extracts the handling of each specific type into its own method, which improves the overall structure of the `convertToUsage` method and makes it easier to read and maintain. \n\nHere\u2019s the output in the requested format:\n\n##########################\n```java\nprotected ResolvedType convertToUsage(Type type, Context context) {\n    if (context == null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    \n    if (type instanceof ClassOrInterfaceType) {\n        return convertClassOrInterfaceType((ClassOrInterfaceType) type, context);\n    } else if (type instanceof PrimitiveType) {\n        return convertPrimitiveType((PrimitiveType) type);\n    } else if (type instanceof WildcardType) {\n        return convertWildcardType((WildcardType) type, context);\n    } else if (type instanceof VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof ArrayType) {\n        return convertArrayType((ArrayType) type, context);\n    } else if (type instanceof UnionType) {\n        return convertUnionType((UnionType) type, context);\n    } else if (type instanceof VarType) {\n        return convertVarType((VarType) type);\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}\n\nprivate ResolvedType convertClassOrInterfaceType(ClassOrInterfaceType classOrInterfaceType, Context context) {\n    return convertToUsage(classOrInterfaceType, context);\n}\n\nprivate ResolvedType convertPrimitiveType(PrimitiveType primitiveType) {\n    return ResolvedPrimitiveType.byName(primitiveType.getType().name());\n}\n\nprivate ResolvedType convertWildcardType(WildcardType wildcardType, Context context) {\n    return convertToUsage(wildcardType, context);\n}\n\nprivate ResolvedType convertArrayType(ArrayType arrayType, Context context) {\n    return convertToUsage(arrayType, context);\n}\n\nprivate ResolvedType convertUnionType(UnionType unionType, Context context) {\n    return new ResolvedUnionType(unionType.getElements().stream()\n            .map(el -> convertToUsage(el, context))\n            .collect(Collectors.toList()));\n}\n\nprivate ResolvedType convertVarType(VarType varType) {\n    Node parent = varType.getParentNode().get();\n    if (!(parent instanceof VariableDeclarator)) {\n        throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n    }\n    final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n    return variableDeclarator.getInitializer()\n            .map(Expression::calculateResolvedType)\n            .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprotected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            return convertToUsage((ArrayType) type, context);\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\nClass content:\n/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            return convertToUsage((ArrayType) type, context);\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\n        return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprotected convertToUsage(arrayType ArrayType, context Context) : ResolvedType extracted from protected convertToUsage(type Type, context Context) : ResolvedType in class com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade", "diffLocations": [{"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "startLine": 677, "endLine": 707, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "startLine": 677, "endLine": 706, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "startLine": 743, "endLine": 745, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }", "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "isPureRefactoring": true, "commitId": "454cc575960fdb902d93b21a56a071e31d3f81d7", "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel", "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade", "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage", "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\nif(wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()){return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.UNBOUNDED;\n}{throw new UnsupportedOperationException(wildcardType.toString());\n}}", "classSignatureBefore": "public class JavaParserFacade ", "methodNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage"], "classNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade"], "classSignatureBeforeSet": ["public class JavaParserFacade "], "purityCheckResultList": [{"isPure": true, "purityComment": "Tolerable changes in the body\n", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n", "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            return convertToUsage((ArrayType) type, context);\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\n        return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n", "diffSourceCodeSet": ["protected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\n        return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n    }"], "invokedMethodSet": ["methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\nif(wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()){return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.UNBOUNDED;\n}{throw new UnsupportedOperationException(wildcardType.toString());\n}}"], "sourceCodeAfterRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            return convertToUsage((ArrayType) type, context);\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\nprotected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\n        return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n    }", "diffSourceCode": "   677:     protected ResolvedType convertToUsage(Type type, Context context) {\n   678:         if (context == null) {\n   679:             throw new NullPointerException(\"Context should not be null\");\n   680:         }\n   681:         if (type instanceof ClassOrInterfaceType) {\n   682:             return convertToUsage((ClassOrInterfaceType) type, context);\n   683:         } else if (type instanceof PrimitiveType) {\n   684:             return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n   685:         } else if (type instanceof WildcardType) {\n   686:             return convertToUsage((WildcardType) type, context);\n   687:         } else if (type instanceof VoidType) {\n   688:             return ResolvedVoidType.INSTANCE;\n   689:         } else if (type instanceof ArrayType) {\n-  690:             ArrayType jpArrayType = (ArrayType) type;\n-  691:             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n-  692:         } else if (type instanceof UnionType) {\n-  693:             UnionType unionType = (UnionType) type;\n-  694:             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n-  695:         } else if (type instanceof VarType) {\n-  696:             Node parent = type.getParentNode().get();\n-  697:             if (!(parent instanceof VariableDeclarator)) {\n-  698:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n-  699:             }\n-  700:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n-  701:             return variableDeclarator.getInitializer()\n-  702:                     .map(Expression::calculateResolvedType)\n-  703:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n-  704:         } else {\n-  705:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n-  706:         }\n-  707:     }\n-  743: \n-  744:     public ResolvedType convert(Type type, Node node) {\n-  745:         return convert(type, JavaParserFactory.getContext(node, typeSolver));\n+  690:             return convertToUsage((ArrayType) type, context);\n+  691:         } else if (type instanceof UnionType) {\n+  692:             UnionType unionType = (UnionType) type;\n+  693:             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n+  694:         } else if (type instanceof VarType) {\n+  695:             Node parent = type.getParentNode().get();\n+  696:             if (!(parent instanceof VariableDeclarator)) {\n+  697:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n+  698:             }\n+  699:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n+  700:             return variableDeclarator.getInitializer()\n+  701:                     .map(Expression::calculateResolvedType)\n+  702:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n+  703:         } else {\n+  704:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n+  705:         }\n+  706:     }\n+  707: \n+  743:     protected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\n+  744:         return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n+  745:     }\n", "uniqueId": "454cc575960fdb902d93b21a56a071e31d3f81d7_677_707_743_745_677_706", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 6, "covered": 44}, "BRANCH": {"missed": 4, "covered": 8}, "LINE": {"missed": 1, "covered": 6}, "COMPLEXITY": {"missed": 4, "covered": 3}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `convertToUsage` method, we can extract the logic for handling different `Type` instances into separate methods. This will make the main method cleaner and easier to understand. \n\nHere\u2019s the refactored code with the extracted methods:\n\n```java\nprotected ResolvedType convertToUsage(Type type, Context context) {\n    if (context == null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    \n    if (type instanceof ClassOrInterfaceType) {\n        return convertToUsageClassOrInterface((ClassOrInterfaceType) type, context);\n    } else if (type instanceof PrimitiveType) {\n        return convertToUsagePrimitive((PrimitiveType) type);\n    } else if (type instanceof WildcardType) {\n        return convertToUsageWildcard((WildcardType) type, context);\n    } else if (type instanceof VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof ArrayType) {\n        return convertToUsageArray((ArrayType) type, context);\n    } else if (type instanceof UnionType) {\n        return convertToUsageUnion((UnionType) type, context);\n    } else if (type instanceof VarType) {\n        return convertToUsageVar((VarType) type);\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}\n\nprivate ResolvedType convertToUsageClassOrInterface(ClassOrInterfaceType classOrInterfaceType, Context context) {\n    String name = qName(classOrInterfaceType);\n    SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n    if (!ref.isSolved()) {\n        throw new UnsolvedSymbolException(name);\n    }\n    ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n    List<ResolvedType> typeParameters = Collections.emptyList();\n    if (classOrInterfaceType.getTypeArguments().isPresent()) {\n        typeParameters = classOrInterfaceType.getTypeArguments().get().stream()\n            .map(pt -> convertToUsage(pt, context))\n            .collect(Collectors.toList());\n    }\n    if (typeDeclaration.isTypeParameter()) {\n        return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n    } else {\n        return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n    }\n}\n\nprivate ResolvedType convertToUsagePrimitive(PrimitiveType primitiveType) {\n    return ResolvedPrimitiveType.byName(primitiveType.getType().name());\n}\n\nprivate ResolvedType convertToUsageWildcard(WildcardType wildcardType, Context context) {\n    if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context));\n    } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context));\n    } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.UNBOUNDED;\n    } else {\n        throw new UnsupportedOperationException(wildcardType.toString());\n    }\n}\n\nprivate ResolvedType convertToUsageArray(ArrayType arrayType, Context context) {\n    return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n}\n\nprivate ResolvedType convertToUsageUnion(UnionType unionType, Context context) {\n    return new ResolvedUnionType(unionType.getElements().stream()\n        .map(el -> convertToUsage(el, context))\n        .collect(Collectors.toList()));\n}\n\nprivate ResolvedType convertToUsageVar(VarType varType) {\n    Node parent = varType.getParentNode().get();\n    if (!(parent instanceof VariableDeclarator)) {\n        throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n    }\n    final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n    return variableDeclarator.getInitializer()\n        .map(Expression::calculateResolvedType)\n        .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n}\n```\n\nThis refactoring extracts the handling of each specific type into its own method, making the `convertToUsage` method much cleaner and easier to follow. Each extracted method is responsible for converting a specific type, which adheres to the Single Responsibility Principle. \n\nThe refactored method code is as follows:\n\n##########################\n```java\nprotected ResolvedType convertToUsage(Type type, Context context) {\n    if (context == null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    \n    if (type instanceof ClassOrInterfaceType) {\n        return convertToUsageClassOrInterface((ClassOrInterfaceType) type, context);\n    } else if (type instanceof PrimitiveType) {\n        return convertToUsagePrimitive((PrimitiveType) type);\n    } else if (type instanceof WildcardType) {\n        return convertToUsageWildcard((WildcardType) type, context);\n    } else if (type instanceof VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof ArrayType) {\n        return convertToUsageArray((ArrayType) type, context);\n    } else if (type instanceof UnionType) {\n        return convertToUsageUnion((UnionType) type, context);\n    } else if (type instanceof VarType) {\n        return convertToUsageVar((VarType) type);\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}\n\nprivate ResolvedType convertToUsageClassOrInterface(ClassOrInterfaceType classOrInterfaceType, Context context) {\n    String name = qName(classOrInterfaceType);\n    SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n    if (!ref.isSolved()) {\n        throw new UnsolvedSymbolException(name);\n    }\n    ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n    List<ResolvedType> typeParameters = Collections.emptyList();\n    if (classOrInterfaceType.getTypeArguments().isPresent()) {\n        typeParameters = classOrInterfaceType.getTypeArguments().get().stream()\n            .map(pt -> convertToUsage(pt, context))\n            .collect(Collectors.toList());\n    }\n    if (typeDeclaration.isTypeParameter()) {\n        return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n    } else {\n        return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n    }\n}\n\nprivate ResolvedType convertToUsagePrimitive(PrimitiveType primitiveType) {\n    return ResolvedPrimitiveType.byName(primitiveType.getType().name());\n}\n\nprivate ResolvedType convertToUsageWildcard(WildcardType wildcardType, Context context) {\n    if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context));\n    } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context));\n    } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.UNBOUNDED;\n    } else {\n        throw new UnsupportedOperationException(wildcardType.toString());\n    }\n}\n\nprivate ResolvedType convertToUsageArray(ArrayType arrayType, Context context) {\n    return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n}\n\nprivate ResolvedType convertToUsageUnion(UnionType unionType, Context context) {\n    return new ResolvedUnionType(unionType.getElements().stream()\n        .map(el -> convertToUsage(el, context))\n        .collect(Collectors.toList()));\n}\n\nprivate ResolvedType convertToUsageVar(VarType varType) {\n    Node parent = varType.getParentNode().get();\n    if (!(parent instanceof VariableDeclarator)) {\n        throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n    }\n    final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n    return variableDeclarator.getInitializer()\n        .map(Expression::calculateResolvedType)\n        .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprotected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\nClass content:\n/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprotected convertToUsage(wildcardType WildcardType, context Context) : ResolvedType extracted from protected convertToUsage(type Type, context Context) : ResolvedType in class com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade", "diffLocations": [{"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "startLine": 677, "endLine": 716, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "startLine": 677, "endLine": 707, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "startLine": 732, "endLine": 742, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }", "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "isPureRefactoring": true, "commitId": "02410715bad58480d6ce66f64db8c11a4fa607b4", "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel", "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade", "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage", "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\nString name=qName(classOrInterfaceType);\nSymbolReference<ResolvedTypeDeclaration> ref=context.solveType(name);\nif(!ref.isSolved()){throw new UnsolvedSymbolException(name);\n}ResolvedTypeDeclaration typeDeclaration=ref.getCorrespondingDeclaration();\nList<ResolvedType> typeParameters=Collections.emptyList();\nif(classOrInterfaceType.getTypeArguments().isPresent()){typeParameters=classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt,context)).collect(Collectors.toList());\n}if(typeDeclaration.isTypeParameter()){if(typeDeclaration instanceof ResolvedTypeParameterDeclaration){return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration)typeDeclaration);\n}{JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration=(JavaParserTypeVariableDeclaration)typeDeclaration;\nreturn new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n}}{return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration)typeDeclaration,typeParameters,typeSolver);\n}}", "classSignatureBefore": "public class JavaParserFacade ", "methodNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage"], "classNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade"], "classSignatureBeforeSet": ["public class JavaParserFacade "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n", "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n", "diffSourceCodeSet": ["protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }"], "invokedMethodSet": ["methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\nString name=qName(classOrInterfaceType);\nSymbolReference<ResolvedTypeDeclaration> ref=context.solveType(name);\nif(!ref.isSolved()){throw new UnsolvedSymbolException(name);\n}ResolvedTypeDeclaration typeDeclaration=ref.getCorrespondingDeclaration();\nList<ResolvedType> typeParameters=Collections.emptyList();\nif(classOrInterfaceType.getTypeArguments().isPresent()){typeParameters=classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt,context)).collect(Collectors.toList());\n}if(typeDeclaration.isTypeParameter()){if(typeDeclaration instanceof ResolvedTypeParameterDeclaration){return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration)typeDeclaration);\n}{JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration=(JavaParserTypeVariableDeclaration)typeDeclaration;\nreturn new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n}}{return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration)typeDeclaration,typeParameters,typeSolver);\n}}"], "sourceCodeAfterRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\nprotected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }", "diffSourceCode": "   677:     protected ResolvedType convertToUsage(Type type, Context context) {\n   678:         if (context == null) {\n   679:             throw new NullPointerException(\"Context should not be null\");\n   680:         }\n   681:         if (type instanceof ClassOrInterfaceType) {\n   682:             return convertToUsage((ClassOrInterfaceType) type, context);\n   683:         } else if (type instanceof PrimitiveType) {\n   684:             return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n   685:         } else if (type instanceof WildcardType) {\n-  686:             WildcardType wildcardType = (WildcardType) type;\n-  687:             if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n-  688:                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n-  689:             } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n-  690:                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n-  691:             } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n-  692:                 return ResolvedWildcard.UNBOUNDED;\n-  693:             } else {\n-  694:                 throw new UnsupportedOperationException(wildcardType.toString());\n-  695:             }\n-  696:         } else if (type instanceof VoidType) {\n-  697:             return ResolvedVoidType.INSTANCE;\n-  698:         } else if (type instanceof ArrayType) {\n-  699:             ArrayType jpArrayType = (ArrayType) type;\n-  700:             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n-  701:         } else if (type instanceof UnionType) {\n-  702:             UnionType unionType = (UnionType) type;\n-  703:             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n-  704:         } else if (type instanceof VarType) {\n-  705:             Node parent = type.getParentNode().get();\n-  706:             if (!(parent instanceof VariableDeclarator)) {\n-  707:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n-  708:             }\n-  709:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n-  710:             return variableDeclarator.getInitializer()\n-  711:                     .map(Expression::calculateResolvedType)\n-  712:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n-  713:         } else {\n-  714:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n-  715:         }\n-  716:     }\n-  732:             } else {\n-  733:                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n-  734:                 return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n-  735:             }\n-  736:         } else {\n-  737:             return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n-  738:         }\n-  739:     }\n-  740: \n-  741:     public ResolvedType convert(Type type, Node node) {\n-  742:         return convert(type, JavaParserFactory.getContext(node, typeSolver));\n+  686:             return convertToUsage((WildcardType) type, context);\n+  687:         } else if (type instanceof VoidType) {\n+  688:             return ResolvedVoidType.INSTANCE;\n+  689:         } else if (type instanceof ArrayType) {\n+  690:             ArrayType jpArrayType = (ArrayType) type;\n+  691:             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n+  692:         } else if (type instanceof UnionType) {\n+  693:             UnionType unionType = (UnionType) type;\n+  694:             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n+  695:         } else if (type instanceof VarType) {\n+  696:             Node parent = type.getParentNode().get();\n+  697:             if (!(parent instanceof VariableDeclarator)) {\n+  698:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n+  699:             }\n+  700:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n+  701:             return variableDeclarator.getInitializer()\n+  702:                     .map(Expression::calculateResolvedType)\n+  703:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n+  704:         } else {\n+  705:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n+  706:         }\n+  707:     }\n+  708: \n+  709:     protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n+  710:         String name = qName(classOrInterfaceType);\n+  711:         SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n+  712:         if (!ref.isSolved()) {\n+  713:             throw new UnsolvedSymbolException(name);\n+  714:         }\n+  715:         ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n+  716:         List<ResolvedType> typeParameters = Collections.emptyList();\n+  732:     protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n+  733:         if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n+  734:             return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n+  735:         } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n+  736:             return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n+  737:         } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n+  738:             return ResolvedWildcard.UNBOUNDED;\n+  739:         } else {\n+  740:             throw new UnsupportedOperationException(wildcardType.toString());\n+  741:         }\n+  742:     }\n", "uniqueId": "02410715bad58480d6ce66f64db8c11a4fa607b4_677_716_732_742_677_707", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 9, "covered": 60}, "BRANCH": {"missed": 1, "covered": 7}, "LINE": {"missed": 2, "covered": 12}, "COMPLEXITY": {"missed": 1, "covered": 4}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `convertToUsage` method, we can extract the handling of different `Type` instances into separate methods. This will make the main method cleaner and easier to understand. \n\nHere\u2019s the refactored code with the extracted methods:\n\n```java\nprotected ResolvedType convertToUsage(Type type, Context context) {\n    if (context == null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        return convertToUsageClassOrInterface((ClassOrInterfaceType) type, context);\n    } else if (type instanceof PrimitiveType) {\n        return convertToUsagePrimitive((PrimitiveType) type);\n    } else if (type instanceof WildcardType) {\n        return convertToUsageWildcard((WildcardType) type, context);\n    } else if (type instanceof VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof ArrayType) {\n        return convertToUsageArray((ArrayType) type, context);\n    } else if (type instanceof UnionType) {\n        return convertToUsageUnion((UnionType) type, context);\n    } else if (type instanceof VarType) {\n        return convertToUsageVar((VarType) type);\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}\n\nprivate ResolvedType convertToUsageClassOrInterface(ClassOrInterfaceType classOrInterfaceType, Context context) {\n    return convertToUsage(classOrInterfaceType, context);\n}\n\nprivate ResolvedType convertToUsagePrimitive(PrimitiveType primitiveType) {\n    return ResolvedPrimitiveType.byName(primitiveType.getType().name());\n}\n\nprivate ResolvedType convertToUsageWildcard(WildcardType wildcardType, Context context) {\n    if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context));\n    } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context));\n    } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.UNBOUNDED;\n    } else {\n        throw new UnsupportedOperationException(wildcardType.toString());\n    }\n}\n\nprivate ResolvedType convertToUsageArray(ArrayType arrayType, Context context) {\n    return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n}\n\nprivate ResolvedType convertToUsageUnion(UnionType unionType, Context context) {\n    return new ResolvedUnionType(unionType.getElements().stream()\n            .map(el -> convertToUsage(el, context))\n            .collect(Collectors.toList()));\n}\n\nprivate ResolvedType convertToUsageVar(VarType varType) {\n    Node parent = varType.getParentNode().get();\n    if (!(parent instanceof VariableDeclarator)) {\n        throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n    }\n    final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n    return variableDeclarator.getInitializer()\n            .map(Expression::calculateResolvedType)\n            .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n}\n```\n\nThis refactoring extracts the logic for handling each specific type into its own method, which improves the overall structure and readability of the `convertToUsage` method. Each extracted method is now responsible for a single type, making it easier to maintain and understand. \n\n##########################\nrefactored_method_code\n##########################\n```java\nprotected ResolvedType convertToUsage(Type type, Context context) {\n    if (context == null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        return convertToUsageClassOrInterface((ClassOrInterfaceType) type, context);\n    } else if (type instanceof PrimitiveType) {\n        return convertToUsagePrimitive((PrimitiveType) type);\n    } else if (type instanceof WildcardType) {\n        return convertToUsageWildcard((WildcardType) type, context);\n    } else if (type instanceof VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof ArrayType) {\n        return convertToUsageArray((ArrayType) type, context);\n    } else if (type instanceof UnionType) {\n        return convertToUsageUnion((UnionType) type, context);\n    } else if (type instanceof VarType) {\n        return convertToUsageVar((VarType) type);\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}\n\nprivate ResolvedType convertToUsageClassOrInterface(ClassOrInterfaceType classOrInterfaceType, Context context) {\n    return convertToUsage(classOrInterfaceType, context);\n}\n\nprivate ResolvedType convertToUsagePrimitive(PrimitiveType primitiveType) {\n    return ResolvedPrimitiveType.byName(primitiveType.getType().name());\n}\n\nprivate ResolvedType convertToUsageWildcard(WildcardType wildcardType, Context context) {\n    if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context));\n    } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context));\n    } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n        return ResolvedWildcard.UNBOUNDED;\n    } else {\n        throw new UnsupportedOperationException(wildcardType.toString());\n    }\n}\n\nprivate ResolvedType convertToUsageArray(ArrayType arrayType, Context context) {\n    return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n}\n\nprivate ResolvedType convertToUsageUnion(UnionType unionType, Context context) {\n    return new ResolvedUnionType(unionType.getElements().stream()\n            .map(el -> convertToUsage(el, context))\n            .collect(Collectors.toList()));\n}\n\nprivate ResolvedType convertToUsageVar(VarType varType) {\n    Node parent = varType.getParentNode().get();\n    if (!(parent instanceof VariableDeclarator)) {\n        throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n    }\n    final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n    return variableDeclarator.getInitializer()\n            .map(Expression::calculateResolvedType)\n            .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n}\n```", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprotected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\nClass content:\n/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Inline Method", "description": "Inline Method\tprivate createDefaultVisitor(configuration PrinterConfiguration) : Function<PrinterConfiguration,VoidVisitor<Void>> inlined to private createDefaultVisitor() : Function<PrinterConfiguration,VoidVisitor<Void>> in class com.github.javaparser.printer.DefaultPrettyPrinter", "diffLocations": [{"filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinter.java", "startLine": 43, "endLine": 46, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinter.java", "startLine": 43, "endLine": 45, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinter.java", "startLine": 48, "endLine": 50, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor(PrinterConfiguration configuration) {\n        return (config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config));\n    }", "filePathBefore": "javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinter.java", "isPureRefactoring": true, "commitId": "97240408d5c48e602a5a277a0af8e98137d32800", "packageNameBefore": "com.github.javaparser.printer", "classNameBefore": "com.github.javaparser.printer.DefaultPrettyPrinter", "methodNameBefore": "com.github.javaparser.printer.DefaultPrettyPrinter#createDefaultVisitor", "classSignatureBefore": "public class DefaultPrettyPrinter implements Printer ", "methodNameBeforeSet": ["com.github.javaparser.printer.DefaultPrettyPrinter#createDefaultVisitor"], "classNameBeforeSet": ["com.github.javaparser.printer.DefaultPrettyPrinter"], "classSignatureBeforeSet": ["public class DefaultPrettyPrinter implements Printer "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2021 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer;\n\nimport java.util.function.Function;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.visitor.VoidVisitor;\nimport com.github.javaparser.printer.configuration.PrinterConfiguration;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration;\n\n/**\n * Pretty printer for AST nodes.\n */\npublic class DefaultPrettyPrinter implements Printer {\n    \n    private PrinterConfiguration configuration;\n    \n    // visitor factory\n    Function<PrinterConfiguration, VoidVisitor<Void>> visitorFactory;\n    \n    // static methods \n    \n    private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor() {\n        PrinterConfiguration configuration = createDefaultConfiguration();\n        return createDefaultVisitor(configuration);\n    }\n    \n    private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor(PrinterConfiguration configuration) {\n        return (config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config));\n    }\n    \n    private static PrinterConfiguration createDefaultConfiguration() {\n        return new DefaultPrinterConfiguration();\n    }\n    \n    // Constructors\n\n    /**\n     * Build a new DefaultPrettyPrinter with a default configuration and a default factory\n     */\n    public DefaultPrettyPrinter() {\n        this(createDefaultVisitor(), createDefaultConfiguration() );\n    }\n    \n    /**\n     * Build a new DefaultPrettyPrinter with a configuration and a default factory\n     * @param configuration\n     */\n    public DefaultPrettyPrinter(PrinterConfiguration configuration) {\n        this(createDefaultVisitor(configuration), configuration );\n    }\n    \n    /**\n     * Build a new DefaultPrettyPrinter with a configuration and a factory to create a visitor to browse the nodes of the AST\n     * @param visitorFactory \n     * @param configuration Configuration to apply\n     */\n    public DefaultPrettyPrinter(Function<PrinterConfiguration, VoidVisitor<Void>> visitorFactory, PrinterConfiguration configuration) {\n        this.configuration = configuration;\n        this.visitorFactory = visitorFactory;\n    }\n    \n    // Methods\n    \n    /*\n     * Returns the Printer configuration\n     */\n    public PrinterConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    /*\n     * set or update the PrettyPrinter configuration\n     */\n    public Printer setConfiguration(PrinterConfiguration configuration) {\n        this.configuration = configuration;\n        return this;\n    }\n\n    @Override\n    public String print(Node node) {\n        // lazy initialization of visitor which can have a state (like a buffer)\n        VoidVisitor<Void> visitor = visitorFactory.apply(configuration);\n        node.accept(visitor, null);\n        return visitor.toString();\n    }\n}\n", "filePathAfter": "javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinter.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2021 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer;\n\nimport java.util.function.Function;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.visitor.VoidVisitor;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration;\nimport com.github.javaparser.printer.configuration.PrinterConfiguration;\n\n/**\n * Pretty printer for AST nodes.\n */\npublic class DefaultPrettyPrinter implements Printer {\n    \n    private PrinterConfiguration configuration;\n    \n    // visitor factory\n    Function<PrinterConfiguration, VoidVisitor<Void>> visitorFactory;\n    \n    // static methods \n    \n    private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor() {\n        return (config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config));\n    }\n    \n    private static PrinterConfiguration createDefaultConfiguration() {\n        return new DefaultPrinterConfiguration();\n    }\n    \n    // Constructors\n\n    /**\n     * Build a new DefaultPrettyPrinter with a default configuration and a default factory\n     */\n    public DefaultPrettyPrinter() {\n        this(createDefaultConfiguration() );\n    }\n    \n    /**\n     * Build a new DefaultPrettyPrinter with a configuration and a default factory\n     * @param configuration\n     */\n    public DefaultPrettyPrinter(PrinterConfiguration configuration) {\n        this(createDefaultVisitor(), configuration );\n    }\n    \n    /**\n     * Build a new DefaultPrettyPrinter with a configuration and a factory to create a visitor to browse the nodes of the AST\n     * @param visitorFactory \n     * @param configuration Configuration to apply\n     */\n    public DefaultPrettyPrinter(Function<PrinterConfiguration, VoidVisitor<Void>> visitorFactory, PrinterConfiguration configuration) {\n        this.configuration = configuration;\n        this.visitorFactory = visitorFactory;\n    }\n    \n    // Methods\n    \n    /*\n     * Returns the Printer configuration\n     */\n    public PrinterConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    /*\n     * set or update the PrettyPrinter configuration\n     */\n    public Printer setConfiguration(PrinterConfiguration configuration) {\n        this.configuration = configuration;\n        return this;\n    }\n\n    @Override\n    public String print(Node node) {\n        // lazy initialization of visitor which can have a state (like a buffer)\n        VoidVisitor<Void> visitor = visitorFactory.apply(configuration);\n        node.accept(visitor, null);\n        return visitor.toString();\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor() {\n        return (config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config));\n    }", "diffSourceCode": "    43:     private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor() {\n-   44:         PrinterConfiguration configuration = createDefaultConfiguration();\n-   45:         return createDefaultVisitor(configuration);\n-   46:     }\n-   48:     private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor(PrinterConfiguration configuration) {\n-   49:         return (config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config));\n-   50:     }\n+   44:         return (config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config));\n+   45:     }\n+   46:     \n+   48:         return new DefaultPrinterConfiguration();\n+   49:     }\n+   50:     \n", "uniqueId": "97240408d5c48e602a5a277a0af8e98137d32800_43_46__43_45_48_50", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 2}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To perform the \"Inline Method\" refactoring operation on the provided code, we will inline the `createDefaultVisitor(PrinterConfiguration configuration)` method. This means we will replace the method call with its implementation directly in the places where it is used.\n\nHere\u2019s the refactored class code after inlining the method:\n\n##########################\n```java\n/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2021 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer;\n\nimport java.util.function.Function;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.visitor.VoidVisitor;\nimport com.github.javaparser.printer.configuration.PrinterConfiguration;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration;\n\n/**\n * Pretty printer for AST nodes.\n */\npublic class DefaultPrettyPrinter implements Printer {\n    \n    private PrinterConfiguration configuration;\n    \n    // visitor factory\n    Function<PrinterConfiguration, VoidVisitor<Void>> visitorFactory;\n    \n    // static methods \n    \n    private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor() {\n        PrinterConfiguration configuration = createDefaultConfiguration();\n        return (config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config));\n    }\n    \n    private static PrinterConfiguration createDefaultConfiguration() {\n        return new DefaultPrinterConfiguration();\n    }\n    \n    // Constructors\n\n    /**\n     * Build a new DefaultPrettyPrinter with a default configuration and a default factory\n     */\n    public DefaultPrettyPrinter() {\n        this(createDefaultVisitor(), createDefaultConfiguration());\n    }\n    \n    /**\n     * Build a new DefaultPrettyPrinter with a configuration and a default factory\n     * @param configuration\n     */\n    public DefaultPrettyPrinter(PrinterConfiguration configuration) {\n        this((config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config)), configuration);\n    }\n    \n    /**\n     * Build a new DefaultPrettyPrinter with a configuration and a factory to create a visitor to browse the nodes of the AST\n     * @param visitorFactory \n     * @param configuration Configuration to apply\n     */\n    public DefaultPrettyPrinter(Function<PrinterConfiguration, VoidVisitor<Void>> visitorFactory, PrinterConfiguration configuration) {\n        this.configuration = configuration;\n        this.visitorFactory = visitorFactory;\n    }\n    \n    // Methods\n    \n    /*\n     * Returns the Printer configuration\n     */\n    public PrinterConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    /*\n     * set or update the PrettyPrinter configuration\n     */\n    public Printer setConfiguration(PrinterConfiguration configuration) {\n        this.configuration = configuration;\n        return this;\n    }\n\n    @Override\n    public String print(Node node) {\n        // lazy initialization of visitor which can have a state (like a buffer)\n        VoidVisitor<Void> visitor = visitorFactory.apply(configuration);\n        node.accept(visitor, null);\n        return visitor.toString();\n    }\n}\n```\n##########################\n\nIn this refactored code, the `createDefaultVisitor(PrinterConfiguration configuration)` method has been inlined in the constructor `DefaultPrettyPrinter(PrinterConfiguration configuration)`. This improves readability by reducing the number of method calls and makes it clearer how the visitor is created directly within the constructor.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor(PrinterConfiguration configuration) {\n        return (config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config));\n    }\n\nClass content:\n/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2021 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer;\n\nimport java.util.function.Function;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.visitor.VoidVisitor;\nimport com.github.javaparser.printer.configuration.PrinterConfiguration;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration;\n\n/**\n * Pretty printer for AST nodes.\n */\npublic class DefaultPrettyPrinter implements Printer {\n    \n    private PrinterConfiguration configuration;\n    \n    // visitor factory\n    Function<PrinterConfiguration, VoidVisitor<Void>> visitorFactory;\n    \n    // static methods \n    \n    private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor() {\n        PrinterConfiguration configuration = createDefaultConfiguration();\n        return createDefaultVisitor(configuration);\n    }\n    \n    private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor(PrinterConfiguration configuration) {\n        return (config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config));\n    }\n    \n    private static PrinterConfiguration createDefaultConfiguration() {\n        return new DefaultPrinterConfiguration();\n    }\n    \n    // Constructors\n\n    /**\n     * Build a new DefaultPrettyPrinter with a default configuration and a default factory\n     */\n    public DefaultPrettyPrinter() {\n        this(createDefaultVisitor(), createDefaultConfiguration() );\n    }\n    \n    /**\n     * Build a new DefaultPrettyPrinter with a configuration and a default factory\n     * @param configuration\n     */\n    public DefaultPrettyPrinter(PrinterConfiguration configuration) {\n        this(createDefaultVisitor(configuration), configuration );\n    }\n    \n    /**\n     * Build a new DefaultPrettyPrinter with a configuration and a factory to create a visitor to browse the nodes of the AST\n     * @param visitorFactory \n     * @param configuration Configuration to apply\n     */\n    public DefaultPrettyPrinter(Function<PrinterConfiguration, VoidVisitor<Void>> visitorFactory, PrinterConfiguration configuration) {\n        this.configuration = configuration;\n        this.visitorFactory = visitorFactory;\n    }\n    \n    // Methods\n    \n    /*\n     * Returns the Printer configuration\n     */\n    public PrinterConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    /*\n     * set or update the PrettyPrinter configuration\n     */\n    public Printer setConfiguration(PrinterConfiguration configuration) {\n        this.configuration = configuration;\n        return this;\n    }\n\n    @Override\n    public String print(Node node) {\n        // lazy initialization of visitor which can have a state (like a buffer)\n        VoidVisitor<Void> visitor = visitorFactory.apply(configuration);\n        node.accept(visitor, null);\n        return visitor.toString();\n    }\n}\n\nRefactoring Operation:\nInline Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\nrefactored_class_code\n##########################\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprotected createSolver() : SymbolSolver extracted from public visit(node FieldAccessExpr, solveLambdas Boolean) : ResolvedType in class com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor", "diffLocations": [{"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java", "startLine": 234, "endLine": 280, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java", "startLine": 234, "endLine": 280, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java", "startLine": 652, "endLine": 654, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }", "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java", "isPureRefactoring": true, "commitId": "b22ebb29abb4e6dcc1d22ca9823e5b2a3473b6a8", "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel", "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor", "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor#visit", "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor#solveDotExpressionType\n methodBody: private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {\nif(parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())){return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();\n}if(parentType.hasField(node.getName().getId())){return parentType.getField(node.getName().getId()).getType();\n}if(parentType.hasInternalType(node.getName().getId())){return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()),typeSolver);\n}{throw new UnsolvedSymbolException(node.getName().getId());\n}}", "classSignatureBefore": "public class TypeExtractor extends DefaultVisitorAdapter ", "methodNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor#visit"], "classNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor"], "classSignatureBeforeSet": ["public class TypeExtractor extends DefaultVisitorAdapter "], "purityCheckResultList": [{"isPure": true, "purityComment": "Tolerable changes in the body\n", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solveGenericTypes;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.ReturnStmt;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnknownType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.symbolsolver.logic.InferenceContext;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.Value;\nimport com.github.javaparser.symbolsolver.model.typesystem.NullType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.MyObjectProvider;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.symbolsolver.resolution.promotion.ConditionalExprHandler;\nimport com.github.javaparser.symbolsolver.resolution.promotion.ConditionalExprResolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.github.javaparser.utils.Log;\nimport com.github.javaparser.utils.Pair;\nimport com.google.common.collect.ImmutableList;\n\npublic class TypeExtractor extends DefaultVisitorAdapter {\n\n    private static final String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private TypeSolver typeSolver;\n    private JavaParserFacade facade;\n    \n    private ReferenceTypeImpl StringReferenceType;\n\n    public TypeExtractor(TypeSolver typeSolver, JavaParserFacade facade) {\n        this.typeSolver = typeSolver;\n        this.facade = facade;\n        //pre-calculate the String reference (optimization)\n        StringReferenceType = new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(JAVA_LANG_STRING), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarator node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof FieldDeclaration) {\n            return facade.convertToUsageVariableType(node);\n        } else if (demandParentNode(node) instanceof VariableDeclarationExpr) {\n            return facade.convertToUsageVariableType(node);\n        }\n        throw new UnsupportedOperationException(demandParentNode(node).getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(Parameter node, Boolean solveLambdas) {\n        if (node.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + node);\n        }\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n\n    @Override\n    public ResolvedType visit(ArrayAccessExpr node, Boolean solveLambdas) {\n        ResolvedType arrayUsageType = node.getName().accept(this, solveLambdas);\n        if (arrayUsageType.isArray()) {\n            return ((ResolvedArrayType) arrayUsageType).getComponentType();\n        }\n        return arrayUsageType;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayCreationExpr node, Boolean solveLambdas) {\n        ResolvedType res = facade.convertToUsage(node.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i = 0; i < node.getLevels().size(); i++) {\n            res = new ResolvedArrayType(res);\n        }\n        return res;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayInitializerExpr node, Boolean solveLambdas) {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(AssignExpr node, Boolean solveLambdas) {\n        return node.getTarget().accept(this, solveLambdas);\n    }\n\n    @Override\n    public ResolvedType visit(BinaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case PLUS:\n            case MINUS:\n            case DIVIDE:\n            case MULTIPLY:\n            case REMAINDER:\n            case BINARY_AND:\n            case BINARY_OR:\n            case XOR:\n                return facade.getBinaryTypeConcrete(node.getLeft(), node.getRight(), solveLambdas, node.getOperator());\n            case LESS_EQUALS:\n            case LESS:\n            case GREATER:\n            case GREATER_EQUALS:\n            case EQUALS:\n            case NOT_EQUALS:\n            case OR:\n            case AND:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case SIGNED_RIGHT_SHIFT:\n            case UNSIGNED_RIGHT_SHIFT:\n            case LEFT_SHIFT:\n                ResolvedType rt = node.getLeft().accept(this, solveLambdas);\n                // apply unary primitive promotion\n                return ResolvedPrimitiveType.unp(rt);\n            default:\n                throw new UnsupportedOperationException(\"Operator \" + node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(CastExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    @Override\n    public ResolvedType visit(ClassExpr node, Boolean solveLambdas) {\n        // This implementation does not regard the actual type argument of the ClassExpr.\n        Type astType = node.getType();\n        ResolvedType jssType = facade.convertToUsage(astType, node.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    }\n\n    /*\n     * The conditional operator has three operand expressions. ? appears between the first and second expressions, and\n     * : appears between the second and third expressions.\n     * There are three kinds of conditional expressions, classified according to the second and third operand\n     * expressions: boolean conditional expressions, numeric conditional expressions, and reference conditional\n     * expressions.\n     * The classification rules are as follows:\n     * 1/ If both the second and the third operand expressions are boolean expressions, the conditional expression is a\n     * boolean conditional expression.\n     * 2/ If both the second and the third operand expressions are numeric expressions, the conditional expression is a\n     * numeric conditional expression.\n     * 3/ Otherwise, the conditional expression is a reference conditional expression\n     */\n    @Override\n    public ResolvedType visit(ConditionalExpr node, Boolean solveLambdas) {\n        ResolvedType thenExpr = node.getThenExpr().accept(this, solveLambdas);\n        ResolvedType elseExpr = node.getElseExpr().accept(this, solveLambdas);\n\n        ConditionalExprHandler rce = ConditionalExprResolver.getConditionExprHandler(thenExpr, elseExpr);\n        try {\n            return rce.resolveType();\n        } catch (UnsupportedOperationException e) {\n            // There is nothing to do because, for the moment, we want to run actual implementation\n        }\n        return node.getThenExpr().accept(this, solveLambdas);\n    }\n    \n    private boolean isCompatible(ResolvedType resolvedType, ResolvedPrimitiveType primitiveType) {\n        return (resolvedType.isPrimitive() && resolvedType.asPrimitive().equals(primitiveType))\n        || (resolvedType.isReferenceType() && resolvedType.asReferenceType().isUnboxableTo(primitiveType));\n    }\n\n    @Override\n    public ResolvedType visit(EnclosedExpr node, Boolean solveLambdas) {\n        return node.getInner().accept(this, solveLambdas);\n    }\n\n    /**\n     * Java Parser can't differentiate between packages, internal types, and fields.\n     * All three are lumped together into FieldAccessExpr. We need to differentiate them.\n     */\n    private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {\n        // Fields and internal type declarations cannot have the same name.\n        // Thus, these checks will always be mutually exclusive.\n        if (parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())) {\n            return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();\n        } else if (parentType.hasField(node.getName().getId())) {\n            return parentType.getField(node.getName().getId()).getType();\n        } else if (parentType.hasInternalType(node.getName().getId())) {\n            return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()), typeSolver);\n        } else {\n            throw new UnsolvedSymbolException(node.getName().getId());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(InstanceOfExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(StringLiteralExpr node, Boolean solveLambdas) {\n        return StringReferenceType;\n    }\n\n    @Override\n    public ResolvedType visit(IntegerLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.INT;\n    }\n\n    @Override\n    public ResolvedType visit(LongLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.LONG;\n    }\n\n    @Override\n    public ResolvedType visit(CharLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.CHAR;\n    }\n\n    @Override\n    public ResolvedType visit(DoubleLiteralExpr node, Boolean solveLambdas) {\n        if (node.getValue().toLowerCase().endsWith(\"f\")) {\n            return ResolvedPrimitiveType.FLOAT;\n        }\n        return ResolvedPrimitiveType.DOUBLE;\n    }\n\n    @Override\n    public ResolvedType visit(BooleanLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(NullLiteralExpr node, Boolean solveLambdas) {\n        return NullType.INSTANCE;\n    }\n\n    @Override\n    public ResolvedType visit(MethodCallExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on method call %s\", ()-> node);\n        // first solve the method\n        MethodUsage ref = facade.solveMethodAsUsage(node);\n        Log.trace(\"getType on method call %s resolved to %s\", ()-> node, ()-> ref);\n        Log.trace(\"getType on method call %s return type is %s\", ()-> node, ref::returnType);\n        return ref.returnType();\n        // the type is the return type of the method\n    }\n\n    @Override\n    public ResolvedType visit(NameExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on name expr %s\", ()-> node);\n        Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, node.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    }\n\n    @Override\n    public ResolvedType visit(TypeExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on type expr %s\", ()-> node);\n        if (!(node.getType() instanceof ClassOrInterfaceType)) {\n            throw new UnsupportedOperationException(node.getType().getClass().getCanonicalName());\n        }\n\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) node.getType();\n        String nameWithScope = classOrInterfaceType.getNameWithScope();\n\n        // JLS 15.13 - ReferenceType :: [TypeArguments] Identifier\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = JavaParserFactory\n                .getContext(classOrInterfaceType, typeSolver)\n                .solveType(nameWithScope);\n        if (typeDeclarationSymbolReference.isSolved()) {\n            return new ReferenceTypeImpl(typeDeclarationSymbolReference.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n\n        // JLS 15.13 - ExpressionName :: [TypeArguments] Identifier\n        Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameWithScope, node);\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n\n        throw new UnsolvedSymbolException(\"Solving \" + node, classOrInterfaceType.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(ObjectCreationExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n    @Override\n    public ResolvedType visit(ThisExpr node, Boolean solveLambdas) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve locally in Compilation unit\n            // first try a buttom/up approach\n            try {\n                return new ReferenceTypeImpl(\n                        facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node, className)),\n                        typeSolver);\n            } catch (IllegalStateException e) {\n                // trying another approach from type solver\n                Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n                SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n                if (clazz.isSolved()) {\n                    return new ReferenceTypeImpl(clazz.getCorrespondingDeclaration(), typeSolver);\n                }\n            }\n        }\n        return new ReferenceTypeImpl(facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node)), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(SuperExpr node, Boolean solveLambdas) {\n        // If 'super' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            String className = node.getTypeName().get().asString();\n            SymbolReference<ResolvedTypeDeclaration> resolvedTypeNameRef = JavaParserFactory.getContext(node, typeSolver).solveType(className);\n            if (resolvedTypeNameRef.isSolved()) {\n                // Cfr JLS $15.12.1\n                ResolvedTypeDeclaration resolvedTypeName = resolvedTypeNameRef.getCorrespondingDeclaration();\n                if (resolvedTypeName.isInterface()) {\n                    return new ReferenceTypeImpl(resolvedTypeName.asInterface(), typeSolver);\n                } else if (resolvedTypeName.isClass()) {\n                    // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n                    return resolvedTypeName.asClass().getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n                } else {\n                    throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n                }\n            } else {\n                throw new UnsolvedSymbolException(className);\n            }\n        }\n\n        ResolvedTypeDeclaration typeOfNode = facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node));\n        if (typeOfNode instanceof ResolvedClassDeclaration) {\n            // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n            return ((ResolvedClassDeclaration) typeOfNode).getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(UnaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case MINUS:\n            case PLUS:\n                return ResolvedPrimitiveType.unp(node.getExpression().accept(this, solveLambdas));\n            case LOGICAL_COMPLEMENT:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case POSTFIX_DECREMENT:\n            case PREFIX_DECREMENT:\n            case POSTFIX_INCREMENT:\n            case PREFIX_INCREMENT:\n            case BITWISE_COMPLEMENT:\n                return node.getExpression().accept(this, solveLambdas);\n            default:\n                throw new UnsupportedOperationException(node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarationExpr node, Boolean solveLambdas) {\n        if (node.getVariables().size() != 1) {\n            throw new UnsupportedOperationException();\n        }\n        return facade.convertToUsageVariableType(node.getVariables().get(0));\n    }\n\n\n    @Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n\n            // The type parameter referred here should be the java.util.stream.Stream.T\n            ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n            if (solveLambdas) {\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof VariableDeclarator)\n        {\n            VariableDeclarator decExpr = (VariableDeclarator) demandParentNode(node);\n            ResolvedType result = decExpr.getType().resolve();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof AssignExpr) {\n            AssignExpr assExpr = (AssignExpr) demandParentNode(node);\n            ResolvedType result = assExpr.calculateResolvedType();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }\n\n    private ResolvedType resolveLambda(LambdaExpr node, ResolvedType result) {\n        // We need to replace the type variables\n        Context ctx = JavaParserFactory.getContext(node, typeSolver);\n        result = solveGenericTypes(result, ctx);\n\n        //We should find out which is the functional method (e.g., apply) and replace the params of the\n        //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n        //lambdas\n        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n        if (functionalMethod.isPresent()) {\n            LambdaExpr lambdaExpr = node;\n\n            InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n            InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n            // At this point parameterType\n            // if Function<T=? super Stream.T, ? extends map.R>\n            // we should replace Stream.T\n            ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n            lambdaCtx.addPair(result, functionalInterfaceType);\n\n            ResolvedType actualType;\n\n            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n            } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                // Get all the return statements in the lambda block\n                List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                if (returnStmts.size() > 0) {\n                    actualType = returnStmts.stream()\n                            .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                            .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                            .findFirst()\n                            .orElse(ResolvedVoidType.INSTANCE);\n\n                } else {\n                    actualType = ResolvedVoidType.INSTANCE;\n                }\n\n\n            } else {\n                throw new UnsupportedOperationException();\n            }\n\n            ResolvedType formalType = functionalMethod.get().returnType();\n\n            // Infer the functional interfaces' return vs actual type\n            funcInterfaceCtx.addPair(formalType, actualType);\n            // Substitute to obtain a new type\n            ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n            // if the functional method returns void anyway\n            // we don't need to bother inferring types\n            if (!(formalType instanceof ResolvedVoidType)) {\n                lambdaCtx.addPair(result, functionalTypeWithReturn);\n                result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public ResolvedType visit(MethodReferenceExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on method reference expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                MethodUsage usage = facade.solveMethodAsUsage(callExpr);\n                ResolvedType result = usage.getParamType(pos);\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethodOpt.isPresent()) {\n                    MethodUsage functionalMethod = functionalMethodOpt.get();\n\n                    for (Pair<ResolvedTypeParameterDeclaration, ResolvedType> typeParamDecl : result.asReferenceType().getTypeParametersMap()) {\n                        functionalMethod = functionalMethod.replaceTypeParameter(typeParamDecl.a, typeParamDecl.b);\n                    }\n\n                    // replace wildcards\n                    for (int i = 0; i < functionalMethod.getNoParams(); i++) {\n                        ResolvedType type = functionalMethod.getParamType(i);\n                        if (type.isWildcard()) {\n                            ResolvedType boundedType = type.asWildcard().getBoundedType();\n                            functionalMethod = functionalMethod.replaceParamType(i, boundedType);\n                        }\n                    }\n\n                    ResolvedType actualType = facade.toMethodUsage(node, functionalMethod.getParamTypes()).returnType();\n                    ResolvedType formalType = functionalMethod.returnType();\n\n                    InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                    inferenceContext.addPair(formalType, actualType);\n                    result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                }\n\n                return result;\n            }\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n        }\n        throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n    }\n\n    @Override\n    public ResolvedType visit(FieldDeclaration node, Boolean solveLambdas) {\n        if (node.getVariables().size() == 1) {\n            return node.getVariables().get(0).accept(this, solveLambdas);\n        }\n        throw new IllegalArgumentException(\"Cannot resolve the type of a field with multiple variable declarations. Pick one\");\n    }\n}\n", "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solveGenericTypes;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.ReturnStmt;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnknownType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.symbolsolver.logic.InferenceContext;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.Value;\nimport com.github.javaparser.symbolsolver.model.typesystem.NullType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.MyObjectProvider;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.symbolsolver.resolution.promotion.ConditionalExprHandler;\nimport com.github.javaparser.symbolsolver.resolution.promotion.ConditionalExprResolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.github.javaparser.utils.Log;\nimport com.github.javaparser.utils.Pair;\nimport com.google.common.collect.ImmutableList;\n\npublic class TypeExtractor extends DefaultVisitorAdapter {\n\n    private static final String JAVA_LANG_STRING = String.class.getCanonicalName();\n    private final ReferenceTypeImpl stringReferenceType;\n\n    private TypeSolver typeSolver;\n    private JavaParserFacade facade;\n    \n\n    public TypeExtractor(TypeSolver typeSolver, JavaParserFacade facade) {\n        this.typeSolver = typeSolver;\n        this.facade = facade;\n        //pre-calculate the String reference (optimization)\n        stringReferenceType = new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(JAVA_LANG_STRING), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarator node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof FieldDeclaration) {\n            return facade.convertToUsageVariableType(node);\n        } else if (demandParentNode(node) instanceof VariableDeclarationExpr) {\n            return facade.convertToUsageVariableType(node);\n        }\n        throw new UnsupportedOperationException(demandParentNode(node).getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(Parameter node, Boolean solveLambdas) {\n        if (node.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + node);\n        }\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n\n    @Override\n    public ResolvedType visit(ArrayAccessExpr node, Boolean solveLambdas) {\n        ResolvedType arrayUsageType = node.getName().accept(this, solveLambdas);\n        if (arrayUsageType.isArray()) {\n            return ((ResolvedArrayType) arrayUsageType).getComponentType();\n        }\n        return arrayUsageType;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayCreationExpr node, Boolean solveLambdas) {\n        ResolvedType res = facade.convertToUsage(node.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i = 0; i < node.getLevels().size(); i++) {\n            res = new ResolvedArrayType(res);\n        }\n        return res;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayInitializerExpr node, Boolean solveLambdas) {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(AssignExpr node, Boolean solveLambdas) {\n        return node.getTarget().accept(this, solveLambdas);\n    }\n\n    @Override\n    public ResolvedType visit(BinaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case PLUS:\n            case MINUS:\n            case DIVIDE:\n            case MULTIPLY:\n            case REMAINDER:\n            case BINARY_AND:\n            case BINARY_OR:\n            case XOR:\n                return facade.getBinaryTypeConcrete(node.getLeft(), node.getRight(), solveLambdas, node.getOperator());\n            case LESS_EQUALS:\n            case LESS:\n            case GREATER:\n            case GREATER_EQUALS:\n            case EQUALS:\n            case NOT_EQUALS:\n            case OR:\n            case AND:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case SIGNED_RIGHT_SHIFT:\n            case UNSIGNED_RIGHT_SHIFT:\n            case LEFT_SHIFT:\n                ResolvedType rt = node.getLeft().accept(this, solveLambdas);\n                // apply unary primitive promotion\n                return ResolvedPrimitiveType.unp(rt);\n            default:\n                throw new UnsupportedOperationException(\"Operator \" + node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(CastExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    @Override\n    public ResolvedType visit(ClassExpr node, Boolean solveLambdas) {\n        // This implementation does not regard the actual type argument of the ClassExpr.\n        Type astType = node.getType();\n        ResolvedType jssType = facade.convertToUsage(astType, node.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    }\n\n    /*\n     * The conditional operator has three operand expressions. ? appears between the first and second expressions, and\n     * : appears between the second and third expressions.\n     * There are three kinds of conditional expressions, classified according to the second and third operand\n     * expressions: boolean conditional expressions, numeric conditional expressions, and reference conditional\n     * expressions.\n     * The classification rules are as follows:\n     * 1/ If both the second and the third operand expressions are boolean expressions, the conditional expression is a\n     * boolean conditional expression.\n     * 2/ If both the second and the third operand expressions are numeric expressions, the conditional expression is a\n     * numeric conditional expression.\n     * 3/ Otherwise, the conditional expression is a reference conditional expression\n     */\n    @Override\n    public ResolvedType visit(ConditionalExpr node, Boolean solveLambdas) {\n        ResolvedType thenExpr = node.getThenExpr().accept(this, solveLambdas);\n        ResolvedType elseExpr = node.getElseExpr().accept(this, solveLambdas);\n\n        ConditionalExprHandler rce = ConditionalExprResolver.getConditionExprHandler(thenExpr, elseExpr);\n        try {\n            return rce.resolveType();\n        } catch (UnsupportedOperationException e) {\n            // There is nothing to do because, for the moment, we want to run actual implementation\n        }\n        return node.getThenExpr().accept(this, solveLambdas);\n    }\n    \n    private boolean isCompatible(ResolvedType resolvedType, ResolvedPrimitiveType primitiveType) {\n        return (resolvedType.isPrimitive() && resolvedType.asPrimitive().equals(primitiveType))\n        || (resolvedType.isReferenceType() && resolvedType.asReferenceType().isUnboxableTo(primitiveType));\n    }\n\n    @Override\n    public ResolvedType visit(EnclosedExpr node, Boolean solveLambdas) {\n        return node.getInner().accept(this, solveLambdas);\n    }\n\n    /**\n     * Java Parser can't differentiate between packages, internal types, and fields.\n     * All three are lumped together into FieldAccessExpr. We need to differentiate them.\n     */\n    private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {\n        // Fields and internal type declarations cannot have the same name.\n        // Thus, these checks will always be mutually exclusive.\n        if (parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())) {\n            return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();\n        } else if (parentType.hasField(node.getName().getId())) {\n            return parentType.getField(node.getName().getId()).getType();\n        } else if (parentType.hasInternalType(node.getName().getId())) {\n            return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()), typeSolver);\n        } else {\n            throw new UnsolvedSymbolException(node.getName().getId());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = createSolver().solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(InstanceOfExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(StringLiteralExpr node, Boolean solveLambdas) {\n        return stringReferenceType;\n    }\n\n    @Override\n    public ResolvedType visit(IntegerLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.INT;\n    }\n\n    @Override\n    public ResolvedType visit(LongLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.LONG;\n    }\n\n    @Override\n    public ResolvedType visit(CharLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.CHAR;\n    }\n\n    @Override\n    public ResolvedType visit(DoubleLiteralExpr node, Boolean solveLambdas) {\n        if (node.getValue().toLowerCase().endsWith(\"f\")) {\n            return ResolvedPrimitiveType.FLOAT;\n        }\n        return ResolvedPrimitiveType.DOUBLE;\n    }\n\n    @Override\n    public ResolvedType visit(BooleanLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(NullLiteralExpr node, Boolean solveLambdas) {\n        return NullType.INSTANCE;\n    }\n\n    @Override\n    public ResolvedType visit(MethodCallExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on method call %s\", ()-> node);\n        // first solve the method\n        MethodUsage ref = facade.solveMethodAsUsage(node);\n        Log.trace(\"getType on method call %s resolved to %s\", ()-> node, ()-> ref);\n        Log.trace(\"getType on method call %s return type is %s\", ()-> node, ref::returnType);\n        return ref.returnType();\n        // the type is the return type of the method\n    }\n\n    @Override\n    public ResolvedType visit(NameExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on name expr %s\", ()-> node);\n        Optional<Value> value = createSolver().solveSymbolAsValue(node.getName().getId(), node);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, node.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    }\n\n    @Override\n    public ResolvedType visit(TypeExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on type expr %s\", ()-> node);\n        if (!(node.getType() instanceof ClassOrInterfaceType)) {\n            throw new UnsupportedOperationException(node.getType().getClass().getCanonicalName());\n        }\n\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) node.getType();\n        String nameWithScope = classOrInterfaceType.getNameWithScope();\n\n        // JLS 15.13 - ReferenceType :: [TypeArguments] Identifier\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = JavaParserFactory\n                .getContext(classOrInterfaceType, typeSolver)\n                .solveType(nameWithScope);\n        if (typeDeclarationSymbolReference.isSolved()) {\n            return new ReferenceTypeImpl(typeDeclarationSymbolReference.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n\n        // JLS 15.13 - ExpressionName :: [TypeArguments] Identifier\n        Optional<Value> value = createSolver().solveSymbolAsValue(nameWithScope, node);\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n\n        throw new UnsolvedSymbolException(\"Solving \" + node, classOrInterfaceType.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(ObjectCreationExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n    @Override\n    public ResolvedType visit(ThisExpr node, Boolean solveLambdas) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve locally in Compilation unit\n            // first try a buttom/up approach\n            try {\n                return new ReferenceTypeImpl(\n                        facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node, className)),\n                        typeSolver);\n            } catch (IllegalStateException e) {\n                // trying another approach from type solver\n                Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n                SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n                if (clazz.isSolved()) {\n                    return new ReferenceTypeImpl(clazz.getCorrespondingDeclaration(), typeSolver);\n                }\n            }\n        }\n        return new ReferenceTypeImpl(facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node)), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(SuperExpr node, Boolean solveLambdas) {\n        // If 'super' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            String className = node.getTypeName().get().asString();\n            SymbolReference<ResolvedTypeDeclaration> resolvedTypeNameRef = JavaParserFactory.getContext(node, typeSolver).solveType(className);\n            if (resolvedTypeNameRef.isSolved()) {\n                // Cfr JLS $15.12.1\n                ResolvedTypeDeclaration resolvedTypeName = resolvedTypeNameRef.getCorrespondingDeclaration();\n                if (resolvedTypeName.isInterface()) {\n                    return new ReferenceTypeImpl(resolvedTypeName.asInterface(), typeSolver);\n                } else if (resolvedTypeName.isClass()) {\n                    // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n                    return resolvedTypeName.asClass().getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n                } else {\n                    throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n                }\n            } else {\n                throw new UnsolvedSymbolException(className);\n            }\n        }\n\n        ResolvedTypeDeclaration typeOfNode = facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node));\n        if (typeOfNode instanceof ResolvedClassDeclaration) {\n            // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n            return ((ResolvedClassDeclaration) typeOfNode).getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(UnaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case MINUS:\n            case PLUS:\n                return ResolvedPrimitiveType.unp(node.getExpression().accept(this, solveLambdas));\n            case LOGICAL_COMPLEMENT:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case POSTFIX_DECREMENT:\n            case PREFIX_DECREMENT:\n            case POSTFIX_INCREMENT:\n            case PREFIX_INCREMENT:\n            case BITWISE_COMPLEMENT:\n                return node.getExpression().accept(this, solveLambdas);\n            default:\n                throw new UnsupportedOperationException(node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarationExpr node, Boolean solveLambdas) {\n        if (node.getVariables().size() != 1) {\n            throw new UnsupportedOperationException();\n        }\n        return facade.convertToUsageVariableType(node.getVariables().get(0));\n    }\n\n\n    @Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n\n            // The type parameter referred here should be the java.util.stream.Stream.T\n            ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n            if (solveLambdas) {\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof VariableDeclarator)\n        {\n            VariableDeclarator decExpr = (VariableDeclarator) demandParentNode(node);\n            ResolvedType result = decExpr.getType().resolve();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof AssignExpr) {\n            AssignExpr assExpr = (AssignExpr) demandParentNode(node);\n            ResolvedType result = assExpr.calculateResolvedType();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }\n\n    private ResolvedType resolveLambda(LambdaExpr node, ResolvedType result) {\n        // We need to replace the type variables\n        Context ctx = JavaParserFactory.getContext(node, typeSolver);\n        result = solveGenericTypes(result, ctx);\n\n        //We should find out which is the functional method (e.g., apply) and replace the params of the\n        //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n        //lambdas\n        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n        if (functionalMethod.isPresent()) {\n            LambdaExpr lambdaExpr = node;\n\n            InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n            InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n            // At this point parameterType\n            // if Function<T=? super Stream.T, ? extends map.R>\n            // we should replace Stream.T\n            ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n            lambdaCtx.addPair(result, functionalInterfaceType);\n\n            ResolvedType actualType;\n\n            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n            } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                // Get all the return statements in the lambda block\n                List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                if (returnStmts.size() > 0) {\n                    actualType = returnStmts.stream()\n                            .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                            .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                            .findFirst()\n                            .orElse(ResolvedVoidType.INSTANCE);\n\n                } else {\n                    actualType = ResolvedVoidType.INSTANCE;\n                }\n\n\n            } else {\n                throw new UnsupportedOperationException();\n            }\n\n            ResolvedType formalType = functionalMethod.get().returnType();\n\n            // Infer the functional interfaces' return vs actual type\n            funcInterfaceCtx.addPair(formalType, actualType);\n            // Substitute to obtain a new type\n            ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n            // if the functional method returns void anyway\n            // we don't need to bother inferring types\n            if (!(formalType instanceof ResolvedVoidType)) {\n                lambdaCtx.addPair(result, functionalTypeWithReturn);\n                result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public ResolvedType visit(MethodReferenceExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on method reference expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                MethodUsage usage = facade.solveMethodAsUsage(callExpr);\n                ResolvedType result = usage.getParamType(pos);\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethodOpt.isPresent()) {\n                    MethodUsage functionalMethod = functionalMethodOpt.get();\n\n                    for (Pair<ResolvedTypeParameterDeclaration, ResolvedType> typeParamDecl : result.asReferenceType().getTypeParametersMap()) {\n                        functionalMethod = functionalMethod.replaceTypeParameter(typeParamDecl.a, typeParamDecl.b);\n                    }\n\n                    // replace wildcards\n                    for (int i = 0; i < functionalMethod.getNoParams(); i++) {\n                        ResolvedType type = functionalMethod.getParamType(i);\n                        if (type.isWildcard()) {\n                            ResolvedType boundedType = type.asWildcard().getBoundedType();\n                            functionalMethod = functionalMethod.replaceParamType(i, boundedType);\n                        }\n                    }\n\n                    ResolvedType actualType = facade.toMethodUsage(node, functionalMethod.getParamTypes()).returnType();\n                    ResolvedType formalType = functionalMethod.returnType();\n\n                    InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                    inferenceContext.addPair(formalType, actualType);\n                    result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                }\n\n                return result;\n            }\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n        }\n        throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n    }\n\n    @Override\n    public ResolvedType visit(FieldDeclaration node, Boolean solveLambdas) {\n        if (node.getVariables().size() == 1) {\n            return node.getVariables().get(0).accept(this, solveLambdas);\n        }\n        throw new IllegalArgumentException(\"Cannot resolve the type of a field with multiple variable declarations. Pick one\");\n    }\n\n    protected SymbolSolver createSolver() {\n        return new SymbolSolver(typeSolver);\n    }\n}\n", "diffSourceCodeSet": ["protected SymbolSolver createSolver() {\n        return new SymbolSolver(typeSolver);\n    }"], "invokedMethodSet": ["methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor#solveDotExpressionType\n methodBody: private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {\nif(parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())){return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();\n}if(parentType.hasField(node.getName().getId())){return parentType.getField(node.getName().getId()).getType();\n}if(parentType.hasInternalType(node.getName().getId())){return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()),typeSolver);\n}{throw new UnsolvedSymbolException(node.getName().getId());\n}}"], "sourceCodeAfterRefactoring": "@Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = createSolver().solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }\nprotected SymbolSolver createSolver() {\n        return new SymbolSolver(typeSolver);\n    }", "diffSourceCode": "   234:     @Override\n   235:     public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n   236:         // We should understand if this is a static access\n   237:         if (node.getScope() instanceof NameExpr ||\n   238:                 node.getScope() instanceof FieldAccessExpr) {\n   239:             Expression staticValue = node.getScope();\n   240:             SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n   241:             if (typeAccessedStatically.isSolved()) {\n   242:                 // TODO here maybe we have to substitute type typeParametersValues\n   243:                 return solveDotExpressionType(\n   244:                         typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n   245:             }\n   246:         } else if (node.getScope() instanceof ThisExpr) {\n   247:             // If we are accessing through a 'this' expression, first resolve the type\n   248:             // corresponding to 'this'\n   249:             SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n   250:             // If found get it's declaration and get the field in there\n   251:             if (solve.isSolved()) {\n   252:                 ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n   253:                 if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n   254:                     return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n   255:                 }\n   256:             }\n   257: \n   258:         } else if (node.getScope().toString().indexOf('.') > 0) {\n   259:             // try to find fully qualified name\n   260:             SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n   261:             if (sr.isSolved()) {\n   262:                 return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n   263:             }\n   264:         }\n   265:         Optional<Value> value = Optional.empty();\n   266:         try {\n-  267:             value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n+  267:             value = createSolver().solveSymbolAsValue(node.getName().getId(), node);\n   268:         } catch (UnsolvedSymbolException use) {\n   269:             // This node may have a package name as part of its fully qualified name.\n   270:             // We should solve for the type declaration inside this package.\n   271:             SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n   272:             if (sref.isSolved()) {\n   273:                 return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n   274:             }\n   275:         }\n   276:         if (value.isPresent()) {\n   277:             return value.get().getType();\n   278:         }\n   279:         throw new UnsolvedSymbolException(node.getName().getId());\n   280:     }\n+  652:     protected SymbolSolver createSolver() {\n+  653:         return new SymbolSolver(typeSolver);\n+  654:     }\n", "uniqueId": "b22ebb29abb4e6dcc1d22ca9823e5b2a3473b6a8_234_280_652_654_234_280", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 5, "covered": 15}, "BRANCH": {"missed": 1, "covered": 1}, "LINE": {"missed": 1, "covered": 2}, "COMPLEXITY": {"missed": 1, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `visit(FieldAccessExpr node, Boolean solveLambdas)` method, we can extract several parts of the logic into separate methods. This will help to clarify the purpose of each section of the code and reduce the complexity of the main method.\n\nHere\u2019s the refactored code with the extracted methods:\n\n```java\n@Override\npublic ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n    if (isStaticAccess(node)) {\n        return handleStaticAccess(node);\n    } else if (node.getScope() instanceof ThisExpr) {\n        return handleThisAccess(node);\n    } else if (isFullyQualifiedName(node)) {\n        return handleFullyQualifiedName(node);\n    }\n\n    return handleUnsolvedSymbol(node);\n}\n\nprivate boolean isStaticAccess(FieldAccessExpr node) {\n    return node.getScope() instanceof NameExpr || node.getScope() instanceof FieldAccessExpr;\n}\n\nprivate ResolvedType handleStaticAccess(FieldAccessExpr node) {\n    Expression staticValue = node.getScope();\n    SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n    if (typeAccessedStatically.isSolved()) {\n        return solveDotExpressionType(typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n    }\n    throw new UnsolvedSymbolException(node.getName().getId());\n}\n\nprivate ResolvedType handleThisAccess(FieldAccessExpr node) {\n    SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n    if (solve.isSolved()) {\n        ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n        if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n            return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n        }\n    }\n    throw new UnsolvedSymbolException(node.getName().getId());\n}\n\nprivate boolean isFullyQualifiedName(FieldAccessExpr node) {\n    return node.getScope().toString().indexOf('.') > 0;\n}\n\nprivate ResolvedType handleFullyQualifiedName(FieldAccessExpr node) {\n    SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n    if (sr.isSolved()) {\n        return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n    }\n    throw new UnsolvedSymbolException(node.getName().getId());\n}\n\nprivate ResolvedType handleUnsolvedSymbol(FieldAccessExpr node) {\n    Optional<Value> value = Optional.empty();\n    try {\n        value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n    } catch (UnsolvedSymbolException use) {\n        SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n        if (sref.isSolved()) {\n            return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n        }\n    }\n    if (value.isPresent()) {\n        return value.get().getType();\n    }\n    throw new UnsolvedSymbolException(node.getName().getId());\n}\n```\n\nThis refactoring extracts the logic for handling different types of access (static, `this`, fully qualified names, and unsolved symbols) into separate methods. This makes the `visit(FieldAccessExpr node, Boolean solveLambdas)` method much clearer and easier to understand at a glance.\n\n##########################\n```java\n@Override\npublic ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n    if (isStaticAccess(node)) {\n        return handleStaticAccess(node);\n    } else if (node.getScope() instanceof ThisExpr) {\n        return handleThisAccess(node);\n    } else if (isFullyQualifiedName(node)) {\n        return handleFullyQualifiedName(node);\n    }\n\n    return handleUnsolvedSymbol(node);\n}\n\nprivate boolean isStaticAccess(FieldAccessExpr node) {\n    return node.getScope() instanceof NameExpr || node.getScope() instanceof FieldAccessExpr;\n}\n\nprivate ResolvedType handleStaticAccess(FieldAccessExpr node) {\n    Expression staticValue = node.getScope();\n    SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n    if (typeAccessedStatically.isSolved()) {\n        return solveDotExpressionType(typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n    }\n    throw new UnsolvedSymbolException(node.getName().getId());\n}\n\nprivate ResolvedType handleThisAccess(FieldAccessExpr node) {\n    SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n    if (solve.isSolved()) {\n        ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n        if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n            return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n        }\n    }\n    throw new UnsolvedSymbolException(node.getName().getId());\n}\n\nprivate boolean isFullyQualifiedName(FieldAccessExpr node) {\n    return node.getScope().toString().indexOf('.') > 0;\n}\n\nprivate ResolvedType handleFullyQualifiedName(FieldAccessExpr node) {\n    SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n    if (sr.isSolved()) {\n        return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n    }\n    throw new UnsolvedSymbolException(node.getName().getId());\n}\n\nprivate ResolvedType handleUnsolvedSymbol(FieldAccessExpr node) {\n    Optional<Value> value = Optional.empty();\n    try {\n        value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n    } catch (UnsolvedSymbolException use) {\n        SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n        if (sref.isSolved()) {\n            return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n        }\n    }\n    if (value.isPresent()) {\n        return value.get().getType();\n    }\n    throw new UnsolvedSymbolException(node.getName().getId());\n}\n```\n##########################\n", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }\n\nClass content:\n/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solveGenericTypes;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.ReturnStmt;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnknownType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.symbolsolver.logic.InferenceContext;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.Value;\nimport com.github.javaparser.symbolsolver.model.typesystem.NullType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.MyObjectProvider;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.symbolsolver.resolution.promotion.ConditionalExprHandler;\nimport com.github.javaparser.symbolsolver.resolution.promotion.ConditionalExprResolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.github.javaparser.utils.Log;\nimport com.github.javaparser.utils.Pair;\nimport com.google.common.collect.ImmutableList;\n\npublic class TypeExtractor extends DefaultVisitorAdapter {\n\n    private static final String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private TypeSolver typeSolver;\n    private JavaParserFacade facade;\n    \n    private ReferenceTypeImpl StringReferenceType;\n\n    public TypeExtractor(TypeSolver typeSolver, JavaParserFacade facade) {\n        this.typeSolver = typeSolver;\n        this.facade = facade;\n        //pre-calculate the String reference (optimization)\n        StringReferenceType = new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(JAVA_LANG_STRING), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarator node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof FieldDeclaration) {\n            return facade.convertToUsageVariableType(node);\n        } else if (demandParentNode(node) instanceof VariableDeclarationExpr) {\n            return facade.convertToUsageVariableType(node);\n        }\n        throw new UnsupportedOperationException(demandParentNode(node).getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(Parameter node, Boolean solveLambdas) {\n        if (node.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + node);\n        }\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n\n    @Override\n    public ResolvedType visit(ArrayAccessExpr node, Boolean solveLambdas) {\n        ResolvedType arrayUsageType = node.getName().accept(this, solveLambdas);\n        if (arrayUsageType.isArray()) {\n            return ((ResolvedArrayType) arrayUsageType).getComponentType();\n        }\n        return arrayUsageType;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayCreationExpr node, Boolean solveLambdas) {\n        ResolvedType res = facade.convertToUsage(node.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i = 0; i < node.getLevels().size(); i++) {\n            res = new ResolvedArrayType(res);\n        }\n        return res;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayInitializerExpr node, Boolean solveLambdas) {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(AssignExpr node, Boolean solveLambdas) {\n        return node.getTarget().accept(this, solveLambdas);\n    }\n\n    @Override\n    public ResolvedType visit(BinaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case PLUS:\n            case MINUS:\n            case DIVIDE:\n            case MULTIPLY:\n            case REMAINDER:\n            case BINARY_AND:\n            case BINARY_OR:\n            case XOR:\n                return facade.getBinaryTypeConcrete(node.getLeft(), node.getRight(), solveLambdas, node.getOperator());\n            case LESS_EQUALS:\n            case LESS:\n            case GREATER:\n            case GREATER_EQUALS:\n            case EQUALS:\n            case NOT_EQUALS:\n            case OR:\n            case AND:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case SIGNED_RIGHT_SHIFT:\n            case UNSIGNED_RIGHT_SHIFT:\n            case LEFT_SHIFT:\n                ResolvedType rt = node.getLeft().accept(this, solveLambdas);\n                // apply unary primitive promotion\n                return ResolvedPrimitiveType.unp(rt);\n            default:\n                throw new UnsupportedOperationException(\"Operator \" + node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(CastExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    @Override\n    public ResolvedType visit(ClassExpr node, Boolean solveLambdas) {\n        // This implementation does not regard the actual type argument of the ClassExpr.\n        Type astType = node.getType();\n        ResolvedType jssType = facade.convertToUsage(astType, node.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    }\n\n    /*\n     * The conditional operator has three operand expressions. ? appears between the first and second expressions, and\n     * : appears between the second and third expressions.\n     * There are three kinds of conditional expressions, classified according to the second and third operand\n     * expressions: boolean conditional expressions, numeric conditional expressions, and reference conditional\n     * expressions.\n     * The classification rules are as follows:\n     * 1/ If both the second and the third operand expressions are boolean expressions, the conditional expression is a\n     * boolean conditional expression.\n     * 2/ If both the second and the third operand expressions are numeric expressions, the conditional expression is a\n     * numeric conditional expression.\n     * 3/ Otherwise, the conditional expression is a reference conditional expression\n     */\n    @Override\n    public ResolvedType visit(ConditionalExpr node, Boolean solveLambdas) {\n        ResolvedType thenExpr = node.getThenExpr().accept(this, solveLambdas);\n        ResolvedType elseExpr = node.getElseExpr().accept(this, solveLambdas);\n\n        ConditionalExprHandler rce = ConditionalExprResolver.getConditionExprHandler(thenExpr, elseExpr);\n        try {\n            return rce.resolveType();\n        } catch (UnsupportedOperationException e) {\n            // There is nothing to do because, for the moment, we want to run actual implementation\n        }\n        return node.getThenExpr().accept(this, solveLambdas);\n    }\n    \n    private boolean isCompatible(ResolvedType resolvedType, ResolvedPrimitiveType primitiveType) {\n        return (resolvedType.isPrimitive() && resolvedType.asPrimitive().equals(primitiveType))\n        || (resolvedType.isReferenceType() && resolvedType.asReferenceType().isUnboxableTo(primitiveType));\n    }\n\n    @Override\n    public ResolvedType visit(EnclosedExpr node, Boolean solveLambdas) {\n        return node.getInner().accept(this, solveLambdas);\n    }\n\n    /**\n     * Java Parser can't differentiate between packages, internal types, and fields.\n     * All three are lumped together into FieldAccessExpr. We need to differentiate them.\n     */\n    private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {\n        // Fields and internal type declarations cannot have the same name.\n        // Thus, these checks will always be mutually exclusive.\n        if (parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())) {\n            return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();\n        } else if (parentType.hasField(node.getName().getId())) {\n            return parentType.getField(node.getName().getId()).getType();\n        } else if (parentType.hasInternalType(node.getName().getId())) {\n            return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()), typeSolver);\n        } else {\n            throw new UnsolvedSymbolException(node.getName().getId());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(InstanceOfExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(StringLiteralExpr node, Boolean solveLambdas) {\n        return StringReferenceType;\n    }\n\n    @Override\n    public ResolvedType visit(IntegerLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.INT;\n    }\n\n    @Override\n    public ResolvedType visit(LongLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.LONG;\n    }\n\n    @Override\n    public ResolvedType visit(CharLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.CHAR;\n    }\n\n    @Override\n    public ResolvedType visit(DoubleLiteralExpr node, Boolean solveLambdas) {\n        if (node.getValue().toLowerCase().endsWith(\"f\")) {\n            return ResolvedPrimitiveType.FLOAT;\n        }\n        return ResolvedPrimitiveType.DOUBLE;\n    }\n\n    @Override\n    public ResolvedType visit(BooleanLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(NullLiteralExpr node, Boolean solveLambdas) {\n        return NullType.INSTANCE;\n    }\n\n    @Override\n    public ResolvedType visit(MethodCallExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on method call %s\", ()-> node);\n        // first solve the method\n        MethodUsage ref = facade.solveMethodAsUsage(node);\n        Log.trace(\"getType on method call %s resolved to %s\", ()-> node, ()-> ref);\n        Log.trace(\"getType on method call %s return type is %s\", ()-> node, ref::returnType);\n        return ref.returnType();\n        // the type is the return type of the method\n    }\n\n    @Override\n    public ResolvedType visit(NameExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on name expr %s\", ()-> node);\n        Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, node.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    }\n\n    @Override\n    public ResolvedType visit(TypeExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on type expr %s\", ()-> node);\n        if (!(node.getType() instanceof ClassOrInterfaceType)) {\n            throw new UnsupportedOperationException(node.getType().getClass().getCanonicalName());\n        }\n\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) node.getType();\n        String nameWithScope = classOrInterfaceType.getNameWithScope();\n\n        // JLS 15.13 - ReferenceType :: [TypeArguments] Identifier\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = JavaParserFactory\n                .getContext(classOrInterfaceType, typeSolver)\n                .solveType(nameWithScope);\n        if (typeDeclarationSymbolReference.isSolved()) {\n            return new ReferenceTypeImpl(typeDeclarationSymbolReference.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n\n        // JLS 15.13 - ExpressionName :: [TypeArguments] Identifier\n        Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameWithScope, node);\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n\n        throw new UnsolvedSymbolException(\"Solving \" + node, classOrInterfaceType.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(ObjectCreationExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n    @Override\n    public ResolvedType visit(ThisExpr node, Boolean solveLambdas) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve locally in Compilation unit\n            // first try a buttom/up approach\n            try {\n                return new ReferenceTypeImpl(\n                        facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node, className)),\n                        typeSolver);\n            } catch (IllegalStateException e) {\n                // trying another approach from type solver\n                Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n                SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n                if (clazz.isSolved()) {\n                    return new ReferenceTypeImpl(clazz.getCorrespondingDeclaration(), typeSolver);\n                }\n            }\n        }\n        return new ReferenceTypeImpl(facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node)), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(SuperExpr node, Boolean solveLambdas) {\n        // If 'super' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            String className = node.getTypeName().get().asString();\n            SymbolReference<ResolvedTypeDeclaration> resolvedTypeNameRef = JavaParserFactory.getContext(node, typeSolver).solveType(className);\n            if (resolvedTypeNameRef.isSolved()) {\n                // Cfr JLS $15.12.1\n                ResolvedTypeDeclaration resolvedTypeName = resolvedTypeNameRef.getCorrespondingDeclaration();\n                if (resolvedTypeName.isInterface()) {\n                    return new ReferenceTypeImpl(resolvedTypeName.asInterface(), typeSolver);\n                } else if (resolvedTypeName.isClass()) {\n                    // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n                    return resolvedTypeName.asClass().getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n                } else {\n                    throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n                }\n            } else {\n                throw new UnsolvedSymbolException(className);\n            }\n        }\n\n        ResolvedTypeDeclaration typeOfNode = facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node));\n        if (typeOfNode instanceof ResolvedClassDeclaration) {\n            // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n            return ((ResolvedClassDeclaration) typeOfNode).getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(UnaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case MINUS:\n            case PLUS:\n                return ResolvedPrimitiveType.unp(node.getExpression().accept(this, solveLambdas));\n            case LOGICAL_COMPLEMENT:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case POSTFIX_DECREMENT:\n            case PREFIX_DECREMENT:\n            case POSTFIX_INCREMENT:\n            case PREFIX_INCREMENT:\n            case BITWISE_COMPLEMENT:\n                return node.getExpression().accept(this, solveLambdas);\n            default:\n                throw new UnsupportedOperationException(node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarationExpr node, Boolean solveLambdas) {\n        if (node.getVariables().size() != 1) {\n            throw new UnsupportedOperationException();\n        }\n        return facade.convertToUsageVariableType(node.getVariables().get(0));\n    }\n\n\n    @Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n\n            // The type parameter referred here should be the java.util.stream.Stream.T\n            ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n            if (solveLambdas) {\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof VariableDeclarator)\n        {\n            VariableDeclarator decExpr = (VariableDeclarator) demandParentNode(node);\n            ResolvedType result = decExpr.getType().resolve();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof AssignExpr) {\n            AssignExpr assExpr = (AssignExpr) demandParentNode(node);\n            ResolvedType result = assExpr.calculateResolvedType();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }\n\n    private ResolvedType resolveLambda(LambdaExpr node, ResolvedType result) {\n        // We need to replace the type variables\n        Context ctx = JavaParserFactory.getContext(node, typeSolver);\n        result = solveGenericTypes(result, ctx);\n\n        //We should find out which is the functional method (e.g., apply) and replace the params of the\n        //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n        //lambdas\n        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n        if (functionalMethod.isPresent()) {\n            LambdaExpr lambdaExpr = node;\n\n            InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n            InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n            // At this point parameterType\n            // if Function<T=? super Stream.T, ? extends map.R>\n            // we should replace Stream.T\n            ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n            lambdaCtx.addPair(result, functionalInterfaceType);\n\n            ResolvedType actualType;\n\n            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n            } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                // Get all the return statements in the lambda block\n                List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                if (returnStmts.size() > 0) {\n                    actualType = returnStmts.stream()\n                            .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                            .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                            .findFirst()\n                            .orElse(ResolvedVoidType.INSTANCE);\n\n                } else {\n                    actualType = ResolvedVoidType.INSTANCE;\n                }\n\n\n            } else {\n                throw new UnsupportedOperationException();\n            }\n\n            ResolvedType formalType = functionalMethod.get().returnType();\n\n            // Infer the functional interfaces' return vs actual type\n            funcInterfaceCtx.addPair(formalType, actualType);\n            // Substitute to obtain a new type\n            ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n            // if the functional method returns void anyway\n            // we don't need to bother inferring types\n            if (!(formalType instanceof ResolvedVoidType)) {\n                lambdaCtx.addPair(result, functionalTypeWithReturn);\n                result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public ResolvedType visit(MethodReferenceExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on method reference expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                MethodUsage usage = facade.solveMethodAsUsage(callExpr);\n                ResolvedType result = usage.getParamType(pos);\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethodOpt.isPresent()) {\n                    MethodUsage functionalMethod = functionalMethodOpt.get();\n\n                    for (Pair<ResolvedTypeParameterDeclaration, ResolvedType> typeParamDecl : result.asReferenceType().getTypeParametersMap()) {\n                        functionalMethod = functionalMethod.replaceTypeParameter(typeParamDecl.a, typeParamDecl.b);\n                    }\n\n                    // replace wildcards\n                    for (int i = 0; i < functionalMethod.getNoParams(); i++) {\n                        ResolvedType type = functionalMethod.getParamType(i);\n                        if (type.isWildcard()) {\n                            ResolvedType boundedType = type.asWildcard().getBoundedType();\n                            functionalMethod = functionalMethod.replaceParamType(i, boundedType);\n                        }\n                    }\n\n                    ResolvedType actualType = facade.toMethodUsage(node, functionalMethod.getParamTypes()).returnType();\n                    ResolvedType formalType = functionalMethod.returnType();\n\n                    InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                    inferenceContext.addPair(formalType, actualType);\n                    result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                }\n\n                return result;\n            }\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n        }\n        throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n    }\n\n    @Override\n    public ResolvedType visit(FieldDeclaration node, Boolean solveLambdas) {\n        if (node.getVariables().size() == 1) {\n            return node.getVariables().get(0).accept(this, solveLambdas);\n        }\n        throw new IllegalArgumentException(\"Cannot resolve the type of a field with multiple variable declarations. Pick one\");\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate getNewLineToken(lineSeparator LineSeparator) : CsmElement extracted from private replaceEolTokens(differenceElements List<DifferenceElement>, lineSeparator LineSeparator) : void in class com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator", "diffLocations": [{"filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java", "startLine": 147, "endLine": 158, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java", "startLine": 150, "endLine": 156, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java", "startLine": 161, "endLine": 163, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n        for (int i = 0; i < differenceElements.size(); i++) {\n            DifferenceElement differenceElement = differenceElements.get(i);\n            if (differenceElement.isAdded()) {\n                CsmElement element = differenceElement.getElement();\n                boolean isWhitespaceToken = element instanceof CsmToken && ((CsmToken) element).isNewLine();\n                if (isWhitespaceToken) {\n                    differenceElements.set(i, new Added(CsmElement.newline(lineSeparator)));\n                }\n            }\n        }\n    }", "filePathBefore": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java", "isPureRefactoring": true, "commitId": "ed79beb63e87f3a58322aee34b1a2e80cfafbd18", "packageNameBefore": "com.github.javaparser.printer.lexicalpreservation", "classNameBefore": "com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator", "methodNameBefore": "com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator#replaceEolTokens", "invokedMethod": "methodSignature: com.github.javaparser.printer.lexicalpreservation.Reshuffled#getElement\n methodBody: public CsmMix getElement() {\nreturn nextOrder;\n}\nmethodSignature: com.github.javaparser.printer.lexicalpreservation.Added#isAdded\n methodBody: public boolean isAdded() {\nreturn true;\n}\nmethodSignature: com.github.javaparser.printer.lexicalpreservation.DifferenceElement#getElement\n methodBody: CsmElement getElement();\nmethodSignature: com.github.javaparser.printer.lexicalpreservation.DifferenceElement#isAdded\n methodBody: boolean isAdded();\nmethodSignature: com.github.javaparser.printer.lexicalpreservation.Reshuffled#isAdded\n methodBody: public boolean isAdded() {\nreturn false;\n}\nmethodSignature: com.github.javaparser.printer.lexicalpreservation.Added#getElement\n methodBody: public CsmElement getElement() {\nreturn element;\n}", "classSignatureBefore": "class LexicalDifferenceCalculator ", "methodNameBeforeSet": ["com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator#replaceEolTokens"], "classNameBeforeSet": ["com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator"], "classSignatureBeforeSet": ["class LexicalDifferenceCalculator "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2021 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer.lexicalpreservation;\n\nimport com.github.javaparser.GeneratedJavaParserConstants;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.CharLiteralExpr;\nimport com.github.javaparser.ast.expr.StringLiteralExpr;\nimport com.github.javaparser.ast.expr.TextBlockLiteralExpr;\nimport com.github.javaparser.ast.observer.ObservableProperty;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.printer.ConcreteSyntaxModel;\nimport com.github.javaparser.printer.Stringable;\nimport com.github.javaparser.printer.SourcePrinter;\nimport com.github.javaparser.printer.concretesyntaxmodel.*;\nimport com.github.javaparser.printer.lexicalpreservation.changes.Change;\nimport com.github.javaparser.printer.lexicalpreservation.changes.ListAdditionChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.ListRemovalChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.ListReplacementChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.NoChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.PropertyChange;\nimport com.github.javaparser.utils.LineSeparator;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\n\nimport static com.github.javaparser.TokenTypes.eolTokenKind;\n\nclass LexicalDifferenceCalculator {\n\n    /**\n     * The ConcreteSyntaxModel represents the general format. This model is a calculated version of the ConcreteSyntaxModel,\n     * with no condition, no lists, just tokens and node children.\n     */\n    static class CalculatedSyntaxModel {\n        final List<CsmElement> elements;\n\n        CalculatedSyntaxModel(List<CsmElement> elements) {\n            this.elements = elements;\n        }\n\n        public CalculatedSyntaxModel from(int index) {\n            return new CalculatedSyntaxModel(new ArrayList<>(elements.subList(index, elements.size())));\n        }\n\n        @Override\n        public String toString() {\n            return \"CalculatedSyntaxModel{\" +\n                    \"elements=\" + elements +\n                    '}';\n        }\n\n        CalculatedSyntaxModel sub(int start, int end) {\n            return new CalculatedSyntaxModel(elements.subList(start, end));\n        }\n\n        void removeIndentationElements() {\n            elements.removeIf(el -> el instanceof CsmIndent || el instanceof CsmUnindent);\n        }\n    }\n\n    static class CsmChild implements CsmElement {\n        private final Node child;\n\n        public Node getChild() {\n            return child;\n        }\n\n        CsmChild(Node child) {\n            this.child = child;\n        }\n\n        @Override\n        public void prettyPrint(Node node, SourcePrinter printer) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public String toString() {\n            return \"child(\" + child.getClass().getSimpleName()+\")\";\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            CsmChild csmChild = (CsmChild) o;\n\n            return child.equals(csmChild.child);\n        }\n\n        @Override\n        public int hashCode() {\n            return child.hashCode();\n        }\n    }\n\n    List<DifferenceElement> calculateListRemovalDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index) {\n        Node container = nodeList.getParentNodeForChildren();\n        CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterListRemoval(element, observableProperty, nodeList, index);\n        return DifferenceElementCalculator.calculate(original, after);\n    }\n\n    List<DifferenceElement> calculateListAdditionDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node nodeAdded) {\n        Node container = nodeList.getParentNodeForChildren();\n        CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterListAddition(element, observableProperty, nodeList, index, nodeAdded);\n\n        List<DifferenceElement> differenceElements = DifferenceElementCalculator.calculate(original, after);\n\n        // Set the line separator character tokens\n        LineSeparator lineSeparator = container.getLineEndingStyleOrDefault(LineSeparator.SYSTEM);\n        replaceEolTokens(differenceElements, lineSeparator);\n\n        return differenceElements;\n    }\n\n    private void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n        for (int i = 0; i < differenceElements.size(); i++) {\n            DifferenceElement differenceElement = differenceElements.get(i);\n            if (differenceElement.isAdded()) {\n                CsmElement element = differenceElement.getElement();\n                boolean isWhitespaceToken = element instanceof CsmToken && ((CsmToken) element).isNewLine();\n                if (isWhitespaceToken) {\n                    differenceElements.set(i, new Added(CsmElement.newline(lineSeparator)));\n                }\n            }\n        }\n    }\n\n    List<DifferenceElement> calculateListReplacementDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node newValue) {\n        Node container = nodeList.getParentNodeForChildren();\n        CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterListReplacement(element, observableProperty, nodeList, index, newValue);\n        return DifferenceElementCalculator.calculate(original, after);\n    }\n\n    void calculatePropertyChange(NodeText nodeText, Node observedNode, ObservableProperty property, Object oldValue, Object newValue) {\n        if (nodeText == null) {\n            throw new NullPointerException();\n        }\n        CsmElement element = ConcreteSyntaxModel.forClass(observedNode.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, observedNode);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterPropertyChange(element, observedNode, property, oldValue, newValue);\n        List<DifferenceElement> differenceElements = DifferenceElementCalculator.calculate(original, after);\n        Difference difference = new Difference(differenceElements, nodeText, observedNode);\n        difference.apply();\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelForNode(CsmElement csm, Node node) {\n        List<CsmElement> elements = new LinkedList<>();\n        calculatedSyntaxModelForNode(csm, node, elements, new NoChange());\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    CalculatedSyntaxModel calculatedSyntaxModelForNode(Node node) {\n        return calculatedSyntaxModelForNode(ConcreteSyntaxModel.forClass(node.getClass()), node);\n    }\n\n    private void calculatedSyntaxModelForNode(CsmElement csm, Node node, List<CsmElement> elements, Change change) {\n        if (csm instanceof CsmSequence) {\n            CsmSequence csmSequence = (CsmSequence) csm;\n            csmSequence.getElements().forEach(e -> calculatedSyntaxModelForNode(e, node, elements, change));\n        } else if (csm instanceof CsmComment) {\n            // nothing to do\n        } else if (csm instanceof CsmSingleReference) {\n            CsmSingleReference csmSingleReference = (CsmSingleReference)csm;\n            Node child;\n            if (change instanceof PropertyChange && ((PropertyChange)change).getProperty() == csmSingleReference.getProperty()) {\n                child = (Node)((PropertyChange)change).getNewValue();\n            } else {\n                child = csmSingleReference.getProperty().getValueAsSingleReference(node);\n            }\n            if (child != null) {\n                // fix issue #2374\n                // Add node comment if needed (it's not very elegant but it works)\n                // We need to be sure that the node is an ExpressionStmt because we can meet\n                // this class definition\n                // a line comment <This is my class, with my comment> followed by\n                // class A {}\n                // In this case keyworld [class] is considered as a token and [A] is a child element\n                // So if we don't care that the node is an ExpressionStmt we could try to generate a wrong definition\n                // like this [class // This is my class, with my comment A {}]\n                if (node.getComment().isPresent() && node instanceof ExpressionStmt) {\n                    LineSeparator lineSeparator = node.getLineEndingStyleOrDefault(LineSeparator.SYSTEM);\n                    elements.add(new CsmChild(node.getComment().get()));\n                    elements.add(new CsmToken(eolTokenKind(lineSeparator), lineSeparator.asRawString()));\n                }\n                elements.add(new CsmChild(child));\n            }\n        } else if (csm instanceof CsmNone) {\n            // nothing to do\n        } else if (csm instanceof CsmToken) {\n            elements.add(csm);\n        } else if (csm instanceof CsmOrphanCommentsEnding) {\n            // nothing to do\n        } else if (csm instanceof CsmList) {\n            CsmList csmList = (CsmList) csm;\n            if (csmList.getProperty().isAboutNodes()) {\n                Object rawValue = change.getValue(csmList.getProperty(), node);\n                NodeList<?> nodeList;\n                if (rawValue instanceof Optional) {\n                    Optional<?> optional = (Optional<?>)rawValue;\n                    if (optional.isPresent()) {\n                        if (!(optional.get() instanceof NodeList)) {\n                            throw new IllegalStateException(\"Expected NodeList, found \" + optional.get().getClass().getCanonicalName());\n                        }\n                        nodeList = (NodeList<?>) optional.get();\n                    } else {\n                        nodeList = new NodeList<>();\n                    }\n                } else {\n                    if (!(rawValue instanceof NodeList)) {\n                        throw new IllegalStateException(\"Expected NodeList, found \" + rawValue.getClass().getCanonicalName());\n                    }\n                    nodeList = (NodeList<?>) rawValue;\n                }\n                if (!nodeList.isEmpty()) {\n                    calculatedSyntaxModelForNode(csmList.getPreceeding(), node, elements, change);\n                    for (int i = 0; i < nodeList.size(); i++) {\n                        if (i != 0) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPre(), node, elements, change);\n                        }\n                        elements.add(new CsmChild(nodeList.get(i)));\n                        if (i != (nodeList.size() - 1)) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPost(), node, elements, change);\n                        }\n\n                    }\n                    calculatedSyntaxModelForNode(csmList.getFollowing(), node, elements, change);\n                }\n            } else {\n                Collection<?> collection = (Collection<?>) change.getValue(csmList.getProperty(), node);\n                if (!collection.isEmpty()) {\n                    calculatedSyntaxModelForNode(csmList.getPreceeding(), node, elements, change);\n\n                    boolean first = true;\n                    for (Iterator<?> it = collection.iterator(); it.hasNext(); ) {\n                        if (!first) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPre(), node, elements, change);\n                        }\n                        Object value = it.next();\n                        if (value instanceof Modifier) {\n                            Modifier modifier = (Modifier)value;\n                            elements.add(new CsmToken(toToken(modifier)));\n                        } else {\n                            throw new UnsupportedOperationException(it.next().getClass().getSimpleName());\n                        }\n                        if (it.hasNext()) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPost(), node, elements, change);\n                        }\n                        first = false;\n                    }\n                    calculatedSyntaxModelForNode(csmList.getFollowing(), node, elements, change);\n                }\n            }\n        } else if (csm instanceof CsmConditional) {\n            CsmConditional csmConditional = (CsmConditional) csm;\n            boolean satisfied = change.evaluate(csmConditional, node);\n            if (satisfied) {\n                calculatedSyntaxModelForNode(csmConditional.getThenElement(), node, elements, change);\n            } else {\n                calculatedSyntaxModelForNode(csmConditional.getElseElement(), node, elements, change);\n            }\n        } else if (csm instanceof CsmIndent) {\n            elements.add(csm);\n        } else if (csm instanceof CsmUnindent) {\n            elements.add(csm);\n        } else if (csm instanceof CsmAttribute) {\n            CsmAttribute csmAttribute = (CsmAttribute) csm;\n            Object value = change.getValue(csmAttribute.getProperty(), node);\n            String text = value.toString();\n            if (value instanceof Stringable) {\n                text = ((Stringable) value).asString();\n            }\n            elements.add(new CsmToken(csmAttribute.getTokenType(node, value.toString(), text), text));\n        } else if ((csm instanceof CsmString) && (node instanceof StringLiteralExpr)) {\n            // fix #2382:\n            // This method calculates the syntax model _after_ the change has been applied.\n            // If the given change is a PropertyChange, the returned model should\n            // contain the new value, otherwise the original/current value should be used.\n            if (change instanceof PropertyChange) {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.STRING_LITERAL,\n                        \"\\\"\" + ((PropertyChange) change).getNewValue() + \"\\\"\"));\n            } else {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.STRING_LITERAL,\n                        \"\\\"\" + ((StringLiteralExpr) node).getValue() + \"\\\"\"));\n            }\n        } else if ((csm instanceof CsmString) && (node instanceof TextBlockLiteralExpr)) {\n            // FIXME: csm should be CsmTextBlock -- See also #2677\n            if (change instanceof PropertyChange) {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.TEXT_BLOCK_LITERAL,\n                        \"\\\"\\\"\\\"\" + ((PropertyChange) change).getNewValue() + \"\\\"\\\"\\\"\"));\n            } else {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.TEXT_BLOCK_LITERAL,\n                        \"\\\"\\\"\\\"\" + ((TextBlockLiteralExpr) node).getValue() + \"\\\"\\\"\\\"\"));\n            }\n        } else if ((csm instanceof CsmChar) && (node instanceof CharLiteralExpr)) {\n            if (change instanceof PropertyChange) {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.CHAR,\n                        \"'\" + ((PropertyChange) change).getNewValue() + \"'\"));\n            } else {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.CHAR,\n                        \"'\" + ((CharLiteralExpr) node).getValue() + \"'\"));\n            }\n        } else if (csm instanceof CsmMix) {\n            CsmMix csmMix = (CsmMix)csm;\n            List<CsmElement> mixElements = new LinkedList<>();\n            csmMix.getElements().forEach(e -> calculatedSyntaxModelForNode(e, node, mixElements, change));\n            elements.add(new CsmMix(mixElements));\n        } else if (csm instanceof CsmChild) {\n            elements.add(csm);\n        } else {\n            throw new UnsupportedOperationException(csm.getClass().getSimpleName()+ \" \" + csm);\n        }\n    }\n\n    public static int toToken(Modifier modifier) {\n        switch (modifier.getKeyword()) {\n            case PUBLIC:\n                return GeneratedJavaParserConstants.PUBLIC;\n            case PRIVATE:\n                return GeneratedJavaParserConstants.PRIVATE;\n            case PROTECTED:\n                return GeneratedJavaParserConstants.PROTECTED;\n            case STATIC:\n                return GeneratedJavaParserConstants.STATIC;\n            case FINAL:\n                return GeneratedJavaParserConstants.FINAL;\n            case ABSTRACT:\n                return GeneratedJavaParserConstants.ABSTRACT;\n            case TRANSIENT:\n                return GeneratedJavaParserConstants.TRANSIENT;\n            case SYNCHRONIZED:\n                return GeneratedJavaParserConstants.SYNCHRONIZED;\n            case VOLATILE:\n                return GeneratedJavaParserConstants.VOLATILE;\n            case NATIVE:\n                return GeneratedJavaParserConstants.NATIVE;\n            case STRICTFP:\n                return GeneratedJavaParserConstants.STRICTFP;\n            case TRANSITIVE:\n                return GeneratedJavaParserConstants.TRANSITIVE;\n            default:\n                throw new UnsupportedOperationException(modifier.getKeyword().name());\n        }\n    }\n\n    ///\n    /// Methods that calculate CalculatedSyntaxModel\n    ///\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterPropertyChange(Node node, ObservableProperty property, Object oldValue, Object newValue) {\n        return calculatedSyntaxModelAfterPropertyChange(ConcreteSyntaxModel.forClass(node.getClass()), node, property, oldValue, newValue);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterPropertyChange(CsmElement csm, Node node, ObservableProperty property, Object oldValue, Object newValue) {\n        List<CsmElement> elements = new LinkedList<>();\n        calculatedSyntaxModelForNode(csm, node, elements, new PropertyChange(property, oldValue, newValue));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListRemoval(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index) {\n        List<CsmElement> elements = new LinkedList<>();\n        Node container = nodeList.getParentNodeForChildren();\n        calculatedSyntaxModelForNode(csm, container, elements, new ListRemovalChange(observableProperty, index));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListAddition(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node nodeAdded) {\n        List<CsmElement> elements = new LinkedList<>();\n        Node container = nodeList.getParentNodeForChildren();\n        calculatedSyntaxModelForNode(csm, container, elements, new ListAdditionChange(observableProperty, index, nodeAdded));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListAddition(Node container, ObservableProperty observableProperty, int index, Node nodeAdded) {\n        CsmElement csm = ConcreteSyntaxModel.forClass(container.getClass());\n        Object rawValue = observableProperty.getRawValue(container);\n        if (!(rawValue instanceof NodeList)) {\n            throw new IllegalStateException(\"Expected NodeList, found \" + rawValue.getClass().getCanonicalName());\n        }\n        NodeList<?> nodeList = (NodeList<?>)rawValue;\n        return calculatedSyntaxModelAfterListAddition(csm, observableProperty, nodeList, index, nodeAdded);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListRemoval(Node container, ObservableProperty observableProperty, int index) {\n        CsmElement csm = ConcreteSyntaxModel.forClass(container.getClass());\n        Object rawValue = observableProperty.getRawValue(container);\n        if (!(rawValue instanceof NodeList)) {\n            throw new IllegalStateException(\"Expected NodeList, found \" + rawValue.getClass().getCanonicalName());\n        }\n        NodeList<?> nodeList = (NodeList<?>)rawValue;\n        return calculatedSyntaxModelAfterListRemoval(csm, observableProperty, nodeList, index);\n    }\n\n    // Visible for testing\n    private CalculatedSyntaxModel calculatedSyntaxModelAfterListReplacement(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node newValue) {\n        List<CsmElement> elements = new LinkedList<>();\n        Node container = nodeList.getParentNodeForChildren();\n        calculatedSyntaxModelForNode(csm, container, elements, new ListReplacementChange(observableProperty, index, newValue));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n}\n", "filePathAfter": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2021 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer.lexicalpreservation;\n\nimport static com.github.javaparser.TokenTypes.eolTokenKind;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.javaparser.GeneratedJavaParserConstants;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.CharLiteralExpr;\nimport com.github.javaparser.ast.expr.StringLiteralExpr;\nimport com.github.javaparser.ast.expr.TextBlockLiteralExpr;\nimport com.github.javaparser.ast.observer.ObservableProperty;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.printer.ConcreteSyntaxModel;\nimport com.github.javaparser.printer.SourcePrinter;\nimport com.github.javaparser.printer.Stringable;\nimport com.github.javaparser.printer.concretesyntaxmodel.*;\nimport com.github.javaparser.printer.lexicalpreservation.changes.Change;\nimport com.github.javaparser.printer.lexicalpreservation.changes.ListAdditionChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.ListRemovalChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.ListReplacementChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.NoChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.PropertyChange;\nimport com.github.javaparser.utils.LineSeparator;\n\nclass LexicalDifferenceCalculator {\n\n    /**\n     * The ConcreteSyntaxModel represents the general format. This model is a calculated version of the ConcreteSyntaxModel,\n     * with no condition, no lists, just tokens and node children.\n     */\n    static class CalculatedSyntaxModel {\n        final List<CsmElement> elements;\n\n        CalculatedSyntaxModel(List<CsmElement> elements) {\n            this.elements = elements;\n        }\n\n        public CalculatedSyntaxModel from(int index) {\n            return new CalculatedSyntaxModel(new ArrayList<>(elements.subList(index, elements.size())));\n        }\n\n        @Override\n        public String toString() {\n            return \"CalculatedSyntaxModel{\" +\n                    \"elements=\" + elements +\n                    '}';\n        }\n\n        CalculatedSyntaxModel sub(int start, int end) {\n            return new CalculatedSyntaxModel(elements.subList(start, end));\n        }\n\n        void removeIndentationElements() {\n            elements.removeIf(el -> el instanceof CsmIndent || el instanceof CsmUnindent);\n        }\n    }\n\n    static class CsmChild implements CsmElement {\n        private final Node child;\n\n        public Node getChild() {\n            return child;\n        }\n\n        CsmChild(Node child) {\n            this.child = child;\n        }\n\n        @Override\n        public void prettyPrint(Node node, SourcePrinter printer) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public String toString() {\n            return \"child(\" + child.getClass().getSimpleName()+\")\";\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            CsmChild csmChild = (CsmChild) o;\n\n            return child.equals(csmChild.child);\n        }\n\n        @Override\n        public int hashCode() {\n            return child.hashCode();\n        }\n    }\n\n    List<DifferenceElement> calculateListRemovalDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index) {\n        Node container = nodeList.getParentNodeForChildren();\n        CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterListRemoval(element, observableProperty, nodeList, index);\n        return DifferenceElementCalculator.calculate(original, after);\n    }\n\n    List<DifferenceElement> calculateListAdditionDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node nodeAdded) {\n        Node container = nodeList.getParentNodeForChildren();\n        CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterListAddition(element, observableProperty, nodeList, index, nodeAdded);\n\n        List<DifferenceElement> differenceElements = DifferenceElementCalculator.calculate(original, after);\n\n        // Set the line separator character tokens\n        LineSeparator lineSeparator = container.getLineEndingStyleOrDefault(LineSeparator.SYSTEM);\n        replaceEolTokens(differenceElements, lineSeparator);\n\n        return differenceElements;\n    }\n\n    /*\n     * Replace EOL token in the list of {@code DifferenceElement} by the specified line separator\n     */\n    private void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n        CsmElement eol = getNewLineToken(lineSeparator);\n        for (int i = 0; i < differenceElements.size(); i++) {\n            DifferenceElement differenceElement = differenceElements.get(i);\n            differenceElements.set(i, differenceElement.replaceEolTokens(eol));\n        }\n    }\n    \n    /*\n     * Returns a new line token \n     */\n    private CsmElement getNewLineToken(LineSeparator lineSeparator) {\n        return CsmElement.newline(lineSeparator);\n    }\n    \n    List<DifferenceElement> calculateListReplacementDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node newValue) {\n        Node container = nodeList.getParentNodeForChildren();\n        CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterListReplacement(element, observableProperty, nodeList, index, newValue);\n        return DifferenceElementCalculator.calculate(original, after);\n    }\n\n    void calculatePropertyChange(NodeText nodeText, Node observedNode, ObservableProperty property, Object oldValue, Object newValue) {\n        if (nodeText == null) {\n            throw new NullPointerException();\n        }\n        CsmElement element = ConcreteSyntaxModel.forClass(observedNode.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, observedNode);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterPropertyChange(element, observedNode, property, oldValue, newValue);\n        List<DifferenceElement> differenceElements = DifferenceElementCalculator.calculate(original, after);\n        Difference difference = new Difference(differenceElements, nodeText, observedNode);\n        difference.apply();\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelForNode(CsmElement csm, Node node) {\n        List<CsmElement> elements = new LinkedList<>();\n        calculatedSyntaxModelForNode(csm, node, elements, new NoChange());\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    CalculatedSyntaxModel calculatedSyntaxModelForNode(Node node) {\n        return calculatedSyntaxModelForNode(ConcreteSyntaxModel.forClass(node.getClass()), node);\n    }\n\n    private void calculatedSyntaxModelForNode(CsmElement csm, Node node, List<CsmElement> elements, Change change) {\n        if (csm instanceof CsmSequence) {\n            CsmSequence csmSequence = (CsmSequence) csm;\n            csmSequence.getElements().forEach(e -> calculatedSyntaxModelForNode(e, node, elements, change));\n        } else if (csm instanceof CsmComment) {\n            // nothing to do\n        } else if (csm instanceof CsmSingleReference) {\n            CsmSingleReference csmSingleReference = (CsmSingleReference)csm;\n            Node child;\n            if (change instanceof PropertyChange && ((PropertyChange)change).getProperty() == csmSingleReference.getProperty()) {\n                child = (Node)((PropertyChange)change).getNewValue();\n            } else {\n                child = csmSingleReference.getProperty().getValueAsSingleReference(node);\n            }\n            if (child != null) {\n                // fix issue #2374\n                // Add node comment if needed (it's not very elegant but it works)\n                // We need to be sure that the node is an ExpressionStmt because we can meet\n                // this class definition\n                // a line comment <This is my class, with my comment> followed by\n                // class A {}\n                // In this case keyworld [class] is considered as a token and [A] is a child element\n                // So if we don't care that the node is an ExpressionStmt we could try to generate a wrong definition\n                // like this [class // This is my class, with my comment A {}]\n                if (node.getComment().isPresent() && node instanceof ExpressionStmt) {\n                    LineSeparator lineSeparator = node.getLineEndingStyleOrDefault(LineSeparator.SYSTEM);\n                    elements.add(new CsmChild(node.getComment().get()));\n                    elements.add(new CsmToken(eolTokenKind(lineSeparator), lineSeparator.asRawString()));\n                }\n                elements.add(new CsmChild(child));\n            }\n        } else if (csm instanceof CsmNone) {\n            // nothing to do\n        } else if (csm instanceof CsmToken) {\n            elements.add(csm);\n        } else if (csm instanceof CsmOrphanCommentsEnding) {\n            // nothing to do\n        } else if (csm instanceof CsmList) {\n            CsmList csmList = (CsmList) csm;\n            if (csmList.getProperty().isAboutNodes()) {\n                Object rawValue = change.getValue(csmList.getProperty(), node);\n                NodeList<?> nodeList;\n                if (rawValue instanceof Optional) {\n                    Optional<?> optional = (Optional<?>)rawValue;\n                    if (optional.isPresent()) {\n                        if (!(optional.get() instanceof NodeList)) {\n                            throw new IllegalStateException(\"Expected NodeList, found \" + optional.get().getClass().getCanonicalName());\n                        }\n                        nodeList = (NodeList<?>) optional.get();\n                    } else {\n                        nodeList = new NodeList<>();\n                    }\n                } else {\n                    if (!(rawValue instanceof NodeList)) {\n                        throw new IllegalStateException(\"Expected NodeList, found \" + rawValue.getClass().getCanonicalName());\n                    }\n                    nodeList = (NodeList<?>) rawValue;\n                }\n                if (!nodeList.isEmpty()) {\n                    calculatedSyntaxModelForNode(csmList.getPreceeding(), node, elements, change);\n                    for (int i = 0; i < nodeList.size(); i++) {\n                        if (i != 0) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPre(), node, elements, change);\n                        }\n                        elements.add(new CsmChild(nodeList.get(i)));\n                        if (i != (nodeList.size() - 1)) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPost(), node, elements, change);\n                        }\n\n                    }\n                    calculatedSyntaxModelForNode(csmList.getFollowing(), node, elements, change);\n                }\n            } else {\n                Collection<?> collection = (Collection<?>) change.getValue(csmList.getProperty(), node);\n                if (!collection.isEmpty()) {\n                    calculatedSyntaxModelForNode(csmList.getPreceeding(), node, elements, change);\n\n                    boolean first = true;\n                    for (Iterator<?> it = collection.iterator(); it.hasNext(); ) {\n                        if (!first) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPre(), node, elements, change);\n                        }\n                        Object value = it.next();\n                        if (value instanceof Modifier) {\n                            Modifier modifier = (Modifier)value;\n                            elements.add(new CsmToken(toToken(modifier)));\n                        } else {\n                            throw new UnsupportedOperationException(it.next().getClass().getSimpleName());\n                        }\n                        if (it.hasNext()) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPost(), node, elements, change);\n                        }\n                        first = false;\n                    }\n                    calculatedSyntaxModelForNode(csmList.getFollowing(), node, elements, change);\n                }\n            }\n        } else if (csm instanceof CsmConditional) {\n            CsmConditional csmConditional = (CsmConditional) csm;\n            boolean satisfied = change.evaluate(csmConditional, node);\n            if (satisfied) {\n                calculatedSyntaxModelForNode(csmConditional.getThenElement(), node, elements, change);\n            } else {\n                calculatedSyntaxModelForNode(csmConditional.getElseElement(), node, elements, change);\n            }\n        } else if (csm instanceof CsmIndent) {\n            elements.add(csm);\n        } else if (csm instanceof CsmUnindent) {\n            elements.add(csm);\n        } else if (csm instanceof CsmAttribute) {\n            CsmAttribute csmAttribute = (CsmAttribute) csm;\n            Object value = change.getValue(csmAttribute.getProperty(), node);\n            String text = value.toString();\n            if (value instanceof Stringable) {\n                text = ((Stringable) value).asString();\n            }\n            elements.add(new CsmToken(csmAttribute.getTokenType(node, value.toString(), text), text));\n        } else if ((csm instanceof CsmString) && (node instanceof StringLiteralExpr)) {\n            // fix #2382:\n            // This method calculates the syntax model _after_ the change has been applied.\n            // If the given change is a PropertyChange, the returned model should\n            // contain the new value, otherwise the original/current value should be used.\n            if (change instanceof PropertyChange) {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.STRING_LITERAL,\n                        \"\\\"\" + ((PropertyChange) change).getNewValue() + \"\\\"\"));\n            } else {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.STRING_LITERAL,\n                        \"\\\"\" + ((StringLiteralExpr) node).getValue() + \"\\\"\"));\n            }\n        } else if ((csm instanceof CsmString) && (node instanceof TextBlockLiteralExpr)) {\n            // FIXME: csm should be CsmTextBlock -- See also #2677\n            if (change instanceof PropertyChange) {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.TEXT_BLOCK_LITERAL,\n                        \"\\\"\\\"\\\"\" + ((PropertyChange) change).getNewValue() + \"\\\"\\\"\\\"\"));\n            } else {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.TEXT_BLOCK_LITERAL,\n                        \"\\\"\\\"\\\"\" + ((TextBlockLiteralExpr) node).getValue() + \"\\\"\\\"\\\"\"));\n            }\n        } else if ((csm instanceof CsmChar) && (node instanceof CharLiteralExpr)) {\n            if (change instanceof PropertyChange) {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.CHAR,\n                        \"'\" + ((PropertyChange) change).getNewValue() + \"'\"));\n            } else {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.CHAR,\n                        \"'\" + ((CharLiteralExpr) node).getValue() + \"'\"));\n            }\n        } else if (csm instanceof CsmMix) {\n            CsmMix csmMix = (CsmMix)csm;\n            List<CsmElement> mixElements = new LinkedList<>();\n            csmMix.getElements().forEach(e -> calculatedSyntaxModelForNode(e, node, mixElements, change));\n            elements.add(new CsmMix(mixElements));\n        } else if (csm instanceof CsmChild) {\n            elements.add(csm);\n        } else {\n            throw new UnsupportedOperationException(csm.getClass().getSimpleName()+ \" \" + csm);\n        }\n    }\n\n    public static int toToken(Modifier modifier) {\n        switch (modifier.getKeyword()) {\n            case PUBLIC:\n                return GeneratedJavaParserConstants.PUBLIC;\n            case PRIVATE:\n                return GeneratedJavaParserConstants.PRIVATE;\n            case PROTECTED:\n                return GeneratedJavaParserConstants.PROTECTED;\n            case STATIC:\n                return GeneratedJavaParserConstants.STATIC;\n            case FINAL:\n                return GeneratedJavaParserConstants.FINAL;\n            case ABSTRACT:\n                return GeneratedJavaParserConstants.ABSTRACT;\n            case TRANSIENT:\n                return GeneratedJavaParserConstants.TRANSIENT;\n            case SYNCHRONIZED:\n                return GeneratedJavaParserConstants.SYNCHRONIZED;\n            case VOLATILE:\n                return GeneratedJavaParserConstants.VOLATILE;\n            case NATIVE:\n                return GeneratedJavaParserConstants.NATIVE;\n            case STRICTFP:\n                return GeneratedJavaParserConstants.STRICTFP;\n            case TRANSITIVE:\n                return GeneratedJavaParserConstants.TRANSITIVE;\n            default:\n                throw new UnsupportedOperationException(modifier.getKeyword().name());\n        }\n    }\n\n    ///\n    /// Methods that calculate CalculatedSyntaxModel\n    ///\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterPropertyChange(Node node, ObservableProperty property, Object oldValue, Object newValue) {\n        return calculatedSyntaxModelAfterPropertyChange(ConcreteSyntaxModel.forClass(node.getClass()), node, property, oldValue, newValue);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterPropertyChange(CsmElement csm, Node node, ObservableProperty property, Object oldValue, Object newValue) {\n        List<CsmElement> elements = new LinkedList<>();\n        calculatedSyntaxModelForNode(csm, node, elements, new PropertyChange(property, oldValue, newValue));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListRemoval(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index) {\n        List<CsmElement> elements = new LinkedList<>();\n        Node container = nodeList.getParentNodeForChildren();\n        calculatedSyntaxModelForNode(csm, container, elements, new ListRemovalChange(observableProperty, index));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListAddition(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node nodeAdded) {\n        List<CsmElement> elements = new LinkedList<>();\n        Node container = nodeList.getParentNodeForChildren();\n        calculatedSyntaxModelForNode(csm, container, elements, new ListAdditionChange(observableProperty, index, nodeAdded));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListAddition(Node container, ObservableProperty observableProperty, int index, Node nodeAdded) {\n        CsmElement csm = ConcreteSyntaxModel.forClass(container.getClass());\n        Object rawValue = observableProperty.getRawValue(container);\n        if (!(rawValue instanceof NodeList)) {\n            throw new IllegalStateException(\"Expected NodeList, found \" + rawValue.getClass().getCanonicalName());\n        }\n        NodeList<?> nodeList = (NodeList<?>)rawValue;\n        return calculatedSyntaxModelAfterListAddition(csm, observableProperty, nodeList, index, nodeAdded);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListRemoval(Node container, ObservableProperty observableProperty, int index) {\n        CsmElement csm = ConcreteSyntaxModel.forClass(container.getClass());\n        Object rawValue = observableProperty.getRawValue(container);\n        if (!(rawValue instanceof NodeList)) {\n            throw new IllegalStateException(\"Expected NodeList, found \" + rawValue.getClass().getCanonicalName());\n        }\n        NodeList<?> nodeList = (NodeList<?>)rawValue;\n        return calculatedSyntaxModelAfterListRemoval(csm, observableProperty, nodeList, index);\n    }\n\n    // Visible for testing\n    private CalculatedSyntaxModel calculatedSyntaxModelAfterListReplacement(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node newValue) {\n        List<CsmElement> elements = new LinkedList<>();\n        Node container = nodeList.getParentNodeForChildren();\n        calculatedSyntaxModelForNode(csm, container, elements, new ListReplacementChange(observableProperty, index, newValue));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n}\n", "diffSourceCodeSet": ["private CsmElement getNewLineToken(LineSeparator lineSeparator) {\n        return CsmElement.newline(lineSeparator);\n    }"], "invokedMethodSet": ["methodSignature: com.github.javaparser.printer.lexicalpreservation.Reshuffled#getElement\n methodBody: public CsmMix getElement() {\nreturn nextOrder;\n}", "methodSignature: com.github.javaparser.printer.lexicalpreservation.Added#isAdded\n methodBody: public boolean isAdded() {\nreturn true;\n}", "methodSignature: com.github.javaparser.printer.lexicalpreservation.DifferenceElement#getElement\n methodBody: CsmElement getElement();", "methodSignature: com.github.javaparser.printer.lexicalpreservation.DifferenceElement#isAdded\n methodBody: boolean isAdded();", "methodSignature: com.github.javaparser.printer.lexicalpreservation.Reshuffled#isAdded\n methodBody: public boolean isAdded() {\nreturn false;\n}", "methodSignature: com.github.javaparser.printer.lexicalpreservation.Added#getElement\n methodBody: public CsmElement getElement() {\nreturn element;\n}"], "sourceCodeAfterRefactoring": "private void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n        CsmElement eol = getNewLineToken(lineSeparator);\n        for (int i = 0; i < differenceElements.size(); i++) {\n            DifferenceElement differenceElement = differenceElements.get(i);\n            differenceElements.set(i, differenceElement.replaceEolTokens(eol));\n        }\n    }\nprivate CsmElement getNewLineToken(LineSeparator lineSeparator) {\n        return CsmElement.newline(lineSeparator);\n    }", "diffSourceCode": "-  147:     private void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n-  148:         for (int i = 0; i < differenceElements.size(); i++) {\n-  149:             DifferenceElement differenceElement = differenceElements.get(i);\n-  150:             if (differenceElement.isAdded()) {\n-  151:                 CsmElement element = differenceElement.getElement();\n-  152:                 boolean isWhitespaceToken = element instanceof CsmToken && ((CsmToken) element).isNewLine();\n-  153:                 if (isWhitespaceToken) {\n-  154:                     differenceElements.set(i, new Added(CsmElement.newline(lineSeparator)));\n-  155:                 }\n-  156:             }\n-  157:         }\n-  158:     }\n-  161:         Node container = nodeList.getParentNodeForChildren();\n-  162:         CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n-  163:         CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n+  147:     /*\n+  148:      * Replace EOL token in the list of {@code DifferenceElement} by the specified line separator\n+  149:      */\n+  150:     private void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n+  151:         CsmElement eol = getNewLineToken(lineSeparator);\n+  152:         for (int i = 0; i < differenceElements.size(); i++) {\n+  153:             DifferenceElement differenceElement = differenceElements.get(i);\n+  154:             differenceElements.set(i, differenceElement.replaceEolTokens(eol));\n+  155:         }\n+  156:     }\n+  157:     \n+  158:     /*\n+  161:     private CsmElement getNewLineToken(LineSeparator lineSeparator) {\n+  162:         return CsmElement.newline(lineSeparator);\n+  163:     }\n", "uniqueId": "ed79beb63e87f3a58322aee34b1a2e80cfafbd18_147_158_161_163_150_156", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 42}, "BRANCH": {"missed": 0, "covered": 10}, "LINE": {"missed": 0, "covered": 8}, "COMPLEXITY": {"missed": 0, "covered": 6}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `replaceEolTokens` method, we can extract the logic that checks if a `DifferenceElement` is an added newline token into a separate method. This will make the code cleaner and easier to understand.\n\nHere\u2019s the refactored code:\n\n```java\nprivate void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n    for (int i = 0; i < differenceElements.size(); i++) {\n        DifferenceElement differenceElement = differenceElements.get(i);\n        if (differenceElement.isAdded()) {\n            CsmElement element = differenceElement.getElement();\n            if (isWhitespaceToken(element)) {\n                differenceElements.set(i, new Added(CsmElement.newline(lineSeparator)));\n            }\n        }\n    }\n}\n\nprivate boolean isWhitespaceToken(CsmElement element) {\n    return element instanceof CsmToken && ((CsmToken) element).isNewLine();\n}\n```\n\nIn this refactoring:\n- The logic that checks if the `CsmElement` is a whitespace token has been extracted into a new method called `isWhitespaceToken`. This method takes a `CsmElement` as a parameter and returns a boolean indicating whether it is a newline token.\n- The `replaceEolTokens` method now calls `isWhitespaceToken`, which improves its readability by reducing complexity.\n\nThe refactored method code is as follows:\n\n##########################\n```java\nprivate void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n    for (int i = 0; i < differenceElements.size(); i++) {\n        DifferenceElement differenceElement = differenceElements.get(i);\n        if (differenceElement.isAdded()) {\n            CsmElement element = differenceElement.getElement();\n            if (isWhitespaceToken(element)) {\n                differenceElements.set(i, new Added(CsmElement.newline(lineSeparator)));\n            }\n        }\n    }\n}\n\nprivate boolean isWhitespaceToken(CsmElement element) {\n    return element instanceof CsmToken && ((CsmToken) element).isNewLine();\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n        for (int i = 0; i < differenceElements.size(); i++) {\n            DifferenceElement differenceElement = differenceElements.get(i);\n            if (differenceElement.isAdded()) {\n                CsmElement element = differenceElement.getElement();\n                boolean isWhitespaceToken = element instanceof CsmToken && ((CsmToken) element).isNewLine();\n                if (isWhitespaceToken) {\n                    differenceElements.set(i, new Added(CsmElement.newline(lineSeparator)));\n                }\n            }\n        }\n    }\n\nClass content:\n/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2021 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer.lexicalpreservation;\n\nimport com.github.javaparser.GeneratedJavaParserConstants;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.CharLiteralExpr;\nimport com.github.javaparser.ast.expr.StringLiteralExpr;\nimport com.github.javaparser.ast.expr.TextBlockLiteralExpr;\nimport com.github.javaparser.ast.observer.ObservableProperty;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.printer.ConcreteSyntaxModel;\nimport com.github.javaparser.printer.Stringable;\nimport com.github.javaparser.printer.SourcePrinter;\nimport com.github.javaparser.printer.concretesyntaxmodel.*;\nimport com.github.javaparser.printer.lexicalpreservation.changes.Change;\nimport com.github.javaparser.printer.lexicalpreservation.changes.ListAdditionChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.ListRemovalChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.ListReplacementChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.NoChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.PropertyChange;\nimport com.github.javaparser.utils.LineSeparator;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\n\nimport static com.github.javaparser.TokenTypes.eolTokenKind;\n\nclass LexicalDifferenceCalculator {\n\n    /**\n     * The ConcreteSyntaxModel represents the general format. This model is a calculated version of the ConcreteSyntaxModel,\n     * with no condition, no lists, just tokens and node children.\n     */\n    static class CalculatedSyntaxModel {\n        final List<CsmElement> elements;\n\n        CalculatedSyntaxModel(List<CsmElement> elements) {\n            this.elements = elements;\n        }\n\n        public CalculatedSyntaxModel from(int index) {\n            return new CalculatedSyntaxModel(new ArrayList<>(elements.subList(index, elements.size())));\n        }\n\n        @Override\n        public String toString() {\n            return \"CalculatedSyntaxModel{\" +\n                    \"elements=\" + elements +\n                    '}';\n        }\n\n        CalculatedSyntaxModel sub(int start, int end) {\n            return new CalculatedSyntaxModel(elements.subList(start, end));\n        }\n\n        void removeIndentationElements() {\n            elements.removeIf(el -> el instanceof CsmIndent || el instanceof CsmUnindent);\n        }\n    }\n\n    static class CsmChild implements CsmElement {\n        private final Node child;\n\n        public Node getChild() {\n            return child;\n        }\n\n        CsmChild(Node child) {\n            this.child = child;\n        }\n\n        @Override\n        public void prettyPrint(Node node, SourcePrinter printer) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public String toString() {\n            return \"child(\" + child.getClass().getSimpleName()+\")\";\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            CsmChild csmChild = (CsmChild) o;\n\n            return child.equals(csmChild.child);\n        }\n\n        @Override\n        public int hashCode() {\n            return child.hashCode();\n        }\n    }\n\n    List<DifferenceElement> calculateListRemovalDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index) {\n        Node container = nodeList.getParentNodeForChildren();\n        CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterListRemoval(element, observableProperty, nodeList, index);\n        return DifferenceElementCalculator.calculate(original, after);\n    }\n\n    List<DifferenceElement> calculateListAdditionDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node nodeAdded) {\n        Node container = nodeList.getParentNodeForChildren();\n        CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterListAddition(element, observableProperty, nodeList, index, nodeAdded);\n\n        List<DifferenceElement> differenceElements = DifferenceElementCalculator.calculate(original, after);\n\n        // Set the line separator character tokens\n        LineSeparator lineSeparator = container.getLineEndingStyleOrDefault(LineSeparator.SYSTEM);\n        replaceEolTokens(differenceElements, lineSeparator);\n\n        return differenceElements;\n    }\n\n    private void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n        for (int i = 0; i < differenceElements.size(); i++) {\n            DifferenceElement differenceElement = differenceElements.get(i);\n            if (differenceElement.isAdded()) {\n                CsmElement element = differenceElement.getElement();\n                boolean isWhitespaceToken = element instanceof CsmToken && ((CsmToken) element).isNewLine();\n                if (isWhitespaceToken) {\n                    differenceElements.set(i, new Added(CsmElement.newline(lineSeparator)));\n                }\n            }\n        }\n    }\n\n    List<DifferenceElement> calculateListReplacementDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node newValue) {\n        Node container = nodeList.getParentNodeForChildren();\n        CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterListReplacement(element, observableProperty, nodeList, index, newValue);\n        return DifferenceElementCalculator.calculate(original, after);\n    }\n\n    void calculatePropertyChange(NodeText nodeText, Node observedNode, ObservableProperty property, Object oldValue, Object newValue) {\n        if (nodeText == null) {\n            throw new NullPointerException();\n        }\n        CsmElement element = ConcreteSyntaxModel.forClass(observedNode.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, observedNode);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterPropertyChange(element, observedNode, property, oldValue, newValue);\n        List<DifferenceElement> differenceElements = DifferenceElementCalculator.calculate(original, after);\n        Difference difference = new Difference(differenceElements, nodeText, observedNode);\n        difference.apply();\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelForNode(CsmElement csm, Node node) {\n        List<CsmElement> elements = new LinkedList<>();\n        calculatedSyntaxModelForNode(csm, node, elements, new NoChange());\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    CalculatedSyntaxModel calculatedSyntaxModelForNode(Node node) {\n        return calculatedSyntaxModelForNode(ConcreteSyntaxModel.forClass(node.getClass()), node);\n    }\n\n    private void calculatedSyntaxModelForNode(CsmElement csm, Node node, List<CsmElement> elements, Change change) {\n        if (csm instanceof CsmSequence) {\n            CsmSequence csmSequence = (CsmSequence) csm;\n            csmSequence.getElements().forEach(e -> calculatedSyntaxModelForNode(e, node, elements, change));\n        } else if (csm instanceof CsmComment) {\n            // nothing to do\n        } else if (csm instanceof CsmSingleReference) {\n            CsmSingleReference csmSingleReference = (CsmSingleReference)csm;\n            Node child;\n            if (change instanceof PropertyChange && ((PropertyChange)change).getProperty() == csmSingleReference.getProperty()) {\n                child = (Node)((PropertyChange)change).getNewValue();\n            } else {\n                child = csmSingleReference.getProperty().getValueAsSingleReference(node);\n            }\n            if (child != null) {\n                // fix issue #2374\n                // Add node comment if needed (it's not very elegant but it works)\n                // We need to be sure that the node is an ExpressionStmt because we can meet\n                // this class definition\n                // a line comment <This is my class, with my comment> followed by\n                // class A {}\n                // In this case keyworld [class] is considered as a token and [A] is a child element\n                // So if we don't care that the node is an ExpressionStmt we could try to generate a wrong definition\n                // like this [class // This is my class, with my comment A {}]\n                if (node.getComment().isPresent() && node instanceof ExpressionStmt) {\n                    LineSeparator lineSeparator = node.getLineEndingStyleOrDefault(LineSeparator.SYSTEM);\n                    elements.add(new CsmChild(node.getComment().get()));\n                    elements.add(new CsmToken(eolTokenKind(lineSeparator), lineSeparator.asRawString()));\n                }\n                elements.add(new CsmChild(child));\n            }\n        } else if (csm instanceof CsmNone) {\n            // nothing to do\n        } else if (csm instanceof CsmToken) {\n            elements.add(csm);\n        } else if (csm instanceof CsmOrphanCommentsEnding) {\n            // nothing to do\n        } else if (csm instanceof CsmList) {\n            CsmList csmList = (CsmList) csm;\n            if (csmList.getProperty().isAboutNodes()) {\n                Object rawValue = change.getValue(csmList.getProperty(), node);\n                NodeList<?> nodeList;\n                if (rawValue instanceof Optional) {\n                    Optional<?> optional = (Optional<?>)rawValue;\n                    if (optional.isPresent()) {\n                        if (!(optional.get() instanceof NodeList)) {\n                            throw new IllegalStateException(\"Expected NodeList, found \" + optional.get().getClass().getCanonicalName());\n                        }\n                        nodeList = (NodeList<?>) optional.get();\n                    } else {\n                        nodeList = new NodeList<>();\n                    }\n                } else {\n                    if (!(rawValue instanceof NodeList)) {\n                        throw new IllegalStateException(\"Expected NodeList, found \" + rawValue.getClass().getCanonicalName());\n                    }\n                    nodeList = (NodeList<?>) rawValue;\n                }\n                if (!nodeList.isEmpty()) {\n                    calculatedSyntaxModelForNode(csmList.getPreceeding(), node, elements, change);\n                    for (int i = 0; i < nodeList.size(); i++) {\n                        if (i != 0) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPre(), node, elements, change);\n                        }\n                        elements.add(new CsmChild(nodeList.get(i)));\n                        if (i != (nodeList.size() - 1)) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPost(), node, elements, change);\n                        }\n\n                    }\n                    calculatedSyntaxModelForNode(csmList.getFollowing(), node, elements, change);\n                }\n            } else {\n                Collection<?> collection = (Collection<?>) change.getValue(csmList.getProperty(), node);\n                if (!collection.isEmpty()) {\n                    calculatedSyntaxModelForNode(csmList.getPreceeding(), node, elements, change);\n\n                    boolean first = true;\n                    for (Iterator<?> it = collection.iterator(); it.hasNext(); ) {\n                        if (!first) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPre(), node, elements, change);\n                        }\n                        Object value = it.next();\n                        if (value instanceof Modifier) {\n                            Modifier modifier = (Modifier)value;\n                            elements.add(new CsmToken(toToken(modifier)));\n                        } else {\n                            throw new UnsupportedOperationException(it.next().getClass().getSimpleName());\n                        }\n                        if (it.hasNext()) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPost(), node, elements, change);\n                        }\n                        first = false;\n                    }\n                    calculatedSyntaxModelForNode(csmList.getFollowing(), node, elements, change);\n                }\n            }\n        } else if (csm instanceof CsmConditional) {\n            CsmConditional csmConditional = (CsmConditional) csm;\n            boolean satisfied = change.evaluate(csmConditional, node);\n            if (satisfied) {\n                calculatedSyntaxModelForNode(csmConditional.getThenElement(), node, elements, change);\n            } else {\n                calculatedSyntaxModelForNode(csmConditional.getElseElement(), node, elements, change);\n            }\n        } else if (csm instanceof CsmIndent) {\n            elements.add(csm);\n        } else if (csm instanceof CsmUnindent) {\n            elements.add(csm);\n        } else if (csm instanceof CsmAttribute) {\n            CsmAttribute csmAttribute = (CsmAttribute) csm;\n            Object value = change.getValue(csmAttribute.getProperty(), node);\n            String text = value.toString();\n            if (value instanceof Stringable) {\n                text = ((Stringable) value).asString();\n            }\n            elements.add(new CsmToken(csmAttribute.getTokenType(node, value.toString(), text), text));\n        } else if ((csm instanceof CsmString) && (node instanceof StringLiteralExpr)) {\n            // fix #2382:\n            // This method calculates the syntax model _after_ the change has been applied.\n            // If the given change is a PropertyChange, the returned model should\n            // contain the new value, otherwise the original/current value should be used.\n            if (change instanceof PropertyChange) {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.STRING_LITERAL,\n                        \"\\\"\" + ((PropertyChange) change).getNewValue() + \"\\\"\"));\n            } else {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.STRING_LITERAL,\n                        \"\\\"\" + ((StringLiteralExpr) node).getValue() + \"\\\"\"));\n            }\n        } else if ((csm instanceof CsmString) && (node instanceof TextBlockLiteralExpr)) {\n            // FIXME: csm should be CsmTextBlock -- See also #2677\n            if (change instanceof PropertyChange) {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.TEXT_BLOCK_LITERAL,\n                        \"\\\"\\\"\\\"\" + ((PropertyChange) change).getNewValue() + \"\\\"\\\"\\\"\"));\n            } else {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.TEXT_BLOCK_LITERAL,\n                        \"\\\"\\\"\\\"\" + ((TextBlockLiteralExpr) node).getValue() + \"\\\"\\\"\\\"\"));\n            }\n        } else if ((csm instanceof CsmChar) && (node instanceof CharLiteralExpr)) {\n            if (change instanceof PropertyChange) {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.CHAR,\n                        \"'\" + ((PropertyChange) change).getNewValue() + \"'\"));\n            } else {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.CHAR,\n                        \"'\" + ((CharLiteralExpr) node).getValue() + \"'\"));\n            }\n        } else if (csm instanceof CsmMix) {\n            CsmMix csmMix = (CsmMix)csm;\n            List<CsmElement> mixElements = new LinkedList<>();\n            csmMix.getElements().forEach(e -> calculatedSyntaxModelForNode(e, node, mixElements, change));\n            elements.add(new CsmMix(mixElements));\n        } else if (csm instanceof CsmChild) {\n            elements.add(csm);\n        } else {\n            throw new UnsupportedOperationException(csm.getClass().getSimpleName()+ \" \" + csm);\n        }\n    }\n\n    public static int toToken(Modifier modifier) {\n        switch (modifier.getKeyword()) {\n            case PUBLIC:\n                return GeneratedJavaParserConstants.PUBLIC;\n            case PRIVATE:\n                return GeneratedJavaParserConstants.PRIVATE;\n            case PROTECTED:\n                return GeneratedJavaParserConstants.PROTECTED;\n            case STATIC:\n                return GeneratedJavaParserConstants.STATIC;\n            case FINAL:\n                return GeneratedJavaParserConstants.FINAL;\n            case ABSTRACT:\n                return GeneratedJavaParserConstants.ABSTRACT;\n            case TRANSIENT:\n                return GeneratedJavaParserConstants.TRANSIENT;\n            case SYNCHRONIZED:\n                return GeneratedJavaParserConstants.SYNCHRONIZED;\n            case VOLATILE:\n                return GeneratedJavaParserConstants.VOLATILE;\n            case NATIVE:\n                return GeneratedJavaParserConstants.NATIVE;\n            case STRICTFP:\n                return GeneratedJavaParserConstants.STRICTFP;\n            case TRANSITIVE:\n                return GeneratedJavaParserConstants.TRANSITIVE;\n            default:\n                throw new UnsupportedOperationException(modifier.getKeyword().name());\n        }\n    }\n\n    ///\n    /// Methods that calculate CalculatedSyntaxModel\n    ///\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterPropertyChange(Node node, ObservableProperty property, Object oldValue, Object newValue) {\n        return calculatedSyntaxModelAfterPropertyChange(ConcreteSyntaxModel.forClass(node.getClass()), node, property, oldValue, newValue);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterPropertyChange(CsmElement csm, Node node, ObservableProperty property, Object oldValue, Object newValue) {\n        List<CsmElement> elements = new LinkedList<>();\n        calculatedSyntaxModelForNode(csm, node, elements, new PropertyChange(property, oldValue, newValue));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListRemoval(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index) {\n        List<CsmElement> elements = new LinkedList<>();\n        Node container = nodeList.getParentNodeForChildren();\n        calculatedSyntaxModelForNode(csm, container, elements, new ListRemovalChange(observableProperty, index));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListAddition(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node nodeAdded) {\n        List<CsmElement> elements = new LinkedList<>();\n        Node container = nodeList.getParentNodeForChildren();\n        calculatedSyntaxModelForNode(csm, container, elements, new ListAdditionChange(observableProperty, index, nodeAdded));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListAddition(Node container, ObservableProperty observableProperty, int index, Node nodeAdded) {\n        CsmElement csm = ConcreteSyntaxModel.forClass(container.getClass());\n        Object rawValue = observableProperty.getRawValue(container);\n        if (!(rawValue instanceof NodeList)) {\n            throw new IllegalStateException(\"Expected NodeList, found \" + rawValue.getClass().getCanonicalName());\n        }\n        NodeList<?> nodeList = (NodeList<?>)rawValue;\n        return calculatedSyntaxModelAfterListAddition(csm, observableProperty, nodeList, index, nodeAdded);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListRemoval(Node container, ObservableProperty observableProperty, int index) {\n        CsmElement csm = ConcreteSyntaxModel.forClass(container.getClass());\n        Object rawValue = observableProperty.getRawValue(container);\n        if (!(rawValue instanceof NodeList)) {\n            throw new IllegalStateException(\"Expected NodeList, found \" + rawValue.getClass().getCanonicalName());\n        }\n        NodeList<?> nodeList = (NodeList<?>)rawValue;\n        return calculatedSyntaxModelAfterListRemoval(csm, observableProperty, nodeList, index);\n    }\n\n    // Visible for testing\n    private CalculatedSyntaxModel calculatedSyntaxModelAfterListReplacement(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node newValue) {\n        List<CsmElement> elements = new LinkedList<>();\n        Node container = nodeList.getParentNodeForChildren();\n        calculatedSyntaxModelForNode(csm, container, elements, new ListReplacementChange(observableProperty, index, newValue));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate getLastParameterIndex(countOfMethodParametersDeclared int) : int extracted from public isApplicable(methodUsage MethodUsage, needleName String, needleParameterTypes List<ResolvedType>, typeSolver TypeSolver) : boolean in class com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic", "diffLocations": [{"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java", "startLine": 354, "endLine": 488, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java", "startLine": 380, "endLine": 514, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java", "startLine": 210, "endLine": 212, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Note the specific naming here -- parameters are part of the method declaration,\n     * while arguments are the values passed when calling a method.\n     * Note that \"needle\" refers to that value being used as a search/query term to match against.\n     *\n     * @return true, if the given MethodUsage matches the given name/types (normally obtained from a ResolvedMethodDeclaration)\n     *\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver)}  }\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver, boolean)}\n     */\n    public static boolean isApplicable(MethodUsage methodUsage, String needleName, List<ResolvedType> needleParameterTypes, TypeSolver typeSolver) {\n        if (!methodUsage.getName().equals(needleName)) {\n            return false;\n        }\n\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodUsageArgumentsPassed = methodUsage.getNoParams();\n        int lastMethodUsageArgumentIndex = Math.max(0, countOfMethodUsageArgumentsPassed - 1);\n\n        // The index of the final argument passed (on the method usage).\n        int needleParameterCount = needleParameterTypes.size();\n        int lastNeedleParameterIndex = Math.max(0, needleParameterCount - 1);\n\n        // TODO: Does the method usage have a declaration at this point..?\n        boolean methodIsDeclaredWithVariadicParameter = methodUsage.getDeclaration().hasVariadicParameter();\n\n        // If the counts do not match and the method is not variadic, this is not a match.\n        if (!methodIsDeclaredWithVariadicParameter && !(needleParameterCount == countOfMethodUsageArgumentsPassed)) {\n            return false;\n        }\n\n        // If the counts do not match and we have provided too few arguments, this is not a match. Note that variadic parameters\n        // allow you to omit the vararg, which would allow a difference of one, but a difference in count of 2 or more is not a match.\n        if (!(needleParameterCount == countOfMethodUsageArgumentsPassed) && needleParameterCount < lastMethodUsageArgumentIndex) {\n            return false;\n        }\n\n        // Iterate over the arguments given to the method, and compare their types against the given method's declared parameter types\n        for (int i = 0; i < needleParameterCount; i++) {\n            ResolvedType actualArgumentType = needleParameterTypes.get(i);\n\n            ResolvedType expectedArgumentType;\n            boolean reachedVariadicParam = methodIsDeclaredWithVariadicParameter && i >= lastMethodUsageArgumentIndex;\n            if (!reachedVariadicParam) {\n                // Not yet reached the variadic parameters -- the expected type is just whatever is at that position.\n                expectedArgumentType = methodUsage.getParamType(i);\n            } else {\n                // We have reached the variadic parameters -- the expected type is the type of the last declared parameter.\n                expectedArgumentType = methodUsage.getParamType(lastMethodUsageArgumentIndex);\n                // Note that the given variadic value might be an array - if so, use the array's component type rather.\n                // This is only valid if ONE argument has been given to the vararg parameter.\n                // Example: {@code void test(String... s) {}} and {@code test(stringArray)} -- {@code String... is assignable by stringArray}\n                // Example: {@code void test(String[]... s) {}} and {@code test(stringArrayArray)} -- {@code String[]... is assignable by stringArrayArray}\n                boolean argumentIsArray = (needleParameterCount == countOfMethodUsageArgumentsPassed) && expectedArgumentType.isAssignableBy(actualArgumentType);\n                if (!argumentIsArray) {\n                    // Get the component type of the declared parameter type.\n                    expectedArgumentType = expectedArgumentType.asArrayType().getComponentType();\n                }\n            }\n\n            // Consider type parameters directly on the method declaration, and ALSO on the enclosing type (e.g. a class)\n            List<ResolvedTypeParameterDeclaration> typeParameters = methodUsage.getDeclaration().getTypeParameters();\n            typeParameters.addAll(methodUsage.declaringType().getTypeParameters());\n\n            ResolvedType expectedTypeWithoutSubstitutions = expectedArgumentType;\n            ResolvedType expectedTypeWithInference = expectedArgumentType;\n            Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n\n            // For each declared parameter, infer the types that will replace generics (type parameters)\n            for (int j = 0; j < countOfMethodUsageArgumentsPassed; j++) {\n                ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(j);\n                ResolvedType parameterType = parameter.getType();\n                if (parameter.isVariadic()) {\n                    // Don't continue if a vararg parameter is reached and there are no arguments left\n                    if (needleParameterCount == j) {\n                        break;\n                    }\n                    parameterType = parameterType.asArrayType().getComponentType();\n                }\n                inferTypes(needleParameterTypes.get(j), parameterType, derivedValues);\n            }\n\n            for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()) {\n                ResolvedTypeParameterDeclaration tp = entry.getKey();\n                expectedTypeWithInference = expectedTypeWithInference.replaceTypeVariables(tp, entry.getValue());\n            }\n\n            // Consider cases where type variables can be replaced (e.g. add(E element) vs add(String element))\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver)));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), bound.getType());\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(bound.getType()));\n                    } else {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.superBound(bound.getType()));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // Consider cases where type variables involve bounds e.g. super/extends\n            ResolvedType expectedTypeWithSubstitutions = expectedTypeWithoutSubstitutions;\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, bound.getType());\n                    } else {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // If the given argument still isn't applicable even after considering type arguments/generics, this is not a match.\n            if (!expectedArgumentType.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithSubstitutions.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithInference.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithoutSubstitutions.isAssignableBy(actualArgumentType)) {\n                return false;\n            }\n        }\n\n        // If the checks above haven't failed, then we've found a match.\n        return true;\n    }", "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java", "isPureRefactoring": true, "commitId": "5aabb7480625e5dba2d32a8efab95a35f8c2e04c", "packageNameBefore": "com.github.javaparser.symbolsolver.resolution", "classNameBefore": "com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic", "methodNameBefore": "com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic#isApplicable", "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic#inferTypes\n methodBody: private static void inferTypes(ResolvedType source, ResolvedType target, Map<ResolvedTypeParameterDeclaration, ResolvedType> mappings) {\nif(source.equals(target)){return;\n}if(source.isReferenceType() && target.isReferenceType()){ResolvedReferenceType sourceRefType=source.asReferenceType();\nResolvedReferenceType targetRefType=target.asReferenceType();\nif(sourceRefType.getQualifiedName().equals(targetRefType.getQualifiedName())){if(!sourceRefType.isRawType() && !targetRefType.isRawType()){for(int i=0; i < sourceRefType.typeParametersValues().size(); i++){inferTypes(sourceRefType.typeParametersValues().get(i),targetRefType.typeParametersValues().get(i),mappings);\n}}}return;\n}if(source.isReferenceType() && target.isWildcard()){if(target.asWildcard().isBounded()){inferTypes(source,target.asWildcard().getBoundedType(),mappings);\nreturn;\n}return;\n}if(source.isWildcard() && target.isWildcard()){return;\n}if(source.isReferenceType() && target.isTypeVariable()){mappings.put(target.asTypeParameter(),source);\nreturn;\n}if(source.isWildcard() && target.isReferenceType()){if(source.asWildcard().isBounded()){inferTypes(source.asWildcard().getBoundedType(),target,mappings);\n}return;\n}if(source.isWildcard() && target.isTypeVariable()){mappings.put(target.asTypeParameter(),source);\nreturn;\n}if(source.isTypeVariable() && target.isTypeVariable()){mappings.put(target.asTypeParameter(),source);\nreturn;\n}if(source.isPrimitive() || target.isPrimitive()){return;\n}if(source.isNull()){return;\n}}", "classSignatureBefore": "public class MethodResolutionLogic ", "methodNameBeforeSet": ["com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic#isApplicable"], "classNameBeforeSet": ["com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic"], "classSignatureBeforeSet": ["public class MethodResolutionLogic "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.resolution;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodLikeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.logic.MethodResolutionCapability;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\n\n/**\n * @author Federico Tomassetti\n */\npublic class MethodResolutionLogic {\n    \n    private static String JAVA_LANG_OBJECT = Object.class.getCanonicalName();\n\n    private static List<ResolvedType> groupVariadicParamValues(List<ResolvedType> argumentsTypes, int startVariadic, ResolvedType variadicType) {\n        List<ResolvedType> res = new ArrayList<>(argumentsTypes.subList(0, startVariadic));\n        List<ResolvedType> variadicValues = argumentsTypes.subList(startVariadic, argumentsTypes.size());\n        if (variadicValues.isEmpty()) {\n            // TODO if there are no variadic values we should default to the bound of the formal type\n            res.add(variadicType);\n        } else {\n            ResolvedType componentType = findCommonType(variadicValues);\n            res.add(new ResolvedArrayType(componentType));\n        }\n        return res;\n    }\n\n    private static ResolvedType findCommonType(List<ResolvedType> variadicValues) {\n        if (variadicValues.isEmpty()) {\n            throw new IllegalArgumentException();\n        }\n        // TODO implement this decently\n        return variadicValues.get(0);\n    }\n\n    public static boolean isApplicable(ResolvedMethodDeclaration method, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n        return isApplicable(method, name, argumentsTypes, typeSolver, false);\n    }\n\n    /**\n     * Note the specific naming here -- parameters are part of the method declaration,\n     * while arguments are the values passed when calling a method.\n     * Note that \"needle\" refers to that value being used as a search/query term to match against.\n     *\n     * @return true, if the given ResolvedMethodDeclaration matches the given name/types (normally obtained from a MethodUsage)\n     *\n     * @see {@link MethodResolutionLogic#isApplicable(MethodUsage, String, List, TypeSolver)}\n     */\n    private static boolean isApplicable(ResolvedMethodDeclaration methodDeclaration, String needleName, List<ResolvedType> needleArgumentTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!methodDeclaration.getName().equals(needleName)) {\n            return false;\n        }\n\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodParametersDeclared = methodDeclaration.getNumberOfParams();\n        int lastMethodParameterIndex = Math.max(0, countOfMethodParametersDeclared - 1);\n\n        // The index of the final argument passed (on the method usage).\n        int countOfNeedleArgumentsPassed = needleArgumentTypes.size();\n        int lastNeedleArgumentIndex = Math.max(0, countOfNeedleArgumentsPassed - 1);\n\n        boolean methodIsDeclaredWithVariadicParameter = methodDeclaration.hasVariadicParameter();\n\n        if (!methodIsDeclaredWithVariadicParameter && (countOfNeedleArgumentsPassed != countOfMethodParametersDeclared)) {\n            // If it is not variadic, and the number of parameters/arguments are unequal -- this is not a match.\n            return false;\n        }\n\n        if (methodIsDeclaredWithVariadicParameter) {\n            // If the method declaration we're considering has a variadic parameter,\n            // attempt to convert the given list of arguments to fit this pattern\n            // e.g. foo(String s, String... s2) {} --- consider the first argument, then group the remainder as an array\n\n            ResolvedType expectedVariadicParameterType = methodDeclaration.getLastParam().getType();\n            for (ResolvedTypeParameterDeclaration tp : methodDeclaration.getTypeParameters()) {\n                expectedVariadicParameterType = replaceTypeParam(expectedVariadicParameterType, tp, typeSolver);\n            }\n\n            if(countOfNeedleArgumentsPassed <= (countOfMethodParametersDeclared - 2)) {\n                // If it is variadic, and the number of arguments are short by **two or more** -- this is not a match.\n                // Note that omitting the variadic parameter is treated as an empty array\n                //  (thus being short of only 1 argument is fine, but being short of 2 or more is not).\n                return false;\n            }\n            if (countOfNeedleArgumentsPassed > countOfMethodParametersDeclared) {\n                // If it is variadic, and we have an \"excess\" of arguments, group the \"trailing\" arguments into an array.\n                // Confirm all of these grouped \"trailing\" arguments have the required type -- if not, this is not a valid type. (Maybe this is also done later..?)\n                for(int variadicArgumentIndex = countOfMethodParametersDeclared; variadicArgumentIndex < countOfNeedleArgumentsPassed; variadicArgumentIndex++) {\n                    ResolvedType currentArgumentType = needleArgumentTypes.get(variadicArgumentIndex);\n                    boolean argumentIsAssignableToVariadicComponentType = expectedVariadicParameterType.asArrayType().getComponentType().isAssignableBy(currentArgumentType);\n                    if(!argumentIsAssignableToVariadicComponentType) {\n                        // If any of the arguments are not assignable to the expected variadic type, this is not a match.\n                        return false;\n                    }\n                }\n                needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());\n            }\n            if (countOfNeedleArgumentsPassed == (countOfMethodParametersDeclared - 1)) {\n                // If it is variadic and we are short of **exactly one** parameter, this is a match.\n                // Note that omitting the variadic parameter is treated as an empty array\n                //  (thus being short of only 1 argument is fine, but being short of 2 or more is not).\n\n                // thus group the \"empty\" value into an empty array...\n                needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());\n            } else if (countOfNeedleArgumentsPassed == countOfMethodParametersDeclared) {\n                ResolvedType actualArgumentType = needleArgumentTypes.get(lastNeedleArgumentIndex);\n                boolean finalArgumentIsArray = actualArgumentType.isArray() && expectedVariadicParameterType.isAssignableBy(actualArgumentType.asArrayType().getComponentType());\n                if(finalArgumentIsArray) {\n                    // Treat as an array of values -- in which case the expected parameter type is the common type of this array.\n                    // no need to do anything\n//                    expectedVariadicParameterType = actualArgumentType.asArrayType().getComponentType();\n                } else {\n                    // Treat as a single value -- in which case, the expected parameter type is the same as the single value.\n                    needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());\n                }\n            } else {\n                // Should be unreachable.\n            }\n        }\n\n\n        // The index of the final argument passed (on the method usage).\n        int countOfNeedleArgumentsPassedAfterGrouping = needleArgumentTypes.size();\n        int lastNeedleArgumentIndexAfterGrouping = Math.max(0, countOfNeedleArgumentsPassed - 1);\n\n        // If variadic parameters are possible then they will have been \"grouped\" into a single argument.\n        // At this point, therefore, the number of arguments must be equal -- if they're not, then there is no match.\n        if (countOfNeedleArgumentsPassedAfterGrouping != countOfMethodParametersDeclared) {\n            return false;\n        }\n\n\n        Map<String, ResolvedType> matchedParameters = new HashMap<>();\n        boolean needForWildCardTolerance = false;\n        for (int i = 0; i < countOfMethodParametersDeclared; i++) {\n            ResolvedType expectedDeclaredType = methodDeclaration.getParam(i).getType();\n            ResolvedType actualArgumentType = needleArgumentTypes.get(i);\n            if ((expectedDeclaredType.isTypeVariable() && !(expectedDeclaredType.isWildcard())) && expectedDeclaredType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedDeclaredType.asTypeParameter().getName(), actualArgumentType);\n                continue;\n            }\n            \n            boolean isAssignableWithoutSubstitution = expectedDeclaredType.isAssignableBy(actualArgumentType) ||\n                    (methodDeclaration.getParam(i).isVariadic() && new ResolvedArrayType(expectedDeclaredType).isAssignableBy(actualArgumentType));\n\n            if (!isAssignableWithoutSubstitution && expectedDeclaredType.isReferenceType() && actualArgumentType.isReferenceType()) {\n                isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                        expectedDeclaredType.asReferenceType(),\n                        actualArgumentType.asReferenceType(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List<ResolvedTypeParameterDeclaration> typeParameters = methodDeclaration.getTypeParameters();\n                typeParameters.addAll(methodDeclaration.declaringType().getTypeParameters());\n                for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                    expectedDeclaredType = replaceTypeParam(expectedDeclaredType, tp, typeSolver);\n                }\n\n                if (!expectedDeclaredType.isAssignableBy(actualArgumentType)) {\n                    if (actualArgumentType.isWildcard() && withWildcardTolerance && !expectedDeclaredType.isPrimitive()) {\n                        needForWildCardTolerance = true;\n                        continue;\n                    }\n                    // if the expected is java.lang.Math.max(double,double) and the type parameters are defined with constrain\n                    // for example LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=T}}}, LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=U}}}\n                    // we want to keep this method for future resolution\n                    if (actualArgumentType.isConstraint() && withWildcardTolerance && expectedDeclaredType.isPrimitive()) {\n                        needForWildCardTolerance = true;\n                        continue;\n                    }\n                    if (methodIsDeclaredWithVariadicParameter && i == countOfMethodParametersDeclared - 1) {\n                        if (new ResolvedArrayType(expectedDeclaredType).isAssignableBy(actualArgumentType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }\n\n    public static boolean isAssignableMatchTypeParameters(ResolvedType expected, ResolvedType actual,\n                                                          Map<String, ResolvedType> matchedParameters) {\n        if (expected.isReferenceType() && actual.isReferenceType()) {\n            return isAssignableMatchTypeParameters(expected.asReferenceType(), actual.asReferenceType(), matchedParameters);\n        }\n        if (expected.isTypeVariable()) {\n            matchedParameters.put(expected.asTypeParameter().getName(), actual);\n            return true;\n        }\n        if (expected.isArray()) {\n            matchedParameters.put(expected.asArrayType().getComponentType().toString(), actual);\n            return true;\n        }\n        throw new UnsupportedOperationException(expected.getClass().getCanonicalName() + \" \" + actual.getClass().getCanonicalName());\n    }\n\n    public static boolean isAssignableMatchTypeParameters(ResolvedReferenceType expected, ResolvedReferenceType actual,\n                                                          Map<String, ResolvedType> matchedParameters) {\n        if (actual.getQualifiedName().equals(expected.getQualifiedName())) {\n            return isAssignableMatchTypeParametersMatchingQName(expected, actual, matchedParameters);\n        } else {\n            List<ResolvedReferenceType> ancestors = actual.getAllAncestors();\n            for (ResolvedReferenceType ancestor : ancestors) {\n                if (isAssignableMatchTypeParametersMatchingQName(expected, ancestor, matchedParameters)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static boolean isAssignableMatchTypeParametersMatchingQName(ResolvedReferenceType expected, ResolvedReferenceType actual,\n                                                                        Map<String, ResolvedType> matchedParameters) {\n\n        if (!expected.getQualifiedName().equals(actual.getQualifiedName())) {\n            return false;\n        }\n        if (expected.typeParametersValues().size() != actual.typeParametersValues().size()) {\n            throw new UnsupportedOperationException();\n            //return true;\n        }\n        for (int i = 0; i < expected.typeParametersValues().size(); i++) {\n            ResolvedType expectedParam = expected.typeParametersValues().get(i);\n            ResolvedType actualParam = actual.typeParametersValues().get(i);\n\n            // In the case of nested parameterizations eg. List<R> <-> List<Integer>\n            // we should peel off one layer and ensure R <-> Integer\n            if (expectedParam.isReferenceType() && actualParam.isReferenceType()) {\n                ResolvedReferenceType r1 = expectedParam.asReferenceType();\n                ResolvedReferenceType r2 = actualParam.asReferenceType();\n                // we can have r1=A and r2=A.B (with B extends A and B is an inner class of A)\n                // in this case we want to verify expected parameter from the actual parameter ancestors \n                return isAssignableMatchTypeParameters(r1, r2, matchedParameters);\n            }\n\n            if (expectedParam.isTypeVariable()) {\n                String expectedParamName = expectedParam.asTypeParameter().getName();\n                if (!actualParam.isTypeVariable() || !actualParam.asTypeParameter().getName().equals(expectedParamName)) {\n                    return matchTypeVariable(expectedParam.asTypeVariable(), actualParam, matchedParameters);\n                }\n            } else if (expectedParam.isReferenceType()) {\n                if (actualParam.isTypeVariable()) {\n                    return matchTypeVariable(actualParam.asTypeVariable(), expectedParam, matchedParameters);\n                }\n                if (!expectedParam.equals(actualParam)) {\n                    return false;\n                }\n            } else if (expectedParam.isWildcard()) {\n                if (expectedParam.asWildcard().isExtends()) {\n                    return isAssignableMatchTypeParameters(expectedParam.asWildcard().getBoundedType(), actual, matchedParameters);\n                }\n                // TODO verify super bound\n                return true;\n            } else {\n                throw new UnsupportedOperationException(expectedParam.describe());\n            }\n        }\n        return true;\n    }\n\n    private static boolean matchTypeVariable(ResolvedTypeVariable typeVariable, ResolvedType type, Map<String, ResolvedType> matchedParameters) {\n        String typeParameterName = typeVariable.asTypeParameter().getName();\n        if (matchedParameters.containsKey(typeParameterName)) {\n            ResolvedType matchedParameter = matchedParameters.get(typeParameterName);\n            if (matchedParameter.isAssignableBy(type)) {\n                return true;\n            } else if (type.isAssignableBy(matchedParameter)) {\n                // update matchedParameters to contain the more general type\n                matchedParameters.put(typeParameterName, type);\n                return true;\n            }\n            return false;\n        } else {\n            matchedParameters.put(typeParameterName, type);\n        }\n        return true;\n    }\n\n    public static ResolvedType replaceTypeParam(ResolvedType type, ResolvedTypeParameterDeclaration tp, TypeSolver typeSolver) {\n        if (type.isTypeVariable() || type.isWildcard()) {\n            if (type.describe().equals(tp.getName())) {\n                List<ResolvedTypeParameterDeclaration.Bound> bounds = tp.getBounds();\n                if (bounds.size() > 1) {\n                    throw new UnsupportedOperationException();\n                }\n                if (bounds.size() == 1) {\n                    return bounds.get(0).getType();\n                }\n                return new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver);\n            }\n            return type;\n        }\n        if (type.isPrimitive()) {\n            return type;\n        }\n        if (type.isArray()) {\n            return new ResolvedArrayType(replaceTypeParam(type.asArrayType().getComponentType(), tp, typeSolver));\n        }\n        if (type.isReferenceType()) {\n            ResolvedReferenceType result = type.asReferenceType();\n            result = result.transformTypeParameters(typeParam -> replaceTypeParam(typeParam, tp, typeSolver)).asReferenceType();\n            return result;\n        }\n        throw new UnsupportedOperationException(\"Replacing \" + type + \", param \" + tp + \" with \" + type.getClass().getCanonicalName());\n    }\n\n    /**\n     * Note the specific naming here -- parameters are part of the method declaration,\n     * while arguments are the values passed when calling a method.\n     * Note that \"needle\" refers to that value being used as a search/query term to match against.\n     *\n     * @return true, if the given MethodUsage matches the given name/types (normally obtained from a ResolvedMethodDeclaration)\n     *\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver)}  }\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver, boolean)}\n     */\n    public static boolean isApplicable(MethodUsage methodUsage, String needleName, List<ResolvedType> needleParameterTypes, TypeSolver typeSolver) {\n        if (!methodUsage.getName().equals(needleName)) {\n            return false;\n        }\n\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodUsageArgumentsPassed = methodUsage.getNoParams();\n        int lastMethodUsageArgumentIndex = Math.max(0, countOfMethodUsageArgumentsPassed - 1);\n\n        // The index of the final argument passed (on the method usage).\n        int needleParameterCount = needleParameterTypes.size();\n        int lastNeedleParameterIndex = Math.max(0, needleParameterCount - 1);\n\n        // TODO: Does the method usage have a declaration at this point..?\n        boolean methodIsDeclaredWithVariadicParameter = methodUsage.getDeclaration().hasVariadicParameter();\n\n        // If the counts do not match and the method is not variadic, this is not a match.\n        if (!methodIsDeclaredWithVariadicParameter && !(needleParameterCount == countOfMethodUsageArgumentsPassed)) {\n            return false;\n        }\n\n        // If the counts do not match and we have provided too few arguments, this is not a match. Note that variadic parameters\n        // allow you to omit the vararg, which would allow a difference of one, but a difference in count of 2 or more is not a match.\n        if (!(needleParameterCount == countOfMethodUsageArgumentsPassed) && needleParameterCount < lastMethodUsageArgumentIndex) {\n            return false;\n        }\n\n        // Iterate over the arguments given to the method, and compare their types against the given method's declared parameter types\n        for (int i = 0; i < needleParameterCount; i++) {\n            ResolvedType actualArgumentType = needleParameterTypes.get(i);\n\n            ResolvedType expectedArgumentType;\n            boolean reachedVariadicParam = methodIsDeclaredWithVariadicParameter && i >= lastMethodUsageArgumentIndex;\n            if (!reachedVariadicParam) {\n                // Not yet reached the variadic parameters -- the expected type is just whatever is at that position.\n                expectedArgumentType = methodUsage.getParamType(i);\n            } else {\n                // We have reached the variadic parameters -- the expected type is the type of the last declared parameter.\n                expectedArgumentType = methodUsage.getParamType(lastMethodUsageArgumentIndex);\n                // Note that the given variadic value might be an array - if so, use the array's component type rather.\n                // This is only valid if ONE argument has been given to the vararg parameter.\n                // Example: {@code void test(String... s) {}} and {@code test(stringArray)} -- {@code String... is assignable by stringArray}\n                // Example: {@code void test(String[]... s) {}} and {@code test(stringArrayArray)} -- {@code String[]... is assignable by stringArrayArray}\n                boolean argumentIsArray = (needleParameterCount == countOfMethodUsageArgumentsPassed) && expectedArgumentType.isAssignableBy(actualArgumentType);\n                if (!argumentIsArray) {\n                    // Get the component type of the declared parameter type.\n                    expectedArgumentType = expectedArgumentType.asArrayType().getComponentType();\n                }\n            }\n\n            // Consider type parameters directly on the method declaration, and ALSO on the enclosing type (e.g. a class)\n            List<ResolvedTypeParameterDeclaration> typeParameters = methodUsage.getDeclaration().getTypeParameters();\n            typeParameters.addAll(methodUsage.declaringType().getTypeParameters());\n\n            ResolvedType expectedTypeWithoutSubstitutions = expectedArgumentType;\n            ResolvedType expectedTypeWithInference = expectedArgumentType;\n            Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n\n            // For each declared parameter, infer the types that will replace generics (type parameters)\n            for (int j = 0; j < countOfMethodUsageArgumentsPassed; j++) {\n                ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(j);\n                ResolvedType parameterType = parameter.getType();\n                if (parameter.isVariadic()) {\n                    // Don't continue if a vararg parameter is reached and there are no arguments left\n                    if (needleParameterCount == j) {\n                        break;\n                    }\n                    parameterType = parameterType.asArrayType().getComponentType();\n                }\n                inferTypes(needleParameterTypes.get(j), parameterType, derivedValues);\n            }\n\n            for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()) {\n                ResolvedTypeParameterDeclaration tp = entry.getKey();\n                expectedTypeWithInference = expectedTypeWithInference.replaceTypeVariables(tp, entry.getValue());\n            }\n\n            // Consider cases where type variables can be replaced (e.g. add(E element) vs add(String element))\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver)));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), bound.getType());\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(bound.getType()));\n                    } else {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.superBound(bound.getType()));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // Consider cases where type variables involve bounds e.g. super/extends\n            ResolvedType expectedTypeWithSubstitutions = expectedTypeWithoutSubstitutions;\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, bound.getType());\n                    } else {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // If the given argument still isn't applicable even after considering type arguments/generics, this is not a match.\n            if (!expectedArgumentType.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithSubstitutions.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithInference.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithoutSubstitutions.isAssignableBy(actualArgumentType)) {\n                return false;\n            }\n        }\n\n        // If the checks above haven't failed, then we've found a match.\n        return true;\n    }\n\n    /**\n     * Filters by given function {@param keyExtractor} using a stateful filter mechanism.\n     *\n     * <pre>\n     *      persons.stream().filter(distinctByKey(Person::getName))\n     * </pre>\n     * <p>\n     * The example above would return a distinct list of persons containing only one person per name.\n     */\n    private static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {\n        Set<Object> seen = ConcurrentHashMap.newKeySet();\n        return t -> seen.add(keyExtractor.apply(t));\n    }\n\n    /**\n     * @param methods we expect the methods to be ordered such that inherited methods are later in the list\n     */\n    public static SymbolReference<ResolvedMethodDeclaration> findMostApplicable(List<ResolvedMethodDeclaration> methods,\n                                                                                String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n        SymbolReference<ResolvedMethodDeclaration> res = findMostApplicable(methods, name, argumentsTypes, typeSolver, false);\n        if (res.isSolved()) {\n            return res;\n        }\n        return findMostApplicable(methods, name, argumentsTypes, typeSolver, true);\n    }\n\n    public static SymbolReference<ResolvedMethodDeclaration> findMostApplicable(List<ResolvedMethodDeclaration> methods,\n                                                                                String name, List<ResolvedType> argumentsTypes,\n                                                                                TypeSolver typeSolver,\n                                                                                boolean wildcardTolerance\n    ) {\n\n        List<ResolvedMethodDeclaration> applicableMethods = methods.stream()\n                // Only consider methods with a matching name\n                .filter(m -> m.getName().equals(name))\n                // Filters out duplicate ResolvedMethodDeclaration by their signature.\n                .filter(distinctByKey(ResolvedMethodDeclaration::getQualifiedSignature))\n                // Checks if ResolvedMethodDeclaration is applicable to argumentsTypes.\n                .filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver, wildcardTolerance))\n                .collect(Collectors.toList());\n\n        // If no applicable methods found, return as unsolved.\n        if (applicableMethods.isEmpty()) {\n            return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n        }\n\n        // If there are multiple possible methods found, null arguments can help to eliminate some matches.\n        if (applicableMethods.size() > 1) {\n            List<Integer> nullParamIndexes = new ArrayList<>();\n            for (int i = 0; i < argumentsTypes.size(); i++) {\n                if (argumentsTypes.get(i).isNull()) {\n                    nullParamIndexes.add(i);\n                }\n            }\n\n            // If some null arguments have been provided, use this to eliminate some opitons.\n            if (!nullParamIndexes.isEmpty()) {\n                // remove method with array param if a non array exists and arg is null\n                Set<ResolvedMethodDeclaration> removeCandidates = new HashSet<>();\n                for (Integer nullParamIndex : nullParamIndexes) {\n                    for (ResolvedMethodDeclaration methDecl : applicableMethods) {\n                        if (methDecl.getParam(nullParamIndex).getType().isArray()) {\n                            removeCandidates.add(methDecl);\n                        }\n                    }\n                }\n\n                // Where candidiates for removal are found, remove them.\n                if (!removeCandidates.isEmpty() && removeCandidates.size() < applicableMethods.size()) {\n                    applicableMethods.removeAll(removeCandidates);\n                }\n            }\n        }\n\n        // If only one applicable method found, short-circuit and return it here.\n        if (applicableMethods.size() == 1) {\n            return SymbolReference.solved(applicableMethods.get(0));\n        }\n        \n        // Examine the applicable methods found, and evaluate each to determine the \"best\" one\n        ResolvedMethodDeclaration winningCandidate = applicableMethods.get(0);\n        ResolvedMethodDeclaration other = null;\n        boolean possibleAmbiguity = false;\n        for (int i = 1; i < applicableMethods.size(); i++) {\n            other = applicableMethods.get(i);\n            if (isMoreSpecific(winningCandidate, other, argumentsTypes)) {\n                possibleAmbiguity = false;\n            } else if (isMoreSpecific(other, winningCandidate, argumentsTypes)) {\n                possibleAmbiguity = false;\n                winningCandidate = other;\n            } else {\n                // 15.12.2.5. Choosing the Most Specific Method\n                // One applicable method m1 is more specific than another applicable method m2, for an invocation with argument\n                // expressions e1, ..., ek, if any of the following are true:\n                // m2 is generic, and m1 is inferred to be more specific than m2 for argument expressions e1, ..., ek by \u00a718.5.4.\n                // 18.5.4. More Specific Method Inference should be verified \n                // ...\n                if (winningCandidate.isGeneric() && !other.isGeneric()) {\n                    winningCandidate = other;\n                } else if (!winningCandidate.isGeneric() && other.isGeneric()) {\n                    // nothing to do at this stage winningCandidate is the winner\n                } else if (winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName())) {\n                    possibleAmbiguity = true;\n                } else {\n                    // we expect the methods to be ordered such that inherited methods are later in the list\n                }\n            }\n        }\n        \n        if (possibleAmbiguity) {\n            // pick the first exact match if it exists\n            if (!isExactMatch(winningCandidate, argumentsTypes)) {\n                if (isExactMatch(other, argumentsTypes)) {\n                    winningCandidate = other;\n                } else {\n                    throw new MethodAmbiguityException(\n                            \"Ambiguous method call: cannot find a most applicable method: \" + winningCandidate\n                                    + \", \" + other);\n                }\n            }\n        }\n\n        return SymbolReference.solved(winningCandidate);\n    }\n\n    protected static boolean isExactMatch(ResolvedMethodLikeDeclaration method, List<ResolvedType> argumentsTypes) {\n        for (int i = 0; i < method.getNumberOfParams(); i++) {\n            if (!method.getParam(i).getType().equals(argumentsTypes.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static ResolvedType getMethodsExplicitAndVariadicParameterType(ResolvedMethodDeclaration method, int i) {\n        int numberOfParams = method.getNumberOfParams();\n\n        if (i < numberOfParams) {\n            return method.getParam(i).getType();\n        }\n        if (method.hasVariadicParameter()) {\n            return method.getParam(numberOfParams - 1).getType();\n        }\n        return null;\n    }\n\n    private static boolean isMoreSpecific(ResolvedMethodDeclaration methodA, ResolvedMethodDeclaration methodB,\n                                          List<ResolvedType> argumentTypes) {\n\n        final boolean aVariadic = methodA.hasVariadicParameter();\n        final boolean bVariadic = methodB.hasVariadicParameter();\n        final int aNumberOfParams = methodA.getNumberOfParams();\n        final int bNumberOfParams = methodB.getNumberOfParams();\n        final int numberOfArgs = argumentTypes.size();\n        final ResolvedType lastArgType = numberOfArgs > 0 ? argumentTypes.get(numberOfArgs - 1) : null;\n        final boolean isLastArgArray = lastArgType != null && lastArgType.isArray();\n        int omittedArgs = 0;\n        boolean isMethodAMoreSpecific = false;\n\n        // If one method declaration has exactly the correct amount of parameters and is not variadic then it is always\n        // preferred to a declaration that is variadic (and hence possibly also has a different amount of parameters).\n        if (!aVariadic && aNumberOfParams == numberOfArgs && (bVariadic && (bNumberOfParams != numberOfArgs ||\n                !isLastArgArray))) {\n            return true;\n        }\n        if (!bVariadic && bNumberOfParams == numberOfArgs && (aVariadic && (aNumberOfParams != numberOfArgs ||\n                !isLastArgArray))) {\n            return false;\n        }\n        \n        // If both methods are variadic but the calling method omits any varArgs, bump the omitted args to\n        // ensure the varargs type is considered when determining which method is more specific\n        if (aVariadic && bVariadic && aNumberOfParams == bNumberOfParams && numberOfArgs == aNumberOfParams - 1) {\n        \tomittedArgs++;\n        }\n\n        // Either both methods are variadic or neither is. So we must compare the parameter types.\n        for (int i = 0; i < numberOfArgs + omittedArgs; i++) {\n            ResolvedType paramTypeA = getMethodsExplicitAndVariadicParameterType(methodA, i);\n            ResolvedType paramTypeB = getMethodsExplicitAndVariadicParameterType(methodB, i);\n            \n            ResolvedType argType = null;\n            if (i < argumentTypes.size()) {\n            \targType = argumentTypes.get(i);\n            }\n\n            // Safety: if a type is null it means a signature with too few parameters managed to get to this point.\n            // This should not happen but it also means that this signature is immediately disqualified.\n            if (paramTypeA == null) {\n                return false;\n            }\n            if (paramTypeB == null) {\n                return true;\n            }\n            // Widening primitive conversions have priority over boxing/unboxing conversions when finding the most\n            // applicable method. E.g. assume we have method call foo(1) and declarations foo(long) and foo(Integer).\n            // The method call will call foo(long), as it requires a widening primitive conversion from int to long\n            // instead of a boxing conversion from int to Integer. See JLS \u00a715.12.2.\n            // This is what we check here.\n            if (argType != null &&\n            \t\tparamTypeA.isPrimitive() == argType.isPrimitive() &&\n                    paramTypeB.isPrimitive() != argType.isPrimitive() &&\n                    paramTypeA.isAssignableBy(argType)) {\n\n                return true;\n            }\n            if (argType != null &&\n            \t\tparamTypeB.isPrimitive() == argType.isPrimitive() &&\n                    paramTypeA.isPrimitive() != argType.isPrimitive() &&\n                    paramTypeB.isAssignableBy(argType)) {\n\n                return false;\n            // if paramA and paramB are not the last parameters\n            // and the type of paramA or paramB (which are not more specific at this stage) is java.lang.Object\n            // then we have to consider others parameters before concluding\n            }\n            if ((i < numberOfArgs - 1)\n                    && (isJavaLangObject(paramTypeB) || (isJavaLangObject(paramTypeA)))) {\n                // consider others parameters\n                // but eventually mark the method A as more specific if the methodB has an argument of type java.lang.Object\n                isMethodAMoreSpecific = isMethodAMoreSpecific || isJavaLangObject(paramTypeB);\n            }\n            // If we get to this point then we check whether one of the methods contains a parameter type that is more\n            // specific. If it does, we can assume the entire declaration is more specific as we would otherwise have\n            // a situation where the declarations are ambiguous in the given context.\n            else {\n                boolean aAssignableFromB = paramTypeA.isAssignableBy(paramTypeB);\n                boolean bAssignableFromA = paramTypeB.isAssignableBy(paramTypeA);\n\n                if (bAssignableFromA && !aAssignableFromB) {\n                    // A's parameter is more specific\n                    return true;\n                }\n                if (aAssignableFromB && !bAssignableFromA) {\n                    // B's parameter is more specific\n                    return false;\n                }\n            }\n        }\n\n        if (aVariadic && !bVariadic) {\n            // if the last argument is an array then m1 is more specific\n            return isLastArgArray;\n        }\n        if (!aVariadic && bVariadic) {\n            // if the last argument is an array and m1 is not variadic then\n            // it is not more specific\n            return !isLastArgArray;\n        }\n\n        return isMethodAMoreSpecific;\n    }\n    \n    private static boolean isJavaLangObject(ResolvedType paramType ) {\n        return paramType.isReferenceType() && paramType.asReferenceType().getQualifiedName().equals(\"java.lang.Object\");\n    }\n\n    private static boolean isMoreSpecific(MethodUsage methodA, MethodUsage methodB) {\n        boolean oneMoreSpecificFound = false;\n        for (int i = 0; i < methodA.getNoParams(); i++) {\n            ResolvedType tdA = methodA.getParamType(i);\n            ResolvedType tdB = methodB.getParamType(i);\n\n            boolean aIsAssignableByB = tdA.isAssignableBy(tdB);\n            boolean bIsAssignableByA = tdB.isAssignableBy(tdA);\n\n            // A is more specific\n            if (bIsAssignableByA && !aIsAssignableByB) {\n                oneMoreSpecificFound = true;\n            }\n            // B is more specific\n            if (aIsAssignableByB && !bIsAssignableByA) {\n                return false;\n            }\n\n            // If B is vararg and A is not, A is more specific\n            if (tdB.isArray() && tdB.asArrayType().getComponentType().isAssignableBy(tdA)) {\n                oneMoreSpecificFound = true;\n            }\n        }\n        return oneMoreSpecificFound;\n    }\n\n    public static Optional<MethodUsage> findMostApplicableUsage(List<MethodUsage> methods, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n        List<MethodUsage> applicableMethods = methods.stream().filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver)).collect(Collectors.toList());\n\n        if (applicableMethods.isEmpty()) {\n            return Optional.empty();\n        }\n        if (applicableMethods.size() == 1) {\n            return Optional.of(applicableMethods.get(0));\n        } else {\n            MethodUsage winningCandidate = applicableMethods.get(0);\n            for (int i = 1; i < applicableMethods.size(); i++) {\n                MethodUsage other = applicableMethods.get(i);\n                if (isMoreSpecific(winningCandidate, other)) {\n                    // nothing to do\n                } else if (isMoreSpecific(other, winningCandidate)) {\n                    winningCandidate = other;\n                } else {\n                    if (winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName())) {\n                        if (!areOverride(winningCandidate, other)) {\n                            throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method: \" + winningCandidate + \", \" + other + \". First declared in \" + winningCandidate.declaringType().getQualifiedName());\n                        }\n                    } else {\n                        // we expect the methods to be ordered such that inherited methods are later in the list\n                        //throw new UnsupportedOperationException();\n                    }\n                }\n            }\n            return Optional.of(winningCandidate);\n        }\n    }\n\n    private static boolean areOverride(MethodUsage winningCandidate, MethodUsage other) {\n        if (!winningCandidate.getName().equals(other.getName())) {\n            return false;\n        }\n        if (winningCandidate.getNoParams() != other.getNoParams()) {\n            return false;\n        }\n        for (int i = 0; i < winningCandidate.getNoParams(); i++) {\n            if (!winningCandidate.getParamTypes().get(i).equals(other.getParamTypes().get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static SymbolReference<ResolvedMethodDeclaration> solveMethodInType(ResolvedTypeDeclaration typeDeclaration,\n                                                                               String name,\n                                                                               List<ResolvedType> argumentsTypes) {\n        return solveMethodInType(typeDeclaration, name, argumentsTypes, false);\n    }\n\n    // TODO: Replace TypeDeclaration.solveMethod\n    public static SymbolReference<ResolvedMethodDeclaration> solveMethodInType(ResolvedTypeDeclaration typeDeclaration,\n                                                                               String name,\n                                                                               List<ResolvedType> argumentsTypes,\n                                                                               boolean staticOnly) {\n\n        if (typeDeclaration instanceof MethodResolutionCapability) {\n            return ((MethodResolutionCapability) typeDeclaration).solveMethod(name, argumentsTypes,\n                    staticOnly);\n        }\n        throw new UnsupportedOperationException(typeDeclaration.getClass().getCanonicalName());\n    }\n\n    private static void inferTypes(ResolvedType source, ResolvedType target, Map<ResolvedTypeParameterDeclaration, ResolvedType> mappings) {\n        if (source.equals(target)) {\n            return;\n        }\n        if (source.isReferenceType() && target.isReferenceType()) {\n            ResolvedReferenceType sourceRefType = source.asReferenceType();\n            ResolvedReferenceType targetRefType = target.asReferenceType();\n            if (sourceRefType.getQualifiedName().equals(targetRefType.getQualifiedName())) {\n                if (!sourceRefType.isRawType() && !targetRefType.isRawType()) {\n                    for (int i = 0; i < sourceRefType.typeParametersValues().size(); i++) {\n                        inferTypes(sourceRefType.typeParametersValues().get(i), targetRefType.typeParametersValues().get(i), mappings);\n                    }\n                }\n            }\n            return;\n        }\n        if (source.isReferenceType() && target.isWildcard()) {\n            if (target.asWildcard().isBounded()) {\n                inferTypes(source, target.asWildcard().getBoundedType(), mappings);\n                return;\n            }\n            return;\n        }\n        if (source.isWildcard() && target.isWildcard()) {\n            return;\n        }\n        if (source.isReferenceType() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n\n        if (source.isWildcard() && target.isReferenceType()) {\n            if (source.asWildcard().isBounded()) {\n                inferTypes(source.asWildcard().getBoundedType(), target, mappings);\n            }\n            return;\n        }\n\n        if (source.isWildcard() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isTypeVariable() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isPrimitive() || target.isPrimitive()) {\n            return;\n        }\n        if (source.isNull()) {\n            return;\n        }\n    }\n\n}\n", "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.resolution;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodLikeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.logic.MethodResolutionCapability;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\n\n/**\n * @author Federico Tomassetti\n */\npublic class MethodResolutionLogic {\n    \n    private static String JAVA_LANG_OBJECT = Object.class.getCanonicalName();\n\n    private static List<ResolvedType> groupVariadicParamValues(List<ResolvedType> argumentsTypes, int startVariadic, ResolvedType variadicType) {\n        List<ResolvedType> res = new ArrayList<>(argumentsTypes.subList(0, startVariadic));\n        List<ResolvedType> variadicValues = argumentsTypes.subList(startVariadic, argumentsTypes.size());\n        if (variadicValues.isEmpty()) {\n            // TODO if there are no variadic values we should default to the bound of the formal type\n            res.add(variadicType);\n        } else {\n            ResolvedType componentType = findCommonType(variadicValues);\n            res.add(new ResolvedArrayType(componentType));\n        }\n        return res;\n    }\n\n    private static ResolvedType findCommonType(List<ResolvedType> variadicValues) {\n        if (variadicValues.isEmpty()) {\n            throw new IllegalArgumentException();\n        }\n        // TODO implement this decently\n        return variadicValues.get(0);\n    }\n\n    public static boolean isApplicable(ResolvedMethodDeclaration method, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n        return isApplicable(method, name, argumentsTypes, typeSolver, false);\n    }\n\n    /**\n     * Note the specific naming here -- parameters are part of the method declaration,\n     * while arguments are the values passed when calling a method.\n     * Note that \"needle\" refers to that value being used as a search/query term to match against.\n     *\n     * @return true, if the given ResolvedMethodDeclaration matches the given name/types (normally obtained from a MethodUsage)\n     *\n     * @see {@link MethodResolutionLogic#isApplicable(MethodUsage, String, List, TypeSolver)}\n     */\n    private static boolean isApplicable(ResolvedMethodDeclaration methodDeclaration, String needleName, List<ResolvedType> needleArgumentTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!methodDeclaration.getName().equals(needleName)) {\n            return false;\n        }\n\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodParametersDeclared = methodDeclaration.getNumberOfParams();\n\n        // The index of the final argument passed (on the method usage).\n        int countOfNeedleArgumentsPassed = needleArgumentTypes.size();\n\n        boolean methodIsDeclaredWithVariadicParameter = methodDeclaration.hasVariadicParameter();\n\n        if (!methodIsDeclaredWithVariadicParameter && (countOfNeedleArgumentsPassed != countOfMethodParametersDeclared)) {\n            // If it is not variadic, and the number of parameters/arguments are unequal -- this is not a match.\n            return false;\n        }\n\n        if (methodIsDeclaredWithVariadicParameter) {\n\n            if(countOfNeedleArgumentsPassed <= (countOfMethodParametersDeclared - 2)) {\n                // If it is variadic, and the number of arguments are short by **two or more** -- this is not a match.\n                // Note that omitting the variadic parameter is treated as an empty array\n                //  (thus being short of only 1 argument is fine, but being short of 2 or more is not).\n                return false;\n            }\n            \n            // If the method declaration we're considering has a variadic parameter,\n            // attempt to convert the given list of arguments to fit this pattern\n            // e.g. foo(String s, String... s2) {} --- consider the first argument, then group the remainder as an array\n\n            ResolvedType expectedVariadicParameterType = methodDeclaration.getLastParam().getType();\n            for (ResolvedTypeParameterDeclaration tp : methodDeclaration.getTypeParameters()) {\n                expectedVariadicParameterType = replaceTypeParam(expectedVariadicParameterType, tp, typeSolver);\n            }\n            \n            if (countOfNeedleArgumentsPassed > countOfMethodParametersDeclared) {\n                // If it is variadic, and we have an \"excess\" of arguments, group the \"trailing\" arguments into an array.\n                // Confirm all of these grouped \"trailing\" arguments have the required type -- if not, this is not a valid type. (Maybe this is also done later..?)\n                for(int variadicArgumentIndex = countOfMethodParametersDeclared; variadicArgumentIndex < countOfNeedleArgumentsPassed; variadicArgumentIndex++) {\n                    ResolvedType currentArgumentType = needleArgumentTypes.get(variadicArgumentIndex);\n                    boolean argumentIsAssignableToVariadicComponentType = expectedVariadicParameterType.asArrayType().getComponentType().isAssignableBy(currentArgumentType);\n                    if(!argumentIsAssignableToVariadicComponentType) {\n                        // If any of the arguments are not assignable to the expected variadic type, this is not a match.\n                        return false;\n                    }\n                }\n            }\n            needleArgumentTypes = groupTrailingArgumentsIntoArray(methodDeclaration, needleArgumentTypes, expectedVariadicParameterType);\n        }\n\n\n        // The index of the final argument passed (on the method usage).\n        int countOfNeedleArgumentsPassedAfterGrouping = needleArgumentTypes.size();\n        int lastNeedleArgumentIndexAfterGrouping = getLastParameterIndex(countOfNeedleArgumentsPassed);\n\n        // If variadic parameters are possible then they will have been \"grouped\" into a single argument.\n        // At this point, therefore, the number of arguments must be equal -- if they're not, then there is no match.\n        if (countOfNeedleArgumentsPassedAfterGrouping != countOfMethodParametersDeclared) {\n            return false;\n        }\n\n\n        Map<String, ResolvedType> matchedParameters = new HashMap<>();\n        boolean needForWildCardTolerance = false;\n        for (int i = 0; i < countOfMethodParametersDeclared; i++) {\n            ResolvedType expectedDeclaredType = methodDeclaration.getParam(i).getType();\n            ResolvedType actualArgumentType = needleArgumentTypes.get(i);\n            if ((expectedDeclaredType.isTypeVariable() && !(expectedDeclaredType.isWildcard())) && expectedDeclaredType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedDeclaredType.asTypeParameter().getName(), actualArgumentType);\n                continue;\n            }\n            \n            boolean isAssignableWithoutSubstitution = expectedDeclaredType.isAssignableBy(actualArgumentType) ||\n                    (methodDeclaration.getParam(i).isVariadic() && new ResolvedArrayType(expectedDeclaredType).isAssignableBy(actualArgumentType));\n\n            if (!isAssignableWithoutSubstitution && expectedDeclaredType.isReferenceType() && actualArgumentType.isReferenceType()) {\n                isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                        expectedDeclaredType.asReferenceType(),\n                        actualArgumentType.asReferenceType(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List<ResolvedTypeParameterDeclaration> typeParameters = methodDeclaration.getTypeParameters();\n                typeParameters.addAll(methodDeclaration.declaringType().getTypeParameters());\n                for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                    expectedDeclaredType = replaceTypeParam(expectedDeclaredType, tp, typeSolver);\n                }\n\n                if (!expectedDeclaredType.isAssignableBy(actualArgumentType)) {\n                    if (actualArgumentType.isWildcard() && withWildcardTolerance && !expectedDeclaredType.isPrimitive()) {\n                        needForWildCardTolerance = true;\n                        continue;\n                    }\n                    // if the expected is java.lang.Math.max(double,double) and the type parameters are defined with constrain\n                    // for example LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=T}}}, LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=U}}}\n                    // we want to keep this method for future resolution\n                    if (actualArgumentType.isConstraint() && withWildcardTolerance && expectedDeclaredType.isPrimitive()) {\n                        needForWildCardTolerance = true;\n                        continue;\n                    }\n                    if (methodIsDeclaredWithVariadicParameter && i == countOfMethodParametersDeclared - 1) {\n                        if (new ResolvedArrayType(expectedDeclaredType).isAssignableBy(actualArgumentType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }\n\n    /*\n     * Returns the last parameter index\n     */\n    private static int getLastParameterIndex(int countOfMethodParametersDeclared) {\n        return Math.max(0, countOfMethodParametersDeclared - 1);\n    }\n\n    private static List<ResolvedType> groupTrailingArgumentsIntoArray(ResolvedMethodDeclaration methodDeclaration,\n                                                                      List<ResolvedType> needleArgumentTypes,\n                                                                      ResolvedType expectedVariadicParameterType) {\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodParametersDeclared = methodDeclaration.getNumberOfParams();\n        int lastMethodParameterIndex = getLastParameterIndex(countOfMethodParametersDeclared);\n\n        // The index of the final argument passed (on the method usage).\n        int countOfNeedleArgumentsPassed = needleArgumentTypes.size();\n        int lastNeedleArgumentIndex = getLastParameterIndex(countOfNeedleArgumentsPassed);\n        \n        if (countOfNeedleArgumentsPassed > countOfMethodParametersDeclared) {\n            // If it is variadic, and we have an \"excess\" of arguments, group the \"trailing\" arguments into an array.\n            // Here we are sure that all of these grouped \"trailing\" arguments have the required type\n            needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());\n        }\n        if (countOfNeedleArgumentsPassed == (countOfMethodParametersDeclared - 1)) {\n            // If it is variadic and we are short of **exactly one** parameter, this is a match.\n            // Note that omitting the variadic parameter is treated as an empty array\n            //  (thus being short of only 1 argument is fine, but being short of 2 or more is not).\n\n            // thus group the \"empty\" value into an empty array...\n            needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());\n        } else if (countOfNeedleArgumentsPassed == countOfMethodParametersDeclared) {\n            ResolvedType actualArgumentType = needleArgumentTypes.get(lastNeedleArgumentIndex);\n            boolean finalArgumentIsArray = actualArgumentType.isArray() && expectedVariadicParameterType.isAssignableBy(actualArgumentType.asArrayType().getComponentType());\n            if(finalArgumentIsArray) {\n                // Treat as an array of values -- in which case the expected parameter type is the common type of this array.\n                // no need to do anything\n                // expectedVariadicParameterType = actualArgumentType.asArrayType().getComponentType();\n            } else {\n                // Treat as a single value -- in which case, the expected parameter type is the same as the single value.\n                needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());\n            }\n        } else {\n            // Should be unreachable.\n        }\n        return needleArgumentTypes;\n    }\n\n    public static boolean isAssignableMatchTypeParameters(ResolvedType expected, ResolvedType actual,\n                                                          Map<String, ResolvedType> matchedParameters) {\n        if (expected.isReferenceType() && actual.isReferenceType()) {\n            return isAssignableMatchTypeParameters(expected.asReferenceType(), actual.asReferenceType(), matchedParameters);\n        }\n        if (expected.isTypeVariable()) {\n            matchedParameters.put(expected.asTypeParameter().getName(), actual);\n            return true;\n        }\n        if (expected.isArray()) {\n            matchedParameters.put(expected.asArrayType().getComponentType().toString(), actual);\n            return true;\n        }\n        throw new UnsupportedOperationException(expected.getClass().getCanonicalName() + \" \" + actual.getClass().getCanonicalName());\n    }\n\n    public static boolean isAssignableMatchTypeParameters(ResolvedReferenceType expected, ResolvedReferenceType actual,\n                                                          Map<String, ResolvedType> matchedParameters) {\n        if (actual.getQualifiedName().equals(expected.getQualifiedName())) {\n            return isAssignableMatchTypeParametersMatchingQName(expected, actual, matchedParameters);\n        } else {\n            List<ResolvedReferenceType> ancestors = actual.getAllAncestors();\n            for (ResolvedReferenceType ancestor : ancestors) {\n                if (isAssignableMatchTypeParametersMatchingQName(expected, ancestor, matchedParameters)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static boolean isAssignableMatchTypeParametersMatchingQName(ResolvedReferenceType expected, ResolvedReferenceType actual,\n                                                                        Map<String, ResolvedType> matchedParameters) {\n\n        if (!expected.getQualifiedName().equals(actual.getQualifiedName())) {\n            return false;\n        }\n        if (expected.typeParametersValues().size() != actual.typeParametersValues().size()) {\n            throw new UnsupportedOperationException();\n            //return true;\n        }\n        for (int i = 0; i < expected.typeParametersValues().size(); i++) {\n            ResolvedType expectedParam = expected.typeParametersValues().get(i);\n            ResolvedType actualParam = actual.typeParametersValues().get(i);\n\n            // In the case of nested parameterizations eg. List<R> <-> List<Integer>\n            // we should peel off one layer and ensure R <-> Integer\n            if (expectedParam.isReferenceType() && actualParam.isReferenceType()) {\n                ResolvedReferenceType r1 = expectedParam.asReferenceType();\n                ResolvedReferenceType r2 = actualParam.asReferenceType();\n                // we can have r1=A and r2=A.B (with B extends A and B is an inner class of A)\n                // in this case we want to verify expected parameter from the actual parameter ancestors \n                return isAssignableMatchTypeParameters(r1, r2, matchedParameters);\n            }\n\n            if (expectedParam.isTypeVariable()) {\n                String expectedParamName = expectedParam.asTypeParameter().getName();\n                if (!actualParam.isTypeVariable() || !actualParam.asTypeParameter().getName().equals(expectedParamName)) {\n                    return matchTypeVariable(expectedParam.asTypeVariable(), actualParam, matchedParameters);\n                }\n            } else if (expectedParam.isReferenceType()) {\n                if (actualParam.isTypeVariable()) {\n                    return matchTypeVariable(actualParam.asTypeVariable(), expectedParam, matchedParameters);\n                }\n                if (!expectedParam.equals(actualParam)) {\n                    return false;\n                }\n            } else if (expectedParam.isWildcard()) {\n                if (expectedParam.asWildcard().isExtends()) {\n                    return isAssignableMatchTypeParameters(expectedParam.asWildcard().getBoundedType(), actual, matchedParameters);\n                }\n                // TODO verify super bound\n                return true;\n            } else {\n                throw new UnsupportedOperationException(expectedParam.describe());\n            }\n        }\n        return true;\n    }\n\n    private static boolean matchTypeVariable(ResolvedTypeVariable typeVariable, ResolvedType type, Map<String, ResolvedType> matchedParameters) {\n        String typeParameterName = typeVariable.asTypeParameter().getName();\n        if (matchedParameters.containsKey(typeParameterName)) {\n            ResolvedType matchedParameter = matchedParameters.get(typeParameterName);\n            if (matchedParameter.isAssignableBy(type)) {\n                return true;\n            } else if (type.isAssignableBy(matchedParameter)) {\n                // update matchedParameters to contain the more general type\n                matchedParameters.put(typeParameterName, type);\n                return true;\n            }\n            return false;\n        } else {\n            matchedParameters.put(typeParameterName, type);\n        }\n        return true;\n    }\n\n    public static ResolvedType replaceTypeParam(ResolvedType type, ResolvedTypeParameterDeclaration tp, TypeSolver typeSolver) {\n        if (type.isTypeVariable() || type.isWildcard()) {\n            if (type.describe().equals(tp.getName())) {\n                List<ResolvedTypeParameterDeclaration.Bound> bounds = tp.getBounds();\n                if (bounds.size() > 1) {\n                    throw new UnsupportedOperationException();\n                }\n                if (bounds.size() == 1) {\n                    return bounds.get(0).getType();\n                }\n                return new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver);\n            }\n            return type;\n        }\n        if (type.isPrimitive()) {\n            return type;\n        }\n        if (type.isArray()) {\n            return new ResolvedArrayType(replaceTypeParam(type.asArrayType().getComponentType(), tp, typeSolver));\n        }\n        if (type.isReferenceType()) {\n            ResolvedReferenceType result = type.asReferenceType();\n            result = result.transformTypeParameters(typeParam -> replaceTypeParam(typeParam, tp, typeSolver)).asReferenceType();\n            return result;\n        }\n        throw new UnsupportedOperationException(\"Replacing \" + type + \", param \" + tp + \" with \" + type.getClass().getCanonicalName());\n    }\n\n    /**\n     * Note the specific naming here -- parameters are part of the method declaration,\n     * while arguments are the values passed when calling a method.\n     * Note that \"needle\" refers to that value being used as a search/query term to match against.\n     *\n     * @return true, if the given MethodUsage matches the given name/types (normally obtained from a ResolvedMethodDeclaration)\n     *\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver)}  }\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver, boolean)}\n     */\n    public static boolean isApplicable(MethodUsage methodUsage, String needleName, List<ResolvedType> needleParameterTypes, TypeSolver typeSolver) {\n        if (!methodUsage.getName().equals(needleName)) {\n            return false;\n        }\n\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodUsageArgumentsPassed = methodUsage.getNoParams();\n        int lastMethodUsageArgumentIndex = getLastParameterIndex(countOfMethodUsageArgumentsPassed);\n\n        // The index of the final argument passed (on the method usage).\n        int needleParameterCount = needleParameterTypes.size();\n        int lastNeedleParameterIndex = getLastParameterIndex(needleParameterCount);\n\n        // TODO: Does the method usage have a declaration at this point..?\n        boolean methodIsDeclaredWithVariadicParameter = methodUsage.getDeclaration().hasVariadicParameter();\n\n        // If the counts do not match and the method is not variadic, this is not a match.\n        if (!methodIsDeclaredWithVariadicParameter && !(needleParameterCount == countOfMethodUsageArgumentsPassed)) {\n            return false;\n        }\n\n        // If the counts do not match and we have provided too few arguments, this is not a match. Note that variadic parameters\n        // allow you to omit the vararg, which would allow a difference of one, but a difference in count of 2 or more is not a match.\n        if (!(needleParameterCount == countOfMethodUsageArgumentsPassed) && needleParameterCount < lastMethodUsageArgumentIndex) {\n            return false;\n        }\n\n        // Iterate over the arguments given to the method, and compare their types against the given method's declared parameter types\n        for (int i = 0; i < needleParameterCount; i++) {\n            ResolvedType actualArgumentType = needleParameterTypes.get(i);\n\n            ResolvedType expectedArgumentType;\n            boolean reachedVariadicParam = methodIsDeclaredWithVariadicParameter && i >= lastMethodUsageArgumentIndex;\n            if (!reachedVariadicParam) {\n                // Not yet reached the variadic parameters -- the expected type is just whatever is at that position.\n                expectedArgumentType = methodUsage.getParamType(i);\n            } else {\n                // We have reached the variadic parameters -- the expected type is the type of the last declared parameter.\n                expectedArgumentType = methodUsage.getParamType(lastMethodUsageArgumentIndex);\n                // Note that the given variadic value might be an array - if so, use the array's component type rather.\n                // This is only valid if ONE argument has been given to the vararg parameter.\n                // Example: {@code void test(String... s) {}} and {@code test(stringArray)} -- {@code String... is assignable by stringArray}\n                // Example: {@code void test(String[]... s) {}} and {@code test(stringArrayArray)} -- {@code String[]... is assignable by stringArrayArray}\n                boolean argumentIsArray = (needleParameterCount == countOfMethodUsageArgumentsPassed) && expectedArgumentType.isAssignableBy(actualArgumentType);\n                if (!argumentIsArray) {\n                    // Get the component type of the declared parameter type.\n                    expectedArgumentType = expectedArgumentType.asArrayType().getComponentType();\n                }\n            }\n\n            // Consider type parameters directly on the method declaration, and ALSO on the enclosing type (e.g. a class)\n            List<ResolvedTypeParameterDeclaration> typeParameters = methodUsage.getDeclaration().getTypeParameters();\n            typeParameters.addAll(methodUsage.declaringType().getTypeParameters());\n\n            ResolvedType expectedTypeWithoutSubstitutions = expectedArgumentType;\n            ResolvedType expectedTypeWithInference = expectedArgumentType;\n            Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n\n            // For each declared parameter, infer the types that will replace generics (type parameters)\n            for (int j = 0; j < countOfMethodUsageArgumentsPassed; j++) {\n                ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(j);\n                ResolvedType parameterType = parameter.getType();\n                if (parameter.isVariadic()) {\n                    // Don't continue if a vararg parameter is reached and there are no arguments left\n                    if (needleParameterCount == j) {\n                        break;\n                    }\n                    parameterType = parameterType.asArrayType().getComponentType();\n                }\n                inferTypes(needleParameterTypes.get(j), parameterType, derivedValues);\n            }\n\n            for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()) {\n                ResolvedTypeParameterDeclaration tp = entry.getKey();\n                expectedTypeWithInference = expectedTypeWithInference.replaceTypeVariables(tp, entry.getValue());\n            }\n\n            // Consider cases where type variables can be replaced (e.g. add(E element) vs add(String element))\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver)));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), bound.getType());\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(bound.getType()));\n                    } else {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.superBound(bound.getType()));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // Consider cases where type variables involve bounds e.g. super/extends\n            ResolvedType expectedTypeWithSubstitutions = expectedTypeWithoutSubstitutions;\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, bound.getType());\n                    } else {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // If the given argument still isn't applicable even after considering type arguments/generics, this is not a match.\n            if (!expectedArgumentType.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithSubstitutions.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithInference.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithoutSubstitutions.isAssignableBy(actualArgumentType)) {\n                return false;\n            }\n        }\n\n        // If the checks above haven't failed, then we've found a match.\n        return true;\n    }\n\n    /**\n     * Filters by given function {@param keyExtractor} using a stateful filter mechanism.\n     *\n     * <pre>\n     *      persons.stream().filter(distinctByKey(Person::getName))\n     * </pre>\n     * <p>\n     * The example above would return a distinct list of persons containing only one person per name.\n     */\n    private static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {\n        Set<Object> seen = ConcurrentHashMap.newKeySet();\n        return t -> seen.add(keyExtractor.apply(t));\n    }\n\n    /**\n     * @param methods we expect the methods to be ordered such that inherited methods are later in the list\n     */\n    public static SymbolReference<ResolvedMethodDeclaration> findMostApplicable(List<ResolvedMethodDeclaration> methods,\n                                                                                String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n        SymbolReference<ResolvedMethodDeclaration> res = findMostApplicable(methods, name, argumentsTypes, typeSolver, false);\n        if (res.isSolved()) {\n            return res;\n        }\n        return findMostApplicable(methods, name, argumentsTypes, typeSolver, true);\n    }\n\n    public static SymbolReference<ResolvedMethodDeclaration> findMostApplicable(List<ResolvedMethodDeclaration> methods,\n                                                                                String name, List<ResolvedType> argumentsTypes,\n                                                                                TypeSolver typeSolver,\n                                                                                boolean wildcardTolerance\n    ) {\n\n        List<ResolvedMethodDeclaration> applicableMethods = methods.stream()\n                // Only consider methods with a matching name\n                .filter(m -> m.getName().equals(name))\n                // Filters out duplicate ResolvedMethodDeclaration by their signature.\n                .filter(distinctByKey(ResolvedMethodDeclaration::getQualifiedSignature))\n                // Checks if ResolvedMethodDeclaration is applicable to argumentsTypes.\n                .filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver, wildcardTolerance))\n                .collect(Collectors.toList());\n\n        // If no applicable methods found, return as unsolved.\n        if (applicableMethods.isEmpty()) {\n            return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n        }\n\n        // If there are multiple possible methods found, null arguments can help to eliminate some matches.\n        if (applicableMethods.size() > 1) {\n            List<Integer> nullParamIndexes = new ArrayList<>();\n            for (int i = 0; i < argumentsTypes.size(); i++) {\n                if (argumentsTypes.get(i).isNull()) {\n                    nullParamIndexes.add(i);\n                }\n            }\n\n            // If some null arguments have been provided, use this to eliminate some opitons.\n            if (!nullParamIndexes.isEmpty()) {\n                // remove method with array param if a non array exists and arg is null\n                Set<ResolvedMethodDeclaration> removeCandidates = new HashSet<>();\n                for (Integer nullParamIndex : nullParamIndexes) {\n                    for (ResolvedMethodDeclaration methDecl : applicableMethods) {\n                        if (methDecl.getParam(nullParamIndex).getType().isArray()) {\n                            removeCandidates.add(methDecl);\n                        }\n                    }\n                }\n\n                // Where candidiates for removal are found, remove them.\n                if (!removeCandidates.isEmpty() && removeCandidates.size() < applicableMethods.size()) {\n                    applicableMethods.removeAll(removeCandidates);\n                }\n            }\n        }\n\n        // If only one applicable method found, short-circuit and return it here.\n        if (applicableMethods.size() == 1) {\n            return SymbolReference.solved(applicableMethods.get(0));\n        }\n        \n        // Examine the applicable methods found, and evaluate each to determine the \"best\" one\n        ResolvedMethodDeclaration winningCandidate = applicableMethods.get(0);\n        ResolvedMethodDeclaration other = null;\n        boolean possibleAmbiguity = false;\n        for (int i = 1; i < applicableMethods.size(); i++) {\n            other = applicableMethods.get(i);\n            if (isMoreSpecific(winningCandidate, other, argumentsTypes)) {\n                possibleAmbiguity = false;\n            } else if (isMoreSpecific(other, winningCandidate, argumentsTypes)) {\n                possibleAmbiguity = false;\n                winningCandidate = other;\n            } else {\n                // 15.12.2.5. Choosing the Most Specific Method\n                // One applicable method m1 is more specific than another applicable method m2, for an invocation with argument\n                // expressions e1, ..., ek, if any of the following are true:\n                // m2 is generic, and m1 is inferred to be more specific than m2 for argument expressions e1, ..., ek by \u00a718.5.4.\n                // 18.5.4. More Specific Method Inference should be verified \n                // ...\n                if (winningCandidate.isGeneric() && !other.isGeneric()) {\n                    winningCandidate = other;\n                } else if (!winningCandidate.isGeneric() && other.isGeneric()) {\n                    // nothing to do at this stage winningCandidate is the winner\n                } else if (winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName())) {\n                    possibleAmbiguity = true;\n                } else {\n                    // we expect the methods to be ordered such that inherited methods are later in the list\n                }\n            }\n        }\n        \n        if (possibleAmbiguity) {\n            // pick the first exact match if it exists\n            if (!isExactMatch(winningCandidate, argumentsTypes)) {\n                if (isExactMatch(other, argumentsTypes)) {\n                    winningCandidate = other;\n                } else {\n                    throw new MethodAmbiguityException(\n                            \"Ambiguous method call: cannot find a most applicable method: \" + winningCandidate\n                                    + \", \" + other);\n                }\n            }\n        }\n\n        return SymbolReference.solved(winningCandidate);\n    }\n\n    protected static boolean isExactMatch(ResolvedMethodLikeDeclaration method, List<ResolvedType> argumentsTypes) {\n        for (int i = 0; i < method.getNumberOfParams(); i++) {\n            if (!method.getParam(i).getType().equals(argumentsTypes.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static ResolvedType getMethodsExplicitAndVariadicParameterType(ResolvedMethodDeclaration method, int i) {\n        int numberOfParams = method.getNumberOfParams();\n\n        if (i < numberOfParams) {\n            return method.getParam(i).getType();\n        }\n        if (method.hasVariadicParameter()) {\n            return method.getParam(numberOfParams - 1).getType();\n        }\n        return null;\n    }\n\n    private static boolean isMoreSpecific(ResolvedMethodDeclaration methodA, ResolvedMethodDeclaration methodB,\n                                          List<ResolvedType> argumentTypes) {\n\n        final boolean aVariadic = methodA.hasVariadicParameter();\n        final boolean bVariadic = methodB.hasVariadicParameter();\n        final int aNumberOfParams = methodA.getNumberOfParams();\n        final int bNumberOfParams = methodB.getNumberOfParams();\n        final int numberOfArgs = argumentTypes.size();\n        final ResolvedType lastArgType = numberOfArgs > 0 ? argumentTypes.get(numberOfArgs - 1) : null;\n        final boolean isLastArgArray = lastArgType != null && lastArgType.isArray();\n        int omittedArgs = 0;\n        boolean isMethodAMoreSpecific = false;\n\n        // If one method declaration has exactly the correct amount of parameters and is not variadic then it is always\n        // preferred to a declaration that is variadic (and hence possibly also has a different amount of parameters).\n        if (!aVariadic && aNumberOfParams == numberOfArgs && (bVariadic && (bNumberOfParams != numberOfArgs ||\n                !isLastArgArray))) {\n            return true;\n        }\n        if (!bVariadic && bNumberOfParams == numberOfArgs && (aVariadic && (aNumberOfParams != numberOfArgs ||\n                !isLastArgArray))) {\n            return false;\n        }\n        \n        // If both methods are variadic but the calling method omits any varArgs, bump the omitted args to\n        // ensure the varargs type is considered when determining which method is more specific\n        if (aVariadic && bVariadic && aNumberOfParams == bNumberOfParams && numberOfArgs == aNumberOfParams - 1) {\n        \tomittedArgs++;\n        }\n\n        // Either both methods are variadic or neither is. So we must compare the parameter types.\n        for (int i = 0; i < numberOfArgs + omittedArgs; i++) {\n            ResolvedType paramTypeA = getMethodsExplicitAndVariadicParameterType(methodA, i);\n            ResolvedType paramTypeB = getMethodsExplicitAndVariadicParameterType(methodB, i);\n            \n            ResolvedType argType = null;\n            if (i < argumentTypes.size()) {\n            \targType = argumentTypes.get(i);\n            }\n\n            // Safety: if a type is null it means a signature with too few parameters managed to get to this point.\n            // This should not happen but it also means that this signature is immediately disqualified.\n            if (paramTypeA == null) {\n                return false;\n            }\n            if (paramTypeB == null) {\n                return true;\n            }\n            // Widening primitive conversions have priority over boxing/unboxing conversions when finding the most\n            // applicable method. E.g. assume we have method call foo(1) and declarations foo(long) and foo(Integer).\n            // The method call will call foo(long), as it requires a widening primitive conversion from int to long\n            // instead of a boxing conversion from int to Integer. See JLS \u00a715.12.2.\n            // This is what we check here.\n            if (argType != null &&\n            \t\tparamTypeA.isPrimitive() == argType.isPrimitive() &&\n                    paramTypeB.isPrimitive() != argType.isPrimitive() &&\n                    paramTypeA.isAssignableBy(argType)) {\n\n                return true;\n            }\n            if (argType != null &&\n            \t\tparamTypeB.isPrimitive() == argType.isPrimitive() &&\n                    paramTypeA.isPrimitive() != argType.isPrimitive() &&\n                    paramTypeB.isAssignableBy(argType)) {\n\n                return false;\n            // if paramA and paramB are not the last parameters\n            // and the type of paramA or paramB (which are not more specific at this stage) is java.lang.Object\n            // then we have to consider others parameters before concluding\n            }\n            if ((i < numberOfArgs - 1)\n                    && (isJavaLangObject(paramTypeB) || (isJavaLangObject(paramTypeA)))) {\n                // consider others parameters\n                // but eventually mark the method A as more specific if the methodB has an argument of type java.lang.Object\n                isMethodAMoreSpecific = isMethodAMoreSpecific || isJavaLangObject(paramTypeB);\n            }\n            // If we get to this point then we check whether one of the methods contains a parameter type that is more\n            // specific. If it does, we can assume the entire declaration is more specific as we would otherwise have\n            // a situation where the declarations are ambiguous in the given context.\n            else {\n                boolean aAssignableFromB = paramTypeA.isAssignableBy(paramTypeB);\n                boolean bAssignableFromA = paramTypeB.isAssignableBy(paramTypeA);\n\n                if (bAssignableFromA && !aAssignableFromB) {\n                    // A's parameter is more specific\n                    return true;\n                }\n                if (aAssignableFromB && !bAssignableFromA) {\n                    // B's parameter is more specific\n                    return false;\n                }\n            }\n        }\n\n        if (aVariadic && !bVariadic) {\n            // if the last argument is an array then m1 is more specific\n            return isLastArgArray;\n        }\n        if (!aVariadic && bVariadic) {\n            // if the last argument is an array and m1 is not variadic then\n            // it is not more specific\n            return !isLastArgArray;\n        }\n\n        return isMethodAMoreSpecific;\n    }\n    \n    private static boolean isJavaLangObject(ResolvedType paramType ) {\n        return paramType.isReferenceType() && paramType.asReferenceType().getQualifiedName().equals(\"java.lang.Object\");\n    }\n\n    private static boolean isMoreSpecific(MethodUsage methodA, MethodUsage methodB) {\n        boolean oneMoreSpecificFound = false;\n        for (int i = 0; i < methodA.getNoParams(); i++) {\n            ResolvedType tdA = methodA.getParamType(i);\n            ResolvedType tdB = methodB.getParamType(i);\n\n            boolean aIsAssignableByB = tdA.isAssignableBy(tdB);\n            boolean bIsAssignableByA = tdB.isAssignableBy(tdA);\n\n            // A is more specific\n            if (bIsAssignableByA && !aIsAssignableByB) {\n                oneMoreSpecificFound = true;\n            }\n            // B is more specific\n            if (aIsAssignableByB && !bIsAssignableByA) {\n                return false;\n            }\n\n            // If B is vararg and A is not, A is more specific\n            if (tdB.isArray() && tdB.asArrayType().getComponentType().isAssignableBy(tdA)) {\n                oneMoreSpecificFound = true;\n            }\n        }\n        return oneMoreSpecificFound;\n    }\n\n    public static Optional<MethodUsage> findMostApplicableUsage(List<MethodUsage> methods, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n        List<MethodUsage> applicableMethods = methods.stream().filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver)).collect(Collectors.toList());\n\n        if (applicableMethods.isEmpty()) {\n            return Optional.empty();\n        }\n        if (applicableMethods.size() == 1) {\n            return Optional.of(applicableMethods.get(0));\n        } else {\n            MethodUsage winningCandidate = applicableMethods.get(0);\n            for (int i = 1; i < applicableMethods.size(); i++) {\n                MethodUsage other = applicableMethods.get(i);\n                if (isMoreSpecific(winningCandidate, other)) {\n                    // nothing to do\n                } else if (isMoreSpecific(other, winningCandidate)) {\n                    winningCandidate = other;\n                } else {\n                    if (winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName())) {\n                        if (!areOverride(winningCandidate, other)) {\n                            throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method: \" + winningCandidate + \", \" + other + \". First declared in \" + winningCandidate.declaringType().getQualifiedName());\n                        }\n                    } else {\n                        // we expect the methods to be ordered such that inherited methods are later in the list\n                        //throw new UnsupportedOperationException();\n                    }\n                }\n            }\n            return Optional.of(winningCandidate);\n        }\n    }\n\n    private static boolean areOverride(MethodUsage winningCandidate, MethodUsage other) {\n        if (!winningCandidate.getName().equals(other.getName())) {\n            return false;\n        }\n        if (winningCandidate.getNoParams() != other.getNoParams()) {\n            return false;\n        }\n        for (int i = 0; i < winningCandidate.getNoParams(); i++) {\n            if (!winningCandidate.getParamTypes().get(i).equals(other.getParamTypes().get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static SymbolReference<ResolvedMethodDeclaration> solveMethodInType(ResolvedTypeDeclaration typeDeclaration,\n                                                                               String name,\n                                                                               List<ResolvedType> argumentsTypes) {\n        return solveMethodInType(typeDeclaration, name, argumentsTypes, false);\n    }\n\n    // TODO: Replace TypeDeclaration.solveMethod\n    public static SymbolReference<ResolvedMethodDeclaration> solveMethodInType(ResolvedTypeDeclaration typeDeclaration,\n                                                                               String name,\n                                                                               List<ResolvedType> argumentsTypes,\n                                                                               boolean staticOnly) {\n\n        if (typeDeclaration instanceof MethodResolutionCapability) {\n            return ((MethodResolutionCapability) typeDeclaration).solveMethod(name, argumentsTypes,\n                    staticOnly);\n        }\n        throw new UnsupportedOperationException(typeDeclaration.getClass().getCanonicalName());\n    }\n\n    private static void inferTypes(ResolvedType source, ResolvedType target, Map<ResolvedTypeParameterDeclaration, ResolvedType> mappings) {\n        if (source.equals(target)) {\n            return;\n        }\n        if (source.isReferenceType() && target.isReferenceType()) {\n            ResolvedReferenceType sourceRefType = source.asReferenceType();\n            ResolvedReferenceType targetRefType = target.asReferenceType();\n            if (sourceRefType.getQualifiedName().equals(targetRefType.getQualifiedName())) {\n                if (!sourceRefType.isRawType() && !targetRefType.isRawType()) {\n                    for (int i = 0; i < sourceRefType.typeParametersValues().size(); i++) {\n                        inferTypes(sourceRefType.typeParametersValues().get(i), targetRefType.typeParametersValues().get(i), mappings);\n                    }\n                }\n            }\n            return;\n        }\n        if (source.isReferenceType() && target.isWildcard()) {\n            if (target.asWildcard().isBounded()) {\n                inferTypes(source, target.asWildcard().getBoundedType(), mappings);\n                return;\n            }\n            return;\n        }\n        if (source.isWildcard() && target.isWildcard()) {\n            return;\n        }\n        if (source.isReferenceType() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n\n        if (source.isWildcard() && target.isReferenceType()) {\n            if (source.asWildcard().isBounded()) {\n                inferTypes(source.asWildcard().getBoundedType(), target, mappings);\n            }\n            return;\n        }\n\n        if (source.isWildcard() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isTypeVariable() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isPrimitive() || target.isPrimitive()) {\n            return;\n        }\n        if (source.isNull()) {\n            return;\n        }\n    }\n\n}\n", "diffSourceCodeSet": ["private static int getLastParameterIndex(int countOfMethodParametersDeclared) {\n        return Math.max(0, countOfMethodParametersDeclared - 1);\n    }"], "invokedMethodSet": ["methodSignature: com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic#inferTypes\n methodBody: private static void inferTypes(ResolvedType source, ResolvedType target, Map<ResolvedTypeParameterDeclaration, ResolvedType> mappings) {\nif(source.equals(target)){return;\n}if(source.isReferenceType() && target.isReferenceType()){ResolvedReferenceType sourceRefType=source.asReferenceType();\nResolvedReferenceType targetRefType=target.asReferenceType();\nif(sourceRefType.getQualifiedName().equals(targetRefType.getQualifiedName())){if(!sourceRefType.isRawType() && !targetRefType.isRawType()){for(int i=0; i < sourceRefType.typeParametersValues().size(); i++){inferTypes(sourceRefType.typeParametersValues().get(i),targetRefType.typeParametersValues().get(i),mappings);\n}}}return;\n}if(source.isReferenceType() && target.isWildcard()){if(target.asWildcard().isBounded()){inferTypes(source,target.asWildcard().getBoundedType(),mappings);\nreturn;\n}return;\n}if(source.isWildcard() && target.isWildcard()){return;\n}if(source.isReferenceType() && target.isTypeVariable()){mappings.put(target.asTypeParameter(),source);\nreturn;\n}if(source.isWildcard() && target.isReferenceType()){if(source.asWildcard().isBounded()){inferTypes(source.asWildcard().getBoundedType(),target,mappings);\n}return;\n}if(source.isWildcard() && target.isTypeVariable()){mappings.put(target.asTypeParameter(),source);\nreturn;\n}if(source.isTypeVariable() && target.isTypeVariable()){mappings.put(target.asTypeParameter(),source);\nreturn;\n}if(source.isPrimitive() || target.isPrimitive()){return;\n}if(source.isNull()){return;\n}}"], "sourceCodeAfterRefactoring": "/**\n     * Note the specific naming here -- parameters are part of the method declaration,\n     * while arguments are the values passed when calling a method.\n     * Note that \"needle\" refers to that value being used as a search/query term to match against.\n     *\n     * @return true, if the given MethodUsage matches the given name/types (normally obtained from a ResolvedMethodDeclaration)\n     *\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver)}  }\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver, boolean)}\n     */\n    public static boolean isApplicable(MethodUsage methodUsage, String needleName, List<ResolvedType> needleParameterTypes, TypeSolver typeSolver) {\n        if (!methodUsage.getName().equals(needleName)) {\n            return false;\n        }\n\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodUsageArgumentsPassed = methodUsage.getNoParams();\n        int lastMethodUsageArgumentIndex = getLastParameterIndex(countOfMethodUsageArgumentsPassed);\n\n        // The index of the final argument passed (on the method usage).\n        int needleParameterCount = needleParameterTypes.size();\n        int lastNeedleParameterIndex = getLastParameterIndex(needleParameterCount);\n\n        // TODO: Does the method usage have a declaration at this point..?\n        boolean methodIsDeclaredWithVariadicParameter = methodUsage.getDeclaration().hasVariadicParameter();\n\n        // If the counts do not match and the method is not variadic, this is not a match.\n        if (!methodIsDeclaredWithVariadicParameter && !(needleParameterCount == countOfMethodUsageArgumentsPassed)) {\n            return false;\n        }\n\n        // If the counts do not match and we have provided too few arguments, this is not a match. Note that variadic parameters\n        // allow you to omit the vararg, which would allow a difference of one, but a difference in count of 2 or more is not a match.\n        if (!(needleParameterCount == countOfMethodUsageArgumentsPassed) && needleParameterCount < lastMethodUsageArgumentIndex) {\n            return false;\n        }\n\n        // Iterate over the arguments given to the method, and compare their types against the given method's declared parameter types\n        for (int i = 0; i < needleParameterCount; i++) {\n            ResolvedType actualArgumentType = needleParameterTypes.get(i);\n\n            ResolvedType expectedArgumentType;\n            boolean reachedVariadicParam = methodIsDeclaredWithVariadicParameter && i >= lastMethodUsageArgumentIndex;\n            if (!reachedVariadicParam) {\n                // Not yet reached the variadic parameters -- the expected type is just whatever is at that position.\n                expectedArgumentType = methodUsage.getParamType(i);\n            } else {\n                // We have reached the variadic parameters -- the expected type is the type of the last declared parameter.\n                expectedArgumentType = methodUsage.getParamType(lastMethodUsageArgumentIndex);\n                // Note that the given variadic value might be an array - if so, use the array's component type rather.\n                // This is only valid if ONE argument has been given to the vararg parameter.\n                // Example: {@code void test(String... s) {}} and {@code test(stringArray)} -- {@code String... is assignable by stringArray}\n                // Example: {@code void test(String[]... s) {}} and {@code test(stringArrayArray)} -- {@code String[]... is assignable by stringArrayArray}\n                boolean argumentIsArray = (needleParameterCount == countOfMethodUsageArgumentsPassed) && expectedArgumentType.isAssignableBy(actualArgumentType);\n                if (!argumentIsArray) {\n                    // Get the component type of the declared parameter type.\n                    expectedArgumentType = expectedArgumentType.asArrayType().getComponentType();\n                }\n            }\n\n            // Consider type parameters directly on the method declaration, and ALSO on the enclosing type (e.g. a class)\n            List<ResolvedTypeParameterDeclaration> typeParameters = methodUsage.getDeclaration().getTypeParameters();\n            typeParameters.addAll(methodUsage.declaringType().getTypeParameters());\n\n            ResolvedType expectedTypeWithoutSubstitutions = expectedArgumentType;\n            ResolvedType expectedTypeWithInference = expectedArgumentType;\n            Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n\n            // For each declared parameter, infer the types that will replace generics (type parameters)\n            for (int j = 0; j < countOfMethodUsageArgumentsPassed; j++) {\n                ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(j);\n                ResolvedType parameterType = parameter.getType();\n                if (parameter.isVariadic()) {\n                    // Don't continue if a vararg parameter is reached and there are no arguments left\n                    if (needleParameterCount == j) {\n                        break;\n                    }\n                    parameterType = parameterType.asArrayType().getComponentType();\n                }\n                inferTypes(needleParameterTypes.get(j), parameterType, derivedValues);\n            }\n\n            for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()) {\n                ResolvedTypeParameterDeclaration tp = entry.getKey();\n                expectedTypeWithInference = expectedTypeWithInference.replaceTypeVariables(tp, entry.getValue());\n            }\n\n            // Consider cases where type variables can be replaced (e.g. add(E element) vs add(String element))\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver)));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), bound.getType());\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(bound.getType()));\n                    } else {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.superBound(bound.getType()));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // Consider cases where type variables involve bounds e.g. super/extends\n            ResolvedType expectedTypeWithSubstitutions = expectedTypeWithoutSubstitutions;\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, bound.getType());\n                    } else {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // If the given argument still isn't applicable even after considering type arguments/generics, this is not a match.\n            if (!expectedArgumentType.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithSubstitutions.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithInference.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithoutSubstitutions.isAssignableBy(actualArgumentType)) {\n                return false;\n            }\n        }\n\n        // If the checks above haven't failed, then we've found a match.\n        return true;\n    }\nprivate static int getLastParameterIndex(int countOfMethodParametersDeclared) {\n        return Math.max(0, countOfMethodParametersDeclared - 1);\n    }", "diffSourceCode": "-  210:                     // for example LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=T}}}, LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=U}}}\n-  211:                     // we want to keep this method for future resolution\n-  212:                     if (actualArgumentType.isConstraint() && withWildcardTolerance && expectedDeclaredType.isPrimitive()) {\n-  354:     /**\n-  355:      * Note the specific naming here -- parameters are part of the method declaration,\n-  356:      * while arguments are the values passed when calling a method.\n-  357:      * Note that \"needle\" refers to that value being used as a search/query term to match against.\n-  358:      *\n-  359:      * @return true, if the given MethodUsage matches the given name/types (normally obtained from a ResolvedMethodDeclaration)\n-  360:      *\n-  361:      * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver)}  }\n-  362:      * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver, boolean)}\n-  363:      */\n-  364:     public static boolean isApplicable(MethodUsage methodUsage, String needleName, List<ResolvedType> needleParameterTypes, TypeSolver typeSolver) {\n-  365:         if (!methodUsage.getName().equals(needleName)) {\n-  366:             return false;\n-  367:         }\n-  368: \n-  369:         // The index of the final method parameter (on the method declaration).\n-  370:         int countOfMethodUsageArgumentsPassed = methodUsage.getNoParams();\n-  371:         int lastMethodUsageArgumentIndex = Math.max(0, countOfMethodUsageArgumentsPassed - 1);\n-  372: \n-  373:         // The index of the final argument passed (on the method usage).\n-  374:         int needleParameterCount = needleParameterTypes.size();\n-  375:         int lastNeedleParameterIndex = Math.max(0, needleParameterCount - 1);\n-  376: \n-  377:         // TODO: Does the method usage have a declaration at this point..?\n-  378:         boolean methodIsDeclaredWithVariadicParameter = methodUsage.getDeclaration().hasVariadicParameter();\n+  210:     private static int getLastParameterIndex(int countOfMethodParametersDeclared) {\n+  211:         return Math.max(0, countOfMethodParametersDeclared - 1);\n+  212:     }\n+  354:             if (type.describe().equals(tp.getName())) {\n+  355:                 List<ResolvedTypeParameterDeclaration.Bound> bounds = tp.getBounds();\n+  356:                 if (bounds.size() > 1) {\n+  357:                     throw new UnsupportedOperationException();\n+  358:                 }\n+  359:                 if (bounds.size() == 1) {\n+  360:                     return bounds.get(0).getType();\n+  361:                 }\n+  362:                 return new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver);\n+  363:             }\n+  364:             return type;\n+  365:         }\n+  366:         if (type.isPrimitive()) {\n+  367:             return type;\n+  368:         }\n+  369:         if (type.isArray()) {\n+  370:             return new ResolvedArrayType(replaceTypeParam(type.asArrayType().getComponentType(), tp, typeSolver));\n+  371:         }\n+  372:         if (type.isReferenceType()) {\n+  373:             ResolvedReferenceType result = type.asReferenceType();\n+  374:             result = result.transformTypeParameters(typeParam -> replaceTypeParam(typeParam, tp, typeSolver)).asReferenceType();\n+  375:             return result;\n+  376:         }\n+  377:         throw new UnsupportedOperationException(\"Replacing \" + type + \", param \" + tp + \" with \" + type.getClass().getCanonicalName());\n+  378:     }\n   379: \n-  380:         // If the counts do not match and the method is not variadic, this is not a match.\n-  381:         if (!methodIsDeclaredWithVariadicParameter && !(needleParameterCount == countOfMethodUsageArgumentsPassed)) {\n-  382:             return false;\n-  383:         }\n-  384: \n-  385:         // If the counts do not match and we have provided too few arguments, this is not a match. Note that variadic parameters\n-  386:         // allow you to omit the vararg, which would allow a difference of one, but a difference in count of 2 or more is not a match.\n-  387:         if (!(needleParameterCount == countOfMethodUsageArgumentsPassed) && needleParameterCount < lastMethodUsageArgumentIndex) {\n-  388:             return false;\n-  389:         }\n-  390: \n-  391:         // Iterate over the arguments given to the method, and compare their types against the given method's declared parameter types\n-  392:         for (int i = 0; i < needleParameterCount; i++) {\n-  393:             ResolvedType actualArgumentType = needleParameterTypes.get(i);\n+  380:     /**\n+  381:      * Note the specific naming here -- parameters are part of the method declaration,\n+  382:      * while arguments are the values passed when calling a method.\n+  383:      * Note that \"needle\" refers to that value being used as a search/query term to match against.\n+  384:      *\n+  385:      * @return true, if the given MethodUsage matches the given name/types (normally obtained from a ResolvedMethodDeclaration)\n+  386:      *\n+  387:      * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver)}  }\n+  388:      * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver, boolean)}\n+  389:      */\n+  390:     public static boolean isApplicable(MethodUsage methodUsage, String needleName, List<ResolvedType> needleParameterTypes, TypeSolver typeSolver) {\n+  391:         if (!methodUsage.getName().equals(needleName)) {\n+  392:             return false;\n+  393:         }\n   394: \n-  395:             ResolvedType expectedArgumentType;\n-  396:             boolean reachedVariadicParam = methodIsDeclaredWithVariadicParameter && i >= lastMethodUsageArgumentIndex;\n-  397:             if (!reachedVariadicParam) {\n-  398:                 // Not yet reached the variadic parameters -- the expected type is just whatever is at that position.\n-  399:                 expectedArgumentType = methodUsage.getParamType(i);\n-  400:             } else {\n-  401:                 // We have reached the variadic parameters -- the expected type is the type of the last declared parameter.\n-  402:                 expectedArgumentType = methodUsage.getParamType(lastMethodUsageArgumentIndex);\n-  403:                 // Note that the given variadic value might be an array - if so, use the array's component type rather.\n-  404:                 // This is only valid if ONE argument has been given to the vararg parameter.\n-  405:                 // Example: {@code void test(String... s) {}} and {@code test(stringArray)} -- {@code String... is assignable by stringArray}\n-  406:                 // Example: {@code void test(String[]... s) {}} and {@code test(stringArrayArray)} -- {@code String[]... is assignable by stringArrayArray}\n-  407:                 boolean argumentIsArray = (needleParameterCount == countOfMethodUsageArgumentsPassed) && expectedArgumentType.isAssignableBy(actualArgumentType);\n-  408:                 if (!argumentIsArray) {\n-  409:                     // Get the component type of the declared parameter type.\n-  410:                     expectedArgumentType = expectedArgumentType.asArrayType().getComponentType();\n-  411:                 }\n-  412:             }\n-  413: \n-  414:             // Consider type parameters directly on the method declaration, and ALSO on the enclosing type (e.g. a class)\n-  415:             List<ResolvedTypeParameterDeclaration> typeParameters = methodUsage.getDeclaration().getTypeParameters();\n-  416:             typeParameters.addAll(methodUsage.declaringType().getTypeParameters());\n-  417: \n-  418:             ResolvedType expectedTypeWithoutSubstitutions = expectedArgumentType;\n-  419:             ResolvedType expectedTypeWithInference = expectedArgumentType;\n-  420:             Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n-  421: \n-  422:             // For each declared parameter, infer the types that will replace generics (type parameters)\n-  423:             for (int j = 0; j < countOfMethodUsageArgumentsPassed; j++) {\n-  424:                 ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(j);\n-  425:                 ResolvedType parameterType = parameter.getType();\n-  426:                 if (parameter.isVariadic()) {\n-  427:                     // Don't continue if a vararg parameter is reached and there are no arguments left\n-  428:                     if (needleParameterCount == j) {\n-  429:                         break;\n-  430:                     }\n-  431:                     parameterType = parameterType.asArrayType().getComponentType();\n-  432:                 }\n-  433:                 inferTypes(needleParameterTypes.get(j), parameterType, derivedValues);\n-  434:             }\n-  435: \n-  436:             for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()) {\n-  437:                 ResolvedTypeParameterDeclaration tp = entry.getKey();\n-  438:                 expectedTypeWithInference = expectedTypeWithInference.replaceTypeVariables(tp, entry.getValue());\n-  439:             }\n-  440: \n-  441:             // Consider cases where type variables can be replaced (e.g. add(E element) vs add(String element))\n-  442:             for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n-  443:                 if (tp.getBounds().isEmpty()) {\n-  444:                     //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n-  445:                     expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver)));\n-  446:                 } else if (tp.getBounds().size() == 1) {\n-  447:                     ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n-  448:                     if (bound.isExtends()) {\n-  449:                         //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), bound.getType());\n-  450:                         expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(bound.getType()));\n-  451:                     } else {\n-  452:                         //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n-  453:                         expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.superBound(bound.getType()));\n-  454:                     }\n-  455:                 } else {\n-  456:                     throw new UnsupportedOperationException();\n-  457:                 }\n-  458:             }\n-  459: \n-  460:             // Consider cases where type variables involve bounds e.g. super/extends\n-  461:             ResolvedType expectedTypeWithSubstitutions = expectedTypeWithoutSubstitutions;\n-  462:             for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n-  463:                 if (tp.getBounds().isEmpty()) {\n-  464:                     expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n-  465:                 } else if (tp.getBounds().size() == 1) {\n-  466:                     ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n-  467:                     if (bound.isExtends()) {\n-  468:                         expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, bound.getType());\n-  469:                     } else {\n-  470:                         expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n-  471:                     }\n-  472:                 } else {\n-  473:                     throw new UnsupportedOperationException();\n-  474:                 }\n-  475:             }\n-  476: \n-  477:             // If the given argument still isn't applicable even after considering type arguments/generics, this is not a match.\n-  478:             if (!expectedArgumentType.isAssignableBy(actualArgumentType)\n-  479:                     && !expectedTypeWithSubstitutions.isAssignableBy(actualArgumentType)\n-  480:                     && !expectedTypeWithInference.isAssignableBy(actualArgumentType)\n-  481:                     && !expectedTypeWithoutSubstitutions.isAssignableBy(actualArgumentType)) {\n-  482:                 return false;\n-  483:             }\n-  484:         }\n+  395:         // The index of the final method parameter (on the method declaration).\n+  396:         int countOfMethodUsageArgumentsPassed = methodUsage.getNoParams();\n+  397:         int lastMethodUsageArgumentIndex = getLastParameterIndex(countOfMethodUsageArgumentsPassed);\n+  398: \n+  399:         // The index of the final argument passed (on the method usage).\n+  400:         int needleParameterCount = needleParameterTypes.size();\n+  401:         int lastNeedleParameterIndex = getLastParameterIndex(needleParameterCount);\n+  402: \n+  403:         // TODO: Does the method usage have a declaration at this point..?\n+  404:         boolean methodIsDeclaredWithVariadicParameter = methodUsage.getDeclaration().hasVariadicParameter();\n+  405: \n+  406:         // If the counts do not match and the method is not variadic, this is not a match.\n+  407:         if (!methodIsDeclaredWithVariadicParameter && !(needleParameterCount == countOfMethodUsageArgumentsPassed)) {\n+  408:             return false;\n+  409:         }\n+  410: \n+  411:         // If the counts do not match and we have provided too few arguments, this is not a match. Note that variadic parameters\n+  412:         // allow you to omit the vararg, which would allow a difference of one, but a difference in count of 2 or more is not a match.\n+  413:         if (!(needleParameterCount == countOfMethodUsageArgumentsPassed) && needleParameterCount < lastMethodUsageArgumentIndex) {\n+  414:             return false;\n+  415:         }\n+  416: \n+  417:         // Iterate over the arguments given to the method, and compare their types against the given method's declared parameter types\n+  418:         for (int i = 0; i < needleParameterCount; i++) {\n+  419:             ResolvedType actualArgumentType = needleParameterTypes.get(i);\n+  420: \n+  421:             ResolvedType expectedArgumentType;\n+  422:             boolean reachedVariadicParam = methodIsDeclaredWithVariadicParameter && i >= lastMethodUsageArgumentIndex;\n+  423:             if (!reachedVariadicParam) {\n+  424:                 // Not yet reached the variadic parameters -- the expected type is just whatever is at that position.\n+  425:                 expectedArgumentType = methodUsage.getParamType(i);\n+  426:             } else {\n+  427:                 // We have reached the variadic parameters -- the expected type is the type of the last declared parameter.\n+  428:                 expectedArgumentType = methodUsage.getParamType(lastMethodUsageArgumentIndex);\n+  429:                 // Note that the given variadic value might be an array - if so, use the array's component type rather.\n+  430:                 // This is only valid if ONE argument has been given to the vararg parameter.\n+  431:                 // Example: {@code void test(String... s) {}} and {@code test(stringArray)} -- {@code String... is assignable by stringArray}\n+  432:                 // Example: {@code void test(String[]... s) {}} and {@code test(stringArrayArray)} -- {@code String[]... is assignable by stringArrayArray}\n+  433:                 boolean argumentIsArray = (needleParameterCount == countOfMethodUsageArgumentsPassed) && expectedArgumentType.isAssignableBy(actualArgumentType);\n+  434:                 if (!argumentIsArray) {\n+  435:                     // Get the component type of the declared parameter type.\n+  436:                     expectedArgumentType = expectedArgumentType.asArrayType().getComponentType();\n+  437:                 }\n+  438:             }\n+  439: \n+  440:             // Consider type parameters directly on the method declaration, and ALSO on the enclosing type (e.g. a class)\n+  441:             List<ResolvedTypeParameterDeclaration> typeParameters = methodUsage.getDeclaration().getTypeParameters();\n+  442:             typeParameters.addAll(methodUsage.declaringType().getTypeParameters());\n+  443: \n+  444:             ResolvedType expectedTypeWithoutSubstitutions = expectedArgumentType;\n+  445:             ResolvedType expectedTypeWithInference = expectedArgumentType;\n+  446:             Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n+  447: \n+  448:             // For each declared parameter, infer the types that will replace generics (type parameters)\n+  449:             for (int j = 0; j < countOfMethodUsageArgumentsPassed; j++) {\n+  450:                 ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(j);\n+  451:                 ResolvedType parameterType = parameter.getType();\n+  452:                 if (parameter.isVariadic()) {\n+  453:                     // Don't continue if a vararg parameter is reached and there are no arguments left\n+  454:                     if (needleParameterCount == j) {\n+  455:                         break;\n+  456:                     }\n+  457:                     parameterType = parameterType.asArrayType().getComponentType();\n+  458:                 }\n+  459:                 inferTypes(needleParameterTypes.get(j), parameterType, derivedValues);\n+  460:             }\n+  461: \n+  462:             for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()) {\n+  463:                 ResolvedTypeParameterDeclaration tp = entry.getKey();\n+  464:                 expectedTypeWithInference = expectedTypeWithInference.replaceTypeVariables(tp, entry.getValue());\n+  465:             }\n+  466: \n+  467:             // Consider cases where type variables can be replaced (e.g. add(E element) vs add(String element))\n+  468:             for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n+  469:                 if (tp.getBounds().isEmpty()) {\n+  470:                     //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n+  471:                     expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver)));\n+  472:                 } else if (tp.getBounds().size() == 1) {\n+  473:                     ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n+  474:                     if (bound.isExtends()) {\n+  475:                         //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), bound.getType());\n+  476:                         expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(bound.getType()));\n+  477:                     } else {\n+  478:                         //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n+  479:                         expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.superBound(bound.getType()));\n+  480:                     }\n+  481:                 } else {\n+  482:                     throw new UnsupportedOperationException();\n+  483:                 }\n+  484:             }\n   485: \n-  486:         // If the checks above haven't failed, then we've found a match.\n-  487:         return true;\n-  488:     }\n-  489: \n-  490:     /**\n-  491:      * Filters by given function {@param keyExtractor} using a stateful filter mechanism.\n-  492:      *\n-  493:      * <pre>\n-  494:      *      persons.stream().filter(distinctByKey(Person::getName))\n-  495:      * </pre>\n-  496:      * <p>\n-  497:      * The example above would return a distinct list of persons containing only one person per name.\n-  498:      */\n-  499:     private static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {\n-  500:         Set<Object> seen = ConcurrentHashMap.newKeySet();\n-  501:         return t -> seen.add(keyExtractor.apply(t));\n-  502:     }\n-  503: \n-  504:     /**\n-  505:      * @param methods we expect the methods to be ordered such that inherited methods are later in the list\n-  506:      */\n-  507:     public static SymbolReference<ResolvedMethodDeclaration> findMostApplicable(List<ResolvedMethodDeclaration> methods,\n-  508:                                                                                 String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n-  509:         SymbolReference<ResolvedMethodDeclaration> res = findMostApplicable(methods, name, argumentsTypes, typeSolver, false);\n-  510:         if (res.isSolved()) {\n-  511:             return res;\n-  512:         }\n-  513:         return findMostApplicable(methods, name, argumentsTypes, typeSolver, true);\n+  486:             // Consider cases where type variables involve bounds e.g. super/extends\n+  487:             ResolvedType expectedTypeWithSubstitutions = expectedTypeWithoutSubstitutions;\n+  488:             for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n+  489:                 if (tp.getBounds().isEmpty()) {\n+  490:                     expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n+  491:                 } else if (tp.getBounds().size() == 1) {\n+  492:                     ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n+  493:                     if (bound.isExtends()) {\n+  494:                         expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, bound.getType());\n+  495:                     } else {\n+  496:                         expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n+  497:                     }\n+  498:                 } else {\n+  499:                     throw new UnsupportedOperationException();\n+  500:                 }\n+  501:             }\n+  502: \n+  503:             // If the given argument still isn't applicable even after considering type arguments/generics, this is not a match.\n+  504:             if (!expectedArgumentType.isAssignableBy(actualArgumentType)\n+  505:                     && !expectedTypeWithSubstitutions.isAssignableBy(actualArgumentType)\n+  506:                     && !expectedTypeWithInference.isAssignableBy(actualArgumentType)\n+  507:                     && !expectedTypeWithoutSubstitutions.isAssignableBy(actualArgumentType)) {\n+  508:                 return false;\n+  509:             }\n+  510:         }\n+  511: \n+  512:         // If the checks above haven't failed, then we've found a match.\n+  513:         return true;\n   514:     }\n", "uniqueId": "5aabb7480625e5dba2d32a8efab95a35f8c2e04c_354_488_210_212_380_514", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 29, "covered": 286}, "BRANCH": {"missed": 9, "covered": 47}, "LINE": {"missed": 6, "covered": 60}, "COMPLEXITY": {"missed": 9, "covered": 20}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `isApplicable` method in the provided code, we can extract some of the logic into smaller, more focused methods. This will help to clarify the purpose of each section of the code and make it easier to understand and test.\n\nHere\u2019s the refactored code with the extracted methods:\n\n```java\n##########################\npublic static boolean isApplicable(MethodUsage methodUsage, String needleName, List<ResolvedType> needleParameterTypes, TypeSolver typeSolver) {\n    if (!methodUsage.getName().equals(needleName)) {\n        return false;\n    }\n\n    int countOfMethodUsageArgumentsPassed = methodUsage.getNoParams();\n    int lastMethodUsageArgumentIndex = Math.max(0, countOfMethodUsageArgumentsPassed - 1);\n    int needleParameterCount = needleParameterTypes.size();\n\n    boolean methodIsDeclaredWithVariadicParameter = methodUsage.getDeclaration().hasVariadicParameter();\n\n    if (!isArgumentCountValid(methodIsDeclaredWithVariadicParameter, needleParameterCount, countOfMethodUsageArgumentsPassed)) {\n        return false;\n    }\n\n    for (int i = 0; i < needleParameterCount; i++) {\n        ResolvedType actualArgumentType = needleParameterTypes.get(i);\n        ResolvedType expectedArgumentType = getExpectedArgumentType(methodUsage, lastMethodUsageArgumentIndex, methodIsDeclaredWithVariadicParameter, i);\n\n        if (!isArgumentTypeApplicable(methodUsage, needleParameterTypes, actualArgumentType, expectedArgumentType, i, countOfMethodUsageArgumentsPassed)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nprivate static boolean isArgumentCountValid(boolean methodIsDeclaredWithVariadicParameter, int needleParameterCount, int countOfMethodUsageArgumentsPassed) {\n    if (!methodIsDeclaredWithVariadicParameter && needleParameterCount != countOfMethodUsageArgumentsPassed) {\n        return false;\n    }\n    return !(needleParameterCount < countOfMethodUsageArgumentsPassed - 1);\n}\n\nprivate static ResolvedType getExpectedArgumentType(MethodUsage methodUsage, int lastMethodUsageArgumentIndex, boolean methodIsDeclaredWithVariadicParameter, int index) {\n    if (!methodIsDeclaredWithVariadicParameter || index < lastMethodUsageArgumentIndex) {\n        return methodUsage.getParamType(index);\n    } else {\n        ResolvedType expectedArgumentType = methodUsage.getParamType(lastMethodUsageArgumentIndex);\n        return expectedArgumentType.isArray() ? expectedArgumentType.asArrayType().getComponentType() : expectedArgumentType;\n    }\n}\n\nprivate static boolean isArgumentTypeApplicable(MethodUsage methodUsage, List<ResolvedType> needleParameterTypes, ResolvedType actualArgumentType, ResolvedType expectedArgumentType, int index, int countOfMethodUsageArgumentsPassed) {\n    List<ResolvedTypeParameterDeclaration> typeParameters = methodUsage.getDeclaration().getTypeParameters();\n    typeParameters.addAll(methodUsage.declaringType().getTypeParameters());\n\n    Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n    inferTypes(needleParameterTypes.get(index), expectedArgumentType, derivedValues);\n\n    for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()) {\n        expectedArgumentType = expectedArgumentType.replaceTypeVariables(entry.getKey(), entry.getValue());\n    }\n\n    return expectedArgumentType.isAssignableBy(actualArgumentType);\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Methods**:\n   - `isArgumentCountValid`: Checks if the argument count is valid based on whether the method is variadic.\n   - `getExpectedArgumentType`: Determines the expected argument type based on the method's parameters and whether it has variadic parameters.\n   - `isArgumentTypeApplicable`: Checks if the actual argument type is applicable to the expected argument type, including type inference.\n\n2. **Improved Readability**: The main `isApplicable` method is now more concise and easier to read, with clear responsibilities delegated to the extracted methods.\n\n3. **Maintainability**: Each extracted method can be tested independently, making it easier to maintain and modify the code in the future.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Note the specific naming here -- parameters are part of the method declaration,\n     * while arguments are the values passed when calling a method.\n     * Note that \"needle\" refers to that value being used as a search/query term to match against.\n     *\n     * @return true, if the given MethodUsage matches the given name/types (normally obtained from a ResolvedMethodDeclaration)\n     *\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver)}  }\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver, boolean)}\n     */\n    public static boolean isApplicable(MethodUsage methodUsage, String needleName, List<ResolvedType> needleParameterTypes, TypeSolver typeSolver) {\n        if (!methodUsage.getName().equals(needleName)) {\n            return false;\n        }\n\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodUsageArgumentsPassed = methodUsage.getNoParams();\n        int lastMethodUsageArgumentIndex = Math.max(0, countOfMethodUsageArgumentsPassed - 1);\n\n        // The index of the final argument passed (on the method usage).\n        int needleParameterCount = needleParameterTypes.size();\n        int lastNeedleParameterIndex = Math.max(0, needleParameterCount - 1);\n\n        // TODO: Does the method usage have a declaration at this point..?\n        boolean methodIsDeclaredWithVariadicParameter = methodUsage.getDeclaration().hasVariadicParameter();\n\n        // If the counts do not match and the method is not variadic, this is not a match.\n        if (!methodIsDeclaredWithVariadicParameter && !(needleParameterCount == countOfMethodUsageArgumentsPassed)) {\n            return false;\n        }\n\n        // If the counts do not match and we have provided too few arguments, this is not a match. Note that variadic parameters\n        // allow you to omit the vararg, which would allow a difference of one, but a difference in count of 2 or more is not a match.\n        if (!(needleParameterCount == countOfMethodUsageArgumentsPassed) && needleParameterCount < lastMethodUsageArgumentIndex) {\n            return false;\n        }\n\n        // Iterate over the arguments given to the method, and compare their types against the given method's declared parameter types\n        for (int i = 0; i < needleParameterCount; i++) {\n            ResolvedType actualArgumentType = needleParameterTypes.get(i);\n\n            ResolvedType expectedArgumentType;\n            boolean reachedVariadicParam = methodIsDeclaredWithVariadicParameter && i >= lastMethodUsageArgumentIndex;\n            if (!reachedVariadicParam) {\n                // Not yet reached the variadic parameters -- the expected type is just whatever is at that position.\n                expectedArgumentType = methodUsage.getParamType(i);\n            } else {\n                // We have reached the variadic parameters -- the expected type is the type of the last declared parameter.\n                expectedArgumentType = methodUsage.getParamType(lastMethodUsageArgumentIndex);\n                // Note that the given variadic value might be an array - if so, use the array's component type rather.\n                // This is only valid if ONE argument has been given to the vararg parameter.\n                // Example: {@code void test(String... s) {}} and {@code test(stringArray)} -- {@code String... is assignable by stringArray}\n                // Example: {@code void test(String[]... s) {}} and {@code test(stringArrayArray)} -- {@code String[]... is assignable by stringArrayArray}\n                boolean argumentIsArray = (needleParameterCount == countOfMethodUsageArgumentsPassed) && expectedArgumentType.isAssignableBy(actualArgumentType);\n                if (!argumentIsArray) {\n                    // Get the component type of the declared parameter type.\n                    expectedArgumentType = expectedArgumentType.asArrayType().getComponentType();\n                }\n            }\n\n            // Consider type parameters directly on the method declaration, and ALSO on the enclosing type (e.g. a class)\n            List<ResolvedTypeParameterDeclaration> typeParameters = methodUsage.getDeclaration().getTypeParameters();\n            typeParameters.addAll(methodUsage.declaringType().getTypeParameters());\n\n            ResolvedType expectedTypeWithoutSubstitutions = expectedArgumentType;\n            ResolvedType expectedTypeWithInference = expectedArgumentType;\n            Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n\n            // For each declared parameter, infer the types that will replace generics (type parameters)\n            for (int j = 0; j < countOfMethodUsageArgumentsPassed; j++) {\n                ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(j);\n                ResolvedType parameterType = parameter.getType();\n                if (parameter.isVariadic()) {\n                    // Don't continue if a vararg parameter is reached and there are no arguments left\n                    if (needleParameterCount == j) {\n                        break;\n                    }\n                    parameterType = parameterType.asArrayType().getComponentType();\n                }\n                inferTypes(needleParameterTypes.get(j), parameterType, derivedValues);\n            }\n\n            for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()) {\n                ResolvedTypeParameterDeclaration tp = entry.getKey();\n                expectedTypeWithInference = expectedTypeWithInference.replaceTypeVariables(tp, entry.getValue());\n            }\n\n            // Consider cases where type variables can be replaced (e.g. add(E element) vs add(String element))\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver)));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), bound.getType());\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(bound.getType()));\n                    } else {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.superBound(bound.getType()));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // Consider cases where type variables involve bounds e.g. super/extends\n            ResolvedType expectedTypeWithSubstitutions = expectedTypeWithoutSubstitutions;\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, bound.getType());\n                    } else {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // If the given argument still isn't applicable even after considering type arguments/generics, this is not a match.\n            if (!expectedArgumentType.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithSubstitutions.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithInference.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithoutSubstitutions.isAssignableBy(actualArgumentType)) {\n                return false;\n            }\n        }\n\n        // If the checks above haven't failed, then we've found a match.\n        return true;\n    }\n\nClass content:\n/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.resolution;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodLikeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.logic.MethodResolutionCapability;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\n\n/**\n * @author Federico Tomassetti\n */\npublic class MethodResolutionLogic {\n    \n    private static String JAVA_LANG_OBJECT = Object.class.getCanonicalName();\n\n    private static List<ResolvedType> groupVariadicParamValues(List<ResolvedType> argumentsTypes, int startVariadic, ResolvedType variadicType) {\n        List<ResolvedType> res = new ArrayList<>(argumentsTypes.subList(0, startVariadic));\n        List<ResolvedType> variadicValues = argumentsTypes.subList(startVariadic, argumentsTypes.size());\n        if (variadicValues.isEmpty()) {\n            // TODO if there are no variadic values we should default to the bound of the formal type\n            res.add(variadicType);\n        } else {\n            ResolvedType componentType = findCommonType(variadicValues);\n            res.add(new ResolvedArrayType(componentType));\n        }\n        return res;\n    }\n\n    private static ResolvedType findCommonType(List<ResolvedType> variadicValues) {\n        if (variadicValues.isEmpty()) {\n            throw new IllegalArgumentException();\n        }\n        // TODO implement this decently\n        return variadicValues.get(0);\n    }\n\n    public static boolean isApplicable(ResolvedMethodDeclaration method, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n        return isApplicable(method, name, argumentsTypes, typeSolver, false);\n    }\n\n    /**\n     * Note the specific naming here -- parameters are part of the method declaration,\n     * while arguments are the values passed when calling a method.\n     * Note that \"needle\" refers to that value being used as a search/query term to match against.\n     *\n     * @return true, if the given ResolvedMethodDeclaration matches the given name/types (normally obtained from a MethodUsage)\n     *\n     * @see {@link MethodResolutionLogic#isApplicable(MethodUsage, String, List, TypeSolver)}\n     */\n    private static boolean isApplicable(ResolvedMethodDeclaration methodDeclaration, String needleName, List<ResolvedType> needleArgumentTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!methodDeclaration.getName().equals(needleName)) {\n            return false;\n        }\n\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodParametersDeclared = methodDeclaration.getNumberOfParams();\n        int lastMethodParameterIndex = Math.max(0, countOfMethodParametersDeclared - 1);\n\n        // The index of the final argument passed (on the method usage).\n        int countOfNeedleArgumentsPassed = needleArgumentTypes.size();\n        int lastNeedleArgumentIndex = Math.max(0, countOfNeedleArgumentsPassed - 1);\n\n        boolean methodIsDeclaredWithVariadicParameter = methodDeclaration.hasVariadicParameter();\n\n        if (!methodIsDeclaredWithVariadicParameter && (countOfNeedleArgumentsPassed != countOfMethodParametersDeclared)) {\n            // If it is not variadic, and the number of parameters/arguments are unequal -- this is not a match.\n            return false;\n        }\n\n        if (methodIsDeclaredWithVariadicParameter) {\n            // If the method declaration we're considering has a variadic parameter,\n            // attempt to convert the given list of arguments to fit this pattern\n            // e.g. foo(String s, String... s2) {} --- consider the first argument, then group the remainder as an array\n\n            ResolvedType expectedVariadicParameterType = methodDeclaration.getLastParam().getType();\n            for (ResolvedTypeParameterDeclaration tp : methodDeclaration.getTypeParameters()) {\n                expectedVariadicParameterType = replaceTypeParam(expectedVariadicParameterType, tp, typeSolver);\n            }\n\n            if(countOfNeedleArgumentsPassed <= (countOfMethodParametersDeclared - 2)) {\n                // If it is variadic, and the number of arguments are short by **two or more** -- this is not a match.\n                // Note that omitting the variadic parameter is treated as an empty array\n                //  (thus being short of only 1 argument is fine, but being short of 2 or more is not).\n                return false;\n            }\n            if (countOfNeedleArgumentsPassed > countOfMethodParametersDeclared) {\n                // If it is variadic, and we have an \"excess\" of arguments, group the \"trailing\" arguments into an array.\n                // Confirm all of these grouped \"trailing\" arguments have the required type -- if not, this is not a valid type. (Maybe this is also done later..?)\n                for(int variadicArgumentIndex = countOfMethodParametersDeclared; variadicArgumentIndex < countOfNeedleArgumentsPassed; variadicArgumentIndex++) {\n                    ResolvedType currentArgumentType = needleArgumentTypes.get(variadicArgumentIndex);\n                    boolean argumentIsAssignableToVariadicComponentType = expectedVariadicParameterType.asArrayType().getComponentType().isAssignableBy(currentArgumentType);\n                    if(!argumentIsAssignableToVariadicComponentType) {\n                        // If any of the arguments are not assignable to the expected variadic type, this is not a match.\n                        return false;\n                    }\n                }\n                needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());\n            }\n            if (countOfNeedleArgumentsPassed == (countOfMethodParametersDeclared - 1)) {\n                // If it is variadic and we are short of **exactly one** parameter, this is a match.\n                // Note that omitting the variadic parameter is treated as an empty array\n                //  (thus being short of only 1 argument is fine, but being short of 2 or more is not).\n\n                // thus group the \"empty\" value into an empty array...\n                needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());\n            } else if (countOfNeedleArgumentsPassed == countOfMethodParametersDeclared) {\n                ResolvedType actualArgumentType = needleArgumentTypes.get(lastNeedleArgumentIndex);\n                boolean finalArgumentIsArray = actualArgumentType.isArray() && expectedVariadicParameterType.isAssignableBy(actualArgumentType.asArrayType().getComponentType());\n                if(finalArgumentIsArray) {\n                    // Treat as an array of values -- in which case the expected parameter type is the common type of this array.\n                    // no need to do anything\n//                    expectedVariadicParameterType = actualArgumentType.asArrayType().getComponentType();\n                } else {\n                    // Treat as a single value -- in which case, the expected parameter type is the same as the single value.\n                    needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());\n                }\n            } else {\n                // Should be unreachable.\n            }\n        }\n\n\n        // The index of the final argument passed (on the method usage).\n        int countOfNeedleArgumentsPassedAfterGrouping = needleArgumentTypes.size();\n        int lastNeedleArgumentIndexAfterGrouping = Math.max(0, countOfNeedleArgumentsPassed - 1);\n\n        // If variadic parameters are possible then they will have been \"grouped\" into a single argument.\n        // At this point, therefore, the number of arguments must be equal -- if they're not, then there is no match.\n        if (countOfNeedleArgumentsPassedAfterGrouping != countOfMethodParametersDeclared) {\n            return false;\n        }\n\n\n        Map<String, ResolvedType> matchedParameters = new HashMap<>();\n        boolean needForWildCardTolerance = false;\n        for (int i = 0; i < countOfMethodParametersDeclared; i++) {\n            ResolvedType expectedDeclaredType = methodDeclaration.getParam(i).getType();\n            ResolvedType actualArgumentType = needleArgumentTypes.get(i);\n            if ((expectedDeclaredType.isTypeVariable() && !(expectedDeclaredType.isWildcard())) && expectedDeclaredType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedDeclaredType.asTypeParameter().getName(), actualArgumentType);\n                continue;\n            }\n            \n            boolean isAssignableWithoutSubstitution = expectedDeclaredType.isAssignableBy(actualArgumentType) ||\n                    (methodDeclaration.getParam(i).isVariadic() && new ResolvedArrayType(expectedDeclaredType).isAssignableBy(actualArgumentType));\n\n            if (!isAssignableWithoutSubstitution && expectedDeclaredType.isReferenceType() && actualArgumentType.isReferenceType()) {\n                isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                        expectedDeclaredType.asReferenceType(),\n                        actualArgumentType.asReferenceType(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List<ResolvedTypeParameterDeclaration> typeParameters = methodDeclaration.getTypeParameters();\n                typeParameters.addAll(methodDeclaration.declaringType().getTypeParameters());\n                for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                    expectedDeclaredType = replaceTypeParam(expectedDeclaredType, tp, typeSolver);\n                }\n\n                if (!expectedDeclaredType.isAssignableBy(actualArgumentType)) {\n                    if (actualArgumentType.isWildcard() && withWildcardTolerance && !expectedDeclaredType.isPrimitive()) {\n                        needForWildCardTolerance = true;\n                        continue;\n                    }\n                    // if the expected is java.lang.Math.max(double,double) and the type parameters are defined with constrain\n                    // for example LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=T}}}, LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=U}}}\n                    // we want to keep this method for future resolution\n                    if (actualArgumentType.isConstraint() && withWildcardTolerance && expectedDeclaredType.isPrimitive()) {\n                        needForWildCardTolerance = true;\n                        continue;\n                    }\n                    if (methodIsDeclaredWithVariadicParameter && i == countOfMethodParametersDeclared - 1) {\n                        if (new ResolvedArrayType(expectedDeclaredType).isAssignableBy(actualArgumentType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }\n\n    public static boolean isAssignableMatchTypeParameters(ResolvedType expected, ResolvedType actual,\n                                                          Map<String, ResolvedType> matchedParameters) {\n        if (expected.isReferenceType() && actual.isReferenceType()) {\n            return isAssignableMatchTypeParameters(expected.asReferenceType(), actual.asReferenceType(), matchedParameters);\n        }\n        if (expected.isTypeVariable()) {\n            matchedParameters.put(expected.asTypeParameter().getName(), actual);\n            return true;\n        }\n        if (expected.isArray()) {\n            matchedParameters.put(expected.asArrayType().getComponentType().toString(), actual);\n            return true;\n        }\n        throw new UnsupportedOperationException(expected.getClass().getCanonicalName() + \" \" + actual.getClass().getCanonicalName());\n    }\n\n    public static boolean isAssignableMatchTypeParameters(ResolvedReferenceType expected, ResolvedReferenceType actual,\n                                                          Map<String, ResolvedType> matchedParameters) {\n        if (actual.getQualifiedName().equals(expected.getQualifiedName())) {\n            return isAssignableMatchTypeParametersMatchingQName(expected, actual, matchedParameters);\n        } else {\n            List<ResolvedReferenceType> ancestors = actual.getAllAncestors();\n            for (ResolvedReferenceType ancestor : ancestors) {\n                if (isAssignableMatchTypeParametersMatchingQName(expected, ancestor, matchedParameters)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static boolean isAssignableMatchTypeParametersMatchingQName(ResolvedReferenceType expected, ResolvedReferenceType actual,\n                                                                        Map<String, ResolvedType> matchedParameters) {\n\n        if (!expected.getQualifiedName().equals(actual.getQualifiedName())) {\n            return false;\n        }\n        if (expected.typeParametersValues().size() != actual.typeParametersValues().size()) {\n            throw new UnsupportedOperationException();\n            //return true;\n        }\n        for (int i = 0; i < expected.typeParametersValues().size(); i++) {\n            ResolvedType expectedParam = expected.typeParametersValues().get(i);\n            ResolvedType actualParam = actual.typeParametersValues().get(i);\n\n            // In the case of nested parameterizations eg. List<R> <-> List<Integer>\n            // we should peel off one layer and ensure R <-> Integer\n            if (expectedParam.isReferenceType() && actualParam.isReferenceType()) {\n                ResolvedReferenceType r1 = expectedParam.asReferenceType();\n                ResolvedReferenceType r2 = actualParam.asReferenceType();\n                // we can have r1=A and r2=A.B (with B extends A and B is an inner class of A)\n                // in this case we want to verify expected parameter from the actual parameter ancestors \n                return isAssignableMatchTypeParameters(r1, r2, matchedParameters);\n            }\n\n            if (expectedParam.isTypeVariable()) {\n                String expectedParamName = expectedParam.asTypeParameter().getName();\n                if (!actualParam.isTypeVariable() || !actualParam.asTypeParameter().getName().equals(expectedParamName)) {\n                    return matchTypeVariable(expectedParam.asTypeVariable(), actualParam, matchedParameters);\n                }\n            } else if (expectedParam.isReferenceType()) {\n                if (actualParam.isTypeVariable()) {\n                    return matchTypeVariable(actualParam.asTypeVariable(), expectedParam, matchedParameters);\n                }\n                if (!expectedParam.equals(actualParam)) {\n                    return false;\n                }\n            } else if (expectedParam.isWildcard()) {\n                if (expectedParam.asWildcard().isExtends()) {\n                    return isAssignableMatchTypeParameters(expectedParam.asWildcard().getBoundedType(), actual, matchedParameters);\n                }\n                // TODO verify super bound\n                return true;\n            } else {\n                throw new UnsupportedOperationException(expectedParam.describe());\n            }\n        }\n        return true;\n    }\n\n    private static boolean matchTypeVariable(ResolvedTypeVariable typeVariable, ResolvedType type, Map<String, ResolvedType> matchedParameters) {\n        String typeParameterName = typeVariable.asTypeParameter().getName();\n        if (matchedParameters.containsKey(typeParameterName)) {\n            ResolvedType matchedParameter = matchedParameters.get(typeParameterName);\n            if (matchedParameter.isAssignableBy(type)) {\n                return true;\n            } else if (type.isAssignableBy(matchedParameter)) {\n                // update matchedParameters to contain the more general type\n                matchedParameters.put(typeParameterName, type);\n                return true;\n            }\n            return false;\n        } else {\n            matchedParameters.put(typeParameterName, type);\n        }\n        return true;\n    }\n\n    public static ResolvedType replaceTypeParam(ResolvedType type, ResolvedTypeParameterDeclaration tp, TypeSolver typeSolver) {\n        if (type.isTypeVariable() || type.isWildcard()) {\n            if (type.describe().equals(tp.getName())) {\n                List<ResolvedTypeParameterDeclaration.Bound> bounds = tp.getBounds();\n                if (bounds.size() > 1) {\n                    throw new UnsupportedOperationException();\n                }\n                if (bounds.size() == 1) {\n                    return bounds.get(0).getType();\n                }\n                return new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver);\n            }\n            return type;\n        }\n        if (type.isPrimitive()) {\n            return type;\n        }\n        if (type.isArray()) {\n            return new ResolvedArrayType(replaceTypeParam(type.asArrayType().getComponentType(), tp, typeSolver));\n        }\n        if (type.isReferenceType()) {\n            ResolvedReferenceType result = type.asReferenceType();\n            result = result.transformTypeParameters(typeParam -> replaceTypeParam(typeParam, tp, typeSolver)).asReferenceType();\n            return result;\n        }\n        throw new UnsupportedOperationException(\"Replacing \" + type + \", param \" + tp + \" with \" + type.getClass().getCanonicalName());\n    }\n\n    /**\n     * Note the specific naming here -- parameters are part of the method declaration,\n     * while arguments are the values passed when calling a method.\n     * Note that \"needle\" refers to that value being used as a search/query term to match against.\n     *\n     * @return true, if the given MethodUsage matches the given name/types (normally obtained from a ResolvedMethodDeclaration)\n     *\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver)}  }\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver, boolean)}\n     */\n    public static boolean isApplicable(MethodUsage methodUsage, String needleName, List<ResolvedType> needleParameterTypes, TypeSolver typeSolver) {\n        if (!methodUsage.getName().equals(needleName)) {\n            return false;\n        }\n\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodUsageArgumentsPassed = methodUsage.getNoParams();\n        int lastMethodUsageArgumentIndex = Math.max(0, countOfMethodUsageArgumentsPassed - 1);\n\n        // The index of the final argument passed (on the method usage).\n        int needleParameterCount = needleParameterTypes.size();\n        int lastNeedleParameterIndex = Math.max(0, needleParameterCount - 1);\n\n        // TODO: Does the method usage have a declaration at this point..?\n        boolean methodIsDeclaredWithVariadicParameter = methodUsage.getDeclaration().hasVariadicParameter();\n\n        // If the counts do not match and the method is not variadic, this is not a match.\n        if (!methodIsDeclaredWithVariadicParameter && !(needleParameterCount == countOfMethodUsageArgumentsPassed)) {\n            return false;\n        }\n\n        // If the counts do not match and we have provided too few arguments, this is not a match. Note that variadic parameters\n        // allow you to omit the vararg, which would allow a difference of one, but a difference in count of 2 or more is not a match.\n        if (!(needleParameterCount == countOfMethodUsageArgumentsPassed) && needleParameterCount < lastMethodUsageArgumentIndex) {\n            return false;\n        }\n\n        // Iterate over the arguments given to the method, and compare their types against the given method's declared parameter types\n        for (int i = 0; i < needleParameterCount; i++) {\n            ResolvedType actualArgumentType = needleParameterTypes.get(i);\n\n            ResolvedType expectedArgumentType;\n            boolean reachedVariadicParam = methodIsDeclaredWithVariadicParameter && i >= lastMethodUsageArgumentIndex;\n            if (!reachedVariadicParam) {\n                // Not yet reached the variadic parameters -- the expected type is just whatever is at that position.\n                expectedArgumentType = methodUsage.getParamType(i);\n            } else {\n                // We have reached the variadic parameters -- the expected type is the type of the last declared parameter.\n                expectedArgumentType = methodUsage.getParamType(lastMethodUsageArgumentIndex);\n                // Note that the given variadic value might be an array - if so, use the array's component type rather.\n                // This is only valid if ONE argument has been given to the vararg parameter.\n                // Example: {@code void test(String... s) {}} and {@code test(stringArray)} -- {@code String... is assignable by stringArray}\n                // Example: {@code void test(String[]... s) {}} and {@code test(stringArrayArray)} -- {@code String[]... is assignable by stringArrayArray}\n                boolean argumentIsArray = (needleParameterCount == countOfMethodUsageArgumentsPassed) && expectedArgumentType.isAssignableBy(actualArgumentType);\n                if (!argumentIsArray) {\n                    // Get the component type of the declared parameter type.\n                    expectedArgumentType = expectedArgumentType.asArrayType().getComponentType();\n                }\n            }\n\n            // Consider type parameters directly on the method declaration, and ALSO on the enclosing type (e.g. a class)\n            List<ResolvedTypeParameterDeclaration> typeParameters = methodUsage.getDeclaration().getTypeParameters();\n            typeParameters.addAll(methodUsage.declaringType().getTypeParameters());\n\n            ResolvedType expectedTypeWithoutSubstitutions = expectedArgumentType;\n            ResolvedType expectedTypeWithInference = expectedArgumentType;\n            Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n\n            // For each declared parameter, infer the types that will replace generics (type parameters)\n            for (int j = 0; j < countOfMethodUsageArgumentsPassed; j++) {\n                ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(j);\n                ResolvedType parameterType = parameter.getType();\n                if (parameter.isVariadic()) {\n                    // Don't continue if a vararg parameter is reached and there are no arguments left\n                    if (needleParameterCount == j) {\n                        break;\n                    }\n                    parameterType = parameterType.asArrayType().getComponentType();\n                }\n                inferTypes(needleParameterTypes.get(j), parameterType, derivedValues);\n            }\n\n            for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()) {\n                ResolvedTypeParameterDeclaration tp = entry.getKey();\n                expectedTypeWithInference = expectedTypeWithInference.replaceTypeVariables(tp, entry.getValue());\n            }\n\n            // Consider cases where type variables can be replaced (e.g. add(E element) vs add(String element))\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver)));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), bound.getType());\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(bound.getType()));\n                    } else {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.superBound(bound.getType()));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // Consider cases where type variables involve bounds e.g. super/extends\n            ResolvedType expectedTypeWithSubstitutions = expectedTypeWithoutSubstitutions;\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, bound.getType());\n                    } else {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // If the given argument still isn't applicable even after considering type arguments/generics, this is not a match.\n            if (!expectedArgumentType.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithSubstitutions.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithInference.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithoutSubstitutions.isAssignableBy(actualArgumentType)) {\n                return false;\n            }\n        }\n\n        // If the checks above haven't failed, then we've found a match.\n        return true;\n    }\n\n    /**\n     * Filters by given function {@param keyExtractor} using a stateful filter mechanism.\n     *\n     * <pre>\n     *      persons.stream().filter(distinctByKey(Person::getName))\n     * </pre>\n     * <p>\n     * The example above would return a distinct list of persons containing only one person per name.\n     */\n    private static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {\n        Set<Object> seen = ConcurrentHashMap.newKeySet();\n        return t -> seen.add(keyExtractor.apply(t));\n    }\n\n    /**\n     * @param methods we expect the methods to be ordered such that inherited methods are later in the list\n     */\n    public static SymbolReference<ResolvedMethodDeclaration> findMostApplicable(List<ResolvedMethodDeclaration> methods,\n                                                                                String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n        SymbolReference<ResolvedMethodDeclaration> res = findMostApplicable(methods, name, argumentsTypes, typeSolver, false);\n        if (res.isSolved()) {\n            return res;\n        }\n        return findMostApplicable(methods, name, argumentsTypes, typeSolver, true);\n    }\n\n    public static SymbolReference<ResolvedMethodDeclaration> findMostApplicable(List<ResolvedMethodDeclaration> methods,\n                                                                                String name, List<ResolvedType> argumentsTypes,\n                                                                                TypeSolver typeSolver,\n                                                                                boolean wildcardTolerance\n    ) {\n\n        List<ResolvedMethodDeclaration> applicableMethods = methods.stream()\n                // Only consider methods with a matching name\n                .filter(m -> m.getName().equals(name))\n                // Filters out duplicate ResolvedMethodDeclaration by their signature.\n                .filter(distinctByKey(ResolvedMethodDeclaration::getQualifiedSignature))\n                // Checks if ResolvedMethodDeclaration is applicable to argumentsTypes.\n                .filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver, wildcardTolerance))\n                .collect(Collectors.toList());\n\n        // If no applicable methods found, return as unsolved.\n        if (applicableMethods.isEmpty()) {\n            return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n        }\n\n        // If there are multiple possible methods found, null arguments can help to eliminate some matches.\n        if (applicableMethods.size() > 1) {\n            List<Integer> nullParamIndexes = new ArrayList<>();\n            for (int i = 0; i < argumentsTypes.size(); i++) {\n                if (argumentsTypes.get(i).isNull()) {\n                    nullParamIndexes.add(i);\n                }\n            }\n\n            // If some null arguments have been provided, use this to eliminate some opitons.\n            if (!nullParamIndexes.isEmpty()) {\n                // remove method with array param if a non array exists and arg is null\n                Set<ResolvedMethodDeclaration> removeCandidates = new HashSet<>();\n                for (Integer nullParamIndex : nullParamIndexes) {\n                    for (ResolvedMethodDeclaration methDecl : applicableMethods) {\n                        if (methDecl.getParam(nullParamIndex).getType().isArray()) {\n                            removeCandidates.add(methDecl);\n                        }\n                    }\n                }\n\n                // Where candidiates for removal are found, remove them.\n                if (!removeCandidates.isEmpty() && removeCandidates.size() < applicableMethods.size()) {\n                    applicableMethods.removeAll(removeCandidates);\n                }\n            }\n        }\n\n        // If only one applicable method found, short-circuit and return it here.\n        if (applicableMethods.size() == 1) {\n            return SymbolReference.solved(applicableMethods.get(0));\n        }\n        \n        // Examine the applicable methods found, and evaluate each to determine the \"best\" one\n        ResolvedMethodDeclaration winningCandidate = applicableMethods.get(0);\n        ResolvedMethodDeclaration other = null;\n        boolean possibleAmbiguity = false;\n        for (int i = 1; i < applicableMethods.size(); i++) {\n            other = applicableMethods.get(i);\n            if (isMoreSpecific(winningCandidate, other, argumentsTypes)) {\n                possibleAmbiguity = false;\n            } else if (isMoreSpecific(other, winningCandidate, argumentsTypes)) {\n                possibleAmbiguity = false;\n                winningCandidate = other;\n            } else {\n                // 15.12.2.5. Choosing the Most Specific Method\n                // One applicable method m1 is more specific than another applicable method m2, for an invocation with argument\n                // expressions e1, ..., ek, if any of the following are true:\n                // m2 is generic, and m1 is inferred to be more specific than m2 for argument expressions e1, ..., ek by \u00a718.5.4.\n                // 18.5.4. More Specific Method Inference should be verified \n                // ...\n                if (winningCandidate.isGeneric() && !other.isGeneric()) {\n                    winningCandidate = other;\n                } else if (!winningCandidate.isGeneric() && other.isGeneric()) {\n                    // nothing to do at this stage winningCandidate is the winner\n                } else if (winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName())) {\n                    possibleAmbiguity = true;\n                } else {\n                    // we expect the methods to be ordered such that inherited methods are later in the list\n                }\n            }\n        }\n        \n        if (possibleAmbiguity) {\n            // pick the first exact match if it exists\n            if (!isExactMatch(winningCandidate, argumentsTypes)) {\n                if (isExactMatch(other, argumentsTypes)) {\n                    winningCandidate = other;\n                } else {\n                    throw new MethodAmbiguityException(\n                            \"Ambiguous method call: cannot find a most applicable method: \" + winningCandidate\n                                    + \", \" + other);\n                }\n            }\n        }\n\n        return SymbolReference.solved(winningCandidate);\n    }\n\n    protected static boolean isExactMatch(ResolvedMethodLikeDeclaration method, List<ResolvedType> argumentsTypes) {\n        for (int i = 0; i < method.getNumberOfParams(); i++) {\n            if (!method.getParam(i).getType().equals(argumentsTypes.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static ResolvedType getMethodsExplicitAndVariadicParameterType(ResolvedMethodDeclaration method, int i) {\n        int numberOfParams = method.getNumberOfParams();\n\n        if (i < numberOfParams) {\n            return method.getParam(i).getType();\n        }\n        if (method.hasVariadicParameter()) {\n            return method.getParam(numberOfParams - 1).getType();\n        }\n        return null;\n    }\n\n    private static boolean isMoreSpecific(ResolvedMethodDeclaration methodA, ResolvedMethodDeclaration methodB,\n                                          List<ResolvedType> argumentTypes) {\n\n        final boolean aVariadic = methodA.hasVariadicParameter();\n        final boolean bVariadic = methodB.hasVariadicParameter();\n        final int aNumberOfParams = methodA.getNumberOfParams();\n        final int bNumberOfParams = methodB.getNumberOfParams();\n        final int numberOfArgs = argumentTypes.size();\n        final ResolvedType lastArgType = numberOfArgs > 0 ? argumentTypes.get(numberOfArgs - 1) : null;\n        final boolean isLastArgArray = lastArgType != null && lastArgType.isArray();\n        int omittedArgs = 0;\n        boolean isMethodAMoreSpecific = false;\n\n        // If one method declaration has exactly the correct amount of parameters and is not variadic then it is always\n        // preferred to a declaration that is variadic (and hence possibly also has a different amount of parameters).\n        if (!aVariadic && aNumberOfParams == numberOfArgs && (bVariadic && (bNumberOfParams != numberOfArgs ||\n                !isLastArgArray))) {\n            return true;\n        }\n        if (!bVariadic && bNumberOfParams == numberOfArgs && (aVariadic && (aNumberOfParams != numberOfArgs ||\n                !isLastArgArray))) {\n            return false;\n        }\n        \n        // If both methods are variadic but the calling method omits any varArgs, bump the omitted args to\n        // ensure the varargs type is considered when determining which method is more specific\n        if (aVariadic && bVariadic && aNumberOfParams == bNumberOfParams && numberOfArgs == aNumberOfParams - 1) {\n        \tomittedArgs++;\n        }\n\n        // Either both methods are variadic or neither is. So we must compare the parameter types.\n        for (int i = 0; i < numberOfArgs + omittedArgs; i++) {\n            ResolvedType paramTypeA = getMethodsExplicitAndVariadicParameterType(methodA, i);\n            ResolvedType paramTypeB = getMethodsExplicitAndVariadicParameterType(methodB, i);\n            \n            ResolvedType argType = null;\n            if (i < argumentTypes.size()) {\n            \targType = argumentTypes.get(i);\n            }\n\n            // Safety: if a type is null it means a signature with too few parameters managed to get to this point.\n            // This should not happen but it also means that this signature is immediately disqualified.\n            if (paramTypeA == null) {\n                return false;\n            }\n            if (paramTypeB == null) {\n                return true;\n            }\n            // Widening primitive conversions have priority over boxing/unboxing conversions when finding the most\n            // applicable method. E.g. assume we have method call foo(1) and declarations foo(long) and foo(Integer).\n            // The method call will call foo(long), as it requires a widening primitive conversion from int to long\n            // instead of a boxing conversion from int to Integer. See JLS \u00a715.12.2.\n            // This is what we check here.\n            if (argType != null &&\n            \t\tparamTypeA.isPrimitive() == argType.isPrimitive() &&\n                    paramTypeB.isPrimitive() != argType.isPrimitive() &&\n                    paramTypeA.isAssignableBy(argType)) {\n\n                return true;\n            }\n            if (argType != null &&\n            \t\tparamTypeB.isPrimitive() == argType.isPrimitive() &&\n                    paramTypeA.isPrimitive() != argType.isPrimitive() &&\n                    paramTypeB.isAssignableBy(argType)) {\n\n                return false;\n            // if paramA and paramB are not the last parameters\n            // and the type of paramA or paramB (which are not more specific at this stage) is java.lang.Object\n            // then we have to consider others parameters before concluding\n            }\n            if ((i < numberOfArgs - 1)\n                    && (isJavaLangObject(paramTypeB) || (isJavaLangObject(paramTypeA)))) {\n                // consider others parameters\n                // but eventually mark the method A as more specific if the methodB has an argument of type java.lang.Object\n                isMethodAMoreSpecific = isMethodAMoreSpecific || isJavaLangObject(paramTypeB);\n            }\n            // If we get to this point then we check whether one of the methods contains a parameter type that is more\n            // specific. If it does, we can assume the entire declaration is more specific as we would otherwise have\n            // a situation where the declarations are ambiguous in the given context.\n            else {\n                boolean aAssignableFromB = paramTypeA.isAssignableBy(paramTypeB);\n                boolean bAssignableFromA = paramTypeB.isAssignableBy(paramTypeA);\n\n                if (bAssignableFromA && !aAssignableFromB) {\n                    // A's parameter is more specific\n                    return true;\n                }\n                if (aAssignableFromB && !bAssignableFromA) {\n                    // B's parameter is more specific\n                    return false;\n                }\n            }\n        }\n\n        if (aVariadic && !bVariadic) {\n            // if the last argument is an array then m1 is more specific\n            return isLastArgArray;\n        }\n        if (!aVariadic && bVariadic) {\n            // if the last argument is an array and m1 is not variadic then\n            // it is not more specific\n            return !isLastArgArray;\n        }\n\n        return isMethodAMoreSpecific;\n    }\n    \n    private static boolean isJavaLangObject(ResolvedType paramType ) {\n        return paramType.isReferenceType() && paramType.asReferenceType().getQualifiedName().equals(\"java.lang.Object\");\n    }\n\n    private static boolean isMoreSpecific(MethodUsage methodA, MethodUsage methodB) {\n        boolean oneMoreSpecificFound = false;\n        for (int i = 0; i < methodA.getNoParams(); i++) {\n            ResolvedType tdA = methodA.getParamType(i);\n            ResolvedType tdB = methodB.getParamType(i);\n\n            boolean aIsAssignableByB = tdA.isAssignableBy(tdB);\n            boolean bIsAssignableByA = tdB.isAssignableBy(tdA);\n\n            // A is more specific\n            if (bIsAssignableByA && !aIsAssignableByB) {\n                oneMoreSpecificFound = true;\n            }\n            // B is more specific\n            if (aIsAssignableByB && !bIsAssignableByA) {\n                return false;\n            }\n\n            // If B is vararg and A is not, A is more specific\n            if (tdB.isArray() && tdB.asArrayType().getComponentType().isAssignableBy(tdA)) {\n                oneMoreSpecificFound = true;\n            }\n        }\n        return oneMoreSpecificFound;\n    }\n\n    public static Optional<MethodUsage> findMostApplicableUsage(List<MethodUsage> methods, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n        List<MethodUsage> applicableMethods = methods.stream().filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver)).collect(Collectors.toList());\n\n        if (applicableMethods.isEmpty()) {\n            return Optional.empty();\n        }\n        if (applicableMethods.size() == 1) {\n            return Optional.of(applicableMethods.get(0));\n        } else {\n            MethodUsage winningCandidate = applicableMethods.get(0);\n            for (int i = 1; i < applicableMethods.size(); i++) {\n                MethodUsage other = applicableMethods.get(i);\n                if (isMoreSpecific(winningCandidate, other)) {\n                    // nothing to do\n                } else if (isMoreSpecific(other, winningCandidate)) {\n                    winningCandidate = other;\n                } else {\n                    if (winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName())) {\n                        if (!areOverride(winningCandidate, other)) {\n                            throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method: \" + winningCandidate + \", \" + other + \". First declared in \" + winningCandidate.declaringType().getQualifiedName());\n                        }\n                    } else {\n                        // we expect the methods to be ordered such that inherited methods are later in the list\n                        //throw new UnsupportedOperationException();\n                    }\n                }\n            }\n            return Optional.of(winningCandidate);\n        }\n    }\n\n    private static boolean areOverride(MethodUsage winningCandidate, MethodUsage other) {\n        if (!winningCandidate.getName().equals(other.getName())) {\n            return false;\n        }\n        if (winningCandidate.getNoParams() != other.getNoParams()) {\n            return false;\n        }\n        for (int i = 0; i < winningCandidate.getNoParams(); i++) {\n            if (!winningCandidate.getParamTypes().get(i).equals(other.getParamTypes().get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static SymbolReference<ResolvedMethodDeclaration> solveMethodInType(ResolvedTypeDeclaration typeDeclaration,\n                                                                               String name,\n                                                                               List<ResolvedType> argumentsTypes) {\n        return solveMethodInType(typeDeclaration, name, argumentsTypes, false);\n    }\n\n    // TODO: Replace TypeDeclaration.solveMethod\n    public static SymbolReference<ResolvedMethodDeclaration> solveMethodInType(ResolvedTypeDeclaration typeDeclaration,\n                                                                               String name,\n                                                                               List<ResolvedType> argumentsTypes,\n                                                                               boolean staticOnly) {\n\n        if (typeDeclaration instanceof MethodResolutionCapability) {\n            return ((MethodResolutionCapability) typeDeclaration).solveMethod(name, argumentsTypes,\n                    staticOnly);\n        }\n        throw new UnsupportedOperationException(typeDeclaration.getClass().getCanonicalName());\n    }\n\n    private static void inferTypes(ResolvedType source, ResolvedType target, Map<ResolvedTypeParameterDeclaration, ResolvedType> mappings) {\n        if (source.equals(target)) {\n            return;\n        }\n        if (source.isReferenceType() && target.isReferenceType()) {\n            ResolvedReferenceType sourceRefType = source.asReferenceType();\n            ResolvedReferenceType targetRefType = target.asReferenceType();\n            if (sourceRefType.getQualifiedName().equals(targetRefType.getQualifiedName())) {\n                if (!sourceRefType.isRawType() && !targetRefType.isRawType()) {\n                    for (int i = 0; i < sourceRefType.typeParametersValues().size(); i++) {\n                        inferTypes(sourceRefType.typeParametersValues().get(i), targetRefType.typeParametersValues().get(i), mappings);\n                    }\n                }\n            }\n            return;\n        }\n        if (source.isReferenceType() && target.isWildcard()) {\n            if (target.asWildcard().isBounded()) {\n                inferTypes(source, target.asWildcard().getBoundedType(), mappings);\n                return;\n            }\n            return;\n        }\n        if (source.isWildcard() && target.isWildcard()) {\n            return;\n        }\n        if (source.isReferenceType() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n\n        if (source.isWildcard() && target.isReferenceType()) {\n            if (source.asWildcard().isBounded()) {\n                inferTypes(source.asWildcard().getBoundedType(), target, mappings);\n            }\n            return;\n        }\n\n        if (source.isWildcard() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isTypeVariable() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isPrimitive() || target.isPrimitive()) {\n            return;\n        }\n        if (source.isNull()) {\n            return;\n        }\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate isAncestor(candidateAncestor ResolvedReferenceType, ownQualifiedName String) : boolean extracted from public getAncestors(acceptIncompleteList boolean) : List<ResolvedReferenceType> in class com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration", "diffLocations": [{"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java", "startLine": 333, "endLine": 385, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java", "startLine": 333, "endLine": 385, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java", "startLine": 387, "endLine": 395, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n\n        // We want to avoid infinite recursion in case of Object having Object as ancestor\n        if (this.isJavaLangObject()) {\n            return ancestors;\n        }\n\n        try {\n            // If a superclass is found, add it as an ancestor\n            getSuperClass().ifPresent(ancestors::add);\n        } catch (UnsolvedSymbolException e) {\n            // in case we could not resolve the super class, we may still be able to resolve (some of) the\n            // implemented interfaces and so we continue gracefully with an (incomplete) list of ancestors\n\n            if (!acceptIncompleteList) {\n                // Only throw if an incomplete ancestor list is unacceptable.\n                throw e;\n            }\n        }\n\n        for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n            try {\n                // If an implemented interface is found, add it as an ancestor\n                ResolvedReferenceType rrt = toReferenceType(implemented);\n                Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = rrt.getTypeDeclaration();\n                if (resolvedReferenceTypeDeclaration.isPresent()) {\n\n                    ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n                    Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n                    if (qualifiedName.isPresent()) {\n\n                        // do not consider an inner or nested class as an ancestor\n                        if (!rtd.getQualifiedName().contains(qualifiedName.get())) {\n                            ancestors.add(rrt);\n                        }\n                    }\n                }\n            } catch (UnsolvedSymbolException e) {\n                // in case we could not resolve some implemented interface, we may still be able to resolve the\n                // extended class or (some of) the other implemented interfaces and so we continue gracefully\n                // with an (incomplete) list of ancestors\n\n                if (!acceptIncompleteList) {\n                    // Only throw if an incomplete ancestor list is unacceptable.\n                    throw e;\n                }\n            }\n        }\n\n        return ancestors;\n    }", "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java", "isPureRefactoring": true, "commitId": "df18fcb41f73c5223b9952a0ede13e410b0e16b9", "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.declarations", "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration", "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#getAncestors", "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#getQualifiedName\n methodBody: public String getQualifiedName() {\nreturn javaParserTypeAdapter.getQualifiedName();\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#toReferenceType\n methodBody: private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType) {\nString className=classOrInterfaceType.getName().getId();\nif(classOrInterfaceType.getScope().isPresent()){className=classOrInterfaceType.getScope().get().toString() + \".\" + className;\n}SymbolReference<ResolvedTypeDeclaration> ref=solveType(className);\nif(!ref.isSolved()){Optional<ClassOrInterfaceType> localScope=classOrInterfaceType.getScope();\nif(localScope.isPresent()){String localName=localScope.get().getName().getId() + \".\" + classOrInterfaceType.getName().getId();\nref=solveType(localName);\n}}if(!ref.isSolved()){throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());\n}if(!classOrInterfaceType.getTypeArguments().isPresent()){return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(),typeSolver);\n}List<ResolvedType> superClassTypeParameters=classOrInterfaceType.getTypeArguments().get().stream().map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta,ta))).collect(Collectors.toList());\nreturn new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(),superClassTypeParameters,typeSolver);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#getSuperClass\n methodBody: public Optional<ResolvedReferenceType> getSuperClass() {\nif(isJavaLangObject()){return Optional.empty();\n}if(wrappedNode.getExtendedTypes().isEmpty()){return Optional.of(object());\n}{return Optional.of(toReferenceType(wrappedNode.getExtendedTypes().getFirst().get()));\n}}", "classSignatureBefore": "public class JavaParserClassDeclaration extends AbstractClassDeclaration implements MethodUsageResolutionCapability ", "methodNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#getAncestors"], "classNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration"], "classSignatureBeforeSet": ["public class JavaParserClassDeclaration extends AbstractClassDeclaration implements MethodUsageResolutionCapability "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics \n Severe changes", "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves", "mappingState": 2}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.declarations;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.AccessSpecifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.core.resolution.MethodUsageResolutionCapability;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\nimport com.github.javaparser.symbolsolver.logic.AbstractClassDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.LazyType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\n\n/**\n * @author Federico Tomassetti\n */\npublic class JavaParserClassDeclaration extends AbstractClassDeclaration implements MethodUsageResolutionCapability {\n\n    ///\n    /// Fields\n    ///\n\n    private TypeSolver typeSolver;\n    private ClassOrInterfaceDeclaration wrappedNode;\n    private JavaParserTypeAdapter<ClassOrInterfaceDeclaration> javaParserTypeAdapter;\n\n    ///\n    /// Constructors\n    ///\n\n    public JavaParserClassDeclaration(ClassOrInterfaceDeclaration wrappedNode,\n                                      TypeSolver typeSolver) {\n        if (wrappedNode.isInterface()) {\n            throw new IllegalArgumentException(\"Interface given\");\n        }\n        this.wrappedNode = wrappedNode;\n        this.typeSolver = typeSolver;\n        this.javaParserTypeAdapter = new JavaParserTypeAdapter<>(wrappedNode, typeSolver);\n    }\n\n    ///\n    /// Public methods: from Object\n    ///\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        JavaParserClassDeclaration that = (JavaParserClassDeclaration) o;\n\n        return wrappedNode.equals(that.wrappedNode);\n    }\n\n    @Override\n    public int hashCode() {\n        return wrappedNode.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return \"JavaParserClassDeclaration{\" +\n                \"wrappedNode=\" + wrappedNode +\n                '}';\n    }\n\n    ///\n    /// Public methods: fields\n    ///\n    \n    @Override\n    public List<ResolvedFieldDeclaration> getAllFields() {\n        List<ResolvedFieldDeclaration> fields = javaParserTypeAdapter.getFieldsForDeclaredVariables();\n\n        getAncestors(true).stream().filter(ancestor -> ancestor.getTypeDeclaration().isPresent())\n                .forEach(ancestor -> ancestor.getTypeDeclaration().get().getAllFields()\n                        .forEach(f -> {\n                            fields.add(new ResolvedFieldDeclaration() {\n\n                                @Override\n                                public AccessSpecifier accessSpecifier() {\n                                    return f.accessSpecifier();\n                                }\n\n                                @Override\n                                public String getName() {\n                                    return f.getName();\n                                }\n\n                                @Override\n                                public ResolvedType getType() {\n                                    return ancestor.useThisTypeParametersOnTheGivenType(f.getType());\n                                }\n\n                                @Override\n                                public boolean isStatic() {\n                                    return f.isStatic();\n                                }\n                                \n                                @Override\n                                public boolean isVolatile() {\n                                    return f.isVolatile();\n                                }\n\n                                @Override\n                                public ResolvedTypeDeclaration declaringType() {\n                                    return f.declaringType();\n                                }\n                                \n                                @Override\n                                public Optional<FieldDeclaration> toAst() {\n                                    return f.toAst();\n                                }\n                            });\n                        }));\n\n        return fields;\n    }\n\n    ///\n    /// Public methods\n    ///\n\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> parameterTypes) {\n        Context ctx = getContext();\n        return ctx.solveMethod(name, parameterTypes, false);\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentTypes,\n                                                    Context invocationContext, List<ResolvedType> typeParameters) {\n        return getContext().solveMethodAsUsage(name, argumentTypes);\n    }\n\n    /**\n     * This method is deprecated because the context is an implementation detail that should not be exposed.\n     * Ideally this method should become private. For this reason all further usages of this method are discouraged.\n     */\n    @Deprecated\n    public Context getContext() {\n        return JavaParserFactory.getContext(wrappedNode, typeSolver);\n    }\n\n    public ResolvedType getUsage(Node node) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public String getName() {\n        return wrappedNode.getName().getId();\n    }\n\n    @Override\n    public Optional<ResolvedReferenceType> getSuperClass() {\n        if(isJavaLangObject()) {\n            // If this is java.lang.Object, it has no super class.\n            return Optional.empty();\n        } else if (wrappedNode.getExtendedTypes().isEmpty()) {\n            // All objects implicitly extend java.lang.Object -- inject it here (only when this isn't java.lang.Object)\n            return Optional.of(object());\n        } else {\n            // Otherwise, return the first ancestor (n.b.: we know it's not empty due to check above).\n            return Optional.of(toReferenceType(wrappedNode.getExtendedTypes().getFirst().get()));\n        }\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getInterfaces() {\n        List<ResolvedReferenceType> interfaces = new ArrayList<>();\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType t : wrappedNode.getImplementedTypes()) {\n                interfaces.add(toReferenceType(t));\n            }\n        }\n        return interfaces;\n    }\n\n    @Override\n    public List<ResolvedConstructorDeclaration> getConstructors() {\n        return AstResolutionUtils.getConstructors(this.wrappedNode, typeSolver, this);\n    }\n\n    @Override\n    public boolean hasDirectlyAnnotation(String canonicalName) {\n        return AstResolutionUtils.hasDirectlyAnnotation(wrappedNode, typeSolver, canonicalName);\n    }\n\n    @Override\n    public boolean isInterface() {\n        return wrappedNode.isInterface();\n    }\n\n    @Override\n    public String getPackageName() {\n        return javaParserTypeAdapter.getPackageName();\n    }\n\n    @Override\n    public String getClassName() {\n        return javaParserTypeAdapter.getClassName();\n    }\n\n    @Override\n    public String getQualifiedName() {\n        return javaParserTypeAdapter.getQualifiedName();\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedReferenceTypeDeclaration other) {\n        return javaParserTypeAdapter.isAssignableBy(other);\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedType type) {\n        return javaParserTypeAdapter.isAssignableBy(type);\n    }\n\n    @Override\n    public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other) {\n        // TODO consider generic types\n        if (this.getQualifiedName().equals(other.getQualifiedName())) {\n            return true;\n        }\n\n        Optional<ResolvedReferenceType> optionalSuperClass = getSuperClass();\n        if (optionalSuperClass.isPresent()) {\n            Optional<ResolvedReferenceTypeDeclaration> optionalSuperclassTypeDeclaration = optionalSuperClass.get().getTypeDeclaration();\n            if (optionalSuperclassTypeDeclaration.isPresent()) {\n                ResolvedReferenceTypeDeclaration superclassTypeDeclaration = optionalSuperclassTypeDeclaration.get();\n                if (superclassTypeDeclaration != this && superclassTypeDeclaration.isClass()) {\n                    if (superclassTypeDeclaration.asClass().canBeAssignedTo(other)) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (this.wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean isTypeParameter() {\n        return false;\n    }\n\n    /**\n     * Resolution should move out of declarations, so that they are pure declarations and the resolution should\n     * work for JavaParser, Reflection and Javassist classes in the same way and not be specific to the three\n     * implementations.\n     */\n    @Deprecated\n    public SymbolReference<ResolvedTypeDeclaration> solveType(String name) {\n        if (this.wrappedNode.getName().getId().equals(name)) {\n            return SymbolReference.solved(this);\n        }\n        SymbolReference<ResolvedTypeDeclaration> ref = javaParserTypeAdapter.solveType(name);\n        if (ref.isSolved()) {\n            return ref;\n        }\n\n        String prefix = wrappedNode.getName() + \".\";\n        if (name.startsWith(prefix) && name.length() > prefix.length()) {\n            return new JavaParserClassDeclaration(this.wrappedNode, typeSolver).solveType(name.substring(prefix.length()));\n        }\n\n        return getContext().getParent()\n                .orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\"))\n                .solveType(name);\n    }\n\n    @Override\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes,\n                                                                  boolean staticOnly) {\n        return getContext().solveMethod(name, argumentsTypes, staticOnly);\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n\n        // We want to avoid infinite recursion in case of Object having Object as ancestor\n        if (this.isJavaLangObject()) {\n            return ancestors;\n        }\n\n        try {\n            // If a superclass is found, add it as an ancestor\n            getSuperClass().ifPresent(ancestors::add);\n        } catch (UnsolvedSymbolException e) {\n            // in case we could not resolve the super class, we may still be able to resolve (some of) the\n            // implemented interfaces and so we continue gracefully with an (incomplete) list of ancestors\n\n            if (!acceptIncompleteList) {\n                // Only throw if an incomplete ancestor list is unacceptable.\n                throw e;\n            }\n        }\n\n        for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n            try {\n                // If an implemented interface is found, add it as an ancestor\n                ResolvedReferenceType rrt = toReferenceType(implemented);\n                Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = rrt.getTypeDeclaration();\n                if (resolvedReferenceTypeDeclaration.isPresent()) {\n\n                    ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n                    Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n                    if (qualifiedName.isPresent()) {\n\n                        // do not consider an inner or nested class as an ancestor\n                        if (!rtd.getQualifiedName().contains(qualifiedName.get())) {\n                            ancestors.add(rrt);\n                        }\n                    }\n                }\n            } catch (UnsolvedSymbolException e) {\n                // in case we could not resolve some implemented interface, we may still be able to resolve the\n                // extended class or (some of) the other implemented interfaces and so we continue gracefully\n                // with an (incomplete) list of ancestors\n\n                if (!acceptIncompleteList) {\n                    // Only throw if an incomplete ancestor list is unacceptable.\n                    throw e;\n                }\n            }\n        }\n\n        return ancestors;\n    }\n\n    @Override\n    public Set<ResolvedMethodDeclaration> getDeclaredMethods() {\n        Set<ResolvedMethodDeclaration> methods = new HashSet<>();\n        for (BodyDeclaration<?> member : wrappedNode.getMembers()) {\n            if (member instanceof MethodDeclaration) {\n                methods.add(new JavaParserMethodDeclaration((MethodDeclaration) member, typeSolver));\n            }\n        }\n        return methods;\n    }\n\n    @Override\n    public List<ResolvedTypeParameterDeclaration> getTypeParameters() {\n        return this.wrappedNode.getTypeParameters().stream().map(\n                (tp) -> new JavaParserTypeParameter(tp, typeSolver)\n        ).collect(Collectors.toList());\n    }\n\n    /**\n     * Returns the JavaParser node associated with this JavaParserClassDeclaration.\n     *\n     * @return A visitable JavaParser node wrapped by this object.\n     */\n    public ClassOrInterfaceDeclaration getWrappedNode() {\n        return wrappedNode;\n    }\n\n    @Override\n    public AccessSpecifier accessSpecifier() {\n        return wrappedNode.getAccessSpecifier();\n    }\n\n    @Override\n    public Optional<Node> toAst() {\n        return Optional.of(wrappedNode);\n    }\n\n    ///\n    /// Protected methods\n    ///\n\n    @Override\n    protected ResolvedReferenceType object() {\n        ResolvedReferenceTypeDeclaration solvedJavaLangObject = typeSolver.getSolvedJavaLangObject();\n        return new ReferenceTypeImpl(solvedJavaLangObject, typeSolver);\n    }\n\n    @Override\n    public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n        return javaParserTypeAdapter.internalTypes();\n    }\n\n    @Override\n    public Optional<ResolvedReferenceTypeDeclaration> containerType() {\n        return javaParserTypeAdapter.containerType();\n    }\n\n    ///\n    /// Private methods\n    ///\n\n    private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType) {\n        String className = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            // look for the qualified name (for example class of type Rectangle2D.Double)\n            className = classOrInterfaceType.getScope().get().toString() + \".\" + className;\n        }\n        SymbolReference<ResolvedTypeDeclaration> ref = solveType(className);\n\n        // If unable to solve by the class name alone, attempt to qualify it.\n        if (!ref.isSolved()) {\n            Optional<ClassOrInterfaceType> localScope = classOrInterfaceType.getScope();\n            if (localScope.isPresent()) {\n                String localName = localScope.get().getName().getId() + \".\" + classOrInterfaceType.getName().getId();\n                ref = solveType(localName);\n            }\n        }\n\n        // If still unable to resolve, throw an exception.\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());\n        }\n\n        if (!classOrInterfaceType.getTypeArguments().isPresent()) {\n            return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n\n        List<ResolvedType> superClassTypeParameters = classOrInterfaceType.getTypeArguments().get()\n                .stream()\n                .map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta, ta)))\n                .collect(Collectors.toList());\n\n        return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), superClassTypeParameters, typeSolver);\n    }\n}\n", "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.declarations;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.AccessSpecifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.core.resolution.MethodUsageResolutionCapability;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\nimport com.github.javaparser.symbolsolver.logic.AbstractClassDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.LazyType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\n\n/**\n * @author Federico Tomassetti\n */\npublic class JavaParserClassDeclaration extends AbstractClassDeclaration implements MethodUsageResolutionCapability {\n\n    ///\n    /// Fields\n    ///\n\n    private TypeSolver typeSolver;\n    private ClassOrInterfaceDeclaration wrappedNode;\n    private JavaParserTypeAdapter<ClassOrInterfaceDeclaration> javaParserTypeAdapter;\n\n    ///\n    /// Constructors\n    ///\n\n    public JavaParserClassDeclaration(ClassOrInterfaceDeclaration wrappedNode,\n                                      TypeSolver typeSolver) {\n        if (wrappedNode.isInterface()) {\n            throw new IllegalArgumentException(\"Interface given\");\n        }\n        this.wrappedNode = wrappedNode;\n        this.typeSolver = typeSolver;\n        this.javaParserTypeAdapter = new JavaParserTypeAdapter<>(wrappedNode, typeSolver);\n    }\n\n    ///\n    /// Public methods: from Object\n    ///\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        JavaParserClassDeclaration that = (JavaParserClassDeclaration) o;\n\n        return wrappedNode.equals(that.wrappedNode);\n    }\n\n    @Override\n    public int hashCode() {\n        return wrappedNode.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return \"JavaParserClassDeclaration{\" +\n                \"wrappedNode=\" + wrappedNode +\n                '}';\n    }\n\n    ///\n    /// Public methods: fields\n    ///\n    \n    @Override\n    public List<ResolvedFieldDeclaration> getAllFields() {\n        List<ResolvedFieldDeclaration> fields = javaParserTypeAdapter.getFieldsForDeclaredVariables();\n\n        getAncestors(true).stream().filter(ancestor -> ancestor.getTypeDeclaration().isPresent())\n                .forEach(ancestor -> ancestor.getTypeDeclaration().get().getAllFields()\n                        .forEach(f -> {\n                            fields.add(new ResolvedFieldDeclaration() {\n\n                                @Override\n                                public AccessSpecifier accessSpecifier() {\n                                    return f.accessSpecifier();\n                                }\n\n                                @Override\n                                public String getName() {\n                                    return f.getName();\n                                }\n\n                                @Override\n                                public ResolvedType getType() {\n                                    return ancestor.useThisTypeParametersOnTheGivenType(f.getType());\n                                }\n\n                                @Override\n                                public boolean isStatic() {\n                                    return f.isStatic();\n                                }\n                                \n                                @Override\n                                public boolean isVolatile() {\n                                    return f.isVolatile();\n                                }\n\n                                @Override\n                                public ResolvedTypeDeclaration declaringType() {\n                                    return f.declaringType();\n                                }\n                                \n                                @Override\n                                public Optional<FieldDeclaration> toAst() {\n                                    return f.toAst();\n                                }\n                            });\n                        }));\n\n        return fields;\n    }\n\n    ///\n    /// Public methods\n    ///\n\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> parameterTypes) {\n        Context ctx = getContext();\n        return ctx.solveMethod(name, parameterTypes, false);\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentTypes,\n                                                    Context invocationContext, List<ResolvedType> typeParameters) {\n        return getContext().solveMethodAsUsage(name, argumentTypes);\n    }\n\n    /**\n     * This method is deprecated because the context is an implementation detail that should not be exposed.\n     * Ideally this method should become private. For this reason all further usages of this method are discouraged.\n     */\n    @Deprecated\n    public Context getContext() {\n        return JavaParserFactory.getContext(wrappedNode, typeSolver);\n    }\n\n    public ResolvedType getUsage(Node node) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public String getName() {\n        return wrappedNode.getName().getId();\n    }\n\n    @Override\n    public Optional<ResolvedReferenceType> getSuperClass() {\n        if(isJavaLangObject()) {\n            // If this is java.lang.Object, it has no super class.\n            return Optional.empty();\n        } else if (wrappedNode.getExtendedTypes().isEmpty()) {\n            // All objects implicitly extend java.lang.Object -- inject it here (only when this isn't java.lang.Object)\n            return Optional.of(object());\n        } else {\n            // Otherwise, return the first ancestor (n.b.: we know it's not empty due to check above).\n            return Optional.of(toReferenceType(wrappedNode.getExtendedTypes().getFirst().get()));\n        }\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getInterfaces() {\n        List<ResolvedReferenceType> interfaces = new ArrayList<>();\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType t : wrappedNode.getImplementedTypes()) {\n                interfaces.add(toReferenceType(t));\n            }\n        }\n        return interfaces;\n    }\n\n    @Override\n    public List<ResolvedConstructorDeclaration> getConstructors() {\n        return AstResolutionUtils.getConstructors(this.wrappedNode, typeSolver, this);\n    }\n\n    @Override\n    public boolean hasDirectlyAnnotation(String canonicalName) {\n        return AstResolutionUtils.hasDirectlyAnnotation(wrappedNode, typeSolver, canonicalName);\n    }\n\n    @Override\n    public boolean isInterface() {\n        return wrappedNode.isInterface();\n    }\n\n    @Override\n    public String getPackageName() {\n        return javaParserTypeAdapter.getPackageName();\n    }\n\n    @Override\n    public String getClassName() {\n        return javaParserTypeAdapter.getClassName();\n    }\n\n    @Override\n    public String getQualifiedName() {\n        return javaParserTypeAdapter.getQualifiedName();\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedReferenceTypeDeclaration other) {\n        return javaParserTypeAdapter.isAssignableBy(other);\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedType type) {\n        return javaParserTypeAdapter.isAssignableBy(type);\n    }\n\n    @Override\n    public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other) {\n        // TODO consider generic types\n        if (this.getQualifiedName().equals(other.getQualifiedName())) {\n            return true;\n        }\n\n        Optional<ResolvedReferenceType> optionalSuperClass = getSuperClass();\n        if (optionalSuperClass.isPresent()) {\n            Optional<ResolvedReferenceTypeDeclaration> optionalSuperclassTypeDeclaration = optionalSuperClass.get().getTypeDeclaration();\n            if (optionalSuperclassTypeDeclaration.isPresent()) {\n                ResolvedReferenceTypeDeclaration superclassTypeDeclaration = optionalSuperclassTypeDeclaration.get();\n                if (superclassTypeDeclaration != this && superclassTypeDeclaration.isClass()) {\n                    if (superclassTypeDeclaration.asClass().canBeAssignedTo(other)) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (this.wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean isTypeParameter() {\n        return false;\n    }\n\n    /**\n     * Resolution should move out of declarations, so that they are pure declarations and the resolution should\n     * work for JavaParser, Reflection and Javassist classes in the same way and not be specific to the three\n     * implementations.\n     */\n    @Deprecated\n    public SymbolReference<ResolvedTypeDeclaration> solveType(String name) {\n        if (this.wrappedNode.getName().getId().equals(name)) {\n            return SymbolReference.solved(this);\n        }\n        SymbolReference<ResolvedTypeDeclaration> ref = javaParserTypeAdapter.solveType(name);\n        if (ref.isSolved()) {\n            return ref;\n        }\n\n        String prefix = wrappedNode.getName() + \".\";\n        if (name.startsWith(prefix) && name.length() > prefix.length()) {\n            return new JavaParserClassDeclaration(this.wrappedNode, typeSolver).solveType(name.substring(prefix.length()));\n        }\n\n        return getContext().getParent()\n                .orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\"))\n                .solveType(name);\n    }\n\n    @Override\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes,\n                                                                  boolean staticOnly) {\n        return getContext().solveMethod(name, argumentsTypes, staticOnly);\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n\n        // We want to avoid infinite recursion in case of Object having Object as ancestor\n        if (this.isJavaLangObject()) {\n            return ancestors;\n        }\n\n        Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n        if (!qualifiedName.isPresent()) {\n            return ancestors;\n        }\n\n        try {\n            // If a superclass is found, add it as an ancestor\n            Optional<ResolvedReferenceType> superClass = getSuperClass();\n            if (superClass.isPresent()) {\n                if (isAncestor(superClass.get(), qualifiedName.get())) {\n                    ancestors.add(superClass.get());\n                }\n            }\n        } catch (UnsolvedSymbolException e) {\n            // in case we could not resolve the super class, we may still be able to resolve (some of) the\n            // implemented interfaces and so we continue gracefully with an (incomplete) list of ancestors\n\n            if (!acceptIncompleteList) {\n                // Only throw if an incomplete ancestor list is unacceptable.\n                throw e;\n            }\n        }\n\n        for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n            try {\n                // If an implemented interface is found, add it as an ancestor\n                ResolvedReferenceType rrt = toReferenceType(implemented);\n                if (isAncestor(rrt, qualifiedName.get())) {\n                    ancestors.add(rrt);\n                }\n            } catch (UnsolvedSymbolException e) {\n                // in case we could not resolve some implemented interface, we may still be able to resolve the\n                // extended class or (some of) the other implemented interfaces and so we continue gracefully\n                // with an (incomplete) list of ancestors\n\n                if (!acceptIncompleteList) {\n                    // Only throw if an incomplete ancestor list is unacceptable.\n                    throw e;\n                }\n            }\n        }\n\n        return ancestors;\n    }\n\n    private boolean isAncestor(ResolvedReferenceType candidateAncestor, String ownQualifiedName) {\n        Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = candidateAncestor.getTypeDeclaration();\n        if (resolvedReferenceTypeDeclaration.isPresent()) {\n            ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n            // do not consider an inner or nested class as an ancestor\n            return !rtd.getQualifiedName().contains(ownQualifiedName);\n        }\n        return false;\n    }\n\n    @Override\n    public Set<ResolvedMethodDeclaration> getDeclaredMethods() {\n        Set<ResolvedMethodDeclaration> methods = new HashSet<>();\n        for (BodyDeclaration<?> member : wrappedNode.getMembers()) {\n            if (member instanceof MethodDeclaration) {\n                methods.add(new JavaParserMethodDeclaration((MethodDeclaration) member, typeSolver));\n            }\n        }\n        return methods;\n    }\n\n    @Override\n    public List<ResolvedTypeParameterDeclaration> getTypeParameters() {\n        return this.wrappedNode.getTypeParameters().stream().map(\n                (tp) -> new JavaParserTypeParameter(tp, typeSolver)\n        ).collect(Collectors.toList());\n    }\n\n    /**\n     * Returns the JavaParser node associated with this JavaParserClassDeclaration.\n     *\n     * @return A visitable JavaParser node wrapped by this object.\n     */\n    public ClassOrInterfaceDeclaration getWrappedNode() {\n        return wrappedNode;\n    }\n\n    @Override\n    public AccessSpecifier accessSpecifier() {\n        return wrappedNode.getAccessSpecifier();\n    }\n\n    @Override\n    public Optional<Node> toAst() {\n        return Optional.of(wrappedNode);\n    }\n\n    ///\n    /// Protected methods\n    ///\n\n    @Override\n    protected ResolvedReferenceType object() {\n        ResolvedReferenceTypeDeclaration solvedJavaLangObject = typeSolver.getSolvedJavaLangObject();\n        return new ReferenceTypeImpl(solvedJavaLangObject, typeSolver);\n    }\n\n    @Override\n    public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n        return javaParserTypeAdapter.internalTypes();\n    }\n\n    @Override\n    public Optional<ResolvedReferenceTypeDeclaration> containerType() {\n        return javaParserTypeAdapter.containerType();\n    }\n\n    ///\n    /// Private methods\n    ///\n\n    private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType) {\n        String className = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            // look for the qualified name (for example class of type Rectangle2D.Double)\n            className = classOrInterfaceType.getScope().get().toString() + \".\" + className;\n        }\n        SymbolReference<ResolvedTypeDeclaration> ref = solveType(className);\n\n        // If unable to solve by the class name alone, attempt to qualify it.\n        if (!ref.isSolved()) {\n            Optional<ClassOrInterfaceType> localScope = classOrInterfaceType.getScope();\n            if (localScope.isPresent()) {\n                String localName = localScope.get().getName().getId() + \".\" + classOrInterfaceType.getName().getId();\n                ref = solveType(localName);\n            }\n        }\n\n        // If still unable to resolve, throw an exception.\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());\n        }\n\n        if (!classOrInterfaceType.getTypeArguments().isPresent()) {\n            return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n\n        List<ResolvedType> superClassTypeParameters = classOrInterfaceType.getTypeArguments().get()\n                .stream()\n                .map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta, ta)))\n                .collect(Collectors.toList());\n\n        return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), superClassTypeParameters, typeSolver);\n    }\n}\n", "diffSourceCodeSet": ["private boolean isAncestor(ResolvedReferenceType candidateAncestor, String ownQualifiedName) {\n        Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = candidateAncestor.getTypeDeclaration();\n        if (resolvedReferenceTypeDeclaration.isPresent()) {\n            ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n            // do not consider an inner or nested class as an ancestor\n            return !rtd.getQualifiedName().contains(ownQualifiedName);\n        }\n        return false;\n    }"], "invokedMethodSet": ["methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#getQualifiedName\n methodBody: public String getQualifiedName() {\nreturn javaParserTypeAdapter.getQualifiedName();\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#toReferenceType\n methodBody: private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType) {\nString className=classOrInterfaceType.getName().getId();\nif(classOrInterfaceType.getScope().isPresent()){className=classOrInterfaceType.getScope().get().toString() + \".\" + className;\n}SymbolReference<ResolvedTypeDeclaration> ref=solveType(className);\nif(!ref.isSolved()){Optional<ClassOrInterfaceType> localScope=classOrInterfaceType.getScope();\nif(localScope.isPresent()){String localName=localScope.get().getName().getId() + \".\" + classOrInterfaceType.getName().getId();\nref=solveType(localName);\n}}if(!ref.isSolved()){throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());\n}if(!classOrInterfaceType.getTypeArguments().isPresent()){return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(),typeSolver);\n}List<ResolvedType> superClassTypeParameters=classOrInterfaceType.getTypeArguments().get().stream().map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta,ta))).collect(Collectors.toList());\nreturn new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(),superClassTypeParameters,typeSolver);\n}", "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#getSuperClass\n methodBody: public Optional<ResolvedReferenceType> getSuperClass() {\nif(isJavaLangObject()){return Optional.empty();\n}if(wrappedNode.getExtendedTypes().isEmpty()){return Optional.of(object());\n}{return Optional.of(toReferenceType(wrappedNode.getExtendedTypes().getFirst().get()));\n}}"], "sourceCodeAfterRefactoring": "@Override\n    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n\n        // We want to avoid infinite recursion in case of Object having Object as ancestor\n        if (this.isJavaLangObject()) {\n            return ancestors;\n        }\n\n        Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n        if (!qualifiedName.isPresent()) {\n            return ancestors;\n        }\n\n        try {\n            // If a superclass is found, add it as an ancestor\n            Optional<ResolvedReferenceType> superClass = getSuperClass();\n            if (superClass.isPresent()) {\n                if (isAncestor(superClass.get(), qualifiedName.get())) {\n                    ancestors.add(superClass.get());\n                }\n            }\n        } catch (UnsolvedSymbolException e) {\n            // in case we could not resolve the super class, we may still be able to resolve (some of) the\n            // implemented interfaces and so we continue gracefully with an (incomplete) list of ancestors\n\n            if (!acceptIncompleteList) {\n                // Only throw if an incomplete ancestor list is unacceptable.\n                throw e;\n            }\n        }\n\n        for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n            try {\n                // If an implemented interface is found, add it as an ancestor\n                ResolvedReferenceType rrt = toReferenceType(implemented);\n                if (isAncestor(rrt, qualifiedName.get())) {\n                    ancestors.add(rrt);\n                }\n            } catch (UnsolvedSymbolException e) {\n                // in case we could not resolve some implemented interface, we may still be able to resolve the\n                // extended class or (some of) the other implemented interfaces and so we continue gracefully\n                // with an (incomplete) list of ancestors\n\n                if (!acceptIncompleteList) {\n                    // Only throw if an incomplete ancestor list is unacceptable.\n                    throw e;\n                }\n            }\n        }\n\n        return ancestors;\n    }\nprivate boolean isAncestor(ResolvedReferenceType candidateAncestor, String ownQualifiedName) {\n        Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = candidateAncestor.getTypeDeclaration();\n        if (resolvedReferenceTypeDeclaration.isPresent()) {\n            ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n            // do not consider an inner or nested class as an ancestor\n            return !rtd.getQualifiedName().contains(ownQualifiedName);\n        }\n        return false;\n    }", "diffSourceCode": "   333:     @Override\n   334:     public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n   335:         List<ResolvedReferenceType> ancestors = new ArrayList<>();\n   336: \n   337:         // We want to avoid infinite recursion in case of Object having Object as ancestor\n   338:         if (this.isJavaLangObject()) {\n   339:             return ancestors;\n   340:         }\n   341: \n-  342:         try {\n-  343:             // If a superclass is found, add it as an ancestor\n-  344:             getSuperClass().ifPresent(ancestors::add);\n-  345:         } catch (UnsolvedSymbolException e) {\n-  346:             // in case we could not resolve the super class, we may still be able to resolve (some of) the\n-  347:             // implemented interfaces and so we continue gracefully with an (incomplete) list of ancestors\n-  348: \n-  349:             if (!acceptIncompleteList) {\n-  350:                 // Only throw if an incomplete ancestor list is unacceptable.\n-  351:                 throw e;\n-  352:             }\n-  353:         }\n-  354: \n-  355:         for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n-  356:             try {\n-  357:                 // If an implemented interface is found, add it as an ancestor\n-  358:                 ResolvedReferenceType rrt = toReferenceType(implemented);\n-  359:                 Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = rrt.getTypeDeclaration();\n-  360:                 if (resolvedReferenceTypeDeclaration.isPresent()) {\n-  361: \n-  362:                     ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n-  363:                     Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n-  364:                     if (qualifiedName.isPresent()) {\n-  365: \n-  366:                         // do not consider an inner or nested class as an ancestor\n-  367:                         if (!rtd.getQualifiedName().contains(qualifiedName.get())) {\n-  368:                             ancestors.add(rrt);\n-  369:                         }\n-  370:                     }\n+  342:         Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n+  343:         if (!qualifiedName.isPresent()) {\n+  344:             return ancestors;\n+  345:         }\n+  346: \n+  347:         try {\n+  348:             // If a superclass is found, add it as an ancestor\n+  349:             Optional<ResolvedReferenceType> superClass = getSuperClass();\n+  350:             if (superClass.isPresent()) {\n+  351:                 if (isAncestor(superClass.get(), qualifiedName.get())) {\n+  352:                     ancestors.add(superClass.get());\n+  353:                 }\n+  354:             }\n+  355:         } catch (UnsolvedSymbolException e) {\n+  356:             // in case we could not resolve the super class, we may still be able to resolve (some of) the\n+  357:             // implemented interfaces and so we continue gracefully with an (incomplete) list of ancestors\n+  358: \n+  359:             if (!acceptIncompleteList) {\n+  360:                 // Only throw if an incomplete ancestor list is unacceptable.\n+  361:                 throw e;\n+  362:             }\n+  363:         }\n+  364: \n+  365:         for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n+  366:             try {\n+  367:                 // If an implemented interface is found, add it as an ancestor\n+  368:                 ResolvedReferenceType rrt = toReferenceType(implemented);\n+  369:                 if (isAncestor(rrt, qualifiedName.get())) {\n+  370:                     ancestors.add(rrt);\n   371:                 }\n   372:             } catch (UnsolvedSymbolException e) {\n   373:                 // in case we could not resolve some implemented interface, we may still be able to resolve the\n   374:                 // extended class or (some of) the other implemented interfaces and so we continue gracefully\n   375:                 // with an (incomplete) list of ancestors\n   376: \n   377:                 if (!acceptIncompleteList) {\n   378:                     // Only throw if an incomplete ancestor list is unacceptable.\n   379:                     throw e;\n   380:                 }\n   381:             }\n   382:         }\n   383: \n   384:         return ancestors;\n   385:     }\n-  387:     @Override\n-  388:     public Set<ResolvedMethodDeclaration> getDeclaredMethods() {\n-  389:         Set<ResolvedMethodDeclaration> methods = new HashSet<>();\n-  390:         for (BodyDeclaration<?> member : wrappedNode.getMembers()) {\n-  391:             if (member instanceof MethodDeclaration) {\n-  392:                 methods.add(new JavaParserMethodDeclaration((MethodDeclaration) member, typeSolver));\n-  393:             }\n-  394:         }\n-  395:         return methods;\n+  387:     private boolean isAncestor(ResolvedReferenceType candidateAncestor, String ownQualifiedName) {\n+  388:         Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = candidateAncestor.getTypeDeclaration();\n+  389:         if (resolvedReferenceTypeDeclaration.isPresent()) {\n+  390:             ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n+  391:             // do not consider an inner or nested class as an ancestor\n+  392:             return !rtd.getQualifiedName().contains(ownQualifiedName);\n+  393:         }\n+  394:         return false;\n+  395:     }\n", "uniqueId": "df18fcb41f73c5223b9952a0ede13e410b0e16b9_333_385_387_395_333_385", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 5, "covered": 72}, "BRANCH": {"missed": 3, "covered": 11}, "LINE": {"missed": 3, "covered": 20}, "COMPLEXITY": {"missed": 2, "covered": 6}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `getAncestors` method, we can extract parts of the code into separate methods. This will help to clarify the purpose of each section and reduce the complexity of the main method.\n\nHere\u2019s the refactored code with the extracted methods:\n\n```java\n@Override\npublic List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n    List<ResolvedReferenceType> ancestors = new ArrayList<>();\n\n    // We want to avoid infinite recursion in case of Object having Object as ancestor\n    if (this.isJavaLangObject()) {\n        return ancestors;\n    }\n\n    addSuperClass(ancestors, acceptIncompleteList);\n    addImplementedInterfaces(ancestors, acceptIncompleteList);\n\n    return ancestors;\n}\n\nprivate void addSuperClass(List<ResolvedReferenceType> ancestors, boolean acceptIncompleteList) {\n    try {\n        // If a superclass is found, add it as an ancestor\n        getSuperClass().ifPresent(ancestors::add);\n    } catch (UnsolvedSymbolException e) {\n        handleUnsolvedSymbolException(e, acceptIncompleteList);\n    }\n}\n\nprivate void addImplementedInterfaces(List<ResolvedReferenceType> ancestors, boolean acceptIncompleteList) {\n    for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n        try {\n            // If an implemented interface is found, add it as an ancestor\n            ResolvedReferenceType rrt = toReferenceType(implemented);\n            Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = rrt.getTypeDeclaration();\n            if (resolvedReferenceTypeDeclaration.isPresent()) {\n                ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n                Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n                if (qualifiedName.isPresent()) {\n                    // do not consider an inner or nested class as an ancestor\n                    if (!rtd.getQualifiedName().contains(qualifiedName.get())) {\n                        ancestors.add(rrt);\n                    }\n                }\n            }\n        } catch (UnsolvedSymbolException e) {\n            handleUnsolvedSymbolException(e, acceptIncompleteList);\n        }\n    }\n}\n\nprivate void handleUnsolvedSymbolException(UnsolvedSymbolException e, boolean acceptIncompleteList) {\n    // in case we could not resolve the super class or some implemented interface,\n    // we may still be able to resolve (some of) the other implemented interfaces\n    if (!acceptIncompleteList) {\n        // Only throw if an incomplete ancestor list is unacceptable.\n        throw e;\n    }\n}\n```\n\nThis refactoring extracts the logic for adding the superclass and implemented interfaces into their own methods (`addSuperClass` and `addImplementedInterfaces`). Additionally, the handling of the `UnsolvedSymbolException` is extracted into a separate method (`handleUnsolvedSymbolException`). This makes the `getAncestors` method cleaner and easier to understand.\n\nHere is the output in the requested format:\n\n##########################\n```java\n@Override\npublic List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n    List<ResolvedReferenceType> ancestors = new ArrayList<>();\n\n    // We want to avoid infinite recursion in case of Object having Object as ancestor\n    if (this.isJavaLangObject()) {\n        return ancestors;\n    }\n\n    addSuperClass(ancestors, acceptIncompleteList);\n    addImplementedInterfaces(ancestors, acceptIncompleteList);\n\n    return ancestors;\n}\n\nprivate void addSuperClass(List<ResolvedReferenceType> ancestors, boolean acceptIncompleteList) {\n    try {\n        // If a superclass is found, add it as an ancestor\n        getSuperClass().ifPresent(ancestors::add);\n    } catch (UnsolvedSymbolException e) {\n        handleUnsolvedSymbolException(e, acceptIncompleteList);\n    }\n}\n\nprivate void addImplementedInterfaces(List<ResolvedReferenceType> ancestors, boolean acceptIncompleteList) {\n    for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n        try {\n            // If an implemented interface is found, add it as an ancestor\n            ResolvedReferenceType rrt = toReferenceType(implemented);\n            Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = rrt.getTypeDeclaration();\n            if (resolvedReferenceTypeDeclaration.isPresent()) {\n                ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n                Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n                if (qualifiedName.isPresent()) {\n                    // do not consider an inner or nested class as an ancestor\n                    if (!rtd.getQualifiedName().contains(qualifiedName.get())) {\n                        ancestors.add(rrt);\n                    }\n                }\n            }\n        } catch (UnsolvedSymbolException e) {\n            handleUnsolvedSymbolException(e, acceptIncompleteList);\n        }\n    }\n}\n\nprivate void handleUnsolvedSymbolException(UnsolvedSymbolException e, boolean acceptIncompleteList) {\n    // in case we could not resolve the super class or some implemented interface,\n    // we may still be able to resolve (some of) the other implemented interfaces\n    if (!acceptIncompleteList) {\n        // Only throw if an incomplete ancestor list is unacceptable.\n        throw e;\n    }\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n\n        // We want to avoid infinite recursion in case of Object having Object as ancestor\n        if (this.isJavaLangObject()) {\n            return ancestors;\n        }\n\n        try {\n            // If a superclass is found, add it as an ancestor\n            getSuperClass().ifPresent(ancestors::add);\n        } catch (UnsolvedSymbolException e) {\n            // in case we could not resolve the super class, we may still be able to resolve (some of) the\n            // implemented interfaces and so we continue gracefully with an (incomplete) list of ancestors\n\n            if (!acceptIncompleteList) {\n                // Only throw if an incomplete ancestor list is unacceptable.\n                throw e;\n            }\n        }\n\n        for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n            try {\n                // If an implemented interface is found, add it as an ancestor\n                ResolvedReferenceType rrt = toReferenceType(implemented);\n                Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = rrt.getTypeDeclaration();\n                if (resolvedReferenceTypeDeclaration.isPresent()) {\n\n                    ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n                    Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n                    if (qualifiedName.isPresent()) {\n\n                        // do not consider an inner or nested class as an ancestor\n                        if (!rtd.getQualifiedName().contains(qualifiedName.get())) {\n                            ancestors.add(rrt);\n                        }\n                    }\n                }\n            } catch (UnsolvedSymbolException e) {\n                // in case we could not resolve some implemented interface, we may still be able to resolve the\n                // extended class or (some of) the other implemented interfaces and so we continue gracefully\n                // with an (incomplete) list of ancestors\n\n                if (!acceptIncompleteList) {\n                    // Only throw if an incomplete ancestor list is unacceptable.\n                    throw e;\n                }\n            }\n        }\n\n        return ancestors;\n    }\n\nClass content:\n/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.declarations;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.AccessSpecifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.core.resolution.MethodUsageResolutionCapability;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\nimport com.github.javaparser.symbolsolver.logic.AbstractClassDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.LazyType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\n\n/**\n * @author Federico Tomassetti\n */\npublic class JavaParserClassDeclaration extends AbstractClassDeclaration implements MethodUsageResolutionCapability {\n\n    ///\n    /// Fields\n    ///\n\n    private TypeSolver typeSolver;\n    private ClassOrInterfaceDeclaration wrappedNode;\n    private JavaParserTypeAdapter<ClassOrInterfaceDeclaration> javaParserTypeAdapter;\n\n    ///\n    /// Constructors\n    ///\n\n    public JavaParserClassDeclaration(ClassOrInterfaceDeclaration wrappedNode,\n                                      TypeSolver typeSolver) {\n        if (wrappedNode.isInterface()) {\n            throw new IllegalArgumentException(\"Interface given\");\n        }\n        this.wrappedNode = wrappedNode;\n        this.typeSolver = typeSolver;\n        this.javaParserTypeAdapter = new JavaParserTypeAdapter<>(wrappedNode, typeSolver);\n    }\n\n    ///\n    /// Public methods: from Object\n    ///\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        JavaParserClassDeclaration that = (JavaParserClassDeclaration) o;\n\n        return wrappedNode.equals(that.wrappedNode);\n    }\n\n    @Override\n    public int hashCode() {\n        return wrappedNode.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return \"JavaParserClassDeclaration{\" +\n                \"wrappedNode=\" + wrappedNode +\n                '}';\n    }\n\n    ///\n    /// Public methods: fields\n    ///\n    \n    @Override\n    public List<ResolvedFieldDeclaration> getAllFields() {\n        List<ResolvedFieldDeclaration> fields = javaParserTypeAdapter.getFieldsForDeclaredVariables();\n\n        getAncestors(true).stream().filter(ancestor -> ancestor.getTypeDeclaration().isPresent())\n                .forEach(ancestor -> ancestor.getTypeDeclaration().get().getAllFields()\n                        .forEach(f -> {\n                            fields.add(new ResolvedFieldDeclaration() {\n\n                                @Override\n                                public AccessSpecifier accessSpecifier() {\n                                    return f.accessSpecifier();\n                                }\n\n                                @Override\n                                public String getName() {\n                                    return f.getName();\n                                }\n\n                                @Override\n                                public ResolvedType getType() {\n                                    return ancestor.useThisTypeParametersOnTheGivenType(f.getType());\n                                }\n\n                                @Override\n                                public boolean isStatic() {\n                                    return f.isStatic();\n                                }\n                                \n                                @Override\n                                public boolean isVolatile() {\n                                    return f.isVolatile();\n                                }\n\n                                @Override\n                                public ResolvedTypeDeclaration declaringType() {\n                                    return f.declaringType();\n                                }\n                                \n                                @Override\n                                public Optional<FieldDeclaration> toAst() {\n                                    return f.toAst();\n                                }\n                            });\n                        }));\n\n        return fields;\n    }\n\n    ///\n    /// Public methods\n    ///\n\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> parameterTypes) {\n        Context ctx = getContext();\n        return ctx.solveMethod(name, parameterTypes, false);\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentTypes,\n                                                    Context invocationContext, List<ResolvedType> typeParameters) {\n        return getContext().solveMethodAsUsage(name, argumentTypes);\n    }\n\n    /**\n     * This method is deprecated because the context is an implementation detail that should not be exposed.\n     * Ideally this method should become private. For this reason all further usages of this method are discouraged.\n     */\n    @Deprecated\n    public Context getContext() {\n        return JavaParserFactory.getContext(wrappedNode, typeSolver);\n    }\n\n    public ResolvedType getUsage(Node node) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public String getName() {\n        return wrappedNode.getName().getId();\n    }\n\n    @Override\n    public Optional<ResolvedReferenceType> getSuperClass() {\n        if(isJavaLangObject()) {\n            // If this is java.lang.Object, it has no super class.\n            return Optional.empty();\n        } else if (wrappedNode.getExtendedTypes().isEmpty()) {\n            // All objects implicitly extend java.lang.Object -- inject it here (only when this isn't java.lang.Object)\n            return Optional.of(object());\n        } else {\n            // Otherwise, return the first ancestor (n.b.: we know it's not empty due to check above).\n            return Optional.of(toReferenceType(wrappedNode.getExtendedTypes().getFirst().get()));\n        }\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getInterfaces() {\n        List<ResolvedReferenceType> interfaces = new ArrayList<>();\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType t : wrappedNode.getImplementedTypes()) {\n                interfaces.add(toReferenceType(t));\n            }\n        }\n        return interfaces;\n    }\n\n    @Override\n    public List<ResolvedConstructorDeclaration> getConstructors() {\n        return AstResolutionUtils.getConstructors(this.wrappedNode, typeSolver, this);\n    }\n\n    @Override\n    public boolean hasDirectlyAnnotation(String canonicalName) {\n        return AstResolutionUtils.hasDirectlyAnnotation(wrappedNode, typeSolver, canonicalName);\n    }\n\n    @Override\n    public boolean isInterface() {\n        return wrappedNode.isInterface();\n    }\n\n    @Override\n    public String getPackageName() {\n        return javaParserTypeAdapter.getPackageName();\n    }\n\n    @Override\n    public String getClassName() {\n        return javaParserTypeAdapter.getClassName();\n    }\n\n    @Override\n    public String getQualifiedName() {\n        return javaParserTypeAdapter.getQualifiedName();\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedReferenceTypeDeclaration other) {\n        return javaParserTypeAdapter.isAssignableBy(other);\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedType type) {\n        return javaParserTypeAdapter.isAssignableBy(type);\n    }\n\n    @Override\n    public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other) {\n        // TODO consider generic types\n        if (this.getQualifiedName().equals(other.getQualifiedName())) {\n            return true;\n        }\n\n        Optional<ResolvedReferenceType> optionalSuperClass = getSuperClass();\n        if (optionalSuperClass.isPresent()) {\n            Optional<ResolvedReferenceTypeDeclaration> optionalSuperclassTypeDeclaration = optionalSuperClass.get().getTypeDeclaration();\n            if (optionalSuperclassTypeDeclaration.isPresent()) {\n                ResolvedReferenceTypeDeclaration superclassTypeDeclaration = optionalSuperclassTypeDeclaration.get();\n                if (superclassTypeDeclaration != this && superclassTypeDeclaration.isClass()) {\n                    if (superclassTypeDeclaration.asClass().canBeAssignedTo(other)) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (this.wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean isTypeParameter() {\n        return false;\n    }\n\n    /**\n     * Resolution should move out of declarations, so that they are pure declarations and the resolution should\n     * work for JavaParser, Reflection and Javassist classes in the same way and not be specific to the three\n     * implementations.\n     */\n    @Deprecated\n    public SymbolReference<ResolvedTypeDeclaration> solveType(String name) {\n        if (this.wrappedNode.getName().getId().equals(name)) {\n            return SymbolReference.solved(this);\n        }\n        SymbolReference<ResolvedTypeDeclaration> ref = javaParserTypeAdapter.solveType(name);\n        if (ref.isSolved()) {\n            return ref;\n        }\n\n        String prefix = wrappedNode.getName() + \".\";\n        if (name.startsWith(prefix) && name.length() > prefix.length()) {\n            return new JavaParserClassDeclaration(this.wrappedNode, typeSolver).solveType(name.substring(prefix.length()));\n        }\n\n        return getContext().getParent()\n                .orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\"))\n                .solveType(name);\n    }\n\n    @Override\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes,\n                                                                  boolean staticOnly) {\n        return getContext().solveMethod(name, argumentsTypes, staticOnly);\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n\n        // We want to avoid infinite recursion in case of Object having Object as ancestor\n        if (this.isJavaLangObject()) {\n            return ancestors;\n        }\n\n        try {\n            // If a superclass is found, add it as an ancestor\n            getSuperClass().ifPresent(ancestors::add);\n        } catch (UnsolvedSymbolException e) {\n            // in case we could not resolve the super class, we may still be able to resolve (some of) the\n            // implemented interfaces and so we continue gracefully with an (incomplete) list of ancestors\n\n            if (!acceptIncompleteList) {\n                // Only throw if an incomplete ancestor list is unacceptable.\n                throw e;\n            }\n        }\n\n        for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n            try {\n                // If an implemented interface is found, add it as an ancestor\n                ResolvedReferenceType rrt = toReferenceType(implemented);\n                Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = rrt.getTypeDeclaration();\n                if (resolvedReferenceTypeDeclaration.isPresent()) {\n\n                    ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n                    Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n                    if (qualifiedName.isPresent()) {\n\n                        // do not consider an inner or nested class as an ancestor\n                        if (!rtd.getQualifiedName().contains(qualifiedName.get())) {\n                            ancestors.add(rrt);\n                        }\n                    }\n                }\n            } catch (UnsolvedSymbolException e) {\n                // in case we could not resolve some implemented interface, we may still be able to resolve the\n                // extended class or (some of) the other implemented interfaces and so we continue gracefully\n                // with an (incomplete) list of ancestors\n\n                if (!acceptIncompleteList) {\n                    // Only throw if an incomplete ancestor list is unacceptable.\n                    throw e;\n                }\n            }\n        }\n\n        return ancestors;\n    }\n\n    @Override\n    public Set<ResolvedMethodDeclaration> getDeclaredMethods() {\n        Set<ResolvedMethodDeclaration> methods = new HashSet<>();\n        for (BodyDeclaration<?> member : wrappedNode.getMembers()) {\n            if (member instanceof MethodDeclaration) {\n                methods.add(new JavaParserMethodDeclaration((MethodDeclaration) member, typeSolver));\n            }\n        }\n        return methods;\n    }\n\n    @Override\n    public List<ResolvedTypeParameterDeclaration> getTypeParameters() {\n        return this.wrappedNode.getTypeParameters().stream().map(\n                (tp) -> new JavaParserTypeParameter(tp, typeSolver)\n        ).collect(Collectors.toList());\n    }\n\n    /**\n     * Returns the JavaParser node associated with this JavaParserClassDeclaration.\n     *\n     * @return A visitable JavaParser node wrapped by this object.\n     */\n    public ClassOrInterfaceDeclaration getWrappedNode() {\n        return wrappedNode;\n    }\n\n    @Override\n    public AccessSpecifier accessSpecifier() {\n        return wrappedNode.getAccessSpecifier();\n    }\n\n    @Override\n    public Optional<Node> toAst() {\n        return Optional.of(wrappedNode);\n    }\n\n    ///\n    /// Protected methods\n    ///\n\n    @Override\n    protected ResolvedReferenceType object() {\n        ResolvedReferenceTypeDeclaration solvedJavaLangObject = typeSolver.getSolvedJavaLangObject();\n        return new ReferenceTypeImpl(solvedJavaLangObject, typeSolver);\n    }\n\n    @Override\n    public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n        return javaParserTypeAdapter.internalTypes();\n    }\n\n    @Override\n    public Optional<ResolvedReferenceTypeDeclaration> containerType() {\n        return javaParserTypeAdapter.containerType();\n    }\n\n    ///\n    /// Private methods\n    ///\n\n    private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType) {\n        String className = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            // look for the qualified name (for example class of type Rectangle2D.Double)\n            className = classOrInterfaceType.getScope().get().toString() + \".\" + className;\n        }\n        SymbolReference<ResolvedTypeDeclaration> ref = solveType(className);\n\n        // If unable to solve by the class name alone, attempt to qualify it.\n        if (!ref.isSolved()) {\n            Optional<ClassOrInterfaceType> localScope = classOrInterfaceType.getScope();\n            if (localScope.isPresent()) {\n                String localName = localScope.get().getName().getId() + \".\" + classOrInterfaceType.getName().getId();\n                ref = solveType(localName);\n            }\n        }\n\n        // If still unable to resolve, throw an exception.\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());\n        }\n\n        if (!classOrInterfaceType.getTypeArguments().isPresent()) {\n            return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n\n        List<ResolvedType> superClassTypeParameters = classOrInterfaceType.getTypeArguments().get()\n                .stream()\n                .map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta, ta)))\n                .collect(Collectors.toList());\n\n        return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), superClassTypeParameters, typeSolver);\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate resolveLambda(node LambdaExpr, result ResolvedType) : ResolvedType extracted from public visit(node LambdaExpr, solveLambdas Boolean) : ResolvedType in class com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor", "diffLocations": [{"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java", "startLine": 647, "endLine": 756, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java", "startLine": 647, "endLine": 710, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java", "startLine": 712, "endLine": 775, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n\n                // The type parameter referred here should be the java.util.stream.Stream.T\n                ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr = node;\n\n                    InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n                    InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n                    // At this point parameterType\n                    // if Function<T=? super Stream.T, ? extends map.R>\n                    // we should replace Stream.T\n                    ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n                    lambdaCtx.addPair(result, functionalInterfaceType);\n\n                    ResolvedType actualType;\n\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n                    } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                        BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                        // Get all the return statements in the lambda block\n                        List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                        if (returnStmts.size() > 0) {\n                            actualType = returnStmts.stream()\n                                    .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                                    .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                                    .findFirst()\n                                    .orElse(ResolvedVoidType.INSTANCE);\n\n                        } else {\n                            actualType = ResolvedVoidType.INSTANCE;\n                        }\n\n\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    ResolvedType formalType = functionalMethod.get().returnType();\n\n                    // Infer the functional interfaces' return vs actual type\n                    funcInterfaceCtx.addPair(formalType, actualType);\n                    // Substitute to obtain a new type\n                    ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n                    // if the functional method returns void anyway\n                    // we don't need to bother inferring types\n                    if (!(formalType instanceof ResolvedVoidType)) {\n                        lambdaCtx.addPair(result, functionalTypeWithReturn);\n                        result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n                    }\n                }\n\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }", "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java", "isPureRefactoring": true, "commitId": "a9adfa6c86ba236edeaa2be318c337f98e5c6720", "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel", "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor", "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor#visit", "classSignatureBefore": "public class TypeExtractor extends DefaultVisitorAdapter ", "methodNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor#visit"], "classNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor"], "classSignatureBeforeSet": ["public class TypeExtractor extends DefaultVisitorAdapter "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solveGenericTypes;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.ArrayAccessExpr;\nimport com.github.javaparser.ast.expr.ArrayCreationExpr;\nimport com.github.javaparser.ast.expr.ArrayInitializerExpr;\nimport com.github.javaparser.ast.expr.AssignExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.BooleanLiteralExpr;\nimport com.github.javaparser.ast.expr.CastExpr;\nimport com.github.javaparser.ast.expr.CharLiteralExpr;\nimport com.github.javaparser.ast.expr.ClassExpr;\nimport com.github.javaparser.ast.expr.ConditionalExpr;\nimport com.github.javaparser.ast.expr.DoubleLiteralExpr;\nimport com.github.javaparser.ast.expr.EnclosedExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.InstanceOfExpr;\nimport com.github.javaparser.ast.expr.IntegerLiteralExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.LongLiteralExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.NullLiteralExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.StringLiteralExpr;\nimport com.github.javaparser.ast.expr.SuperExpr;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.expr.UnaryExpr;\nimport com.github.javaparser.ast.expr.VariableDeclarationExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.ReturnStmt;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnknownType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.symbolsolver.logic.InferenceContext;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.Value;\nimport com.github.javaparser.symbolsolver.model.typesystem.NullType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.MyObjectProvider;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.github.javaparser.utils.Log;\nimport com.github.javaparser.utils.Pair;\nimport com.google.common.collect.ImmutableList;\n\npublic class TypeExtractor extends DefaultVisitorAdapter {\n\n    private static final String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private TypeSolver typeSolver;\n    private JavaParserFacade facade;\n    \n    private ReferenceTypeImpl StringReferenceType;\n\n    public TypeExtractor(TypeSolver typeSolver, JavaParserFacade facade) {\n        this.typeSolver = typeSolver;\n        this.facade = facade;\n        //pre-calculate the String reference (optimization)\n        StringReferenceType = new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(JAVA_LANG_STRING), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarator node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof FieldDeclaration) {\n            return facade.convertToUsageVariableType(node);\n        } else if (demandParentNode(node) instanceof VariableDeclarationExpr) {\n            return facade.convertToUsageVariableType(node);\n        }\n        throw new UnsupportedOperationException(demandParentNode(node).getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(Parameter node, Boolean solveLambdas) {\n        if (node.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + node);\n        }\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n\n    @Override\n    public ResolvedType visit(ArrayAccessExpr node, Boolean solveLambdas) {\n        ResolvedType arrayUsageType = node.getName().accept(this, solveLambdas);\n        if (arrayUsageType.isArray()) {\n            return ((ResolvedArrayType) arrayUsageType).getComponentType();\n        }\n        return arrayUsageType;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayCreationExpr node, Boolean solveLambdas) {\n        ResolvedType res = facade.convertToUsage(node.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i = 0; i < node.getLevels().size(); i++) {\n            res = new ResolvedArrayType(res);\n        }\n        return res;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayInitializerExpr node, Boolean solveLambdas) {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(AssignExpr node, Boolean solveLambdas) {\n        return node.getTarget().accept(this, solveLambdas);\n    }\n\n    @Override\n    public ResolvedType visit(BinaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case PLUS:\n            case MINUS:\n            case DIVIDE:\n            case MULTIPLY:\n            case REMAINDER:\n            case BINARY_AND:\n            case BINARY_OR:\n            case XOR:\n                return facade.getBinaryTypeConcrete(node.getLeft(), node.getRight(), solveLambdas, node.getOperator());\n            case LESS_EQUALS:\n            case LESS:\n            case GREATER:\n            case GREATER_EQUALS:\n            case EQUALS:\n            case NOT_EQUALS:\n            case OR:\n            case AND:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case SIGNED_RIGHT_SHIFT:\n            case UNSIGNED_RIGHT_SHIFT:\n            case LEFT_SHIFT:\n                ResolvedType rt = node.getLeft().accept(this, solveLambdas);\n                // apply unary primitive promotion\n                return ResolvedPrimitiveType.unp(rt);\n            default:\n                throw new UnsupportedOperationException(\"Operator \" + node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(CastExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    @Override\n    public ResolvedType visit(ClassExpr node, Boolean solveLambdas) {\n        // This implementation does not regard the actual type argument of the ClassExpr.\n        Type astType = node.getType();\n        ResolvedType jssType = facade.convertToUsage(astType, node.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    }\n\n    /*\n     * The conditional operator has three operand expressions. ? appears between the first and second expressions, and\n     * : appears between the second and third expressions.\n     * There are three kinds of conditional expressions, classified according to the second and third operand\n     * expressions: boolean conditional expressions, numeric conditional expressions, and reference conditional\n     * expressions.\n     * The classification rules are as follows:\n     * 1/ If both the second and the third operand expressions are boolean expressions, the conditional expression is a\n     * boolean conditional expression.\n     * 2/ If both the second and the third operand expressions are numeric expressions, the conditional expression is a\n     * numeric conditional expression.\n     * 3/ Otherwise, the conditional expression is a reference conditional expression\n     */\n    @Override\n    public ResolvedType visit(ConditionalExpr node, Boolean solveLambdas) {\n        ResolvedType thenExpr = node.getThenExpr().accept(this, solveLambdas);\n        ResolvedType elseExpr = node.getElseExpr().accept(this, solveLambdas);\n        \n        // manage null expression\n        if ( thenExpr.isNull()) {\n            return  elseExpr;\n        }\n        if ( elseExpr.isNull()) {\n            return  thenExpr;\n        }\n        /*\n         * Boolean conditional expressions are standalone expressions\n         * The type of a boolean conditional expression is determined as follows:\n         * If the second and third operands are both of type Boolean, the conditional expression has type Boolean.\n         * Otherwise, the conditional expression has type boolean.\n         */\n        if ( thenExpr.isAssignableBy(ResolvedPrimitiveType.BOOLEAN) \n                && elseExpr.isAssignableBy(ResolvedPrimitiveType.BOOLEAN)) {\n            if (thenExpr.isReferenceType() && elseExpr.isReferenceType()) {\n                return thenExpr.asReferenceType();\n            }\n            return thenExpr.isPrimitive() ? thenExpr : elseExpr;\n        }\n        \n        /*\n         * Numeric conditional expressions are standalone expressions (\u00a715.2).\n         * The type of a numeric conditional expression is determined as follows:\n         * If the second and third operands have the same type, then that is the type of the conditional expression.\n         * If one of the second and third operands is of primitive type T, and the type of the other is the result of\n         * applying boxing conversion (\u00a75.1.7) to T, then the type of the conditional expression is T.\n         * If one of the operands is of type byte or Byte and the other is of type short or Short, then the type of the\n         * conditional expression is short.\n         * If one of the operands is of type T where T is byte, short, or char, and the other operand is a constant\n         * expression (\u00a715.28) of type int whose value is representable in type T, then the type of the conditional\n         * expression is T.\n         * If one of the operands is of type T, where T is Byte, Short, or Character, and the other operand is a\n         * constant expression of type int whose value is representable in the type U which is the result of applying\n         * unboxing conversion to T, then the type of the conditional expression is U.\n         * Otherwise, binary numeric promotion (\u00a75.6.2) is applied to the operand types, and the type of the\n         * conditional expression is the promoted type of the second and third operands.\n         */\n        if (thenExpr.isNumericType() && elseExpr.isNumericType()) {\n            ResolvedPrimitiveType[] resolvedPrimitiveTypeSubList = new ResolvedPrimitiveType[] {ResolvedPrimitiveType.BYTE, ResolvedPrimitiveType.SHORT, ResolvedPrimitiveType.CHAR};\n            /*\n             *  If the second and third operands have the same type, then that is the type of the conditional expression.\n             */\n            String qnameTypeThenExpr = thenExpr.isPrimitive() ? thenExpr.asPrimitive().describe()\n                    : thenExpr.asReferenceType().describe();\n            String qnameTypeElseExpr = elseExpr.isPrimitive() ? elseExpr.asPrimitive().describe()\n                    : elseExpr.asReferenceType().describe();\n            if (qnameTypeThenExpr.equals(qnameTypeElseExpr)) {\n                return thenExpr;\n            }\n            /*\n             * If one of the second and third operands is of primitive type T, and the type of the other is the result of\n             * applying boxing conversion (\u00a75.1.7) to T, then the type of the conditional expression is T.\n             */\n            else if ((thenExpr.isPrimitive() && elseExpr.isReferenceType()\n                    && isCompatible(elseExpr.asReferenceType(), thenExpr.asPrimitive()))) {\n                return thenExpr;\n            } else if ((elseExpr.isPrimitive() && thenExpr.isReferenceType()\n                    && isCompatible(thenExpr.asReferenceType(), elseExpr.asPrimitive()))) {\n                return elseExpr;\n            }\n            /*\n             * If one of the operands is of type byte or Byte and the other is of type short or Short, then the type of the\n             * conditional expression is short.\n             */\n            else if ((isCompatible(thenExpr, ResolvedPrimitiveType.BYTE) && isCompatible(elseExpr, ResolvedPrimitiveType.SHORT))\n                    || (isCompatible(elseExpr, ResolvedPrimitiveType.BYTE) && isCompatible(thenExpr, ResolvedPrimitiveType.SHORT))) {\n                return ResolvedPrimitiveType.SHORT;\n            }\n            /*\n             *  If one of the operands is of type T where T is byte, short, or char, and the\n             *  other operand is a constant expression (\u00a715.28) of type int whose value is\n             *  representable in type T, then the type of the conditional expression is T\n             *  How can we know if the constant expression of type int is representable in type T ?\n             *  \"The constant expression of type int is representable in type T\" is a runtime decision!\n             */\n            else if (thenExpr.isPrimitive() && elseExpr.isPrimitive()) {\n                if (((ResolvedPrimitiveType)thenExpr).in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)elseExpr).equals(ResolvedPrimitiveType.INT)) {\n                    return thenExpr;\n                } else if (((ResolvedPrimitiveType)elseExpr).in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)thenExpr).equals(ResolvedPrimitiveType.INT)) {\n                    return elseExpr;\n                }\n            }\n             /*  If one of the operands is of type T, where T is Byte, Short, or Character,\n             * and the other operand is a constant expression of type int whose value is\n             * representable in the type U which is the result of applying unboxing\n             * conversion to T, then the type of the conditional expression is U.\n             * A priori this is a runtime decision!\n             */\n            else if (thenExpr.isReference() && elseExpr.isPrimitive()\n                    && thenExpr.asReferenceType().isUnboxable()\n                    && thenExpr.asReferenceType().toUnboxedType().get().in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)elseExpr).equals(ResolvedPrimitiveType.INT)) {\n                return thenExpr.asReferenceType().toUnboxedType().get();\n            } else if (elseExpr.isReference() && thenExpr.isPrimitive()\n                    && elseExpr.asReferenceType().isUnboxable()\n                    && elseExpr.asReferenceType().toUnboxedType().get().in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)thenExpr).equals(ResolvedPrimitiveType.INT)) {\n                return elseExpr.asReferenceType().toUnboxedType().get();\n            }\n             \n            /* Otherwise, binary numeric promotion (\u00a75.6.2) is applied to the operand types,\n             * and the type of the conditional expression is the promoted type of the second\n             * and third operands.\n             */\n            ResolvedPrimitiveType PrimitiveThenExpr = thenExpr.isPrimitive() ? thenExpr.asPrimitive()\n                    : thenExpr.asReferenceType().toUnboxedType().get();\n            ResolvedPrimitiveType PrimitiveElseExpr = elseExpr.isPrimitive() ? elseExpr.asPrimitive()\n                    : elseExpr.asReferenceType().toUnboxedType().get();\n            return PrimitiveThenExpr.bnp(PrimitiveElseExpr);\n        }\n        \n        /*\n         * Otherwise, the conditional expression is a reference conditional expression.\n         * A reference conditional expression is a poly expression if it appears in an assignment context or an\n         * invocation context (\u00a75.2. \u00a75.3).\n         * Otherwise, it is a standalone expression.\n         * The type of a poly reference conditional expression is the same as its target type.\n         * The type of a standalone reference conditional expression is determined as follows:\n         * If the second and third operands have the same type (which may be the null type), then that is the type of\n         * the conditional expression.\n         * If the type of one of the second and third operands is the null type, and the type of the other operand is a\n         * reference type, then the type of the conditional expression is that reference type.\n         * Otherwise, the second and third operands are of types S1 and S2 respectively. Let T1 be the type that\n         * results from applying boxing conversion to S1, and let T2 be the type that results from applying boxing\n         * conversion to S2. The type of the conditional expression is the result of applying capture conversion\n         * (\u00a75.1.10) to lub(T1, T2).\n         * TODO : must be implemented\n         */\n        if (node.isPolyExpression()) {\n            // The type of a poly reference conditional expression is the same as its target type.\n            Optional<Node> parentNode = node.getParentNode();\n            if (parentNode.isPresent()) {\n                Node parent = parentNode.get();\n                if (parent instanceof AssignExpr) {\n                    return visit((AssignExpr)parent, solveLambdas);\n                } else if (parent instanceof MethodCallExpr) {\n                    // how to define the target type?\n                    // a priori it is the type of the parameter of the method which takes the value of the conditional expression\n                    // TODO for the moment we keep the original return type\n                    return thenExpr;\n                }\n                throw new RuntimeException(\"Cannot resolve type of poly expression \"+ node.toString());\n            } else {\n                throw new RuntimeException(\"Parent node unexpectedly empty\");\n            }\n            \n        }\n        \n        // The type of a standalone reference conditional expression is determined as follows:\n        \n        // If the second and third operands have the same type (which may be the null type), then that is the type of\n        // the conditional expression.\n        if (thenExpr.equals(elseExpr)) {\n            return thenExpr;\n        }\n        // If the type of one of the second and third operands is the null type, and the type of the other operand is a\n        // reference type, then the type of the conditional expression is that reference type.\n        // this case is already supported above\n        \n        // Otherwise, the second and third operands are of types S1 and S2 respectively. Let T1 be the type that\n        // results from applying boxing conversion to S1, and let T2 be the type that results from applying boxing\n        // conversion to S2. The type of the conditional expression is the result of applying capture conversion\n        // (\u00a75.1.10) to lub(T1, T2).\n        ResolvedType resolvedThenType = thenExpr.isPrimitive() ? TypeHelper.toBoxedType(thenExpr.asPrimitive(), typeSolver) : thenExpr;\n        ResolvedType resolvedElseType = elseExpr.isPrimitive() ? TypeHelper.toBoxedType(elseExpr.asPrimitive(), typeSolver) : elseExpr;\n        \n        // TypeHelper.leastUpperBound method is not yet implemented so for the moment we keep the original return type of this method\n        // TODO implement TypeHelper.leastUpperBound method\n        // return TypeHelper.leastUpperBound(new HashSet<ResolvedType>(Arrays.asList(resolvedThenType, resolvedElseType)));\n        return node.getThenExpr().accept(this, solveLambdas);\n    }\n    \n    private boolean isCompatible(ResolvedType resolvedType, ResolvedPrimitiveType primitiveType) {\n        return (resolvedType.isPrimitive() && resolvedType.asPrimitive().equals(primitiveType))\n        || (resolvedType.isReferenceType() && resolvedType.asReferenceType().isUnboxableTo(primitiveType));\n    }\n\n    @Override\n    public ResolvedType visit(EnclosedExpr node, Boolean solveLambdas) {\n        return node.getInner().accept(this, solveLambdas);\n    }\n\n    /**\n     * Java Parser can't differentiate between packages, internal types, and fields.\n     * All three are lumped together into FieldAccessExpr. We need to differentiate them.\n     */\n    private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {\n        // Fields and internal type declarations cannot have the same name.\n        // Thus, these checks will always be mutually exclusive.\n        if (parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())) {\n            return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();\n        } else if (parentType.hasField(node.getName().getId())) {\n            return parentType.getField(node.getName().getId()).getType();\n        } else if (parentType.hasInternalType(node.getName().getId())) {\n            return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()), typeSolver);\n        } else {\n            throw new UnsolvedSymbolException(node.getName().getId());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(InstanceOfExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(StringLiteralExpr node, Boolean solveLambdas) {\n        return StringReferenceType;\n    }\n\n    @Override\n    public ResolvedType visit(IntegerLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.INT;\n    }\n\n    @Override\n    public ResolvedType visit(LongLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.LONG;\n    }\n\n    @Override\n    public ResolvedType visit(CharLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.CHAR;\n    }\n\n    @Override\n    public ResolvedType visit(DoubleLiteralExpr node, Boolean solveLambdas) {\n        if (node.getValue().toLowerCase().endsWith(\"f\")) {\n            return ResolvedPrimitiveType.FLOAT;\n        }\n        return ResolvedPrimitiveType.DOUBLE;\n    }\n\n    @Override\n    public ResolvedType visit(BooleanLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(NullLiteralExpr node, Boolean solveLambdas) {\n        return NullType.INSTANCE;\n    }\n\n    @Override\n    public ResolvedType visit(MethodCallExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on method call %s\", ()-> node);\n        // first solve the method\n        MethodUsage ref = facade.solveMethodAsUsage(node);\n        Log.trace(\"getType on method call %s resolved to %s\", ()-> node, ()-> ref);\n        Log.trace(\"getType on method call %s return type is %s\", ()-> node, ref::returnType);\n        return ref.returnType();\n        // the type is the return type of the method\n    }\n\n    @Override\n    public ResolvedType visit(NameExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on name expr %s\", ()-> node);\n        Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, node.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    }\n\n    @Override\n    public ResolvedType visit(TypeExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on type expr %s\", ()-> node);\n        if (!(node.getType() instanceof ClassOrInterfaceType)) {\n            // TODO / FIXME... e.g. System.out::println\n            throw new UnsupportedOperationException(node.getType().getClass().getCanonicalName());\n        }\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) node.getType();\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = JavaParserFactory\n                .getContext(classOrInterfaceType, typeSolver)\n                .solveType(classOrInterfaceType.getName().getId());\n        if (!typeDeclarationSymbolReference.isSolved()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, classOrInterfaceType.getName().getId());\n        } else {\n            return new ReferenceTypeImpl(typeDeclarationSymbolReference.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n    }\n\n    @Override\n    public ResolvedType visit(ObjectCreationExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n    @Override\n    public ResolvedType visit(ThisExpr node, Boolean solveLambdas) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve locally in Compilation unit\n            // first try a buttom/up approach\n            try {\n                return new ReferenceTypeImpl(\n                        facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node, className)),\n                        typeSolver);\n            } catch (IllegalStateException e) {\n                // trying another approach from type solver\n                Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n                SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n                if (clazz.isSolved()) {\n                    return new ReferenceTypeImpl(clazz.getCorrespondingDeclaration(), typeSolver);\n                }\n            }\n        }\n        return new ReferenceTypeImpl(facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node)), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(SuperExpr node, Boolean solveLambdas) {\n        // If 'super' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            String className = node.getTypeName().get().asString();\n            SymbolReference<ResolvedTypeDeclaration> resolvedTypeNameRef = JavaParserFactory.getContext(node, typeSolver).solveType(className);\n            if (resolvedTypeNameRef.isSolved()) {\n                // Cfr JLS $15.12.1\n                ResolvedTypeDeclaration resolvedTypeName = resolvedTypeNameRef.getCorrespondingDeclaration();\n                if (resolvedTypeName.isInterface()) {\n                    return new ReferenceTypeImpl(resolvedTypeName.asInterface(), typeSolver);\n                } else if (resolvedTypeName.isClass()) {\n                    // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n                    return resolvedTypeName.asClass().getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n                } else {\n                    throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n                }\n            } else {\n                throw new UnsolvedSymbolException(className);\n            }\n        }\n\n        ResolvedTypeDeclaration typeOfNode = facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node));\n        if (typeOfNode instanceof ResolvedClassDeclaration) {\n            // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n            return ((ResolvedClassDeclaration) typeOfNode).getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(UnaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case MINUS:\n            case PLUS:\n                return node.getExpression().accept(this, solveLambdas);\n            case LOGICAL_COMPLEMENT:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case POSTFIX_DECREMENT:\n            case PREFIX_DECREMENT:\n            case POSTFIX_INCREMENT:\n            case PREFIX_INCREMENT:\n            case BITWISE_COMPLEMENT:\n                return node.getExpression().accept(this, solveLambdas);\n            default:\n                throw new UnsupportedOperationException(node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarationExpr node, Boolean solveLambdas) {\n        if (node.getVariables().size() != 1) {\n            throw new UnsupportedOperationException();\n        }\n        return facade.convertToUsageVariableType(node.getVariables().get(0));\n    }\n\n\n    @Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n\n                // The type parameter referred here should be the java.util.stream.Stream.T\n                ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr = node;\n\n                    InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n                    InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n                    // At this point parameterType\n                    // if Function<T=? super Stream.T, ? extends map.R>\n                    // we should replace Stream.T\n                    ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n                    lambdaCtx.addPair(result, functionalInterfaceType);\n\n                    ResolvedType actualType;\n\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n                    } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                        BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                        // Get all the return statements in the lambda block\n                        List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                        if (returnStmts.size() > 0) {\n                            actualType = returnStmts.stream()\n                                    .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                                    .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                                    .findFirst()\n                                    .orElse(ResolvedVoidType.INSTANCE);\n\n                        } else {\n                            actualType = ResolvedVoidType.INSTANCE;\n                        }\n\n\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    ResolvedType formalType = functionalMethod.get().returnType();\n\n                    // Infer the functional interfaces' return vs actual type\n                    funcInterfaceCtx.addPair(formalType, actualType);\n                    // Substitute to obtain a new type\n                    ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n                    // if the functional method returns void anyway\n                    // we don't need to bother inferring types\n                    if (!(formalType instanceof ResolvedVoidType)) {\n                        lambdaCtx.addPair(result, functionalTypeWithReturn);\n                        result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n                    }\n                }\n\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }\n\n    @Override\n    public ResolvedType visit(MethodReferenceExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on method reference expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                MethodUsage usage = facade.solveMethodAsUsage(callExpr);\n                ResolvedType result = usage.getParamType(pos);\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethodOpt.isPresent()) {\n                    MethodUsage functionalMethod = functionalMethodOpt.get();\n\n                    for (Pair<ResolvedTypeParameterDeclaration, ResolvedType> typeParamDecl : result.asReferenceType().getTypeParametersMap()) {\n                        functionalMethod = functionalMethod.replaceTypeParameter(typeParamDecl.a, typeParamDecl.b);\n                    }\n\n                    // replace wildcards\n                    for (int i = 0; i < functionalMethod.getNoParams(); i++) {\n                        ResolvedType type = functionalMethod.getParamType(i);\n                        if (type.isWildcard()) {\n                            ResolvedType boundedType = type.asWildcard().getBoundedType();\n                            functionalMethod = functionalMethod.replaceParamType(i, boundedType);\n                        }\n                    }\n\n                    ResolvedType actualType = facade.toMethodUsage(node, functionalMethod.getParamTypes()).returnType();\n                    ResolvedType formalType = functionalMethod.returnType();\n\n                    InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                    inferenceContext.addPair(formalType, actualType);\n                    result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                }\n\n                return result;\n            }\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n        }\n        throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n    }\n\n    @Override\n    public ResolvedType visit(FieldDeclaration node, Boolean solveLambdas) {\n        if (node.getVariables().size() == 1) {\n            return node.getVariables().get(0).accept(this, solveLambdas);\n        }\n        throw new IllegalArgumentException(\"Cannot resolve the type of a field with multiple variable declarations. Pick one\");\n    }\n}\n", "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solveGenericTypes;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.ArrayAccessExpr;\nimport com.github.javaparser.ast.expr.ArrayCreationExpr;\nimport com.github.javaparser.ast.expr.ArrayInitializerExpr;\nimport com.github.javaparser.ast.expr.AssignExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.BooleanLiteralExpr;\nimport com.github.javaparser.ast.expr.CastExpr;\nimport com.github.javaparser.ast.expr.CharLiteralExpr;\nimport com.github.javaparser.ast.expr.ClassExpr;\nimport com.github.javaparser.ast.expr.ConditionalExpr;\nimport com.github.javaparser.ast.expr.DoubleLiteralExpr;\nimport com.github.javaparser.ast.expr.EnclosedExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.InstanceOfExpr;\nimport com.github.javaparser.ast.expr.IntegerLiteralExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.LongLiteralExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.NullLiteralExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.StringLiteralExpr;\nimport com.github.javaparser.ast.expr.SuperExpr;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.expr.UnaryExpr;\nimport com.github.javaparser.ast.expr.VariableDeclarationExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.ReturnStmt;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnknownType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.symbolsolver.logic.InferenceContext;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.Value;\nimport com.github.javaparser.symbolsolver.model.typesystem.NullType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.MyObjectProvider;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.github.javaparser.utils.Log;\nimport com.github.javaparser.utils.Pair;\nimport com.google.common.collect.ImmutableList;\n\npublic class TypeExtractor extends DefaultVisitorAdapter {\n\n    private static final String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private TypeSolver typeSolver;\n    private JavaParserFacade facade;\n    \n    private ReferenceTypeImpl StringReferenceType;\n\n    public TypeExtractor(TypeSolver typeSolver, JavaParserFacade facade) {\n        this.typeSolver = typeSolver;\n        this.facade = facade;\n        //pre-calculate the String reference (optimization)\n        StringReferenceType = new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(JAVA_LANG_STRING), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarator node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof FieldDeclaration) {\n            return facade.convertToUsageVariableType(node);\n        } else if (demandParentNode(node) instanceof VariableDeclarationExpr) {\n            return facade.convertToUsageVariableType(node);\n        }\n        throw new UnsupportedOperationException(demandParentNode(node).getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(Parameter node, Boolean solveLambdas) {\n        if (node.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + node);\n        }\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n\n    @Override\n    public ResolvedType visit(ArrayAccessExpr node, Boolean solveLambdas) {\n        ResolvedType arrayUsageType = node.getName().accept(this, solveLambdas);\n        if (arrayUsageType.isArray()) {\n            return ((ResolvedArrayType) arrayUsageType).getComponentType();\n        }\n        return arrayUsageType;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayCreationExpr node, Boolean solveLambdas) {\n        ResolvedType res = facade.convertToUsage(node.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i = 0; i < node.getLevels().size(); i++) {\n            res = new ResolvedArrayType(res);\n        }\n        return res;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayInitializerExpr node, Boolean solveLambdas) {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(AssignExpr node, Boolean solveLambdas) {\n        return node.getTarget().accept(this, solveLambdas);\n    }\n\n    @Override\n    public ResolvedType visit(BinaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case PLUS:\n            case MINUS:\n            case DIVIDE:\n            case MULTIPLY:\n            case REMAINDER:\n            case BINARY_AND:\n            case BINARY_OR:\n            case XOR:\n                return facade.getBinaryTypeConcrete(node.getLeft(), node.getRight(), solveLambdas, node.getOperator());\n            case LESS_EQUALS:\n            case LESS:\n            case GREATER:\n            case GREATER_EQUALS:\n            case EQUALS:\n            case NOT_EQUALS:\n            case OR:\n            case AND:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case SIGNED_RIGHT_SHIFT:\n            case UNSIGNED_RIGHT_SHIFT:\n            case LEFT_SHIFT:\n                ResolvedType rt = node.getLeft().accept(this, solveLambdas);\n                // apply unary primitive promotion\n                return ResolvedPrimitiveType.unp(rt);\n            default:\n                throw new UnsupportedOperationException(\"Operator \" + node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(CastExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    @Override\n    public ResolvedType visit(ClassExpr node, Boolean solveLambdas) {\n        // This implementation does not regard the actual type argument of the ClassExpr.\n        Type astType = node.getType();\n        ResolvedType jssType = facade.convertToUsage(astType, node.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    }\n\n    /*\n     * The conditional operator has three operand expressions. ? appears between the first and second expressions, and\n     * : appears between the second and third expressions.\n     * There are three kinds of conditional expressions, classified according to the second and third operand\n     * expressions: boolean conditional expressions, numeric conditional expressions, and reference conditional\n     * expressions.\n     * The classification rules are as follows:\n     * 1/ If both the second and the third operand expressions are boolean expressions, the conditional expression is a\n     * boolean conditional expression.\n     * 2/ If both the second and the third operand expressions are numeric expressions, the conditional expression is a\n     * numeric conditional expression.\n     * 3/ Otherwise, the conditional expression is a reference conditional expression\n     */\n    @Override\n    public ResolvedType visit(ConditionalExpr node, Boolean solveLambdas) {\n        ResolvedType thenExpr = node.getThenExpr().accept(this, solveLambdas);\n        ResolvedType elseExpr = node.getElseExpr().accept(this, solveLambdas);\n        \n        // manage null expression\n        if ( thenExpr.isNull()) {\n            return  elseExpr;\n        }\n        if ( elseExpr.isNull()) {\n            return  thenExpr;\n        }\n        /*\n         * Boolean conditional expressions are standalone expressions\n         * The type of a boolean conditional expression is determined as follows:\n         * If the second and third operands are both of type Boolean, the conditional expression has type Boolean.\n         * Otherwise, the conditional expression has type boolean.\n         */\n        if ( thenExpr.isAssignableBy(ResolvedPrimitiveType.BOOLEAN) \n                && elseExpr.isAssignableBy(ResolvedPrimitiveType.BOOLEAN)) {\n            if (thenExpr.isReferenceType() && elseExpr.isReferenceType()) {\n                return thenExpr.asReferenceType();\n            }\n            return thenExpr.isPrimitive() ? thenExpr : elseExpr;\n        }\n        \n        /*\n         * Numeric conditional expressions are standalone expressions (\u00a715.2).\n         * The type of a numeric conditional expression is determined as follows:\n         * If the second and third operands have the same type, then that is the type of the conditional expression.\n         * If one of the second and third operands is of primitive type T, and the type of the other is the result of\n         * applying boxing conversion (\u00a75.1.7) to T, then the type of the conditional expression is T.\n         * If one of the operands is of type byte or Byte and the other is of type short or Short, then the type of the\n         * conditional expression is short.\n         * If one of the operands is of type T where T is byte, short, or char, and the other operand is a constant\n         * expression (\u00a715.28) of type int whose value is representable in type T, then the type of the conditional\n         * expression is T.\n         * If one of the operands is of type T, where T is Byte, Short, or Character, and the other operand is a\n         * constant expression of type int whose value is representable in the type U which is the result of applying\n         * unboxing conversion to T, then the type of the conditional expression is U.\n         * Otherwise, binary numeric promotion (\u00a75.6.2) is applied to the operand types, and the type of the\n         * conditional expression is the promoted type of the second and third operands.\n         */\n        if (thenExpr.isNumericType() && elseExpr.isNumericType()) {\n            ResolvedPrimitiveType[] resolvedPrimitiveTypeSubList = new ResolvedPrimitiveType[] {ResolvedPrimitiveType.BYTE, ResolvedPrimitiveType.SHORT, ResolvedPrimitiveType.CHAR};\n            /*\n             *  If the second and third operands have the same type, then that is the type of the conditional expression.\n             */\n            String qnameTypeThenExpr = thenExpr.isPrimitive() ? thenExpr.asPrimitive().describe()\n                    : thenExpr.asReferenceType().describe();\n            String qnameTypeElseExpr = elseExpr.isPrimitive() ? elseExpr.asPrimitive().describe()\n                    : elseExpr.asReferenceType().describe();\n            if (qnameTypeThenExpr.equals(qnameTypeElseExpr)) {\n                return thenExpr;\n            }\n            /*\n             * If one of the second and third operands is of primitive type T, and the type of the other is the result of\n             * applying boxing conversion (\u00a75.1.7) to T, then the type of the conditional expression is T.\n             */\n            else if ((thenExpr.isPrimitive() && elseExpr.isReferenceType()\n                    && isCompatible(elseExpr.asReferenceType(), thenExpr.asPrimitive()))) {\n                return thenExpr;\n            } else if ((elseExpr.isPrimitive() && thenExpr.isReferenceType()\n                    && isCompatible(thenExpr.asReferenceType(), elseExpr.asPrimitive()))) {\n                return elseExpr;\n            }\n            /*\n             * If one of the operands is of type byte or Byte and the other is of type short or Short, then the type of the\n             * conditional expression is short.\n             */\n            else if ((isCompatible(thenExpr, ResolvedPrimitiveType.BYTE) && isCompatible(elseExpr, ResolvedPrimitiveType.SHORT))\n                    || (isCompatible(elseExpr, ResolvedPrimitiveType.BYTE) && isCompatible(thenExpr, ResolvedPrimitiveType.SHORT))) {\n                return ResolvedPrimitiveType.SHORT;\n            }\n            /*\n             *  If one of the operands is of type T where T is byte, short, or char, and the\n             *  other operand is a constant expression (\u00a715.28) of type int whose value is\n             *  representable in type T, then the type of the conditional expression is T\n             *  How can we know if the constant expression of type int is representable in type T ?\n             *  \"The constant expression of type int is representable in type T\" is a runtime decision!\n             */\n            else if (thenExpr.isPrimitive() && elseExpr.isPrimitive()) {\n                if (((ResolvedPrimitiveType)thenExpr).in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)elseExpr).equals(ResolvedPrimitiveType.INT)) {\n                    return thenExpr;\n                } else if (((ResolvedPrimitiveType)elseExpr).in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)thenExpr).equals(ResolvedPrimitiveType.INT)) {\n                    return elseExpr;\n                }\n            }\n             /*  If one of the operands is of type T, where T is Byte, Short, or Character,\n             * and the other operand is a constant expression of type int whose value is\n             * representable in the type U which is the result of applying unboxing\n             * conversion to T, then the type of the conditional expression is U.\n             * A priori this is a runtime decision!\n             */\n            else if (thenExpr.isReference() && elseExpr.isPrimitive()\n                    && thenExpr.asReferenceType().isUnboxable()\n                    && thenExpr.asReferenceType().toUnboxedType().get().in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)elseExpr).equals(ResolvedPrimitiveType.INT)) {\n                return thenExpr.asReferenceType().toUnboxedType().get();\n            } else if (elseExpr.isReference() && thenExpr.isPrimitive()\n                    && elseExpr.asReferenceType().isUnboxable()\n                    && elseExpr.asReferenceType().toUnboxedType().get().in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)thenExpr).equals(ResolvedPrimitiveType.INT)) {\n                return elseExpr.asReferenceType().toUnboxedType().get();\n            }\n             \n            /* Otherwise, binary numeric promotion (\u00a75.6.2) is applied to the operand types,\n             * and the type of the conditional expression is the promoted type of the second\n             * and third operands.\n             */\n            ResolvedPrimitiveType PrimitiveThenExpr = thenExpr.isPrimitive() ? thenExpr.asPrimitive()\n                    : thenExpr.asReferenceType().toUnboxedType().get();\n            ResolvedPrimitiveType PrimitiveElseExpr = elseExpr.isPrimitive() ? elseExpr.asPrimitive()\n                    : elseExpr.asReferenceType().toUnboxedType().get();\n            return PrimitiveThenExpr.bnp(PrimitiveElseExpr);\n        }\n        \n        /*\n         * Otherwise, the conditional expression is a reference conditional expression.\n         * A reference conditional expression is a poly expression if it appears in an assignment context or an\n         * invocation context (\u00a75.2. \u00a75.3).\n         * Otherwise, it is a standalone expression.\n         * The type of a poly reference conditional expression is the same as its target type.\n         * The type of a standalone reference conditional expression is determined as follows:\n         * If the second and third operands have the same type (which may be the null type), then that is the type of\n         * the conditional expression.\n         * If the type of one of the second and third operands is the null type, and the type of the other operand is a\n         * reference type, then the type of the conditional expression is that reference type.\n         * Otherwise, the second and third operands are of types S1 and S2 respectively. Let T1 be the type that\n         * results from applying boxing conversion to S1, and let T2 be the type that results from applying boxing\n         * conversion to S2. The type of the conditional expression is the result of applying capture conversion\n         * (\u00a75.1.10) to lub(T1, T2).\n         * TODO : must be implemented\n         */\n        if (node.isPolyExpression()) {\n            // The type of a poly reference conditional expression is the same as its target type.\n            Optional<Node> parentNode = node.getParentNode();\n            if (parentNode.isPresent()) {\n                Node parent = parentNode.get();\n                if (parent instanceof AssignExpr) {\n                    return visit((AssignExpr)parent, solveLambdas);\n                } else if (parent instanceof MethodCallExpr) {\n                    // how to define the target type?\n                    // a priori it is the type of the parameter of the method which takes the value of the conditional expression\n                    // TODO for the moment we keep the original return type\n                    return thenExpr;\n                }\n                throw new RuntimeException(\"Cannot resolve type of poly expression \"+ node.toString());\n            } else {\n                throw new RuntimeException(\"Parent node unexpectedly empty\");\n            }\n            \n        }\n        \n        // The type of a standalone reference conditional expression is determined as follows:\n        \n        // If the second and third operands have the same type (which may be the null type), then that is the type of\n        // the conditional expression.\n        if (thenExpr.equals(elseExpr)) {\n            return thenExpr;\n        }\n        // If the type of one of the second and third operands is the null type, and the type of the other operand is a\n        // reference type, then the type of the conditional expression is that reference type.\n        // this case is already supported above\n        \n        // Otherwise, the second and third operands are of types S1 and S2 respectively. Let T1 be the type that\n        // results from applying boxing conversion to S1, and let T2 be the type that results from applying boxing\n        // conversion to S2. The type of the conditional expression is the result of applying capture conversion\n        // (\u00a75.1.10) to lub(T1, T2).\n        ResolvedType resolvedThenType = thenExpr.isPrimitive() ? TypeHelper.toBoxedType(thenExpr.asPrimitive(), typeSolver) : thenExpr;\n        ResolvedType resolvedElseType = elseExpr.isPrimitive() ? TypeHelper.toBoxedType(elseExpr.asPrimitive(), typeSolver) : elseExpr;\n        \n        // TypeHelper.leastUpperBound method is not yet implemented so for the moment we keep the original return type of this method\n        // TODO implement TypeHelper.leastUpperBound method\n        // return TypeHelper.leastUpperBound(new HashSet<ResolvedType>(Arrays.asList(resolvedThenType, resolvedElseType)));\n        return node.getThenExpr().accept(this, solveLambdas);\n    }\n    \n    private boolean isCompatible(ResolvedType resolvedType, ResolvedPrimitiveType primitiveType) {\n        return (resolvedType.isPrimitive() && resolvedType.asPrimitive().equals(primitiveType))\n        || (resolvedType.isReferenceType() && resolvedType.asReferenceType().isUnboxableTo(primitiveType));\n    }\n\n    @Override\n    public ResolvedType visit(EnclosedExpr node, Boolean solveLambdas) {\n        return node.getInner().accept(this, solveLambdas);\n    }\n\n    /**\n     * Java Parser can't differentiate between packages, internal types, and fields.\n     * All three are lumped together into FieldAccessExpr. We need to differentiate them.\n     */\n    private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {\n        // Fields and internal type declarations cannot have the same name.\n        // Thus, these checks will always be mutually exclusive.\n        if (parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())) {\n            return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();\n        } else if (parentType.hasField(node.getName().getId())) {\n            return parentType.getField(node.getName().getId()).getType();\n        } else if (parentType.hasInternalType(node.getName().getId())) {\n            return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()), typeSolver);\n        } else {\n            throw new UnsolvedSymbolException(node.getName().getId());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(InstanceOfExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(StringLiteralExpr node, Boolean solveLambdas) {\n        return StringReferenceType;\n    }\n\n    @Override\n    public ResolvedType visit(IntegerLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.INT;\n    }\n\n    @Override\n    public ResolvedType visit(LongLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.LONG;\n    }\n\n    @Override\n    public ResolvedType visit(CharLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.CHAR;\n    }\n\n    @Override\n    public ResolvedType visit(DoubleLiteralExpr node, Boolean solveLambdas) {\n        if (node.getValue().toLowerCase().endsWith(\"f\")) {\n            return ResolvedPrimitiveType.FLOAT;\n        }\n        return ResolvedPrimitiveType.DOUBLE;\n    }\n\n    @Override\n    public ResolvedType visit(BooleanLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(NullLiteralExpr node, Boolean solveLambdas) {\n        return NullType.INSTANCE;\n    }\n\n    @Override\n    public ResolvedType visit(MethodCallExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on method call %s\", ()-> node);\n        // first solve the method\n        MethodUsage ref = facade.solveMethodAsUsage(node);\n        Log.trace(\"getType on method call %s resolved to %s\", ()-> node, ()-> ref);\n        Log.trace(\"getType on method call %s return type is %s\", ()-> node, ref::returnType);\n        return ref.returnType();\n        // the type is the return type of the method\n    }\n\n    @Override\n    public ResolvedType visit(NameExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on name expr %s\", ()-> node);\n        Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, node.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    }\n\n    @Override\n    public ResolvedType visit(TypeExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on type expr %s\", ()-> node);\n        if (!(node.getType() instanceof ClassOrInterfaceType)) {\n            // TODO / FIXME... e.g. System.out::println\n            throw new UnsupportedOperationException(node.getType().getClass().getCanonicalName());\n        }\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) node.getType();\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = JavaParserFactory\n                .getContext(classOrInterfaceType, typeSolver)\n                .solveType(classOrInterfaceType.getName().getId());\n        if (!typeDeclarationSymbolReference.isSolved()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, classOrInterfaceType.getName().getId());\n        } else {\n            return new ReferenceTypeImpl(typeDeclarationSymbolReference.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n    }\n\n    @Override\n    public ResolvedType visit(ObjectCreationExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n    @Override\n    public ResolvedType visit(ThisExpr node, Boolean solveLambdas) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve locally in Compilation unit\n            // first try a buttom/up approach\n            try {\n                return new ReferenceTypeImpl(\n                        facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node, className)),\n                        typeSolver);\n            } catch (IllegalStateException e) {\n                // trying another approach from type solver\n                Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n                SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n                if (clazz.isSolved()) {\n                    return new ReferenceTypeImpl(clazz.getCorrespondingDeclaration(), typeSolver);\n                }\n            }\n        }\n        return new ReferenceTypeImpl(facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node)), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(SuperExpr node, Boolean solveLambdas) {\n        // If 'super' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            String className = node.getTypeName().get().asString();\n            SymbolReference<ResolvedTypeDeclaration> resolvedTypeNameRef = JavaParserFactory.getContext(node, typeSolver).solveType(className);\n            if (resolvedTypeNameRef.isSolved()) {\n                // Cfr JLS $15.12.1\n                ResolvedTypeDeclaration resolvedTypeName = resolvedTypeNameRef.getCorrespondingDeclaration();\n                if (resolvedTypeName.isInterface()) {\n                    return new ReferenceTypeImpl(resolvedTypeName.asInterface(), typeSolver);\n                } else if (resolvedTypeName.isClass()) {\n                    // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n                    return resolvedTypeName.asClass().getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n                } else {\n                    throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n                }\n            } else {\n                throw new UnsolvedSymbolException(className);\n            }\n        }\n\n        ResolvedTypeDeclaration typeOfNode = facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node));\n        if (typeOfNode instanceof ResolvedClassDeclaration) {\n            // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n            return ((ResolvedClassDeclaration) typeOfNode).getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(UnaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case MINUS:\n            case PLUS:\n                return node.getExpression().accept(this, solveLambdas);\n            case LOGICAL_COMPLEMENT:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case POSTFIX_DECREMENT:\n            case PREFIX_DECREMENT:\n            case POSTFIX_INCREMENT:\n            case PREFIX_INCREMENT:\n            case BITWISE_COMPLEMENT:\n                return node.getExpression().accept(this, solveLambdas);\n            default:\n                throw new UnsupportedOperationException(node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarationExpr node, Boolean solveLambdas) {\n        if (node.getVariables().size() != 1) {\n            throw new UnsupportedOperationException();\n        }\n        return facade.convertToUsageVariableType(node.getVariables().get(0));\n    }\n\n\n    @Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n\n            // The type parameter referred here should be the java.util.stream.Stream.T\n            ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n            if (solveLambdas) {\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof VariableDeclarator)\n        {\n            VariableDeclarator decExpr = (VariableDeclarator) demandParentNode(node);\n            ResolvedType result = decExpr.getType().resolve();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof AssignExpr) {\n            AssignExpr assExpr = (AssignExpr) demandParentNode(node);\n            ResolvedType result = assExpr.calculateResolvedType();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }\n\n    private ResolvedType resolveLambda(LambdaExpr node, ResolvedType result) {\n        // We need to replace the type variables\n        Context ctx = JavaParserFactory.getContext(node, typeSolver);\n        result = solveGenericTypes(result, ctx);\n\n        //We should find out which is the functional method (e.g., apply) and replace the params of the\n        //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n        //lambdas\n        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n        if (functionalMethod.isPresent()) {\n            LambdaExpr lambdaExpr = node;\n\n            InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n            InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n            // At this point parameterType\n            // if Function<T=? super Stream.T, ? extends map.R>\n            // we should replace Stream.T\n            ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n            lambdaCtx.addPair(result, functionalInterfaceType);\n\n            ResolvedType actualType;\n\n            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n            } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                // Get all the return statements in the lambda block\n                List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                if (returnStmts.size() > 0) {\n                    actualType = returnStmts.stream()\n                            .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                            .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                            .findFirst()\n                            .orElse(ResolvedVoidType.INSTANCE);\n\n                } else {\n                    actualType = ResolvedVoidType.INSTANCE;\n                }\n\n\n            } else {\n                throw new UnsupportedOperationException();\n            }\n\n            ResolvedType formalType = functionalMethod.get().returnType();\n\n            // Infer the functional interfaces' return vs actual type\n            funcInterfaceCtx.addPair(formalType, actualType);\n            // Substitute to obtain a new type\n            ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n            // if the functional method returns void anyway\n            // we don't need to bother inferring types\n            if (!(formalType instanceof ResolvedVoidType)) {\n                lambdaCtx.addPair(result, functionalTypeWithReturn);\n                result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public ResolvedType visit(MethodReferenceExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on method reference expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                MethodUsage usage = facade.solveMethodAsUsage(callExpr);\n                ResolvedType result = usage.getParamType(pos);\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethodOpt.isPresent()) {\n                    MethodUsage functionalMethod = functionalMethodOpt.get();\n\n                    for (Pair<ResolvedTypeParameterDeclaration, ResolvedType> typeParamDecl : result.asReferenceType().getTypeParametersMap()) {\n                        functionalMethod = functionalMethod.replaceTypeParameter(typeParamDecl.a, typeParamDecl.b);\n                    }\n\n                    // replace wildcards\n                    for (int i = 0; i < functionalMethod.getNoParams(); i++) {\n                        ResolvedType type = functionalMethod.getParamType(i);\n                        if (type.isWildcard()) {\n                            ResolvedType boundedType = type.asWildcard().getBoundedType();\n                            functionalMethod = functionalMethod.replaceParamType(i, boundedType);\n                        }\n                    }\n\n                    ResolvedType actualType = facade.toMethodUsage(node, functionalMethod.getParamTypes()).returnType();\n                    ResolvedType formalType = functionalMethod.returnType();\n\n                    InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                    inferenceContext.addPair(formalType, actualType);\n                    result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                }\n\n                return result;\n            }\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n        }\n        throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n    }\n\n    @Override\n    public ResolvedType visit(FieldDeclaration node, Boolean solveLambdas) {\n        if (node.getVariables().size() == 1) {\n            return node.getVariables().get(0).accept(this, solveLambdas);\n        }\n        throw new IllegalArgumentException(\"Cannot resolve the type of a field with multiple variable declarations. Pick one\");\n    }\n}\n", "diffSourceCodeSet": ["private ResolvedType resolveLambda(LambdaExpr node, ResolvedType result) {\n        // We need to replace the type variables\n        Context ctx = JavaParserFactory.getContext(node, typeSolver);\n        result = solveGenericTypes(result, ctx);\n\n        //We should find out which is the functional method (e.g., apply) and replace the params of the\n        //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n        //lambdas\n        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n        if (functionalMethod.isPresent()) {\n            LambdaExpr lambdaExpr = node;\n\n            InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n            InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n            // At this point parameterType\n            // if Function<T=? super Stream.T, ? extends map.R>\n            // we should replace Stream.T\n            ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n            lambdaCtx.addPair(result, functionalInterfaceType);\n\n            ResolvedType actualType;\n\n            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n            } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                // Get all the return statements in the lambda block\n                List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                if (returnStmts.size() > 0) {\n                    actualType = returnStmts.stream()\n                            .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                            .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                            .findFirst()\n                            .orElse(ResolvedVoidType.INSTANCE);\n\n                } else {\n                    actualType = ResolvedVoidType.INSTANCE;\n                }\n\n\n            } else {\n                throw new UnsupportedOperationException();\n            }\n\n            ResolvedType formalType = functionalMethod.get().returnType();\n\n            // Infer the functional interfaces' return vs actual type\n            funcInterfaceCtx.addPair(formalType, actualType);\n            // Substitute to obtain a new type\n            ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n            // if the functional method returns void anyway\n            // we don't need to bother inferring types\n            if (!(formalType instanceof ResolvedVoidType)) {\n                lambdaCtx.addPair(result, functionalTypeWithReturn);\n                result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n            }\n        }\n        return result;\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n\n            // The type parameter referred here should be the java.util.stream.Stream.T\n            ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n            if (solveLambdas) {\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof VariableDeclarator)\n        {\n            VariableDeclarator decExpr = (VariableDeclarator) demandParentNode(node);\n            ResolvedType result = decExpr.getType().resolve();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof AssignExpr) {\n            AssignExpr assExpr = (AssignExpr) demandParentNode(node);\n            ResolvedType result = assExpr.calculateResolvedType();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }\nprivate ResolvedType resolveLambda(LambdaExpr node, ResolvedType result) {\n        // We need to replace the type variables\n        Context ctx = JavaParserFactory.getContext(node, typeSolver);\n        result = solveGenericTypes(result, ctx);\n\n        //We should find out which is the functional method (e.g., apply) and replace the params of the\n        //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n        //lambdas\n        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n        if (functionalMethod.isPresent()) {\n            LambdaExpr lambdaExpr = node;\n\n            InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n            InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n            // At this point parameterType\n            // if Function<T=? super Stream.T, ? extends map.R>\n            // we should replace Stream.T\n            ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n            lambdaCtx.addPair(result, functionalInterfaceType);\n\n            ResolvedType actualType;\n\n            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n            } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                // Get all the return statements in the lambda block\n                List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                if (returnStmts.size() > 0) {\n                    actualType = returnStmts.stream()\n                            .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                            .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                            .findFirst()\n                            .orElse(ResolvedVoidType.INSTANCE);\n\n                } else {\n                    actualType = ResolvedVoidType.INSTANCE;\n                }\n\n\n            } else {\n                throw new UnsupportedOperationException();\n            }\n\n            ResolvedType formalType = functionalMethod.get().returnType();\n\n            // Infer the functional interfaces' return vs actual type\n            funcInterfaceCtx.addPair(formalType, actualType);\n            // Substitute to obtain a new type\n            ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n            // if the functional method returns void anyway\n            // we don't need to bother inferring types\n            if (!(formalType instanceof ResolvedVoidType)) {\n                lambdaCtx.addPair(result, functionalTypeWithReturn);\n                result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n            }\n        }\n        return result;\n    }", "diffSourceCode": "   647:     @Override\n   648:     public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n   649:         if (demandParentNode(node) instanceof MethodCallExpr) {\n   650:             MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n   651:             int pos = JavaParserSymbolDeclaration.getParamPos(node);\n   652:             SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n   653:             if (!refMethod.isSolved()) {\n   654:                 throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n   655:             }\n   656:             Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n-  657:             if (solveLambdas) {\n-  658: \n-  659:                 // The type parameter referred here should be the java.util.stream.Stream.T\n-  660:                 ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-  661: \n+  657: \n+  658:             // The type parameter referred here should be the java.util.stream.Stream.T\n+  659:             ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+  660: \n+  661:             if (solveLambdas) {\n   662:                 if (callExpr.hasScope()) {\n   663:                     Expression scope = callExpr.getScope().get();\n   664: \n   665:                     // If it is a static call we should not try to get the type of the scope\n   666:                     boolean staticCall = false;\n   667:                     if (scope instanceof NameExpr) {\n   668:                         NameExpr nameExpr = (NameExpr) scope;\n   669:                         try {\n   670:                             SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n   671:                             if (type.isSolved()) {\n   672:                                 staticCall = true;\n   673:                             }\n   674:                         } catch (Exception e) {\n   675: \n   676:                         }\n   677:                     }\n   678: \n   679:                     if (!staticCall) {\n   680:                         ResolvedType scopeType = facade.getType(scope);\n   681:                         if (scopeType.isReferenceType()) {\n   682:                             result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n   683:                         }\n   684:                     }\n   685:                 }\n   686: \n-  687:                 // We need to replace the type variables\n-  688:                 Context ctx = JavaParserFactory.getContext(node, typeSolver);\n-  689:                 result = solveGenericTypes(result, ctx);\n-  690: \n-  691:                 //We should find out which is the functional method (e.g., apply) and replace the params of the\n-  692:                 //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n-  693:                 //lambdas\n-  694:                 Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n-  695:                 if (functionalMethod.isPresent()) {\n-  696:                     LambdaExpr lambdaExpr = node;\n-  697: \n-  698:                     InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n-  699:                     InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n-  700: \n-  701:                     // At this point parameterType\n-  702:                     // if Function<T=? super Stream.T, ? extends map.R>\n-  703:                     // we should replace Stream.T\n-  704:                     ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n-  705: \n-  706:                     lambdaCtx.addPair(result, functionalInterfaceType);\n-  707: \n-  708:                     ResolvedType actualType;\n-  709: \n-  710:                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-  711:                         actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n-  712:                     } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n-  713:                         BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n-  714: \n-  715:                         // Get all the return statements in the lambda block\n-  716:                         List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n-  717: \n-  718:                         if (returnStmts.size() > 0) {\n-  719:                             actualType = returnStmts.stream()\n-  720:                                     .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n-  721:                                     .filter(x -> x != null && !x.isVoid() && !x.isNull())\n-  722:                                     .findFirst()\n-  723:                                     .orElse(ResolvedVoidType.INSTANCE);\n-  724: \n-  725:                         } else {\n-  726:                             actualType = ResolvedVoidType.INSTANCE;\n-  727:                         }\n-  728: \n-  729: \n-  730:                     } else {\n-  731:                         throw new UnsupportedOperationException();\n-  732:                     }\n+  687:                 result = resolveLambda(node, result);\n+  688:             }\n+  689:             return result;\n+  690:         } else if (demandParentNode(node) instanceof VariableDeclarator)\n+  691:         {\n+  692:             VariableDeclarator decExpr = (VariableDeclarator) demandParentNode(node);\n+  693:             ResolvedType result = decExpr.getType().resolve();\n+  694: \n+  695:             if (solveLambdas) {\n+  696:                 result = resolveLambda(node, result);\n+  697:             }\n+  698:             return result;\n+  699:         } else if (demandParentNode(node) instanceof AssignExpr) {\n+  700:             AssignExpr assExpr = (AssignExpr) demandParentNode(node);\n+  701:             ResolvedType result = assExpr.calculateResolvedType();\n+  702: \n+  703:             if (solveLambdas) {\n+  704:                 result = resolveLambda(node, result);\n+  705:             }\n+  706:             return result;\n+  707:         } else {\n+  708:             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+  709:         }\n+  710:     }\n+  711: \n+  712:     private ResolvedType resolveLambda(LambdaExpr node, ResolvedType result) {\n+  713:         // We need to replace the type variables\n+  714:         Context ctx = JavaParserFactory.getContext(node, typeSolver);\n+  715:         result = solveGenericTypes(result, ctx);\n+  716: \n+  717:         //We should find out which is the functional method (e.g., apply) and replace the params of the\n+  718:         //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n+  719:         //lambdas\n+  720:         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n+  721:         if (functionalMethod.isPresent()) {\n+  722:             LambdaExpr lambdaExpr = node;\n+  723: \n+  724:             InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n+  725:             InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n+  726: \n+  727:             // At this point parameterType\n+  728:             // if Function<T=? super Stream.T, ? extends map.R>\n+  729:             // we should replace Stream.T\n+  730:             ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n+  731: \n+  732:             lambdaCtx.addPair(result, functionalInterfaceType);\n   733: \n-  734:                     ResolvedType formalType = functionalMethod.get().returnType();\n+  734:             ResolvedType actualType;\n   735: \n-  736:                     // Infer the functional interfaces' return vs actual type\n-  737:                     funcInterfaceCtx.addPair(formalType, actualType);\n-  738:                     // Substitute to obtain a new type\n-  739:                     ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n+  736:             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+  737:                 actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n+  738:             } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n+  739:                 BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n   740: \n-  741:                     // if the functional method returns void anyway\n-  742:                     // we don't need to bother inferring types\n-  743:                     if (!(formalType instanceof ResolvedVoidType)) {\n-  744:                         lambdaCtx.addPair(result, functionalTypeWithReturn);\n-  745:                         result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n-  746:                     }\n-  747:                 }\n-  748: \n-  749:                 return result;\n-  750:             } else {\n-  751:                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-  752:             }\n-  753:         } else {\n-  754:             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n-  755:         }\n-  756:     }\n-  757: \n-  758:     @Override\n-  759:     public ResolvedType visit(MethodReferenceExpr node, Boolean solveLambdas) {\n-  760:         if (demandParentNode(node) instanceof MethodCallExpr) {\n-  761:             MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n-  762:             int pos = JavaParserSymbolDeclaration.getParamPos(node);\n-  763:             SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr, false);\n-  764:             if (!refMethod.isSolved()) {\n-  765:                 throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n-  766:             }\n-  767:             Log.trace(\"getType on method reference expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n-  768:             if (solveLambdas) {\n-  769:                 MethodUsage usage = facade.solveMethodAsUsage(callExpr);\n-  770:                 ResolvedType result = usage.getParamType(pos);\n-  771:                 // We need to replace the type variables\n-  772:                 Context ctx = JavaParserFactory.getContext(node, typeSolver);\n-  773:                 result = solveGenericTypes(result, ctx);\n-  774: \n-  775:                 //We should find out which is the functional method (e.g., apply) and replace the params of the\n+  741:                 // Get all the return statements in the lambda block\n+  742:                 List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n+  743: \n+  744:                 if (returnStmts.size() > 0) {\n+  745:                     actualType = returnStmts.stream()\n+  746:                             .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n+  747:                             .filter(x -> x != null && !x.isVoid() && !x.isNull())\n+  748:                             .findFirst()\n+  749:                             .orElse(ResolvedVoidType.INSTANCE);\n+  750: \n+  751:                 } else {\n+  752:                     actualType = ResolvedVoidType.INSTANCE;\n+  753:                 }\n+  754: \n+  755: \n+  756:             } else {\n+  757:                 throw new UnsupportedOperationException();\n+  758:             }\n+  759: \n+  760:             ResolvedType formalType = functionalMethod.get().returnType();\n+  761: \n+  762:             // Infer the functional interfaces' return vs actual type\n+  763:             funcInterfaceCtx.addPair(formalType, actualType);\n+  764:             // Substitute to obtain a new type\n+  765:             ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n+  766: \n+  767:             // if the functional method returns void anyway\n+  768:             // we don't need to bother inferring types\n+  769:             if (!(formalType instanceof ResolvedVoidType)) {\n+  770:                 lambdaCtx.addPair(result, functionalTypeWithReturn);\n+  771:                 result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n+  772:             }\n+  773:         }\n+  774:         return result;\n+  775:     }\n", "uniqueId": "a9adfa6c86ba236edeaa2be318c337f98e5c6720_647_756_712_775_647_710", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 5, "covered": 15}, "BRANCH": {"missed": 1, "covered": 1}, "LINE": {"missed": 1, "covered": 2}, "COMPLEXITY": {"missed": 1, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `visit(LambdaExpr node, Boolean solveLambdas)` method, we can extract several distinct operations into their own methods. This will help to clarify the purpose of each section of the code and reduce the complexity of the main method.\n\nHere\u2019s the refactored code with extracted methods:\n\n```java\n@Override\npublic ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n    if (!(demandParentNode(node) instanceof MethodCallExpr)) {\n        throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n    }\n\n    MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n    int pos = JavaParserSymbolDeclaration.getParamPos(node);\n    SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n    \n    if (!refMethod.isSolved()) {\n        throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n    }\n\n    Log.trace(\"getType on lambda expr %s\", () -> refMethod.getCorrespondingDeclaration().getName());\n    \n    if (solveLambdas) {\n        return handleLambdaWithSolving(node, callExpr, pos, refMethod);\n    } else {\n        return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n    }\n}\n\nprivate ResolvedType handleLambdaWithSolving(LambdaExpr node, MethodCallExpr callExpr, int pos, SymbolReference<ResolvedMethodDeclaration> refMethod) {\n    ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n    if (callExpr.hasScope()) {\n        result = adjustResultForScope(callExpr, result);\n    }\n\n    Context ctx = JavaParserFactory.getContext(node, typeSolver);\n    result = solveGenericTypes(result, ctx);\n\n    Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n    if (functionalMethod.isPresent()) {\n        return inferTypesFromFunctionalMethod(node, result, functionalMethod.get());\n    }\n\n    return result;\n}\n\nprivate ResolvedType adjustResultForScope(MethodCallExpr callExpr, ResolvedType result) {\n    Expression scope = callExpr.getScope().get();\n    boolean staticCall = isStaticCall(scope);\n\n    if (!staticCall) {\n        ResolvedType scopeType = facade.getType(scope);\n        if (scopeType.isReferenceType()) {\n            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n        }\n    }\n    return result;\n}\n\nprivate boolean isStaticCall(Expression scope) {\n    if (scope instanceof NameExpr) {\n        NameExpr nameExpr = (NameExpr) scope;\n        try {\n            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n            return type.isSolved();\n        } catch (Exception e) {\n            // Log or handle exception if necessary\n        }\n    }\n    return false;\n}\n\nprivate ResolvedType inferTypesFromFunctionalMethod(LambdaExpr lambdaExpr, ResolvedType result, MethodUsage functionalMethod) {\n    InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n    InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n    ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.getDeclaration().declaringType(), typeSolver);\n    lambdaCtx.addPair(result, functionalInterfaceType);\n\n    ResolvedType actualType = getActualTypeFromLambdaBody(lambdaExpr);\n    ResolvedType formalType = functionalMethod.returnType();\n\n    funcInterfaceCtx.addPair(formalType, actualType);\n    ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n    if (!(formalType instanceof ResolvedVoidType)) {\n        lambdaCtx.addPair(result, functionalTypeWithReturn);\n        result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n    }\n\n    return result;\n}\n\nprivate ResolvedType getActualTypeFromLambdaBody(LambdaExpr lambdaExpr) {\n    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n        return facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n    } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n        return getReturnTypeFromBlock((BlockStmt) lambdaExpr.getBody());\n    } else {\n        throw new UnsupportedOperationException();\n    }\n}\n\nprivate ResolvedType getReturnTypeFromBlock(BlockStmt blockStmt) {\n    List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n    if (!returnStmts.isEmpty()) {\n        return returnStmts.stream()\n                .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                .findFirst()\n                .orElse(ResolvedVoidType.INSTANCE);\n    } else {\n        return ResolvedVoidType.INSTANCE;\n    }\n}\n```\n\n### Explanation of Changes:\n1. **Extracted Methods**: The main logic of the `visit` method was broken down into smaller methods:\n   - `handleLambdaWithSolving`: Handles the logic when solving lambdas.\n   - `adjustResultForScope`: Adjusts the result based on the scope of the method call.\n   - `isStaticCall`: Determines if the method call is static.\n   - `inferTypesFromFunctionalMethod`: Infers types based on the functional method.\n   - `getActualTypeFromLambdaBody`: Retrieves the actual type from the lambda body.\n   - `getReturnTypeFromBlock`: Extracts the return type from a block statement.\n\n2. **Improved Readability**: Each method now has a single responsibility, making the code easier to read and maintain.\n\n3. **Reduced Complexity**: The main `visit` method is now much shorter and focuses on the high-level flow of logic, delegating specific tasks to helper methods.\n\nThis refactoring enhances the modularity and clarity of the code, making it easier to understand and modify in the future.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n\n                // The type parameter referred here should be the java.util.stream.Stream.T\n                ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr = node;\n\n                    InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n                    InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n                    // At this point parameterType\n                    // if Function<T=? super Stream.T, ? extends map.R>\n                    // we should replace Stream.T\n                    ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n                    lambdaCtx.addPair(result, functionalInterfaceType);\n\n                    ResolvedType actualType;\n\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n                    } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                        BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                        // Get all the return statements in the lambda block\n                        List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                        if (returnStmts.size() > 0) {\n                            actualType = returnStmts.stream()\n                                    .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                                    .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                                    .findFirst()\n                                    .orElse(ResolvedVoidType.INSTANCE);\n\n                        } else {\n                            actualType = ResolvedVoidType.INSTANCE;\n                        }\n\n\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    ResolvedType formalType = functionalMethod.get().returnType();\n\n                    // Infer the functional interfaces' return vs actual type\n                    funcInterfaceCtx.addPair(formalType, actualType);\n                    // Substitute to obtain a new type\n                    ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n                    // if the functional method returns void anyway\n                    // we don't need to bother inferring types\n                    if (!(formalType instanceof ResolvedVoidType)) {\n                        lambdaCtx.addPair(result, functionalTypeWithReturn);\n                        result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n                    }\n                }\n\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }\n\nClass content:\n/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solveGenericTypes;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.ArrayAccessExpr;\nimport com.github.javaparser.ast.expr.ArrayCreationExpr;\nimport com.github.javaparser.ast.expr.ArrayInitializerExpr;\nimport com.github.javaparser.ast.expr.AssignExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.BooleanLiteralExpr;\nimport com.github.javaparser.ast.expr.CastExpr;\nimport com.github.javaparser.ast.expr.CharLiteralExpr;\nimport com.github.javaparser.ast.expr.ClassExpr;\nimport com.github.javaparser.ast.expr.ConditionalExpr;\nimport com.github.javaparser.ast.expr.DoubleLiteralExpr;\nimport com.github.javaparser.ast.expr.EnclosedExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.InstanceOfExpr;\nimport com.github.javaparser.ast.expr.IntegerLiteralExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.LongLiteralExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.NullLiteralExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.StringLiteralExpr;\nimport com.github.javaparser.ast.expr.SuperExpr;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.expr.UnaryExpr;\nimport com.github.javaparser.ast.expr.VariableDeclarationExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.ReturnStmt;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnknownType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.symbolsolver.logic.InferenceContext;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.Value;\nimport com.github.javaparser.symbolsolver.model.typesystem.NullType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.MyObjectProvider;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.github.javaparser.utils.Log;\nimport com.github.javaparser.utils.Pair;\nimport com.google.common.collect.ImmutableList;\n\npublic class TypeExtractor extends DefaultVisitorAdapter {\n\n    private static final String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private TypeSolver typeSolver;\n    private JavaParserFacade facade;\n    \n    private ReferenceTypeImpl StringReferenceType;\n\n    public TypeExtractor(TypeSolver typeSolver, JavaParserFacade facade) {\n        this.typeSolver = typeSolver;\n        this.facade = facade;\n        //pre-calculate the String reference (optimization)\n        StringReferenceType = new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(JAVA_LANG_STRING), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarator node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof FieldDeclaration) {\n            return facade.convertToUsageVariableType(node);\n        } else if (demandParentNode(node) instanceof VariableDeclarationExpr) {\n            return facade.convertToUsageVariableType(node);\n        }\n        throw new UnsupportedOperationException(demandParentNode(node).getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(Parameter node, Boolean solveLambdas) {\n        if (node.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + node);\n        }\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n\n    @Override\n    public ResolvedType visit(ArrayAccessExpr node, Boolean solveLambdas) {\n        ResolvedType arrayUsageType = node.getName().accept(this, solveLambdas);\n        if (arrayUsageType.isArray()) {\n            return ((ResolvedArrayType) arrayUsageType).getComponentType();\n        }\n        return arrayUsageType;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayCreationExpr node, Boolean solveLambdas) {\n        ResolvedType res = facade.convertToUsage(node.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i = 0; i < node.getLevels().size(); i++) {\n            res = new ResolvedArrayType(res);\n        }\n        return res;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayInitializerExpr node, Boolean solveLambdas) {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(AssignExpr node, Boolean solveLambdas) {\n        return node.getTarget().accept(this, solveLambdas);\n    }\n\n    @Override\n    public ResolvedType visit(BinaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case PLUS:\n            case MINUS:\n            case DIVIDE:\n            case MULTIPLY:\n            case REMAINDER:\n            case BINARY_AND:\n            case BINARY_OR:\n            case XOR:\n                return facade.getBinaryTypeConcrete(node.getLeft(), node.getRight(), solveLambdas, node.getOperator());\n            case LESS_EQUALS:\n            case LESS:\n            case GREATER:\n            case GREATER_EQUALS:\n            case EQUALS:\n            case NOT_EQUALS:\n            case OR:\n            case AND:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case SIGNED_RIGHT_SHIFT:\n            case UNSIGNED_RIGHT_SHIFT:\n            case LEFT_SHIFT:\n                ResolvedType rt = node.getLeft().accept(this, solveLambdas);\n                // apply unary primitive promotion\n                return ResolvedPrimitiveType.unp(rt);\n            default:\n                throw new UnsupportedOperationException(\"Operator \" + node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(CastExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    @Override\n    public ResolvedType visit(ClassExpr node, Boolean solveLambdas) {\n        // This implementation does not regard the actual type argument of the ClassExpr.\n        Type astType = node.getType();\n        ResolvedType jssType = facade.convertToUsage(astType, node.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    }\n\n    /*\n     * The conditional operator has three operand expressions. ? appears between the first and second expressions, and\n     * : appears between the second and third expressions.\n     * There are three kinds of conditional expressions, classified according to the second and third operand\n     * expressions: boolean conditional expressions, numeric conditional expressions, and reference conditional\n     * expressions.\n     * The classification rules are as follows:\n     * 1/ If both the second and the third operand expressions are boolean expressions, the conditional expression is a\n     * boolean conditional expression.\n     * 2/ If both the second and the third operand expressions are numeric expressions, the conditional expression is a\n     * numeric conditional expression.\n     * 3/ Otherwise, the conditional expression is a reference conditional expression\n     */\n    @Override\n    public ResolvedType visit(ConditionalExpr node, Boolean solveLambdas) {\n        ResolvedType thenExpr = node.getThenExpr().accept(this, solveLambdas);\n        ResolvedType elseExpr = node.getElseExpr().accept(this, solveLambdas);\n        \n        // manage null expression\n        if ( thenExpr.isNull()) {\n            return  elseExpr;\n        }\n        if ( elseExpr.isNull()) {\n            return  thenExpr;\n        }\n        /*\n         * Boolean conditional expressions are standalone expressions\n         * The type of a boolean conditional expression is determined as follows:\n         * If the second and third operands are both of type Boolean, the conditional expression has type Boolean.\n         * Otherwise, the conditional expression has type boolean.\n         */\n        if ( thenExpr.isAssignableBy(ResolvedPrimitiveType.BOOLEAN) \n                && elseExpr.isAssignableBy(ResolvedPrimitiveType.BOOLEAN)) {\n            if (thenExpr.isReferenceType() && elseExpr.isReferenceType()) {\n                return thenExpr.asReferenceType();\n            }\n            return thenExpr.isPrimitive() ? thenExpr : elseExpr;\n        }\n        \n        /*\n         * Numeric conditional expressions are standalone expressions (\u00a715.2).\n         * The type of a numeric conditional expression is determined as follows:\n         * If the second and third operands have the same type, then that is the type of the conditional expression.\n         * If one of the second and third operands is of primitive type T, and the type of the other is the result of\n         * applying boxing conversion (\u00a75.1.7) to T, then the type of the conditional expression is T.\n         * If one of the operands is of type byte or Byte and the other is of type short or Short, then the type of the\n         * conditional expression is short.\n         * If one of the operands is of type T where T is byte, short, or char, and the other operand is a constant\n         * expression (\u00a715.28) of type int whose value is representable in type T, then the type of the conditional\n         * expression is T.\n         * If one of the operands is of type T, where T is Byte, Short, or Character, and the other operand is a\n         * constant expression of type int whose value is representable in the type U which is the result of applying\n         * unboxing conversion to T, then the type of the conditional expression is U.\n         * Otherwise, binary numeric promotion (\u00a75.6.2) is applied to the operand types, and the type of the\n         * conditional expression is the promoted type of the second and third operands.\n         */\n        if (thenExpr.isNumericType() && elseExpr.isNumericType()) {\n            ResolvedPrimitiveType[] resolvedPrimitiveTypeSubList = new ResolvedPrimitiveType[] {ResolvedPrimitiveType.BYTE, ResolvedPrimitiveType.SHORT, ResolvedPrimitiveType.CHAR};\n            /*\n             *  If the second and third operands have the same type, then that is the type of the conditional expression.\n             */\n            String qnameTypeThenExpr = thenExpr.isPrimitive() ? thenExpr.asPrimitive().describe()\n                    : thenExpr.asReferenceType().describe();\n            String qnameTypeElseExpr = elseExpr.isPrimitive() ? elseExpr.asPrimitive().describe()\n                    : elseExpr.asReferenceType().describe();\n            if (qnameTypeThenExpr.equals(qnameTypeElseExpr)) {\n                return thenExpr;\n            }\n            /*\n             * If one of the second and third operands is of primitive type T, and the type of the other is the result of\n             * applying boxing conversion (\u00a75.1.7) to T, then the type of the conditional expression is T.\n             */\n            else if ((thenExpr.isPrimitive() && elseExpr.isReferenceType()\n                    && isCompatible(elseExpr.asReferenceType(), thenExpr.asPrimitive()))) {\n                return thenExpr;\n            } else if ((elseExpr.isPrimitive() && thenExpr.isReferenceType()\n                    && isCompatible(thenExpr.asReferenceType(), elseExpr.asPrimitive()))) {\n                return elseExpr;\n            }\n            /*\n             * If one of the operands is of type byte or Byte and the other is of type short or Short, then the type of the\n             * conditional expression is short.\n             */\n            else if ((isCompatible(thenExpr, ResolvedPrimitiveType.BYTE) && isCompatible(elseExpr, ResolvedPrimitiveType.SHORT))\n                    || (isCompatible(elseExpr, ResolvedPrimitiveType.BYTE) && isCompatible(thenExpr, ResolvedPrimitiveType.SHORT))) {\n                return ResolvedPrimitiveType.SHORT;\n            }\n            /*\n             *  If one of the operands is of type T where T is byte, short, or char, and the\n             *  other operand is a constant expression (\u00a715.28) of type int whose value is\n             *  representable in type T, then the type of the conditional expression is T\n             *  How can we know if the constant expression of type int is representable in type T ?\n             *  \"The constant expression of type int is representable in type T\" is a runtime decision!\n             */\n            else if (thenExpr.isPrimitive() && elseExpr.isPrimitive()) {\n                if (((ResolvedPrimitiveType)thenExpr).in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)elseExpr).equals(ResolvedPrimitiveType.INT)) {\n                    return thenExpr;\n                } else if (((ResolvedPrimitiveType)elseExpr).in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)thenExpr).equals(ResolvedPrimitiveType.INT)) {\n                    return elseExpr;\n                }\n            }\n             /*  If one of the operands is of type T, where T is Byte, Short, or Character,\n             * and the other operand is a constant expression of type int whose value is\n             * representable in the type U which is the result of applying unboxing\n             * conversion to T, then the type of the conditional expression is U.\n             * A priori this is a runtime decision!\n             */\n            else if (thenExpr.isReference() && elseExpr.isPrimitive()\n                    && thenExpr.asReferenceType().isUnboxable()\n                    && thenExpr.asReferenceType().toUnboxedType().get().in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)elseExpr).equals(ResolvedPrimitiveType.INT)) {\n                return thenExpr.asReferenceType().toUnboxedType().get();\n            } else if (elseExpr.isReference() && thenExpr.isPrimitive()\n                    && elseExpr.asReferenceType().isUnboxable()\n                    && elseExpr.asReferenceType().toUnboxedType().get().in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)thenExpr).equals(ResolvedPrimitiveType.INT)) {\n                return elseExpr.asReferenceType().toUnboxedType().get();\n            }\n             \n            /* Otherwise, binary numeric promotion (\u00a75.6.2) is applied to the operand types,\n             * and the type of the conditional expression is the promoted type of the second\n             * and third operands.\n             */\n            ResolvedPrimitiveType PrimitiveThenExpr = thenExpr.isPrimitive() ? thenExpr.asPrimitive()\n                    : thenExpr.asReferenceType().toUnboxedType().get();\n            ResolvedPrimitiveType PrimitiveElseExpr = elseExpr.isPrimitive() ? elseExpr.asPrimitive()\n                    : elseExpr.asReferenceType().toUnboxedType().get();\n            return PrimitiveThenExpr.bnp(PrimitiveElseExpr);\n        }\n        \n        /*\n         * Otherwise, the conditional expression is a reference conditional expression.\n         * A reference conditional expression is a poly expression if it appears in an assignment context or an\n         * invocation context (\u00a75.2. \u00a75.3).\n         * Otherwise, it is a standalone expression.\n         * The type of a poly reference conditional expression is the same as its target type.\n         * The type of a standalone reference conditional expression is determined as follows:\n         * If the second and third operands have the same type (which may be the null type), then that is the type of\n         * the conditional expression.\n         * If the type of one of the second and third operands is the null type, and the type of the other operand is a\n         * reference type, then the type of the conditional expression is that reference type.\n         * Otherwise, the second and third operands are of types S1 and S2 respectively. Let T1 be the type that\n         * results from applying boxing conversion to S1, and let T2 be the type that results from applying boxing\n         * conversion to S2. The type of the conditional expression is the result of applying capture conversion\n         * (\u00a75.1.10) to lub(T1, T2).\n         * TODO : must be implemented\n         */\n        if (node.isPolyExpression()) {\n            // The type of a poly reference conditional expression is the same as its target type.\n            Optional<Node> parentNode = node.getParentNode();\n            if (parentNode.isPresent()) {\n                Node parent = parentNode.get();\n                if (parent instanceof AssignExpr) {\n                    return visit((AssignExpr)parent, solveLambdas);\n                } else if (parent instanceof MethodCallExpr) {\n                    // how to define the target type?\n                    // a priori it is the type of the parameter of the method which takes the value of the conditional expression\n                    // TODO for the moment we keep the original return type\n                    return thenExpr;\n                }\n                throw new RuntimeException(\"Cannot resolve type of poly expression \"+ node.toString());\n            } else {\n                throw new RuntimeException(\"Parent node unexpectedly empty\");\n            }\n            \n        }\n        \n        // The type of a standalone reference conditional expression is determined as follows:\n        \n        // If the second and third operands have the same type (which may be the null type), then that is the type of\n        // the conditional expression.\n        if (thenExpr.equals(elseExpr)) {\n            return thenExpr;\n        }\n        // If the type of one of the second and third operands is the null type, and the type of the other operand is a\n        // reference type, then the type of the conditional expression is that reference type.\n        // this case is already supported above\n        \n        // Otherwise, the second and third operands are of types S1 and S2 respectively. Let T1 be the type that\n        // results from applying boxing conversion to S1, and let T2 be the type that results from applying boxing\n        // conversion to S2. The type of the conditional expression is the result of applying capture conversion\n        // (\u00a75.1.10) to lub(T1, T2).\n        ResolvedType resolvedThenType = thenExpr.isPrimitive() ? TypeHelper.toBoxedType(thenExpr.asPrimitive(), typeSolver) : thenExpr;\n        ResolvedType resolvedElseType = elseExpr.isPrimitive() ? TypeHelper.toBoxedType(elseExpr.asPrimitive(), typeSolver) : elseExpr;\n        \n        // TypeHelper.leastUpperBound method is not yet implemented so for the moment we keep the original return type of this method\n        // TODO implement TypeHelper.leastUpperBound method\n        // return TypeHelper.leastUpperBound(new HashSet<ResolvedType>(Arrays.asList(resolvedThenType, resolvedElseType)));\n        return node.getThenExpr().accept(this, solveLambdas);\n    }\n    \n    private boolean isCompatible(ResolvedType resolvedType, ResolvedPrimitiveType primitiveType) {\n        return (resolvedType.isPrimitive() && resolvedType.asPrimitive().equals(primitiveType))\n        || (resolvedType.isReferenceType() && resolvedType.asReferenceType().isUnboxableTo(primitiveType));\n    }\n\n    @Override\n    public ResolvedType visit(EnclosedExpr node, Boolean solveLambdas) {\n        return node.getInner().accept(this, solveLambdas);\n    }\n\n    /**\n     * Java Parser can't differentiate between packages, internal types, and fields.\n     * All three are lumped together into FieldAccessExpr. We need to differentiate them.\n     */\n    private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {\n        // Fields and internal type declarations cannot have the same name.\n        // Thus, these checks will always be mutually exclusive.\n        if (parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())) {\n            return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();\n        } else if (parentType.hasField(node.getName().getId())) {\n            return parentType.getField(node.getName().getId()).getType();\n        } else if (parentType.hasInternalType(node.getName().getId())) {\n            return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()), typeSolver);\n        } else {\n            throw new UnsolvedSymbolException(node.getName().getId());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(InstanceOfExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(StringLiteralExpr node, Boolean solveLambdas) {\n        return StringReferenceType;\n    }\n\n    @Override\n    public ResolvedType visit(IntegerLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.INT;\n    }\n\n    @Override\n    public ResolvedType visit(LongLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.LONG;\n    }\n\n    @Override\n    public ResolvedType visit(CharLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.CHAR;\n    }\n\n    @Override\n    public ResolvedType visit(DoubleLiteralExpr node, Boolean solveLambdas) {\n        if (node.getValue().toLowerCase().endsWith(\"f\")) {\n            return ResolvedPrimitiveType.FLOAT;\n        }\n        return ResolvedPrimitiveType.DOUBLE;\n    }\n\n    @Override\n    public ResolvedType visit(BooleanLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(NullLiteralExpr node, Boolean solveLambdas) {\n        return NullType.INSTANCE;\n    }\n\n    @Override\n    public ResolvedType visit(MethodCallExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on method call %s\", ()-> node);\n        // first solve the method\n        MethodUsage ref = facade.solveMethodAsUsage(node);\n        Log.trace(\"getType on method call %s resolved to %s\", ()-> node, ()-> ref);\n        Log.trace(\"getType on method call %s return type is %s\", ()-> node, ref::returnType);\n        return ref.returnType();\n        // the type is the return type of the method\n    }\n\n    @Override\n    public ResolvedType visit(NameExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on name expr %s\", ()-> node);\n        Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, node.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    }\n\n    @Override\n    public ResolvedType visit(TypeExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on type expr %s\", ()-> node);\n        if (!(node.getType() instanceof ClassOrInterfaceType)) {\n            // TODO / FIXME... e.g. System.out::println\n            throw new UnsupportedOperationException(node.getType().getClass().getCanonicalName());\n        }\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) node.getType();\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = JavaParserFactory\n                .getContext(classOrInterfaceType, typeSolver)\n                .solveType(classOrInterfaceType.getName().getId());\n        if (!typeDeclarationSymbolReference.isSolved()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, classOrInterfaceType.getName().getId());\n        } else {\n            return new ReferenceTypeImpl(typeDeclarationSymbolReference.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n    }\n\n    @Override\n    public ResolvedType visit(ObjectCreationExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n    @Override\n    public ResolvedType visit(ThisExpr node, Boolean solveLambdas) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve locally in Compilation unit\n            // first try a buttom/up approach\n            try {\n                return new ReferenceTypeImpl(\n                        facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node, className)),\n                        typeSolver);\n            } catch (IllegalStateException e) {\n                // trying another approach from type solver\n                Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n                SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n                if (clazz.isSolved()) {\n                    return new ReferenceTypeImpl(clazz.getCorrespondingDeclaration(), typeSolver);\n                }\n            }\n        }\n        return new ReferenceTypeImpl(facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node)), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(SuperExpr node, Boolean solveLambdas) {\n        // If 'super' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            String className = node.getTypeName().get().asString();\n            SymbolReference<ResolvedTypeDeclaration> resolvedTypeNameRef = JavaParserFactory.getContext(node, typeSolver).solveType(className);\n            if (resolvedTypeNameRef.isSolved()) {\n                // Cfr JLS $15.12.1\n                ResolvedTypeDeclaration resolvedTypeName = resolvedTypeNameRef.getCorrespondingDeclaration();\n                if (resolvedTypeName.isInterface()) {\n                    return new ReferenceTypeImpl(resolvedTypeName.asInterface(), typeSolver);\n                } else if (resolvedTypeName.isClass()) {\n                    // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n                    return resolvedTypeName.asClass().getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n                } else {\n                    throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n                }\n            } else {\n                throw new UnsolvedSymbolException(className);\n            }\n        }\n\n        ResolvedTypeDeclaration typeOfNode = facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node));\n        if (typeOfNode instanceof ResolvedClassDeclaration) {\n            // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n            return ((ResolvedClassDeclaration) typeOfNode).getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(UnaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case MINUS:\n            case PLUS:\n                return node.getExpression().accept(this, solveLambdas);\n            case LOGICAL_COMPLEMENT:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case POSTFIX_DECREMENT:\n            case PREFIX_DECREMENT:\n            case POSTFIX_INCREMENT:\n            case PREFIX_INCREMENT:\n            case BITWISE_COMPLEMENT:\n                return node.getExpression().accept(this, solveLambdas);\n            default:\n                throw new UnsupportedOperationException(node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarationExpr node, Boolean solveLambdas) {\n        if (node.getVariables().size() != 1) {\n            throw new UnsupportedOperationException();\n        }\n        return facade.convertToUsageVariableType(node.getVariables().get(0));\n    }\n\n\n    @Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n\n                // The type parameter referred here should be the java.util.stream.Stream.T\n                ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr = node;\n\n                    InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n                    InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n                    // At this point parameterType\n                    // if Function<T=? super Stream.T, ? extends map.R>\n                    // we should replace Stream.T\n                    ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n                    lambdaCtx.addPair(result, functionalInterfaceType);\n\n                    ResolvedType actualType;\n\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n                    } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                        BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                        // Get all the return statements in the lambda block\n                        List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                        if (returnStmts.size() > 0) {\n                            actualType = returnStmts.stream()\n                                    .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                                    .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                                    .findFirst()\n                                    .orElse(ResolvedVoidType.INSTANCE);\n\n                        } else {\n                            actualType = ResolvedVoidType.INSTANCE;\n                        }\n\n\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    ResolvedType formalType = functionalMethod.get().returnType();\n\n                    // Infer the functional interfaces' return vs actual type\n                    funcInterfaceCtx.addPair(formalType, actualType);\n                    // Substitute to obtain a new type\n                    ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n                    // if the functional method returns void anyway\n                    // we don't need to bother inferring types\n                    if (!(formalType instanceof ResolvedVoidType)) {\n                        lambdaCtx.addPair(result, functionalTypeWithReturn);\n                        result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n                    }\n                }\n\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }\n\n    @Override\n    public ResolvedType visit(MethodReferenceExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on method reference expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                MethodUsage usage = facade.solveMethodAsUsage(callExpr);\n                ResolvedType result = usage.getParamType(pos);\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethodOpt.isPresent()) {\n                    MethodUsage functionalMethod = functionalMethodOpt.get();\n\n                    for (Pair<ResolvedTypeParameterDeclaration, ResolvedType> typeParamDecl : result.asReferenceType().getTypeParametersMap()) {\n                        functionalMethod = functionalMethod.replaceTypeParameter(typeParamDecl.a, typeParamDecl.b);\n                    }\n\n                    // replace wildcards\n                    for (int i = 0; i < functionalMethod.getNoParams(); i++) {\n                        ResolvedType type = functionalMethod.getParamType(i);\n                        if (type.isWildcard()) {\n                            ResolvedType boundedType = type.asWildcard().getBoundedType();\n                            functionalMethod = functionalMethod.replaceParamType(i, boundedType);\n                        }\n                    }\n\n                    ResolvedType actualType = facade.toMethodUsage(node, functionalMethod.getParamTypes()).returnType();\n                    ResolvedType formalType = functionalMethod.returnType();\n\n                    InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                    inferenceContext.addPair(formalType, actualType);\n                    result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                }\n\n                return result;\n            }\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n        }\n        throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n    }\n\n    @Override\n    public ResolvedType visit(FieldDeclaration node, Boolean solveLambdas) {\n        if (node.getVariables().size() == 1) {\n            return node.getVariables().get(0).accept(this, solveLambdas);\n        }\n        throw new IllegalArgumentException(\"Cannot resolve the type of a field with multiple variable declarations. Pick one\");\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract And Move Method", "description": "Extract And Move Method\tpublic internalTypes() : Set<ResolvedReferenceTypeDeclaration> extracted from public internalTypes() : Set<ResolvedReferenceTypeDeclaration> in class com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration & moved to class com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeAdapter", "diffLocations": [{"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java", "startLine": 359, "endLine": 371, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java", "startLine": 357, "endLine": 360, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java", "startLine": 187, "endLine": 198, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n        // Use a special Set implementation that avoids calculating the hashCode of the node,\n        // since this can be very time-consuming for big node trees, and we are sure there are\n        // no duplicates in the members list.\n        Set<ResolvedReferenceTypeDeclaration> res = Collections.newSetFromMap(new IdentityHashMap<>());\n        for (BodyDeclaration<?> member : this.wrappedNode.getMembers()) {\n            if (member instanceof TypeDeclaration) {\n                res.add(JavaParserFacade.get(typeSolver).getTypeDeclaration((TypeDeclaration) member));\n            }\n        }\n        return res;\n    }", "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java", "isPureRefactoring": true, "commitId": "c378a677ebcd999d853b3e5867ac7ca7cd8e73cb", "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.declarations", "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration", "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration#internalTypes", "classSignatureBefore": "public class JavaParserInterfaceDeclaration extends AbstractTypeDeclaration\n        implements ResolvedInterfaceDeclaration, MethodResolutionCapability, MethodUsageResolutionCapability ", "methodNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration#internalTypes"], "classNameBeforeSet": ["com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration"], "classSignatureBeforeSet": ["public class JavaParserInterfaceDeclaration extends AbstractTypeDeclaration\n        implements ResolvedInterfaceDeclaration, MethodResolutionCapability, MethodUsageResolutionCapability "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.declarations;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.AccessSpecifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedInterfaceDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.core.resolution.MethodUsageResolutionCapability;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\nimport com.github.javaparser.symbolsolver.logic.AbstractTypeDeclaration;\nimport com.github.javaparser.symbolsolver.logic.MethodResolutionCapability;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.LazyType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\n\n/**\n * @author Federico Tomassetti\n */\npublic class JavaParserInterfaceDeclaration extends AbstractTypeDeclaration\n        implements ResolvedInterfaceDeclaration, MethodResolutionCapability, MethodUsageResolutionCapability {\n\n    private TypeSolver typeSolver;\n    private ClassOrInterfaceDeclaration wrappedNode;\n    private JavaParserTypeAdapter<ClassOrInterfaceDeclaration> javaParserTypeAdapter;\n\n    public JavaParserInterfaceDeclaration(ClassOrInterfaceDeclaration wrappedNode, TypeSolver typeSolver) {\n        if (!wrappedNode.isInterface()) {\n            throw new IllegalArgumentException();\n        }\n        this.wrappedNode = wrappedNode;\n        this.typeSolver = typeSolver;\n        this.javaParserTypeAdapter = new JavaParserTypeAdapter<>(wrappedNode, typeSolver);\n    }\n\n    @Override\n    public Set<ResolvedMethodDeclaration> getDeclaredMethods() {\n        Set<ResolvedMethodDeclaration> methods = new HashSet<>();\n        for (BodyDeclaration<?> member : wrappedNode.getMembers()) {\n            if (member instanceof com.github.javaparser.ast.body.MethodDeclaration) {\n                methods.add(new JavaParserMethodDeclaration((com.github.javaparser.ast.body.MethodDeclaration) member, typeSolver));\n            }\n        }\n        return methods;\n    }\n\n    public Context getContext() {\n        return JavaParserFactory.getContext(wrappedNode, typeSolver);\n    }\n\n    public ResolvedType getUsage(Node node) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        JavaParserInterfaceDeclaration that = (JavaParserInterfaceDeclaration) o;\n\n        if (!wrappedNode.equals(that.wrappedNode)) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return wrappedNode.hashCode();\n    }\n\n    @Override\n    public String getName() {\n        return wrappedNode.getName().getId();\n    }\n\n    @Override\n    public ResolvedInterfaceDeclaration asInterface() {\n        return this;\n    }\n\n    @Override\n    public boolean hasDirectlyAnnotation(String canonicalName) {\n        return AstResolutionUtils.hasDirectlyAnnotation(wrappedNode, typeSolver, canonicalName);\n    }\n\n    @Override\n    public boolean isInterface() {\n        return true;\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getInterfacesExtended() {\n        List<ResolvedReferenceType> interfaces = new ArrayList<>();\n        for (ClassOrInterfaceType t : wrappedNode.getExtendedTypes()) {\n            interfaces.add(new ReferenceTypeImpl(\n                    solveType(t.getName().getId()).getCorrespondingDeclaration().asInterface(), typeSolver));\n        }\n        return interfaces;\n    }\n\n    @Override\n    public String getPackageName() {\n        return javaParserTypeAdapter.getPackageName();\n    }\n\n    @Override\n    public String getClassName() {\n        return javaParserTypeAdapter.getClassName();\n    }\n\n    @Override\n    public String getQualifiedName() {\n        return javaParserTypeAdapter.getQualifiedName();\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedReferenceTypeDeclaration other) {\n        return javaParserTypeAdapter.isAssignableBy(other);\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedType type) {\n        return javaParserTypeAdapter.isAssignableBy(type);\n    }\n\n    @Override\n    public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other) {\n        // TODO consider generic types\n        if (this.getQualifiedName().equals(other.getQualifiedName())) {\n            return true;\n        }\n        if (this.wrappedNode.getExtendedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getExtendedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (this.wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean isTypeParameter() {\n        return false;\n    }\n\n    @Override\n    public List<ResolvedFieldDeclaration> getAllFields() {\n        List<ResolvedFieldDeclaration> fields = javaParserTypeAdapter.getFieldsForDeclaredVariables();\n\n        getAncestors()\n                .stream()\n                .filter(ancestor -> ancestor.getTypeDeclaration().isPresent())\n                .forEach(ancestor -> ancestor.getTypeDeclaration().get()\n                        .getAllFields()\n                        .forEach(f -> {\n                            fields.add(new ResolvedFieldDeclaration() {\n\n                                @Override\n                                public AccessSpecifier accessSpecifier() {\n                                    return f.accessSpecifier();\n                                }\n\n                                @Override\n                                public String getName() {\n                                    return f.getName();\n                                }\n\n                                @Override\n                                public ResolvedType getType() {\n                                    return ancestor.useThisTypeParametersOnTheGivenType(f.getType());\n                                }\n\n                                @Override\n                                public boolean isStatic() {\n                                    return f.isStatic();\n                                }\n\n                                @Override\n                                public ResolvedTypeDeclaration declaringType() {\n                                    return f.declaringType();\n                                }\n                                \n                                @Override\n                                public Optional<FieldDeclaration> toAst() {\n                                    return f.toAst();\n                                }\n                            });\n                        })\n                );\n        \n        return fields;\n    }\n\n\n    @Override\n    public String toString() {\n        return \"JavaParserInterfaceDeclaration{\" +\n                \"wrappedNode=\" + wrappedNode +\n                '}';\n    }\n\n    /**\n     * This method is deprecated because it receives the TypesSolver as a parameter.\n     * Eventually we would like to remove all usages of TypeSolver as a parameter.\n     *\n     * Also, resolution should move out of declarations, so that they are pure declarations and the resolution should\n     * work for JavaParser, Reflection and Javassist classes in the same way and not be specific to the three\n     * implementations.\n     */\n    @Deprecated\n    public SymbolReference<ResolvedTypeDeclaration> solveType(String name) {\n        if (this.wrappedNode.getName().getId().equals(name)) {\n            return SymbolReference.solved(this);\n        }\n        SymbolReference<ResolvedTypeDeclaration> ref = javaParserTypeAdapter.solveType(name);\n        if (ref.isSolved()) {\n            return ref;\n        }\n\n        String prefix = wrappedNode.getName() + \".\";\n        if (name.startsWith(prefix) && name.length() > prefix.length()) {\n            return new JavaParserInterfaceDeclaration(this.wrappedNode, typeSolver).solveType(name.substring(prefix.length()));\n        }\n\n        return getContext().getParent()\n                .orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\"))\n                .solveType(name);\n    }\n\n    @Override\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes,\n                                                                  boolean staticOnly) {\n        return getContext().solveMethod(name, argumentsTypes, staticOnly);\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentTypes,\n                                                    Context invocationContext, List<ResolvedType> typeParameters) {\n        return getContext().solveMethodAsUsage(name, argumentTypes);\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n        if (wrappedNode.getExtendedTypes() != null) {\n            for (ClassOrInterfaceType extended : wrappedNode.getExtendedTypes()) {\n                try {\n                    ancestors.add(toReferenceType(extended));\n                } catch (UnsolvedSymbolException e) {\n                    if (!acceptIncompleteList) {\n                        // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n                        throw e;\n                    }\n                }\n            }\n        }\n\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n                try {\n                    ancestors.add(toReferenceType(implemented));\n                } catch (UnsolvedSymbolException e) {\n                    if (!acceptIncompleteList) {\n                        // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n                        throw e;\n                    }\n                }\n            }\n        }\n        return ancestors;\n    }\n\n    @Override\n    public List<ResolvedTypeParameterDeclaration> getTypeParameters() {\n        if (this.wrappedNode.getTypeParameters() == null) {\n            return Collections.emptyList();\n        } else {\n            return this.wrappedNode.getTypeParameters().stream().map(\n                    (tp) -> new JavaParserTypeParameter(tp, typeSolver)\n            ).collect(Collectors.toList());\n        }\n    }\n\n    /**\n     * Returns the JavaParser node associated with this JavaParserInterfaceDeclaration.\n     *\n     * @return A visitable JavaParser node wrapped by this object.\n     */\n    public ClassOrInterfaceDeclaration getWrappedNode() {\n        return wrappedNode;\n    }\n\n    @Override\n    public AccessSpecifier accessSpecifier() {\n        return wrappedNode.getAccessSpecifier();\n    }\n\n    @Override\n    public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n        // Use a special Set implementation that avoids calculating the hashCode of the node,\n        // since this can be very time-consuming for big node trees, and we are sure there are\n        // no duplicates in the members list.\n        Set<ResolvedReferenceTypeDeclaration> res = Collections.newSetFromMap(new IdentityHashMap<>());\n        for (BodyDeclaration<?> member : this.wrappedNode.getMembers()) {\n            if (member instanceof TypeDeclaration) {\n                res.add(JavaParserFacade.get(typeSolver).getTypeDeclaration((TypeDeclaration) member));\n            }\n        }\n        return res;\n    }\n\n    @Override\n    public Optional<ResolvedReferenceTypeDeclaration> containerType() {\n        return javaParserTypeAdapter.containerType();\n    }\n\n    @Override\n    public List<ResolvedConstructorDeclaration> getConstructors() {\n        return Collections.emptyList();\n    }\n\n    @Override\n    public Optional<ClassOrInterfaceDeclaration> toAst() {\n        return Optional.of(wrappedNode);\n    }\n\n    ///\n    /// Private methods\n    ///\n\n    private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType) {\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = null;\n        String typeName = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            typeName = classOrInterfaceType.getScope().get().asString() + \".\" + typeName;\n        }\n\n        if (typeName.indexOf('.') > -1) {\n            ref = typeSolver.tryToSolveType(typeName);\n        }\n        if (ref == null || !ref.isSolved()) {\n            ref = solveType(typeName);\n        }\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());\n        }\n        if (!classOrInterfaceType.getTypeArguments().isPresent()) {\n            return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n        List<ResolvedType> superClassTypeParameters = classOrInterfaceType.getTypeArguments().get()\n                .stream().map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta, ta)))\n                .collect(Collectors.toList());\n        return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), superClassTypeParameters, typeSolver);\n    }\n}\n", "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.declarations;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.AccessSpecifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedInterfaceDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.core.resolution.MethodUsageResolutionCapability;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\nimport com.github.javaparser.symbolsolver.logic.AbstractTypeDeclaration;\nimport com.github.javaparser.symbolsolver.logic.MethodResolutionCapability;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.LazyType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\n\n/**\n * @author Federico Tomassetti\n */\npublic class JavaParserInterfaceDeclaration extends AbstractTypeDeclaration\n        implements ResolvedInterfaceDeclaration, MethodResolutionCapability, MethodUsageResolutionCapability {\n\n    private TypeSolver typeSolver;\n    private ClassOrInterfaceDeclaration wrappedNode;\n    private JavaParserTypeAdapter<ClassOrInterfaceDeclaration> javaParserTypeAdapter;\n\n    public JavaParserInterfaceDeclaration(ClassOrInterfaceDeclaration wrappedNode, TypeSolver typeSolver) {\n        if (!wrappedNode.isInterface()) {\n            throw new IllegalArgumentException();\n        }\n        this.wrappedNode = wrappedNode;\n        this.typeSolver = typeSolver;\n        this.javaParserTypeAdapter = new JavaParserTypeAdapter<>(wrappedNode, typeSolver);\n    }\n\n    @Override\n    public Set<ResolvedMethodDeclaration> getDeclaredMethods() {\n        Set<ResolvedMethodDeclaration> methods = new HashSet<>();\n        for (BodyDeclaration<?> member : wrappedNode.getMembers()) {\n            if (member instanceof com.github.javaparser.ast.body.MethodDeclaration) {\n                methods.add(new JavaParserMethodDeclaration((com.github.javaparser.ast.body.MethodDeclaration) member, typeSolver));\n            }\n        }\n        return methods;\n    }\n\n    public Context getContext() {\n        return JavaParserFactory.getContext(wrappedNode, typeSolver);\n    }\n\n    public ResolvedType getUsage(Node node) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        JavaParserInterfaceDeclaration that = (JavaParserInterfaceDeclaration) o;\n\n        if (!wrappedNode.equals(that.wrappedNode)) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return wrappedNode.hashCode();\n    }\n\n    @Override\n    public String getName() {\n        return wrappedNode.getName().getId();\n    }\n\n    @Override\n    public ResolvedInterfaceDeclaration asInterface() {\n        return this;\n    }\n\n    @Override\n    public boolean hasDirectlyAnnotation(String canonicalName) {\n        return AstResolutionUtils.hasDirectlyAnnotation(wrappedNode, typeSolver, canonicalName);\n    }\n\n    @Override\n    public boolean isInterface() {\n        return true;\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getInterfacesExtended() {\n        List<ResolvedReferenceType> interfaces = new ArrayList<>();\n        for (ClassOrInterfaceType t : wrappedNode.getExtendedTypes()) {\n            interfaces.add(new ReferenceTypeImpl(\n                    solveType(t.getName().getId()).getCorrespondingDeclaration().asInterface(), typeSolver));\n        }\n        return interfaces;\n    }\n\n    @Override\n    public String getPackageName() {\n        return javaParserTypeAdapter.getPackageName();\n    }\n\n    @Override\n    public String getClassName() {\n        return javaParserTypeAdapter.getClassName();\n    }\n\n    @Override\n    public String getQualifiedName() {\n        return javaParserTypeAdapter.getQualifiedName();\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedReferenceTypeDeclaration other) {\n        return javaParserTypeAdapter.isAssignableBy(other);\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedType type) {\n        return javaParserTypeAdapter.isAssignableBy(type);\n    }\n\n    @Override\n    public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other) {\n        // TODO consider generic types\n        if (this.getQualifiedName().equals(other.getQualifiedName())) {\n            return true;\n        }\n        if (this.wrappedNode.getExtendedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getExtendedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (this.wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean isTypeParameter() {\n        return false;\n    }\n\n    @Override\n    public List<ResolvedFieldDeclaration> getAllFields() {\n        List<ResolvedFieldDeclaration> fields = javaParserTypeAdapter.getFieldsForDeclaredVariables();\n\n        getAncestors()\n                .stream()\n                .filter(ancestor -> ancestor.getTypeDeclaration().isPresent())\n                .forEach(ancestor -> ancestor.getTypeDeclaration().get()\n                        .getAllFields()\n                        .forEach(f -> {\n                            fields.add(new ResolvedFieldDeclaration() {\n\n                                @Override\n                                public AccessSpecifier accessSpecifier() {\n                                    return f.accessSpecifier();\n                                }\n\n                                @Override\n                                public String getName() {\n                                    return f.getName();\n                                }\n\n                                @Override\n                                public ResolvedType getType() {\n                                    return ancestor.useThisTypeParametersOnTheGivenType(f.getType());\n                                }\n\n                                @Override\n                                public boolean isStatic() {\n                                    return f.isStatic();\n                                }\n\n                                @Override\n                                public ResolvedTypeDeclaration declaringType() {\n                                    return f.declaringType();\n                                }\n                                \n                                @Override\n                                public Optional<FieldDeclaration> toAst() {\n                                    return f.toAst();\n                                }\n                            });\n                        })\n                );\n        \n        return fields;\n    }\n\n\n    @Override\n    public String toString() {\n        return \"JavaParserInterfaceDeclaration{\" +\n                \"wrappedNode=\" + wrappedNode +\n                '}';\n    }\n\n    /**\n     * This method is deprecated because it receives the TypesSolver as a parameter.\n     * Eventually we would like to remove all usages of TypeSolver as a parameter.\n     *\n     * Also, resolution should move out of declarations, so that they are pure declarations and the resolution should\n     * work for JavaParser, Reflection and Javassist classes in the same way and not be specific to the three\n     * implementations.\n     */\n    @Deprecated\n    public SymbolReference<ResolvedTypeDeclaration> solveType(String name) {\n        if (this.wrappedNode.getName().getId().equals(name)) {\n            return SymbolReference.solved(this);\n        }\n        SymbolReference<ResolvedTypeDeclaration> ref = javaParserTypeAdapter.solveType(name);\n        if (ref.isSolved()) {\n            return ref;\n        }\n\n        String prefix = wrappedNode.getName() + \".\";\n        if (name.startsWith(prefix) && name.length() > prefix.length()) {\n            return new JavaParserInterfaceDeclaration(this.wrappedNode, typeSolver).solveType(name.substring(prefix.length()));\n        }\n\n        return getContext().getParent()\n                .orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\"))\n                .solveType(name);\n    }\n\n    @Override\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes,\n                                                                  boolean staticOnly) {\n        return getContext().solveMethod(name, argumentsTypes, staticOnly);\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentTypes,\n                                                    Context invocationContext, List<ResolvedType> typeParameters) {\n        return getContext().solveMethodAsUsage(name, argumentTypes);\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n        if (wrappedNode.getExtendedTypes() != null) {\n            for (ClassOrInterfaceType extended : wrappedNode.getExtendedTypes()) {\n                try {\n                    ancestors.add(toReferenceType(extended));\n                } catch (UnsolvedSymbolException e) {\n                    if (!acceptIncompleteList) {\n                        // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n                        throw e;\n                    }\n                }\n            }\n        }\n\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n                try {\n                    ancestors.add(toReferenceType(implemented));\n                } catch (UnsolvedSymbolException e) {\n                    if (!acceptIncompleteList) {\n                        // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n                        throw e;\n                    }\n                }\n            }\n        }\n        return ancestors;\n    }\n\n    @Override\n    public List<ResolvedTypeParameterDeclaration> getTypeParameters() {\n        if (this.wrappedNode.getTypeParameters() == null) {\n            return Collections.emptyList();\n        } else {\n            return this.wrappedNode.getTypeParameters().stream().map(\n                    (tp) -> new JavaParserTypeParameter(tp, typeSolver)\n            ).collect(Collectors.toList());\n        }\n    }\n\n    /**\n     * Returns the JavaParser node associated with this JavaParserInterfaceDeclaration.\n     *\n     * @return A visitable JavaParser node wrapped by this object.\n     */\n    public ClassOrInterfaceDeclaration getWrappedNode() {\n        return wrappedNode;\n    }\n\n    @Override\n    public AccessSpecifier accessSpecifier() {\n        return wrappedNode.getAccessSpecifier();\n    }\n\n    @Override\n    public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n        return javaParserTypeAdapter.internalTypes();\n    }\n\n    @Override\n    public Optional<ResolvedReferenceTypeDeclaration> containerType() {\n        return javaParserTypeAdapter.containerType();\n    }\n\n    @Override\n    public List<ResolvedConstructorDeclaration> getConstructors() {\n        return Collections.emptyList();\n    }\n\n    @Override\n    public Optional<ClassOrInterfaceDeclaration> toAst() {\n        return Optional.of(wrappedNode);\n    }\n\n    ///\n    /// Private methods\n    ///\n\n    private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType) {\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = null;\n        String typeName = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            typeName = classOrInterfaceType.getScope().get().asString() + \".\" + typeName;\n        }\n\n        if (typeName.indexOf('.') > -1) {\n            ref = typeSolver.tryToSolveType(typeName);\n        }\n        if (ref == null || !ref.isSolved()) {\n            ref = solveType(typeName);\n        }\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());\n        }\n        if (!classOrInterfaceType.getTypeArguments().isPresent()) {\n            return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n        List<ResolvedType> superClassTypeParameters = classOrInterfaceType.getTypeArguments().get()\n                .stream().map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta, ta)))\n                .collect(Collectors.toList());\n        return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), superClassTypeParameters, typeSolver);\n    }\n}\n", "diffSourceCodeSet": ["if (this.wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Override\n    public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n        return javaParserTypeAdapter.internalTypes();\n    }\nif (this.wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }", "diffSourceCode": "-  187: \n-  188:         // TODO FIXME: Remove null check -- should be an empty list...\n-  189:         if (this.wrappedNode.getImplementedTypes() != null) {\n-  190:             for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n-  191:                 ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n-  192:                 if (ancestor.canBeAssignedTo(other)) {\n-  193:                     return true;\n-  194:                 }\n-  195:             }\n-  196:         }\n-  197: \n-  198:         return false;\n-  357:     }\n-  358: \n-  359:     @Override\n-  360:     public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n-  361:         // Use a special Set implementation that avoids calculating the hashCode of the node,\n-  362:         // since this can be very time-consuming for big node trees, and we are sure there are\n-  363:         // no duplicates in the members list.\n-  364:         Set<ResolvedReferenceTypeDeclaration> res = Collections.newSetFromMap(new IdentityHashMap<>());\n-  365:         for (BodyDeclaration<?> member : this.wrappedNode.getMembers()) {\n-  366:             if (member instanceof TypeDeclaration) {\n-  367:                 res.add(JavaParserFacade.get(typeSolver).getTypeDeclaration((TypeDeclaration) member));\n-  368:             }\n-  369:         }\n-  370:         return res;\n-  371:     }\n+  187:         if (this.wrappedNode.getImplementedTypes() != null) {\n+  188:             for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n+  189:                 ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n+  190:                 if (ancestor.canBeAssignedTo(other)) {\n+  191:                     return true;\n+  192:                 }\n+  193:             }\n+  194:         }\n+  195: \n+  196:         return false;\n+  197:     }\n+  198: \n+  357:     @Override\n+  358:     public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n+  359:         return javaParserTypeAdapter.internalTypes();\n+  360:     }\n+  361: \n+  362:     @Override\n+  363:     public Optional<ResolvedReferenceTypeDeclaration> containerType() {\n+  364:         return javaParserTypeAdapter.containerType();\n+  365:     }\n+  366: \n+  367:     @Override\n+  368:     public List<ResolvedConstructorDeclaration> getConstructors() {\n+  369:         return Collections.emptyList();\n+  370:     }\n+  371: \n", "uniqueId": "c378a677ebcd999d853b3e5867ac7ca7cd8e73cb_359_371_187_198_357_360", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 32}, "BRANCH": {"missed": 0, "covered": 4}, "LINE": {"missed": 0, "covered": 6}, "COMPLEXITY": {"missed": 0, "covered": 3}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To refactor the provided code, we will extract the logic for creating the `Set<ResolvedReferenceTypeDeclaration>` from the `internalTypes` method in the `JavaParserInterfaceDeclaration` class and move it to a new static method in the `JavaParserFacade` class. This will improve modularity and readability.\n\n### Step 1: Analyze the Code\nThe `internalTypes` method currently contains logic to create a set of `ResolvedReferenceTypeDeclaration` from the members of the `wrappedNode`. This logic can be encapsulated in a separate method.\n\n### Step 2: Extract Method\nWe will create a new public static method in the `JavaParserFacade` class that takes the `ClassOrInterfaceDeclaration` and the `TypeSolver` as parameters and returns the set of `ResolvedReferenceTypeDeclaration`.\n\n### Step 3: Move Method\nThe extracted method will be moved to `JavaParserFacade.java`.\n\n### Step 4: Update the Refactored Method\nThe `internalTypes` method in `JavaParserInterfaceDeclaration` will be updated to call the new static method from `JavaParserFacade`.\n\n### Target File Path\nThe target file path for the extracted method will be:\n```\njavaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java\n```\n\n### Extracted Method Code\nHere is the extracted method code that will be added to `JavaParserFacade`:\n```java\npublic static Set<ResolvedReferenceTypeDeclaration> extractInternalTypes(ClassOrInterfaceDeclaration wrappedNode, TypeSolver typeSolver) {\n    Set<ResolvedReferenceTypeDeclaration> res = Collections.newSetFromMap(new IdentityHashMap<>());\n    for (BodyDeclaration<?> member : wrappedNode.getMembers()) {\n        if (member instanceof TypeDeclaration) {\n            res.add(get(typeSolver).getTypeDeclaration((TypeDeclaration) member));\n        }\n    }\n    return res;\n}\n```\n\n### Refactored Method Code\nHere is the refactored `internalTypes` method in `JavaParserInterfaceDeclaration`:\n```java\n@Override\npublic Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n    return JavaParserFacade.extractInternalTypes(this.wrappedNode, typeSolver);\n}\n```\n\n### Final Output\nHere is the complete output as per the requested format:\n\n##########################\njavaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java\n##########################\npublic static Set<ResolvedReferenceTypeDeclaration> extractInternalTypes(ClassOrInterfaceDeclaration wrappedNode, TypeSolver typeSolver) {\n    Set<ResolvedReferenceTypeDeclaration> res = Collections.newSetFromMap(new IdentityHashMap<>());\n    for (BodyDeclaration<?> member : wrappedNode.getMembers()) {\n        if (member instanceof TypeDeclaration) {\n            res.add(get(typeSolver).getTypeDeclaration((TypeDeclaration) member));\n        }\n    }\n    return res;\n}\n##########################\n@Override\npublic Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n    return JavaParserFacade.extractInternalTypes(this.wrappedNode, typeSolver);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n    public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n        // Use a special Set implementation that avoids calculating the hashCode of the node,\n        // since this can be very time-consuming for big node trees, and we are sure there are\n        // no duplicates in the members list.\n        Set<ResolvedReferenceTypeDeclaration> res = Collections.newSetFromMap(new IdentityHashMap<>());\n        for (BodyDeclaration<?> member : this.wrappedNode.getMembers()) {\n            if (member instanceof TypeDeclaration) {\n                res.add(JavaParserFacade.get(typeSolver).getTypeDeclaration((TypeDeclaration) member));\n            }\n        }\n        return res;\n    }\n\nClass content:\n/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.declarations;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.AccessSpecifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedInterfaceDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.core.resolution.MethodUsageResolutionCapability;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\nimport com.github.javaparser.symbolsolver.logic.AbstractTypeDeclaration;\nimport com.github.javaparser.symbolsolver.logic.MethodResolutionCapability;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.LazyType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\n\n/**\n * @author Federico Tomassetti\n */\npublic class JavaParserInterfaceDeclaration extends AbstractTypeDeclaration\n        implements ResolvedInterfaceDeclaration, MethodResolutionCapability, MethodUsageResolutionCapability {\n\n    private TypeSolver typeSolver;\n    private ClassOrInterfaceDeclaration wrappedNode;\n    private JavaParserTypeAdapter<ClassOrInterfaceDeclaration> javaParserTypeAdapter;\n\n    public JavaParserInterfaceDeclaration(ClassOrInterfaceDeclaration wrappedNode, TypeSolver typeSolver) {\n        if (!wrappedNode.isInterface()) {\n            throw new IllegalArgumentException();\n        }\n        this.wrappedNode = wrappedNode;\n        this.typeSolver = typeSolver;\n        this.javaParserTypeAdapter = new JavaParserTypeAdapter<>(wrappedNode, typeSolver);\n    }\n\n    @Override\n    public Set<ResolvedMethodDeclaration> getDeclaredMethods() {\n        Set<ResolvedMethodDeclaration> methods = new HashSet<>();\n        for (BodyDeclaration<?> member : wrappedNode.getMembers()) {\n            if (member instanceof com.github.javaparser.ast.body.MethodDeclaration) {\n                methods.add(new JavaParserMethodDeclaration((com.github.javaparser.ast.body.MethodDeclaration) member, typeSolver));\n            }\n        }\n        return methods;\n    }\n\n    public Context getContext() {\n        return JavaParserFactory.getContext(wrappedNode, typeSolver);\n    }\n\n    public ResolvedType getUsage(Node node) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        JavaParserInterfaceDeclaration that = (JavaParserInterfaceDeclaration) o;\n\n        if (!wrappedNode.equals(that.wrappedNode)) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return wrappedNode.hashCode();\n    }\n\n    @Override\n    public String getName() {\n        return wrappedNode.getName().getId();\n    }\n\n    @Override\n    public ResolvedInterfaceDeclaration asInterface() {\n        return this;\n    }\n\n    @Override\n    public boolean hasDirectlyAnnotation(String canonicalName) {\n        return AstResolutionUtils.hasDirectlyAnnotation(wrappedNode, typeSolver, canonicalName);\n    }\n\n    @Override\n    public boolean isInterface() {\n        return true;\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getInterfacesExtended() {\n        List<ResolvedReferenceType> interfaces = new ArrayList<>();\n        for (ClassOrInterfaceType t : wrappedNode.getExtendedTypes()) {\n            interfaces.add(new ReferenceTypeImpl(\n                    solveType(t.getName().getId()).getCorrespondingDeclaration().asInterface(), typeSolver));\n        }\n        return interfaces;\n    }\n\n    @Override\n    public String getPackageName() {\n        return javaParserTypeAdapter.getPackageName();\n    }\n\n    @Override\n    public String getClassName() {\n        return javaParserTypeAdapter.getClassName();\n    }\n\n    @Override\n    public String getQualifiedName() {\n        return javaParserTypeAdapter.getQualifiedName();\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedReferenceTypeDeclaration other) {\n        return javaParserTypeAdapter.isAssignableBy(other);\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedType type) {\n        return javaParserTypeAdapter.isAssignableBy(type);\n    }\n\n    @Override\n    public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other) {\n        // TODO consider generic types\n        if (this.getQualifiedName().equals(other.getQualifiedName())) {\n            return true;\n        }\n        if (this.wrappedNode.getExtendedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getExtendedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (this.wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean isTypeParameter() {\n        return false;\n    }\n\n    @Override\n    public List<ResolvedFieldDeclaration> getAllFields() {\n        List<ResolvedFieldDeclaration> fields = javaParserTypeAdapter.getFieldsForDeclaredVariables();\n\n        getAncestors()\n                .stream()\n                .filter(ancestor -> ancestor.getTypeDeclaration().isPresent())\n                .forEach(ancestor -> ancestor.getTypeDeclaration().get()\n                        .getAllFields()\n                        .forEach(f -> {\n                            fields.add(new ResolvedFieldDeclaration() {\n\n                                @Override\n                                public AccessSpecifier accessSpecifier() {\n                                    return f.accessSpecifier();\n                                }\n\n                                @Override\n                                public String getName() {\n                                    return f.getName();\n                                }\n\n                                @Override\n                                public ResolvedType getType() {\n                                    return ancestor.useThisTypeParametersOnTheGivenType(f.getType());\n                                }\n\n                                @Override\n                                public boolean isStatic() {\n                                    return f.isStatic();\n                                }\n\n                                @Override\n                                public ResolvedTypeDeclaration declaringType() {\n                                    return f.declaringType();\n                                }\n                                \n                                @Override\n                                public Optional<FieldDeclaration> toAst() {\n                                    return f.toAst();\n                                }\n                            });\n                        })\n                );\n        \n        return fields;\n    }\n\n\n    @Override\n    public String toString() {\n        return \"JavaParserInterfaceDeclaration{\" +\n                \"wrappedNode=\" + wrappedNode +\n                '}';\n    }\n\n    /**\n     * This method is deprecated because it receives the TypesSolver as a parameter.\n     * Eventually we would like to remove all usages of TypeSolver as a parameter.\n     *\n     * Also, resolution should move out of declarations, so that they are pure declarations and the resolution should\n     * work for JavaParser, Reflection and Javassist classes in the same way and not be specific to the three\n     * implementations.\n     */\n    @Deprecated\n    public SymbolReference<ResolvedTypeDeclaration> solveType(String name) {\n        if (this.wrappedNode.getName().getId().equals(name)) {\n            return SymbolReference.solved(this);\n        }\n        SymbolReference<ResolvedTypeDeclaration> ref = javaParserTypeAdapter.solveType(name);\n        if (ref.isSolved()) {\n            return ref;\n        }\n\n        String prefix = wrappedNode.getName() + \".\";\n        if (name.startsWith(prefix) && name.length() > prefix.length()) {\n            return new JavaParserInterfaceDeclaration(this.wrappedNode, typeSolver).solveType(name.substring(prefix.length()));\n        }\n\n        return getContext().getParent()\n                .orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\"))\n                .solveType(name);\n    }\n\n    @Override\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes,\n                                                                  boolean staticOnly) {\n        return getContext().solveMethod(name, argumentsTypes, staticOnly);\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentTypes,\n                                                    Context invocationContext, List<ResolvedType> typeParameters) {\n        return getContext().solveMethodAsUsage(name, argumentTypes);\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n        if (wrappedNode.getExtendedTypes() != null) {\n            for (ClassOrInterfaceType extended : wrappedNode.getExtendedTypes()) {\n                try {\n                    ancestors.add(toReferenceType(extended));\n                } catch (UnsolvedSymbolException e) {\n                    if (!acceptIncompleteList) {\n                        // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n                        throw e;\n                    }\n                }\n            }\n        }\n\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n                try {\n                    ancestors.add(toReferenceType(implemented));\n                } catch (UnsolvedSymbolException e) {\n                    if (!acceptIncompleteList) {\n                        // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n                        throw e;\n                    }\n                }\n            }\n        }\n        return ancestors;\n    }\n\n    @Override\n    public List<ResolvedTypeParameterDeclaration> getTypeParameters() {\n        if (this.wrappedNode.getTypeParameters() == null) {\n            return Collections.emptyList();\n        } else {\n            return this.wrappedNode.getTypeParameters().stream().map(\n                    (tp) -> new JavaParserTypeParameter(tp, typeSolver)\n            ).collect(Collectors.toList());\n        }\n    }\n\n    /**\n     * Returns the JavaParser node associated with this JavaParserInterfaceDeclaration.\n     *\n     * @return A visitable JavaParser node wrapped by this object.\n     */\n    public ClassOrInterfaceDeclaration getWrappedNode() {\n        return wrappedNode;\n    }\n\n    @Override\n    public AccessSpecifier accessSpecifier() {\n        return wrappedNode.getAccessSpecifier();\n    }\n\n    @Override\n    public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n        // Use a special Set implementation that avoids calculating the hashCode of the node,\n        // since this can be very time-consuming for big node trees, and we are sure there are\n        // no duplicates in the members list.\n        Set<ResolvedReferenceTypeDeclaration> res = Collections.newSetFromMap(new IdentityHashMap<>());\n        for (BodyDeclaration<?> member : this.wrappedNode.getMembers()) {\n            if (member instanceof TypeDeclaration) {\n                res.add(JavaParserFacade.get(typeSolver).getTypeDeclaration((TypeDeclaration) member));\n            }\n        }\n        return res;\n    }\n\n    @Override\n    public Optional<ResolvedReferenceTypeDeclaration> containerType() {\n        return javaParserTypeAdapter.containerType();\n    }\n\n    @Override\n    public List<ResolvedConstructorDeclaration> getConstructors() {\n        return Collections.emptyList();\n    }\n\n    @Override\n    public Optional<ClassOrInterfaceDeclaration> toAst() {\n        return Optional.of(wrappedNode);\n    }\n\n    ///\n    /// Private methods\n    ///\n\n    private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType) {\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = null;\n        String typeName = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            typeName = classOrInterfaceType.getScope().get().asString() + \".\" + typeName;\n        }\n\n        if (typeName.indexOf('.') > -1) {\n            ref = typeSolver.tryToSolveType(typeName);\n        }\n        if (ref == null || !ref.isSolved()) {\n            ref = solveType(typeName);\n        }\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());\n        }\n        if (!classOrInterfaceType.getTypeArguments().isPresent()) {\n            return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n        List<ResolvedType> superClassTypeParameters = classOrInterfaceType.getTypeArguments().get()\n                .stream().map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta, ta)))\n                .collect(Collectors.toList());\n        return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), superClassTypeParameters, typeSolver);\n    }\n}\n\nRefactoring Operation:\nExtract And Move Method\n\nProject Structure:\n['javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/JavaSymbolSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/SourceFileInfoExtractor.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/core/resolution/Context.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/core/resolution/MethodUsageResolutionCapability.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/core/resolution/TypeVariableResolutionCapability.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/declarations/common/MethodDeclarationCommonLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparser/Navigator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparser/package-info.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/DefaultVisitorAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFactory.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/LambdaArgumentTypePlaceholder.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractJavaParserContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractMethodLikeDeclarationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AnnotationDeclarationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AnonymousClassDeclarationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BinaryExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/CatchClauseContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ClassOrInterfaceDeclarationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ClassOrInterfaceDeclarationExtendsContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/CompilationUnitContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ConstructorContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ContextHelper.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/EnclosedExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/EnumDeclarationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/FieldAccessContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ForEachStatementContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ForStatementContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/IfStatementContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/InstanceOfExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/JavaParserTypeDeclarationAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodReferenceExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ObjectCreationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/StatementContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/SwitchEntryContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/TryWithResourceContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/UnaryExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/VariableDeclarationExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/VariableDeclaratorContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/AstResolutionUtils.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/DefaultConstructorDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnnotationDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnnotationMemberDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnonymousClassDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserConstructorDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumConstantDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserFieldDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserMethodDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserParameterDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserPatternDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserSymbolDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeParameter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeVariableDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserVariableDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/AbstractSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/FieldSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/NoSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/ParameterSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/PatternSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/VariableSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/package-info.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationMemberDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistConstructorDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumConstantDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistFactory.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistFieldDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistInterfaceDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodLikeDeclarationAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistParameterDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeParameter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistUtils.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/package-info.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/AbstractClassDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/AbstractTypeDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/ConfilictingGenericTypesException.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/FunctionalInterfaceLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/InferenceContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/InferenceVariableType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/MethodResolutionCapability.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/ObjectProvider.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/resolution/SymbolReference.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/resolution/TypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/resolution/Value.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/typesystem/LazyType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/typesystem/NullType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/typesystem/ReferenceTypeImpl.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/MyObjectProvider.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationMemberDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionConstructorDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionEnumConstantDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionEnumDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionFactory.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionFieldDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionInterfaceDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionMethodDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionMethodResolutionLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionParameterDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionPatternDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionTypeParameter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/comparators/ClassComparator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/comparators/MethodComparator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/comparators/ParameterComparator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/package-info.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/ConstructorResolutionLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/SymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/SymbolSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameCategory.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameRole.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/Bound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ConstraintFormula.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ConstraintFormulaSet.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ControlFlowLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ExpressionHelper.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/InferenceVariable.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/InferenceVariableSubstitution.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/Instantiation.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/InstantiationSet.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/MethodType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ProperLowerBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ProperUpperBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/Substitution.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInference.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInferenceCache.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/CapturesBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/FalseBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/SameAsBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/SubtypeOfBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/ThrowsBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/ExpressionCompatibleWithType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/LambdaThrowsCompatibleWithType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/MethodReferenceThrowsCompatibleWithType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeCompatibleWithType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeContainedByType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeSameAsType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeSubtypeOfType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/AarTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/ClassLoaderTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/CombinedTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/JarTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/JavaParserTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/MemoryTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/ReflectionTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/utils/FileUtils.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/utils/SymbolSolverCollectionStrategy.java']\n\nFile Path Before Refactoring:\njavaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, and you need move the extracted method to another existing java file, output the target file path, extracted method code, refactored method code after refactoring.\nThe extracted method code should be the public static method.\nThe refactored method code should use the moved class to call the extracted method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\ntarget_file_path\n##########################\nextracted_method_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpackage languageLevelValidation_recordAsTypeIdentifier_forbidden(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest to package languageLevelValidation_recordAsTypeIdentifier_forbidden(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest.LanguageLevels", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 50, "endLine": 55, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 53, "endLine": 58, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "9e55bc54539d393e1948c8d4a89b1511ed379fad", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#languageLevelValidation_recordAsTypeIdentifier_forbidden", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#languageLevelValidation_recordAsTypeIdentifier_forbidden"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @Nested\n    class LanguageLevels {\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_forbidNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticFields2() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinalWithoutExplicit() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }", "diffSourceCode": "-   50:     @ParameterizedTest\n-   51:     @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n-   52:     void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n-   53:         String s = \"class record {}\";\n-   54:         CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n-   55:     }\n-   56: \n-   57:     /**\n-   58:      * https://openjdk.java.net/jeps/395#Description\n+   50:             });\n+   51:         }\n+   52: \n+   53:         @ParameterizedTest\n+   54:         @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n+   55:         void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n+   56:             String s = \"class record {}\";\n+   57:             CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n+   58:         }\n", "uniqueId": "9e55bc54539d393e1948c8d4a89b1511ed379fad_50_55__53_58", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To perform the requested refactoring, we will move the method `languageLevelValidation_recordAsTypeIdentifier_forbidden` from the `RecordDeclarationTest` class to the `TestParser` class, which is a utility class that seems appropriate for handling parsing-related methods. We will make the method `public static` and update the test method to call this new static method.\n\n### Step 1: Identify the target file path\nThe `TestParser` class is located at:\n```\njavaparser-core-testing/src/test/java/com/github/javaparser/utils/TestParser.java\n```\n\n### Step 2: Move the method code\nWe will move the following method code to the `TestParser` class:\n\n```java\n@ParameterizedTest\n@EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\nvoid languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n    String s = \"class record {}\";\n    CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n}\n```\n\n### Moved Class Code\nThe moved method will be added to the `TestParser` class as follows:\n\n```java\npublic static void languageLevelValidationRecordAsTypeIdentifierForbidden(ParserConfiguration.LanguageLevel languageLevel) {\n    String s = \"class record {}\";\n    CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n}\n```\n\n### Step 3: Refactor the original method\nThe original method in the `RecordDeclarationTest` class will be updated to call the new static method in `TestParser`:\n\n```java\n@ParameterizedTest\n@EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\nvoid languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n    assertThrows(AssertionFailedError.class, () -> {\n        TestParser.languageLevelValidationRecordAsTypeIdentifierForbidden(languageLevel);\n    });\n}\n```\n\n### Final Output\nHere is the final output in the requested format:\n\n##########################\njavaparser-core-testing/src/test/java/com/github/javaparser/utils/TestParser.java\n##########################\npublic static void languageLevelValidationRecordAsTypeIdentifierForbidden(ParserConfiguration.LanguageLevel languageLevel) {\n    String s = \"class record {}\";\n    CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n}\n##########################\n@ParameterizedTest\n@EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\nvoid languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n    assertThrows(AssertionFailedError.class, () -> {\n        TestParser.languageLevelValidationRecordAsTypeIdentifierForbidden(languageLevel);\n    });\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['javaparser-core-testing/src/test/java/com/github/javaparser/CommentsInserterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/GeneratedJavaParserTokenManagerTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/Issue1017Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/Issue2482Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/JavaParserTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/JavaTokenTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/JavadocParserTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/LineSeparatorProcessorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ParseErrorRecoveryTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ParserConfigurationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/PositionMappingTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ProblemTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ProvidersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/RangeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/TokenRangeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/TokenTypesTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/AncestorDescendantTests.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/CompilationUnitTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/DataKeyTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/FindNodeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ListObservationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/NodeListTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/NodePositionTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/NodeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ObservationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ParseResultTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ReplaceNodeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/WalkFindTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/AnnotationDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/AnnotationMemberDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/ClassOrInterfaceDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/ConstructorDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/FieldDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/MethodDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/TypeDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/comments/CommentTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/AssignExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/BinaryExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/CharLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/DoubleLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/InstanceOfExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/LambdaExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/LiteralStringValueExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/MethodCallExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/MethodReferenceExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/NameTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/ObjectCreationExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/SimpleNameTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/StringLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/SuperExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/SwitchExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/TextBlockLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/ThisExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/imports/ImportDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithBodyTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithJavadocTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithModifiersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithOptionalScopeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithTraversableScopeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithVariablesTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/observer/PropagatingAstObserverTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/BreakStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/ForEachStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/IfElseStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/SwitchStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/TryStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/YieldStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/ArrayTypeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/ClassOrInterfaceTypeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/TypeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java10ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java11ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java12ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java13ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java14PreviewValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java14ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java15PreviewValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java15ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java16PreviewValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java16ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_0ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_1ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_3ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_4ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java5ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java6ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java7ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java8ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java9ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/CloneVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/GenericVisitorWithDefaultsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/HashCodeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/ModifierVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/NoCommentEqualsVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/NoCommentHashCodeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/ObjectIdentityHashCodeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/TreeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/VoidVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/VoidVisitorWithDefaultsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/ClassOrInterfaceDeclarationBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/CompilationUnitBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/EnumDeclarationBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/FieldDeclarationBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithAnnotationsBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithMembersBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithParametersBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithThrownExceptionsBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/issues/Issue2627Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/javadoc/JavadocExtractorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/javadoc/JavadocTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/javadoc/description/JavadocInlineTagTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/manual/BulkParseTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/metamodel/BaseNodeMetaModelTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/metamodel/PropertyMetaModelTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/modules/ModuleDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelAcceptanceTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/DefaultPrettyPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/DotPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/JsonPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/PrettyPrintVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/PrettyPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/PrinterConfigurationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/TestVisitor.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/XmlPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/YamlPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/AbstractLexicalPreservingTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/AnnotationSpaceTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/DifferenceElementCalculatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1467Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1634Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1766Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1793Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2290Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2374Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2393Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2592Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2610Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2620Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2806Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/PrettyPrinterIssue2340Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/PrettyPrinterIssue2351Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/TransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/ArrayCreationLevelTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/CompilationUnitTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationMemberDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ClassOrInterfaceDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ConstructorDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumConstantDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/FieldDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/InitializerDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/MethodDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/OperatorTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/StatementTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/remove/NodeRemovalTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/CodeGenerationUtilsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/LineSeparatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/LogTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/PairTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/ParserCollectionStrategyTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/PositionUtilsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/SourceRootTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/SourceZipTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestParser.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/UtilsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/VisitorListTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/VisitorMapTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/VisitorSetTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/version/Java10PostProcessorTest.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/TestFileIso88591.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/DefaultStrategy.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_cr.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_crlf.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_lf.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_minimal.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/range/A.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/range/B.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/A.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/B.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/PrimaryType.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/PrimaryType2.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/Z.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/.abc/bla.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/Bla.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/module-info.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info/demo/Main.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info/demo/module-info.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info_in_root/demo/Main.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info_in_root/module-info.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/without_module_info/demo/Main.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/source.root/Y.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/wiki_samples/TestFile.java', 'javaparser-core-testing/src/test/test_sourcecode/com/github/javaparser/printer/JavaConcepts.java', 'javaparser-core-testing/src/test/test_sourcecode/com/github/javaparser/printer/PrettyPrintVisitor.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpackage languageLevelValidation_recordAsTypeIdentifier_permitted(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest to package languageLevelValidation_recordAsTypeIdentifier_permitted(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest.LanguageLevels", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 41, "endLine": 48, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 44, "endLine": 51, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "9e55bc54539d393e1948c8d4a89b1511ed379fad", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#languageLevelValidation_recordAsTypeIdentifier_permitted", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#languageLevelValidation_recordAsTypeIdentifier_permitted"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @Nested\n    class LanguageLevels {\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_forbidNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticFields2() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinalWithoutExplicit() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }", "diffSourceCode": "-   41:     @ParameterizedTest\n-   42:     @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n-   43:     void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n-   44:         String s = \"class record {}\";\n-   45:         assertThrows(AssertionFailedError.class, () -> {\n-   46:             CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n-   47:         });\n-   48:     }\n-   49: \n-   50:     @ParameterizedTest\n-   51:     @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n+   41:             CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n+   42:         }\n+   43: \n+   44:         @ParameterizedTest\n+   45:         @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n+   46:         void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n+   47:             String s = \"class record {}\";\n+   48:             assertThrows(AssertionFailedError.class, () -> {\n+   49:                 CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n+   50:             });\n+   51:         }\n", "uniqueId": "9e55bc54539d393e1948c8d4a89b1511ed379fad_41_48__44_51", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To refactor the provided code by moving the method `languageLevelValidation_recordAsTypeIdentifier_permitted` to an existing Java file, we will follow these steps:\n\n1. Identify a suitable existing class to move the method to. Given the context of the method, it seems appropriate to move it to the `RecordDeclarationTest` class since it deals with record declarations and their validation.\n\n2. Update the method to be a public static method.\n\n3. Refactor the original test method to call the moved method.\n\n### Target File Path\nThe target file path for the moved method will be:\n```\njavaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java\n```\n\n### Moved Class Code\nThe moved method code will be:\n```java\npublic static void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n    String s = \"class record {}\";\n    assertThrows(AssertionFailedError.class, () -> {\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    });\n}\n```\n\n### Refactored Method Code\nThe refactored method code in the `RecordDeclarationTest` class will be:\n```java\n@ParameterizedTest\n@EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\nvoid languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n    RecordDeclarationTest.languageLevelValidation_recordAsTypeIdentifier_permitted(languageLevel);\n}\n```\n\n### Final Output\nHere is the complete output in the required format:\n\n##########################\njavaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java\n##########################\npublic static void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n    String s = \"class record {}\";\n    assertThrows(AssertionFailedError.class, () -> {\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    });\n}\n##########################\n@ParameterizedTest\n@EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\nvoid languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n    RecordDeclarationTest.languageLevelValidation_recordAsTypeIdentifier_permitted(languageLevel);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['javaparser-core-testing/src/test/java/com/github/javaparser/CommentsInserterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/GeneratedJavaParserTokenManagerTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/Issue1017Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/Issue2482Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/JavaParserTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/JavaTokenTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/JavadocParserTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/LineSeparatorProcessorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ParseErrorRecoveryTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ParserConfigurationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/PositionMappingTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ProblemTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ProvidersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/RangeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/TokenRangeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/TokenTypesTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/AncestorDescendantTests.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/CompilationUnitTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/DataKeyTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/FindNodeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ListObservationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/NodeListTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/NodePositionTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/NodeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ObservationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ParseResultTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/ReplaceNodeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/WalkFindTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/AnnotationDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/AnnotationMemberDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/ClassOrInterfaceDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/ConstructorDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/FieldDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/MethodDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/TypeDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/comments/CommentTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/AssignExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/BinaryExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/CharLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/DoubleLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/InstanceOfExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/LambdaExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/LiteralStringValueExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/MethodCallExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/MethodReferenceExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/NameTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/ObjectCreationExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/SimpleNameTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/StringLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/SuperExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/SwitchExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/TextBlockLiteralExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/expr/ThisExprTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/imports/ImportDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithBodyTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithJavadocTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithModifiersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithOptionalScopeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithTraversableScopeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/nodeTypes/NodeWithVariablesTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/observer/PropagatingAstObserverTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/BreakStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/ForEachStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/IfElseStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/SwitchStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/TryStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/stmt/YieldStmtTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/ArrayTypeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/ClassOrInterfaceTypeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/TypeTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java10ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java11ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java12ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java13ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java14PreviewValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java14ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java15PreviewValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java15ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java16PreviewValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java16ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_0ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_1ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_3ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java1_4ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java5ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java6ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java7ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java8ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/validator/Java9ValidatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/CloneVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/GenericVisitorWithDefaultsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/HashCodeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/ModifierVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/NoCommentEqualsVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/NoCommentHashCodeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/ObjectIdentityHashCodeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/TreeVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/VoidVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/ast/visitor/VoidVisitorWithDefaultsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/ClassOrInterfaceDeclarationBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/CompilationUnitBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/EnumDeclarationBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/FieldDeclarationBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithAnnotationsBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithMembersBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithParametersBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/builders/NodeWithThrownExceptionsBuildersTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/issues/Issue2627Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/javadoc/JavadocExtractorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/javadoc/JavadocTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/javadoc/description/JavadocInlineTagTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/manual/BulkParseTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/metamodel/BaseNodeMetaModelTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/metamodel/PropertyMetaModelTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/modules/ModuleDeclarationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelAcceptanceTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/ConcreteSyntaxModelTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/DefaultPrettyPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/DotPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/JsonPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/PrettyPrintVisitorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/PrettyPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/PrinterConfigurationTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/TestVisitor.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/XmlPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/YamlPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/AbstractLexicalPreservingTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/AnnotationSpaceTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/DifferenceElementCalculatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1467Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1634Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1766Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue1793Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2290Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2374Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2393Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2592Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2610Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2620Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/Issue2806Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinterTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/PrettyPrinterIssue2340Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/PrettyPrinterIssue2351Test.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/TransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/ArrayCreationLevelTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/CompilationUnitTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/AnnotationMemberDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ClassOrInterfaceDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/ConstructorDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumConstantDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/EnumDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/FieldDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/InitializerDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/MethodDeclarationTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/OperatorTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/printer/lexicalpreservation/transformations/ast/body/StatementTransformationsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/remove/NodeRemovalTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/CodeGenerationUtilsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/LineSeparatorTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/LogTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/PairTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/ParserCollectionStrategyTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/PositionUtilsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/SourceRootTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/SourceZipTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestParser.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/UtilsTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/VisitorListTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/VisitorMapTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/utils/VisitorSetTest.java', 'javaparser-core-testing/src/test/java/com/github/javaparser/version/Java10PostProcessorTest.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/TestFileIso88591.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/DefaultStrategy.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_cr.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_crlf.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_lf.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/issue_samples/issue_2627/Ops_minimal.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/range/A.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/range/B.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/A.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/B.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/PrimaryType.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/PrimaryType2.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/storage/Z.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/.abc/bla.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/Bla.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/module-info.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info/demo/Main.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info/demo/module-info.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info_in_root/demo/Main.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/with_module_info_in_root/module-info.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/projectroot/issue2615/without_module_info/demo/Main.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/utils/source.root/Y.java', 'javaparser-core-testing/src/test/resources/com/github/javaparser/wiki_samples/TestFile.java', 'javaparser-core-testing/src/test/test_sourcecode/com/github/javaparser/printer/JavaConcepts.java', 'javaparser-core-testing/src/test/test_sourcecode/com/github/javaparser/printer/PrettyPrintVisitor.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate parametrizedTypeUpperBounded(type String, parameterType String) : ResolvedTypeVariable extracted from private parametrizedType(type String, parameterType String) : ResolvedTypeVariable in class com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeTest", "diffLocations": [{"filePath": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/model/typesystem/ReferenceTypeTest.java", "startLine": 955, "endLine": 958, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/model/typesystem/ReferenceTypeTest.java", "startLine": 971, "endLine": 973, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/model/typesystem/ReferenceTypeTest.java", "startLine": 975, "endLine": 978, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n        return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n                Arrays.asList((extendBound(parameterType)))));\n    }", "filePathBefore": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/model/typesystem/ReferenceTypeTest.java", "isPureRefactoring": true, "commitId": "cc159998ac7c83234e2665cbc479f85dcc27f5d0", "packageNameBefore": "com.github.javaparser.symbolsolver.model.typesystem", "classNameBefore": "com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeTest", "methodNameBefore": "com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeTest#parametrizedType", "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeTest#extendBound\n methodBody: private Bound extendBound(String type) {\nreturn Bound.extendsBound(type(type));\n}\nmethodSignature: com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration#onType\n methodBody: static ResolvedTypeParameterDeclaration onType(final String name, String classQName, List<Bound> bounds) {\nreturn new ResolvedTypeParameterDeclaration(){\n  @Override public String getName(){\n    return name;\n  }\n  @Override public boolean declaredOnType(){\n    return true;\n  }\n  @Override public boolean declaredOnMethod(){\n    return false;\n  }\n  @Override public boolean declaredOnConstructor(){\n    return false;\n  }\n  @Override public String getContainerQualifiedName(){\n    return classQName;\n  }\n  @Override public String getContainerId(){\n    return classQName;\n  }\n  @Override public ResolvedTypeParametrizable getContainer(){\n    return null;\n  }\n  @Override public List<Bound> getBounds(){\n    return bounds;\n  }\n  @Override public String toString(){\n    return \"TypeParameter onType \" + name;\n  }\n  @Override public Optional<ResolvedReferenceTypeDeclaration> containerType(){\n    throw new UnsupportedOperationException();\n  }\n  @Override public ResolvedReferenceType object(){\n    throw new UnsupportedOperationException();\n  }\n}\n;\n}", "classSignatureBefore": "class ReferenceTypeTest extends AbstractSymbolResolutionTest ", "methodNameBeforeSet": ["com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeTest#parametrizedType"], "classNameBeforeSet": ["com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeTest"], "classSignatureBeforeSet": ["class ReferenceTypeTest extends AbstractSymbolResolutionTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.model.typesystem;\n\nimport com.github.javaparser.*;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.resolution.TypeSolver;\nimport com.github.javaparser.resolution.declarations.*;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.Bound;\nimport com.github.javaparser.resolution.model.typesystem.NullType;\nimport com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.resolution.types.*;\nimport com.github.javaparser.symbolsolver.AbstractSymbolResolutionTest;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.ProtocolException;\nimport java.nio.Buffer;\nimport java.nio.CharBuffer;\nimport java.nio.file.FileSystemException;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static org.hamcrest.CoreMatchers.*;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.collection.IsIterableContainingInAnyOrder.containsInAnyOrder;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass ReferenceTypeTest extends AbstractSymbolResolutionTest {\n\n    private ReferenceTypeImpl listOfA;\n    private ReferenceTypeImpl listOfStrings;\n    private ReferenceTypeImpl linkedListOfString;\n    private ReferenceTypeImpl collectionOfString;\n    private ReferenceTypeImpl listOfWildcardExtendsString;\n    private ReferenceTypeImpl listOfWildcardSuperString;\n    private ReferenceTypeImpl object;\n    private ReferenceTypeImpl string;\n    private TypeSolver typeSolver;\n    private ReferenceTypeImpl ioException;\n    private ResolvedType unionWithIOExceptionAsCommonAncestor;\n    private ResolvedType unionWithThrowableAsCommonAncestor;\n\n    @BeforeEach\n    void setup() {\n        typeSolver = new ReflectionTypeSolver();\n        object = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));\n        string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver));\n        listOfA = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(\"A\", \"foo.Bar\", Collections.emptyList()))));\n        listOfStrings = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        linkedListOfString = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(LinkedList.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        collectionOfString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(Collection.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        listOfWildcardExtendsString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(ResolvedWildcard.extendsBound(string)));\n        listOfWildcardSuperString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(ResolvedWildcard.superBound(string)));\n        ioException = new ReferenceTypeImpl(new ReflectionClassDeclaration(IOException.class, typeSolver));\n        unionWithIOExceptionAsCommonAncestor = new ResolvedUnionType(Arrays.asList(\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(ProtocolException.class, typeSolver)),\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(FileSystemException.class, typeSolver))\n        ));\n        unionWithThrowableAsCommonAncestor = new ResolvedUnionType(Arrays.asList(\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(ClassCastException.class, typeSolver)),\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(AssertionError.class, typeSolver))\n        ));\n        \n        // minimal initialization of JavaParser\n        ParserConfiguration configuration = new ParserConfiguration()\n                .setSymbolResolver(new JavaSymbolSolver(new ReflectionTypeSolver()));\n        // Setup parser\n        StaticJavaParser.setConfiguration(configuration);\n    }\n\n    @Test\n    void testDerivationOfTypeParameters() {\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl ref1 = new ReferenceTypeImpl(typeSolver.solveType(LinkedList.class.getCanonicalName()));\n        assertEquals(1, ref1.typeParametersValues().size());\n        assertEquals(true, ref1.typeParametersValues().get(0).isTypeVariable());\n        assertEquals(\"E\", ref1.typeParametersValues().get(0).asTypeParameter().getName());\n    }\n\n    @Test\n    void testIsArray() {\n        assertEquals(false, object.isArray());\n        assertEquals(false, string.isArray());\n        assertEquals(false, listOfA.isArray());\n        assertEquals(false, listOfStrings.isArray());\n    }\n\n    @Test\n    void testIsPrimitive() {\n        assertEquals(false, object.isPrimitive());\n        assertEquals(false, string.isPrimitive());\n        assertEquals(false, listOfA.isPrimitive());\n        assertEquals(false, listOfStrings.isPrimitive());\n    }\n\n    @Test\n    void testIsNull() {\n        assertEquals(false, object.isNull());\n        assertEquals(false, string.isNull());\n        assertEquals(false, listOfA.isNull());\n        assertEquals(false, listOfStrings.isNull());\n    }\n\n    @Test\n    void testIsReference() {\n        assertEquals(true, object.isReference());\n        assertEquals(true, string.isReference());\n        assertEquals(true, listOfA.isReference());\n        assertEquals(true, listOfStrings.isReference());\n    }\n\n    @Test\n    void testIsReferenceType() {\n        assertEquals(true, object.isReferenceType());\n        assertEquals(true, string.isReferenceType());\n        assertEquals(true, listOfA.isReferenceType());\n        assertEquals(true, listOfStrings.isReferenceType());\n    }\n\n    @Test\n    void testIsVoid() {\n        assertEquals(false, object.isVoid());\n        assertEquals(false, string.isVoid());\n        assertEquals(false, listOfA.isVoid());\n        assertEquals(false, listOfStrings.isVoid());\n    }\n\n    @Test\n    void testIsTypeVariable() {\n        assertEquals(false, object.isTypeVariable());\n        assertEquals(false, string.isTypeVariable());\n        assertEquals(false, listOfA.isTypeVariable());\n        assertEquals(false, listOfStrings.isTypeVariable());\n    }\n\n    @Test\n    void testAsReferenceTypeUsage() {\n        assertTrue(object == object.asReferenceType());\n        assertTrue(string == string.asReferenceType());\n        assertTrue(listOfA == listOfA.asReferenceType());\n        assertTrue(listOfStrings == listOfStrings.asReferenceType());\n    }\n\n    @Test\n    void testAsTypeParameter() {\n        assertThrows(UnsupportedOperationException.class, () -> object.asTypeParameter());\n    }\n\n    @Test\n    void testAsArrayTypeUsage() {\n        assertThrows(UnsupportedOperationException.class, () -> object.asArrayType());\n    }\n\n    @Test\n    void testAsDescribe() {\n        assertEquals(\"java.lang.Object\", object.describe());\n        assertEquals(\"java.lang.String\", string.describe());\n        assertEquals(\"java.util.List<A>\", listOfA.describe());\n        assertEquals(\"java.util.List<java.lang.String>\", listOfStrings.describe());\n    }\n\n    @Test\n    void testReplaceParam() {\n        ResolvedTypeParameterDeclaration tpA = ResolvedTypeParameterDeclaration.onType(\"A\", \"foo.Bar\", Collections.emptyList());\n        assertTrue(object == object.replaceTypeVariables(tpA, object));\n        assertTrue(string == string.replaceTypeVariables(tpA, object));\n        assertEquals(listOfStrings, listOfStrings.replaceTypeVariables(tpA, object));\n        assertEquals(listOfStrings, listOfA.replaceTypeVariables(tpA, string));\n    }\n\n    @Test\n    void testIsAssignableBySimple() {\n        assertEquals(true, object.isAssignableBy(string));\n        assertEquals(false, string.isAssignableBy(object));\n        assertEquals(false, listOfStrings.isAssignableBy(listOfA));\n        assertEquals(false, listOfA.isAssignableBy(listOfStrings));\n\n        assertEquals(false, object.isAssignableBy(ResolvedVoidType.INSTANCE));\n        assertEquals(false, string.isAssignableBy(ResolvedVoidType.INSTANCE));\n        assertEquals(false, listOfStrings.isAssignableBy(ResolvedVoidType.INSTANCE));\n        assertEquals(false, listOfA.isAssignableBy(ResolvedVoidType.INSTANCE));\n\n        assertEquals(true, object.isAssignableBy(NullType.INSTANCE));\n        assertEquals(true, string.isAssignableBy(NullType.INSTANCE));\n        assertEquals(true, listOfStrings.isAssignableBy(NullType.INSTANCE));\n        assertEquals(true, listOfA.isAssignableBy(NullType.INSTANCE));\n    }\n\n    @Test\n    void testIsAssignableByBoxedPrimitive() {\n        ResolvedReferenceType numberType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Number.class, typeSolver));\n        ResolvedReferenceType intType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Integer.class, typeSolver));\n        ResolvedReferenceType doubleType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Double.class, typeSolver));\n        ResolvedReferenceType byteType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Byte.class, typeSolver));\n        ResolvedReferenceType shortType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Short.class, typeSolver));\n        ResolvedReferenceType charType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Character.class, typeSolver));\n        ResolvedReferenceType longType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Long.class, typeSolver));\n        ResolvedReferenceType booleanType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Boolean.class, typeSolver));\n        ResolvedReferenceType floatType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Float.class, typeSolver));\n\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.INT));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.DOUBLE));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.SHORT));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.LONG));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.FLOAT));\n        assertEquals(false, numberType.isAssignableBy(ResolvedPrimitiveType.BOOLEAN));\n        assertEquals(true, intType.isAssignableBy(ResolvedPrimitiveType.INT));\n        assertEquals(true, doubleType.isAssignableBy(ResolvedPrimitiveType.DOUBLE));\n        assertEquals(true, byteType.isAssignableBy(ResolvedPrimitiveType.BYTE));\n        assertEquals(true, shortType.isAssignableBy(ResolvedPrimitiveType.SHORT));\n        assertEquals(true, charType.isAssignableBy(ResolvedPrimitiveType.CHAR));\n        assertEquals(true, longType.isAssignableBy(ResolvedPrimitiveType.LONG));\n        assertEquals(true, booleanType.isAssignableBy(ResolvedPrimitiveType.BOOLEAN));\n        assertEquals(true, floatType.isAssignableBy(ResolvedPrimitiveType.FLOAT));\n    }\n\n    @Test\n    void testIsCorresponding() {\n\n        // ResolvedReferenceTypeTester is defined to allow to test protected method isCorrespondingBoxingType(..)\n        class ResolvedReferenceTypeTester extends ReferenceTypeImpl {\n\n            public ResolvedReferenceTypeTester(ResolvedReferenceTypeDeclaration typeDeclaration,\n                                               TypeSolver typeSolver) {\n                super(typeDeclaration);\n            }\n\n            public boolean isCorrespondingBoxingType(String name) {\n                return super.isCorrespondingBoxingType(name);\n            }\n\n        }\n\n        ResolvedReferenceTypeTester numberType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Number.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester intType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Integer.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester doubleType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Double.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester byteType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Byte.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester shortType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Short.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester charType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Character.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester longType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Long.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester booleanType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Boolean.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester floatType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Float.class, typeSolver), typeSolver);\n\n        ResolvedReferenceTypeTester otherType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(String.class, typeSolver), typeSolver);\n\n        assertEquals(true, intType.isCorrespondingBoxingType(ResolvedPrimitiveType.INT.describe()));\n        assertEquals(true, doubleType.isCorrespondingBoxingType(ResolvedPrimitiveType.DOUBLE.describe()));\n        assertEquals(true, byteType.isCorrespondingBoxingType(ResolvedPrimitiveType.BYTE.describe()));\n        assertEquals(true, shortType.isCorrespondingBoxingType(ResolvedPrimitiveType.SHORT.describe()));\n        assertEquals(true, charType.isCorrespondingBoxingType(ResolvedPrimitiveType.CHAR.describe()));\n        assertEquals(true, longType.isCorrespondingBoxingType(ResolvedPrimitiveType.LONG.describe()));\n        assertEquals(true, booleanType.isCorrespondingBoxingType(ResolvedPrimitiveType.BOOLEAN.describe()));\n        assertEquals(true, floatType.isCorrespondingBoxingType(ResolvedPrimitiveType.FLOAT.describe()));\n\n        assertEquals(false, numberType.isCorrespondingBoxingType(ResolvedPrimitiveType.INT.describe()));\n\n        assertThrows(IllegalArgumentException.class, () -> {\n            intType.isCorrespondingBoxingType(\"String\");\n        });\n    }\n\n    @Test\n    void testIsAssignableByGenerics() {\n        assertEquals(false, listOfStrings.isAssignableBy(listOfWildcardExtendsString));\n        assertEquals(false, listOfStrings.isAssignableBy(listOfWildcardExtendsString));\n        assertEquals(true, listOfWildcardExtendsString.isAssignableBy(listOfStrings));\n        assertEquals(false, listOfWildcardExtendsString.isAssignableBy(listOfWildcardSuperString));\n        assertEquals(true, listOfWildcardSuperString.isAssignableBy(listOfStrings));\n        assertEquals(false, listOfWildcardSuperString.isAssignableBy(listOfWildcardExtendsString));\n    }\n\n    @Test\n    void testIsAssignableByGenericsInheritance() {\n        assertEquals(true, collectionOfString.isAssignableBy(collectionOfString));\n        assertEquals(true, collectionOfString.isAssignableBy(listOfStrings));\n        assertEquals(true, collectionOfString.isAssignableBy(linkedListOfString));\n\n        assertEquals(false, listOfStrings.isAssignableBy(collectionOfString));\n        assertEquals(true, listOfStrings.isAssignableBy(listOfStrings));\n        assertEquals(true, listOfStrings.isAssignableBy(linkedListOfString));\n\n        assertEquals(false, linkedListOfString.isAssignableBy(collectionOfString));\n        assertEquals(false, linkedListOfString.isAssignableBy(listOfStrings));\n        assertEquals(true, linkedListOfString.isAssignableBy(linkedListOfString));\n    }\n    \n    @Test\n    void testIsAssignableByUnionType() {\n        assertEquals(true, ioException.isAssignableBy(unionWithIOExceptionAsCommonAncestor));\n        assertEquals(false, ioException.isAssignableBy(unionWithThrowableAsCommonAncestor));\n    }\n\n    @Test\n    void testGetAllAncestorsConsideringTypeParameters() {\n        assertThat(linkedListOfString.getAllAncestors(), hasItem(object));\n        assertThat(linkedListOfString.getAllAncestors(), hasItem(listOfStrings));\n        assertThat(linkedListOfString.getAllAncestors(), hasItem(collectionOfString));\n        assertThat(linkedListOfString.getAllAncestors(), not(hasItem(listOfA)));\n    }\n\n    class Foo {\n\n    }\n\n    class Bar extends Foo {\n\n    }\n\n    class Bazzer<A, B, C> {\n\n    }\n\n    class MoreBazzing<A, B> extends Bazzer<B, String, A> {\n\n    }\n\n    @Test\n    void testGetAllAncestorsConsideringGenericsCases() {\n        ReferenceTypeImpl foo = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver));\n        ReferenceTypeImpl bar = new ReferenceTypeImpl(new ReflectionClassDeclaration(Bar.class, typeSolver));\n        ReferenceTypeImpl left, right;\n\n        //YES MoreBazzing<Foo, Bar> e1 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(foo, bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<? extends Foo, Bar> e2 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(ResolvedWildcard.extendsBound(foo), bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<Foo, ? extends Bar> e3 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(foo, ResolvedWildcard.extendsBound(bar)))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<? extends Foo, ? extends Foo> e4 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(ResolvedWildcard.extendsBound(foo), ResolvedWildcard.extendsBound(foo)))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<? extends Foo, ? extends Foo> e5 = new MoreBazzing<Bar, Bar>();\n        left = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                ImmutableList.of(ResolvedWildcard.extendsBound(foo), ResolvedWildcard.extendsBound(foo)));\n        right = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                ImmutableList.of(bar, bar));\n        assertEquals(true, left.isAssignableBy(right));\n\n        //YES Bazzer<Object, String, String> e6 = new MoreBazzing<String, Object>();\n        left = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                ImmutableList.of(object, string, string));\n        right = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                ImmutableList.of(string, object));\n\n        // To debug the following\n        List<ResolvedReferenceType> ancestors = right.getAllAncestors();\n        ResolvedReferenceType moreBazzingAncestor = ancestors.stream()\n                .filter(a -> a.getQualifiedName().endsWith(\"Bazzer\"))\n                .findFirst().get();\n\n        assertEquals(true, left.isAssignableBy(right));\n\n        //YES Bazzer<String,String,String> e7 = new MoreBazzing<String, String>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(string, string, string))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(string, string)))\n        );\n\n        //YES Bazzer<Bar,String,Foo> e8 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(bar, string, foo))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES Bazzer<Foo,String,Bar> e9 = new MoreBazzing<Bar, Foo>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(foo, string, bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n\n        //NO Bazzer<Bar,String,Foo> n1 = new MoreBazzing<Bar, Foo>();\n        assertEquals(false,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(bar, string, foo))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n\n        //NO Bazzer<Bar,String,Bar> n2 = new MoreBazzing<Bar, Foo>();\n        assertEquals(false,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(bar, string, foo))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n\n        //NO Bazzer<Foo,Object,Bar> n3 = new MoreBazzing<Bar, Foo>();\n        assertEquals(false,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(foo, object, bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n    }\n\n    @Test\n    void charSequenceIsAssignableToObject() {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl charSequence = new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(CharSequence.class, typeSolver));\n        ReferenceTypeImpl object = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));\n        assertEquals(false, charSequence.isAssignableBy(object));\n        assertEquals(true, object.isAssignableBy(charSequence));\n    }\n\n    @Test\n    void testGetFieldTypeExisting() {\n        class Foo<A> {\n\n            List<A> elements;\n        }\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver));\n\n        assertEquals(true, ref.getFieldType(\"elements\").isPresent());\n        assertEquals(true, ref.getFieldType(\"elements\").get().isReferenceType());\n        assertEquals(List.class.getCanonicalName(), ref.getFieldType(\"elements\").get().asReferenceType().getQualifiedName());\n        assertEquals(1, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().size());\n        assertEquals(true, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).isTypeVariable());\n        assertEquals(\"A\", ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).asTypeParameter().getName());\n\n        ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n\n        assertEquals(true, ref.getFieldType(\"elements\").isPresent());\n        assertEquals(true, ref.getFieldType(\"elements\").get().isReferenceType());\n        assertEquals(List.class.getCanonicalName(), ref.getFieldType(\"elements\").get().asReferenceType().getQualifiedName());\n        assertEquals(1, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().size());\n        assertEquals(true, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).isReferenceType());\n        assertEquals(String.class.getCanonicalName(), ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).asReferenceType().getQualifiedName());\n    }\n\n    @Test\n    void testGetFieldTypeUnexisting() {\n        class Foo<A> {\n\n            List<A> elements;\n        }\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver));\n\n        assertEquals(false, ref.getFieldType(\"bar\").isPresent());\n\n        ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n\n        assertEquals(false, ref.getFieldType(\"bar\").isPresent());\n    }\n\n    @Test\n    void testTypeParamValue() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration arraylist = new ReflectionClassDeclaration(ArrayList.class, typeResolver);\n        ResolvedClassDeclaration abstractList = new ReflectionClassDeclaration(AbstractList.class, typeResolver);\n        ResolvedClassDeclaration abstractCollection = new ReflectionClassDeclaration(AbstractCollection.class, typeResolver);\n        ResolvedInterfaceDeclaration list = new ReflectionInterfaceDeclaration(List.class, typeResolver);\n        ResolvedInterfaceDeclaration collection = new ReflectionInterfaceDeclaration(Collection.class, typeResolver);\n        ResolvedInterfaceDeclaration iterable = new ReflectionInterfaceDeclaration(Iterable.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType arrayListOfString = new ReferenceTypeImpl(arraylist, ImmutableList.of(string));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(arraylist.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(abstractList.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(abstractCollection.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(list.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(collection.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(iterable.getTypeParameters().get(0)));\n    }\n\n    @Test\n    void testGetAllAncestorsOnRawType() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration arraylist = new ReflectionClassDeclaration(ArrayList.class, typeResolver);\n        ResolvedReferenceType rawArrayList = new ReferenceTypeImpl(arraylist);\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        rawArrayList.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(9, ancestors.size());\n\n        ResolvedTypeVariable tv = new ResolvedTypeVariable(arraylist.getTypeParameters().get(0));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(RandomAccess.class, typeResolver)), ancestors.get(\"java.util.RandomAccess\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractCollection.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.AbstractCollection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(List.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.List\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Cloneable.class, typeResolver)), ancestors.get(\"java.lang.Cloneable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractList.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.AbstractList\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.lang.Iterable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Serializable.class, typeResolver)), ancestors.get(\"java.io.Serializable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForInterface() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedInterfaceDeclaration list = new ReflectionInterfaceDeclaration(List.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType listOfString = new ReferenceTypeImpl(list, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        listOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(2, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForClassAbstractCollection() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration abstractCollection = new ReflectionClassDeclaration(AbstractCollection.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType abstractCollectionOfString = new ReferenceTypeImpl(abstractCollection, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        abstractCollectionOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(3, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForClassAbstractList() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration abstractList = new ReflectionClassDeclaration(AbstractList.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType abstractListOfString = new ReferenceTypeImpl(abstractList, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        abstractListOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(5, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractCollection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.AbstractCollection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(List.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.List\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForClassArrayList() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration arraylist = new ReflectionClassDeclaration(ArrayList.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType arrayListOfString = new ReferenceTypeImpl(arraylist, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        arrayListOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(9, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(RandomAccess.class, typeResolver)), ancestors.get(\"java.util.RandomAccess\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractCollection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.AbstractCollection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(List.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.List\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Cloneable.class, typeResolver)), ancestors.get(\"java.lang.Cloneable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractList.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.AbstractList\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Serializable.class, typeResolver)), ancestors.get(\"java.io.Serializable\"));\n    }\n\n    @Test\n    void testTypeParametersValues() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedReferenceType stream = new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Stream.class, typeResolver));\n        assertEquals(1, stream.typeParametersValues().size());\n        assertEquals(new ResolvedTypeVariable(new ReflectionInterfaceDeclaration(Stream.class, typeResolver).getTypeParameters().get(0)), stream.typeParametersValues().get(0));\n    }\n\n    @Test\n    void testReplaceTypeVariables() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedInterfaceDeclaration streamInterface = new ReflectionInterfaceDeclaration(Stream.class, typeResolver);\n        ResolvedReferenceType stream = new ReferenceTypeImpl(streamInterface);\n\n        ResolvedMethodDeclaration streamMap = streamInterface.getDeclaredMethods().stream().filter(m -> m.getName().equals(\"map\")).findFirst().get();\n        ResolvedTypeParameterDeclaration streamMapR = streamMap.findTypeParameter(\"T\").get();\n        ResolvedTypeVariable typeVariable = new ResolvedTypeVariable(streamMapR);\n        stream = stream.deriveTypeParameters(stream.typeParametersMap().toBuilder().setValue(stream.getTypeDeclaration().get().getTypeParameters().get(0), typeVariable).build());\n\n        ResolvedTypeParameterDeclaration tpToReplace = streamInterface.getTypeParameters().get(0);\n        ResolvedType replaced = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n\n        ResolvedType streamReplaced = stream.replaceTypeVariables(tpToReplace, replaced);\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", streamReplaced.describe());\n    }\n\n    @Test\n    void testReplaceTypeVariablesWithLambdaInBetween() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedInterfaceDeclaration streamInterface = new ReflectionInterfaceDeclaration(Stream.class, typeResolver);\n        ResolvedReferenceType stream = new ReferenceTypeImpl(streamInterface);\n\n        ResolvedMethodDeclaration streamMap = streamInterface.getDeclaredMethods().stream().filter(m -> m.getName().equals(\"map\")).findFirst().get();\n        ResolvedTypeParameterDeclaration streamMapR = streamMap.findTypeParameter(\"T\").get();\n        ResolvedTypeVariable typeVariable = new ResolvedTypeVariable(streamMapR);\n        stream = stream.deriveTypeParameters(stream.typeParametersMap().toBuilder().setValue(stream.getTypeDeclaration().get().getTypeParameters().get(0), typeVariable).build());\n\n        ResolvedTypeParameterDeclaration tpToReplace = streamInterface.getTypeParameters().get(0);\n        ResolvedType replaced = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n\n        ResolvedType streamReplaced = stream.replaceTypeVariables(tpToReplace, replaced);\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", streamReplaced.describe());\n    }\n\n    @Test\n    void testDirectAncestorsOfObject() {\n        assertEquals(0, object.getDirectAncestors().size());\n    }\n\n    @Test\n    void testDirectAncestorsOfInterface() {\n        ResolvedReferenceType iterableOfString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(Iterable.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        assertEquals(0, iterableOfString.getDirectAncestors().size());\n    }\n\n    @Test\n    void testDirectAncestorsOfInterfaceExtendingInterface() {\n        assertEquals(1, collectionOfString.getDirectAncestors().size());\n        ResolvedReferenceType ancestor1 = collectionOfString.getDirectAncestors().get(0);\n        assertEquals(\"java.lang.Iterable\", ancestor1.getQualifiedName());\n        assertEquals(1, ancestor1.getTypeParametersMap().size());\n        assertEquals(\"T\", ancestor1.getTypeParametersMap().get(0).a.getName());\n        assertEquals(\"java.lang.String\", ancestor1.getTypeParametersMap().get(0).b.describe());\n    }\n\n    @Test\n    void testDirectAncestorsOfClassWithoutSuperClassOrInterfaces() {\n        ResolvedReferenceType buffer = new ReferenceTypeImpl(new ReflectionClassDeclaration(Buffer.class, typeSolver));\n        Set<String> ancestors = buffer.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        assertThat(ancestors, equalTo(new HashSet<>(Arrays.asList(\"java.lang.Object\"))));\n    }\n\n    @Test\n    void testDirectAncestorsOfObjectClass() {\n        ResolvedReferenceType object = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));\n        Set<String> ancestors = object.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        assertEquals(new HashSet<>(), ancestors);\n    }\n\n    @Test\n    void testDirectAncestorsOfClassWithSuperClass() {\n        ResolvedReferenceType charbuffer = new ReferenceTypeImpl(new ReflectionClassDeclaration(CharBuffer.class, typeSolver));\n        Set<String> ancestors = charbuffer.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        assertThat(ancestors, containsInAnyOrder(\n                \"java.lang.CharSequence\",\n                \"java.lang.Appendable\",\n                \"java.nio.Buffer\",\n                \"java.lang.Readable\",\n                \"java.lang.Comparable<java.nio.CharBuffer>\"\n        ));\n    }\n\n    @Test\n    void testDirectAncestorsOfClassWithInterfaces() {\n        Set<String> ancestors = string.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        // FIXME: Remove this temporary fix which varies the test based on the detected JDK which is running these tests.\n        TestJdk currentJdk = TestJdk.getCurrentHostJdk();\n        if (currentJdk.getMajorVersion() < 12) {\n            // JDK 12 introduced \"java.lang.constant.Constable\"\n            assertThat(ancestors, containsInAnyOrder(\n                    \"java.lang.CharSequence\",\n                    \"java.lang.Object\",\n                    \"java.lang.Comparable<java.lang.String>\",\n                    \"java.io.Serializable\"\n            ));\n        } else {\n            // JDK 12 introduced \"java.lang.constant.Constable\"\n            assertThat(ancestors, containsInAnyOrder(\n                    \"java.lang.CharSequence\",\n                    \"java.lang.Object\",\n                    \"java.lang.Comparable<java.lang.String>\",\n                    \"java.io.Serializable\",\n                    \"java.lang.constant.Constable\",\n                    \"java.lang.constant.ConstantDesc\"\n            ));\n        }\n    }\n\n    @Test\n    void testDeclaredFields() {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        String code = \"class A { private int i; char c; public long l; } class B extends A { private float f; boolean b; };\";\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n        CompilationUnit cu = new JavaParser(parserConfiguration)\n                .parse(ParseStart.COMPILATION_UNIT, new StringProvider(code)).getResult().get();\n\n        ClassOrInterfaceDeclaration classA = cu.getClassByName(\"A\").get();\n        ClassOrInterfaceDeclaration classB = cu.getClassByName(\"B\").get();\n\n        ResolvedReferenceType rtA = new ReferenceTypeImpl(classA.resolve());\n        ResolvedReferenceType rtB = new ReferenceTypeImpl(classB.resolve());\n\n        assertEquals(3, rtA.getDeclaredFields().size());\n        assertTrue(rtA.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"i\")));\n        assertTrue(rtA.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"c\")));\n        assertTrue(rtA.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"l\")));\n\n        assertEquals(2, rtB.getDeclaredFields().size());\n        assertTrue(rtB.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"f\")));\n        assertTrue(rtB.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"b\")));\n    }\n\n    @Test\n    void testGetAllFieldsVisibleToInheritors() {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        String code = \"class A { private int i; char c; public long l; } class B extends A { private float f; boolean b; };\";\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n        CompilationUnit cu = new JavaParser(parserConfiguration)\n                .parse(ParseStart.COMPILATION_UNIT, new StringProvider(code)).getResult().get();\n\n        ClassOrInterfaceDeclaration classA = cu.getClassByName(\"A\").get();\n        ClassOrInterfaceDeclaration classB = cu.getClassByName(\"B\").get();\n\n        ResolvedReferenceType rtA = new ReferenceTypeImpl(classA.resolve());\n        ResolvedReferenceType rtB = new ReferenceTypeImpl(classB.resolve());\n\n        assertEquals(2, rtA.getAllFieldsVisibleToInheritors().size());\n        assertTrue(rtA.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"c\")));\n        assertTrue(rtA.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"l\")));\n\n        assertEquals(3, rtB.getAllFieldsVisibleToInheritors().size());\n        assertTrue(rtB.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"c\")));\n        assertTrue(rtB.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"l\")));\n        assertTrue(rtB.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"b\")));\n    }\n    \n    @Test\n    void erasure_non_generic_type() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A {}\");\n        ResolvedType expected = types.get(0);\n        assertEquals(expected, types.get(0).erasure());\n    }\n    \n    @Test\n    // The erasure of a parameterized type\n    void erasure_rawtype() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A<String> {}\");\n        ResolvedType rt = types.get(0);\n        String expected = \"A\";\n        ResolvedType erasedType = rt.erasure();\n        assertTrue(rt.asReferenceType().isRawType());\n        assertTrue(erasedType.asReferenceType().typeParametersValues().isEmpty());\n        assertEquals(expected, erasedType.describe());\n    }\n\n    @Test\n    // The erasure of an array type T[] is |T|[].\n    void erasure_arraytype() {\n        // create a type : List <String>\n        ResolvedType genericList = array(genericType(List.class.getCanonicalName(), String.class.getCanonicalName()));\n        String expected = \"java.util.List[]\";\n        assertEquals(expected, genericList.erasure().describe());\n    }\n    \n    @Test\n    // The erasure of an array type T[] is |T|[].\n    void erasure_arraytype_with_bound() {\n        // create a type : List <T extends Serializable>\n        ResolvedTypeVariable typeArguments = parametrizedType(\"T\", Serializable.class.getCanonicalName());\n        ResolvedType genericList = array(genericType(List.class.getCanonicalName(), typeArguments));\n        String expected = \"java.util.List<java.io.Serializable>[]\";\n        assertEquals(expected, genericList.erasure().describe());\n    }\n    \n    @Test\n    // The erasure of a type variable (\u00a74.4) is the erasure of its leftmost bound.\n    void erasure_type_variable() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A<T extends Number> {}\");\n        ResolvedType rt = types.get(0);\n        String expected =  \"A<java.lang.Number>\";\n        assertEquals(expected, rt.erasure().describe());\n    }\n    \n    @Test\n    // The erasure of a nested type T.C is |T|.C.\n    void erasure_nested_type() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A<T> {\" +\n                        \"  class C{}\" +\n                        \"}\",\n                \"class A {\" +\n                        \"  class C{}\" +\n                        \"}\");\n        ResolvedType typeA = types.get(0);\n        ResolvedType typeC = types.get(1);\n        // ResolvedType expectedErasedAType= types.get(2);\n        ResolvedType expectedErasedCType = types.get(3);\n        String expectedA = \"A\";\n        String expectedC = \"A.C\";\n        assertEquals(expectedA, typeA.erasure().describe());\n        assertEquals(expectedC, typeC.erasure().describe());\n        // this type declaration are not equals because the type returned by typeA.erasure() always contains original\n        // typeParameters\n        // assertEquals(expectedErasedAType, typeA.erasure());\n        assertEquals(expectedErasedCType, typeC.erasure());\n    }\n    \n    // return a generic type with type arguments (arguments can be bounded)\n    private ResolvedType genericType(String type, ResolvedType... parameterTypes) {\n        return type(type, toList(parameterTypes));\n    }\n    \n    // return a generic type with type arguments\n    private ResolvedType genericType(String type, String... parameterTypes) {\n        return new ReferenceTypeImpl(typeSolver.solveType(type), types(parameterTypes));\n    }\n    \n    // return a list of types\n    private List<ResolvedType> types(String... types) {\n        return Arrays.stream(types).map(type -> type(type)).collect(Collectors.toList());\n    }\n\n    // return the specified type\n    private ResolvedType type(String type) {\n        return type(type, new ArrayList<>());\n    }\n    \n    private ResolvedType type(String type, List<ResolvedType> typeArguments) {\n        return new ReferenceTypeImpl(typeSolver.solveType(type), typeArguments);\n    }\n    \n    // return a type parameter\n    private ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n        return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n                Arrays.asList((extendBound(parameterType)))));\n    }\n\n    // rturn an extend bound\n    private Bound extendBound(String type) {\n        return Bound.extendsBound(type(type));\n    }\n\n    private Set<ResolvedType> toSet(ResolvedType... resolvedTypes) {\n        return new HashSet<>(toList(resolvedTypes));\n    }\n    \n    private List<ResolvedType> toList(ResolvedType... resolvedTypes) {\n        return Arrays.asList(resolvedTypes);\n    }\n    \n    // return an array type from the base type\n    private ResolvedType array(ResolvedType baseType) {\n        return new ResolvedArrayType(baseType);\n    }\n    \n    // return a list of types from the declared types (using a static parser) \n    private List<ResolvedType> declaredTypes(String... lines) {\n        CompilationUnit tree = treeOf(lines);\n        List<ResolvedType> results = Lists.newLinkedList();\n        for (ClassOrInterfaceDeclaration classTree : tree.findAll(ClassOrInterfaceDeclaration.class)) {\n            results.add(new ReferenceTypeImpl(classTree.resolve()));\n        }\n        return results;\n    }\n\n    private CompilationUnit treeOf(String... lines) {\n        StringBuilder builder = new StringBuilder();\n        for (String line : lines) {\n            builder.append(line).append(System.lineSeparator());\n        }\n        return StaticJavaParser.parse(builder.toString());\n    }\n    \n}\n", "filePathAfter": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/model/typesystem/ReferenceTypeTest.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.model.typesystem;\n\nimport static org.hamcrest.CoreMatchers.*;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.collection.IsIterableContainingInAnyOrder.containsInAnyOrder;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.ProtocolException;\nimport java.nio.Buffer;\nimport java.nio.CharBuffer;\nimport java.nio.file.FileSystemException;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport com.github.javaparser.*;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.resolution.TypeSolver;\nimport com.github.javaparser.resolution.declarations.*;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.Bound;\nimport com.github.javaparser.resolution.model.typesystem.NullType;\nimport com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.resolution.types.*;\nimport com.github.javaparser.symbolsolver.AbstractSymbolResolutionTest;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\n\nclass ReferenceTypeTest extends AbstractSymbolResolutionTest {\n\n    private ReferenceTypeImpl listOfA;\n    private ReferenceTypeImpl listOfStrings;\n    private ReferenceTypeImpl linkedListOfString;\n    private ReferenceTypeImpl collectionOfString;\n    private ReferenceTypeImpl listOfWildcardExtendsString;\n    private ReferenceTypeImpl listOfWildcardSuperString;\n    private ReferenceTypeImpl object;\n    private ReferenceTypeImpl string;\n    private TypeSolver typeSolver;\n    private ReferenceTypeImpl ioException;\n    private ResolvedType unionWithIOExceptionAsCommonAncestor;\n    private ResolvedType unionWithThrowableAsCommonAncestor;\n\n    @BeforeEach\n    void setup() {\n        typeSolver = new ReflectionTypeSolver();\n        object = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));\n        string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver));\n        listOfA = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(\"A\", \"foo.Bar\", Collections.emptyList()))));\n        listOfStrings = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        linkedListOfString = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(LinkedList.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        collectionOfString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(Collection.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        listOfWildcardExtendsString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(ResolvedWildcard.extendsBound(string)));\n        listOfWildcardSuperString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(ResolvedWildcard.superBound(string)));\n        ioException = new ReferenceTypeImpl(new ReflectionClassDeclaration(IOException.class, typeSolver));\n        unionWithIOExceptionAsCommonAncestor = new ResolvedUnionType(Arrays.asList(\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(ProtocolException.class, typeSolver)),\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(FileSystemException.class, typeSolver))\n        ));\n        unionWithThrowableAsCommonAncestor = new ResolvedUnionType(Arrays.asList(\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(ClassCastException.class, typeSolver)),\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(AssertionError.class, typeSolver))\n        ));\n\n        // minimal initialization of JavaParser\n        ParserConfiguration configuration = new ParserConfiguration()\n                .setSymbolResolver(new JavaSymbolSolver(new ReflectionTypeSolver()));\n        // Setup parser\n        StaticJavaParser.setConfiguration(configuration);\n    }\n\n    @Test\n    void testDerivationOfTypeParameters() {\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl ref1 = new ReferenceTypeImpl(typeSolver.solveType(LinkedList.class.getCanonicalName()));\n        assertEquals(1, ref1.typeParametersValues().size());\n        assertEquals(true, ref1.typeParametersValues().get(0).isTypeVariable());\n        assertEquals(\"E\", ref1.typeParametersValues().get(0).asTypeParameter().getName());\n    }\n\n    @Test\n    void testIsArray() {\n        assertEquals(false, object.isArray());\n        assertEquals(false, string.isArray());\n        assertEquals(false, listOfA.isArray());\n        assertEquals(false, listOfStrings.isArray());\n    }\n\n    @Test\n    void testIsPrimitive() {\n        assertEquals(false, object.isPrimitive());\n        assertEquals(false, string.isPrimitive());\n        assertEquals(false, listOfA.isPrimitive());\n        assertEquals(false, listOfStrings.isPrimitive());\n    }\n\n    @Test\n    void testIsNull() {\n        assertEquals(false, object.isNull());\n        assertEquals(false, string.isNull());\n        assertEquals(false, listOfA.isNull());\n        assertEquals(false, listOfStrings.isNull());\n    }\n\n    @Test\n    void testIsReference() {\n        assertEquals(true, object.isReference());\n        assertEquals(true, string.isReference());\n        assertEquals(true, listOfA.isReference());\n        assertEquals(true, listOfStrings.isReference());\n    }\n\n    @Test\n    void testIsReferenceType() {\n        assertEquals(true, object.isReferenceType());\n        assertEquals(true, string.isReferenceType());\n        assertEquals(true, listOfA.isReferenceType());\n        assertEquals(true, listOfStrings.isReferenceType());\n    }\n\n    @Test\n    void testIsVoid() {\n        assertEquals(false, object.isVoid());\n        assertEquals(false, string.isVoid());\n        assertEquals(false, listOfA.isVoid());\n        assertEquals(false, listOfStrings.isVoid());\n    }\n\n    @Test\n    void testIsTypeVariable() {\n        assertEquals(false, object.isTypeVariable());\n        assertEquals(false, string.isTypeVariable());\n        assertEquals(false, listOfA.isTypeVariable());\n        assertEquals(false, listOfStrings.isTypeVariable());\n    }\n\n    @Test\n    void testAsReferenceTypeUsage() {\n        assertTrue(object == object.asReferenceType());\n        assertTrue(string == string.asReferenceType());\n        assertTrue(listOfA == listOfA.asReferenceType());\n        assertTrue(listOfStrings == listOfStrings.asReferenceType());\n    }\n\n    @Test\n    void testAsTypeParameter() {\n        assertThrows(UnsupportedOperationException.class, () -> object.asTypeParameter());\n    }\n\n    @Test\n    void testAsArrayTypeUsage() {\n        assertThrows(UnsupportedOperationException.class, () -> object.asArrayType());\n    }\n\n    @Test\n    void testAsDescribe() {\n        assertEquals(\"java.lang.Object\", object.describe());\n        assertEquals(\"java.lang.String\", string.describe());\n        assertEquals(\"java.util.List<A>\", listOfA.describe());\n        assertEquals(\"java.util.List<java.lang.String>\", listOfStrings.describe());\n    }\n\n    @Test\n    void testReplaceParam() {\n        ResolvedTypeParameterDeclaration tpA = ResolvedTypeParameterDeclaration.onType(\"A\", \"foo.Bar\", Collections.emptyList());\n        assertTrue(object == object.replaceTypeVariables(tpA, object));\n        assertTrue(string == string.replaceTypeVariables(tpA, object));\n        assertEquals(listOfStrings, listOfStrings.replaceTypeVariables(tpA, object));\n        assertEquals(listOfStrings, listOfA.replaceTypeVariables(tpA, string));\n    }\n\n    @Test\n    void testIsAssignableBySimple() {\n        assertEquals(true, object.isAssignableBy(string));\n        assertEquals(false, string.isAssignableBy(object));\n        assertEquals(false, listOfStrings.isAssignableBy(listOfA));\n        assertEquals(false, listOfA.isAssignableBy(listOfStrings));\n\n        assertEquals(false, object.isAssignableBy(ResolvedVoidType.INSTANCE));\n        assertEquals(false, string.isAssignableBy(ResolvedVoidType.INSTANCE));\n        assertEquals(false, listOfStrings.isAssignableBy(ResolvedVoidType.INSTANCE));\n        assertEquals(false, listOfA.isAssignableBy(ResolvedVoidType.INSTANCE));\n\n        assertEquals(true, object.isAssignableBy(NullType.INSTANCE));\n        assertEquals(true, string.isAssignableBy(NullType.INSTANCE));\n        assertEquals(true, listOfStrings.isAssignableBy(NullType.INSTANCE));\n        assertEquals(true, listOfA.isAssignableBy(NullType.INSTANCE));\n    }\n\n    @Test\n    void testIsAssignableByBoxedPrimitive() {\n        ResolvedReferenceType numberType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Number.class, typeSolver));\n        ResolvedReferenceType intType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Integer.class, typeSolver));\n        ResolvedReferenceType doubleType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Double.class, typeSolver));\n        ResolvedReferenceType byteType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Byte.class, typeSolver));\n        ResolvedReferenceType shortType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Short.class, typeSolver));\n        ResolvedReferenceType charType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Character.class, typeSolver));\n        ResolvedReferenceType longType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Long.class, typeSolver));\n        ResolvedReferenceType booleanType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Boolean.class, typeSolver));\n        ResolvedReferenceType floatType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Float.class, typeSolver));\n\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.INT));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.DOUBLE));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.SHORT));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.LONG));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.FLOAT));\n        assertEquals(false, numberType.isAssignableBy(ResolvedPrimitiveType.BOOLEAN));\n        assertEquals(true, intType.isAssignableBy(ResolvedPrimitiveType.INT));\n        assertEquals(true, doubleType.isAssignableBy(ResolvedPrimitiveType.DOUBLE));\n        assertEquals(true, byteType.isAssignableBy(ResolvedPrimitiveType.BYTE));\n        assertEquals(true, shortType.isAssignableBy(ResolvedPrimitiveType.SHORT));\n        assertEquals(true, charType.isAssignableBy(ResolvedPrimitiveType.CHAR));\n        assertEquals(true, longType.isAssignableBy(ResolvedPrimitiveType.LONG));\n        assertEquals(true, booleanType.isAssignableBy(ResolvedPrimitiveType.BOOLEAN));\n        assertEquals(true, floatType.isAssignableBy(ResolvedPrimitiveType.FLOAT));\n    }\n\n    @Test\n    void testIsCorresponding() {\n\n        // ResolvedReferenceTypeTester is defined to allow to test protected method isCorrespondingBoxingType(..)\n        class ResolvedReferenceTypeTester extends ReferenceTypeImpl {\n\n            public ResolvedReferenceTypeTester(ResolvedReferenceTypeDeclaration typeDeclaration,\n                                               TypeSolver typeSolver) {\n                super(typeDeclaration);\n            }\n\n            @Override\n\t\t\tpublic boolean isCorrespondingBoxingType(String name) {\n                return super.isCorrespondingBoxingType(name);\n            }\n\n        }\n\n        ResolvedReferenceTypeTester numberType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Number.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester intType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Integer.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester doubleType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Double.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester byteType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Byte.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester shortType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Short.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester charType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Character.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester longType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Long.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester booleanType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Boolean.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester floatType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Float.class, typeSolver), typeSolver);\n\n        ResolvedReferenceTypeTester otherType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(String.class, typeSolver), typeSolver);\n\n        assertEquals(true, intType.isCorrespondingBoxingType(ResolvedPrimitiveType.INT.describe()));\n        assertEquals(true, doubleType.isCorrespondingBoxingType(ResolvedPrimitiveType.DOUBLE.describe()));\n        assertEquals(true, byteType.isCorrespondingBoxingType(ResolvedPrimitiveType.BYTE.describe()));\n        assertEquals(true, shortType.isCorrespondingBoxingType(ResolvedPrimitiveType.SHORT.describe()));\n        assertEquals(true, charType.isCorrespondingBoxingType(ResolvedPrimitiveType.CHAR.describe()));\n        assertEquals(true, longType.isCorrespondingBoxingType(ResolvedPrimitiveType.LONG.describe()));\n        assertEquals(true, booleanType.isCorrespondingBoxingType(ResolvedPrimitiveType.BOOLEAN.describe()));\n        assertEquals(true, floatType.isCorrespondingBoxingType(ResolvedPrimitiveType.FLOAT.describe()));\n\n        assertEquals(false, numberType.isCorrespondingBoxingType(ResolvedPrimitiveType.INT.describe()));\n\n        assertThrows(IllegalArgumentException.class, () -> {\n            intType.isCorrespondingBoxingType(\"String\");\n        });\n    }\n\n    @Test\n    void testIsAssignableByGenerics() {\n        assertEquals(false, listOfStrings.isAssignableBy(listOfWildcardExtendsString));\n        assertEquals(false, listOfStrings.isAssignableBy(listOfWildcardExtendsString));\n        assertEquals(true, listOfWildcardExtendsString.isAssignableBy(listOfStrings));\n        assertEquals(false, listOfWildcardExtendsString.isAssignableBy(listOfWildcardSuperString));\n        assertEquals(true, listOfWildcardSuperString.isAssignableBy(listOfStrings));\n        assertEquals(false, listOfWildcardSuperString.isAssignableBy(listOfWildcardExtendsString));\n    }\n\n    @Test\n    void testIsAssignableByGenericsInheritance() {\n        assertEquals(true, collectionOfString.isAssignableBy(collectionOfString));\n        assertEquals(true, collectionOfString.isAssignableBy(listOfStrings));\n        assertEquals(true, collectionOfString.isAssignableBy(linkedListOfString));\n\n        assertEquals(false, listOfStrings.isAssignableBy(collectionOfString));\n        assertEquals(true, listOfStrings.isAssignableBy(listOfStrings));\n        assertEquals(true, listOfStrings.isAssignableBy(linkedListOfString));\n\n        assertEquals(false, linkedListOfString.isAssignableBy(collectionOfString));\n        assertEquals(false, linkedListOfString.isAssignableBy(listOfStrings));\n        assertEquals(true, linkedListOfString.isAssignableBy(linkedListOfString));\n    }\n\n    @Test\n    void testIsAssignableByUnionType() {\n        assertEquals(true, ioException.isAssignableBy(unionWithIOExceptionAsCommonAncestor));\n        assertEquals(false, ioException.isAssignableBy(unionWithThrowableAsCommonAncestor));\n    }\n\n    @Test\n    void testGetAllAncestorsConsideringTypeParameters() {\n        assertThat(linkedListOfString.getAllAncestors(), hasItem(object));\n        assertThat(linkedListOfString.getAllAncestors(), hasItem(listOfStrings));\n        assertThat(linkedListOfString.getAllAncestors(), hasItem(collectionOfString));\n        assertThat(linkedListOfString.getAllAncestors(), not(hasItem(listOfA)));\n    }\n\n    class Foo {\n\n    }\n\n    class Bar extends Foo {\n\n    }\n\n    class Bazzer<A, B, C> {\n\n    }\n\n    class MoreBazzing<A, B> extends Bazzer<B, String, A> {\n\n    }\n\n    @Test\n    void testGetAllAncestorsConsideringGenericsCases() {\n        ReferenceTypeImpl foo = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver));\n        ReferenceTypeImpl bar = new ReferenceTypeImpl(new ReflectionClassDeclaration(Bar.class, typeSolver));\n        ReferenceTypeImpl left, right;\n\n        //YES MoreBazzing<Foo, Bar> e1 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(foo, bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<? extends Foo, Bar> e2 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(ResolvedWildcard.extendsBound(foo), bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<Foo, ? extends Bar> e3 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(foo, ResolvedWildcard.extendsBound(bar)))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<? extends Foo, ? extends Foo> e4 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(ResolvedWildcard.extendsBound(foo), ResolvedWildcard.extendsBound(foo)))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<? extends Foo, ? extends Foo> e5 = new MoreBazzing<Bar, Bar>();\n        left = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                ImmutableList.of(ResolvedWildcard.extendsBound(foo), ResolvedWildcard.extendsBound(foo)));\n        right = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                ImmutableList.of(bar, bar));\n        assertEquals(true, left.isAssignableBy(right));\n\n        //YES Bazzer<Object, String, String> e6 = new MoreBazzing<String, Object>();\n        left = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                ImmutableList.of(object, string, string));\n        right = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                ImmutableList.of(string, object));\n\n        // To debug the following\n        List<ResolvedReferenceType> ancestors = right.getAllAncestors();\n        ResolvedReferenceType moreBazzingAncestor = ancestors.stream()\n                .filter(a -> a.getQualifiedName().endsWith(\"Bazzer\"))\n                .findFirst().get();\n\n        assertEquals(true, left.isAssignableBy(right));\n\n        //YES Bazzer<String,String,String> e7 = new MoreBazzing<String, String>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(string, string, string))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(string, string)))\n        );\n\n        //YES Bazzer<Bar,String,Foo> e8 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(bar, string, foo))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES Bazzer<Foo,String,Bar> e9 = new MoreBazzing<Bar, Foo>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(foo, string, bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n\n        //NO Bazzer<Bar,String,Foo> n1 = new MoreBazzing<Bar, Foo>();\n        assertEquals(false,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(bar, string, foo))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n\n        //NO Bazzer<Bar,String,Bar> n2 = new MoreBazzing<Bar, Foo>();\n        assertEquals(false,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(bar, string, foo))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n\n        //NO Bazzer<Foo,Object,Bar> n3 = new MoreBazzing<Bar, Foo>();\n        assertEquals(false,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(foo, object, bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n    }\n\n    @Test\n    void charSequenceIsAssignableToObject() {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl charSequence = new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(CharSequence.class, typeSolver));\n        ReferenceTypeImpl object = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));\n        assertEquals(false, charSequence.isAssignableBy(object));\n        assertEquals(true, object.isAssignableBy(charSequence));\n    }\n\n    @Test\n    void testGetFieldTypeExisting() {\n        class Foo<A> {\n\n            List<A> elements;\n        }\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver));\n\n        assertEquals(true, ref.getFieldType(\"elements\").isPresent());\n        assertEquals(true, ref.getFieldType(\"elements\").get().isReferenceType());\n        assertEquals(List.class.getCanonicalName(), ref.getFieldType(\"elements\").get().asReferenceType().getQualifiedName());\n        assertEquals(1, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().size());\n        assertEquals(true, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).isTypeVariable());\n        assertEquals(\"A\", ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).asTypeParameter().getName());\n\n        ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n\n        assertEquals(true, ref.getFieldType(\"elements\").isPresent());\n        assertEquals(true, ref.getFieldType(\"elements\").get().isReferenceType());\n        assertEquals(List.class.getCanonicalName(), ref.getFieldType(\"elements\").get().asReferenceType().getQualifiedName());\n        assertEquals(1, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().size());\n        assertEquals(true, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).isReferenceType());\n        assertEquals(String.class.getCanonicalName(), ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).asReferenceType().getQualifiedName());\n    }\n\n    @Test\n    void testGetFieldTypeUnexisting() {\n        class Foo<A> {\n\n            List<A> elements;\n        }\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver));\n\n        assertEquals(false, ref.getFieldType(\"bar\").isPresent());\n\n        ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n\n        assertEquals(false, ref.getFieldType(\"bar\").isPresent());\n    }\n\n    @Test\n    void testTypeParamValue() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration arraylist = new ReflectionClassDeclaration(ArrayList.class, typeResolver);\n        ResolvedClassDeclaration abstractList = new ReflectionClassDeclaration(AbstractList.class, typeResolver);\n        ResolvedClassDeclaration abstractCollection = new ReflectionClassDeclaration(AbstractCollection.class, typeResolver);\n        ResolvedInterfaceDeclaration list = new ReflectionInterfaceDeclaration(List.class, typeResolver);\n        ResolvedInterfaceDeclaration collection = new ReflectionInterfaceDeclaration(Collection.class, typeResolver);\n        ResolvedInterfaceDeclaration iterable = new ReflectionInterfaceDeclaration(Iterable.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType arrayListOfString = new ReferenceTypeImpl(arraylist, ImmutableList.of(string));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(arraylist.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(abstractList.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(abstractCollection.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(list.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(collection.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(iterable.getTypeParameters().get(0)));\n    }\n\n    @Test\n    void testGetAllAncestorsOnRawType() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration arraylist = new ReflectionClassDeclaration(ArrayList.class, typeResolver);\n        ResolvedReferenceType rawArrayList = new ReferenceTypeImpl(arraylist);\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        rawArrayList.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(9, ancestors.size());\n\n        ResolvedTypeVariable tv = new ResolvedTypeVariable(arraylist.getTypeParameters().get(0));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(RandomAccess.class, typeResolver)), ancestors.get(\"java.util.RandomAccess\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractCollection.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.AbstractCollection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(List.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.List\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Cloneable.class, typeResolver)), ancestors.get(\"java.lang.Cloneable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractList.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.AbstractList\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.lang.Iterable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Serializable.class, typeResolver)), ancestors.get(\"java.io.Serializable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForInterface() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedInterfaceDeclaration list = new ReflectionInterfaceDeclaration(List.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType listOfString = new ReferenceTypeImpl(list, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        listOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(2, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForClassAbstractCollection() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration abstractCollection = new ReflectionClassDeclaration(AbstractCollection.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType abstractCollectionOfString = new ReferenceTypeImpl(abstractCollection, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        abstractCollectionOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(3, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForClassAbstractList() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration abstractList = new ReflectionClassDeclaration(AbstractList.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType abstractListOfString = new ReferenceTypeImpl(abstractList, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        abstractListOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(5, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractCollection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.AbstractCollection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(List.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.List\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForClassArrayList() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration arraylist = new ReflectionClassDeclaration(ArrayList.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType arrayListOfString = new ReferenceTypeImpl(arraylist, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        arrayListOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(9, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(RandomAccess.class, typeResolver)), ancestors.get(\"java.util.RandomAccess\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractCollection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.AbstractCollection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(List.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.List\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Cloneable.class, typeResolver)), ancestors.get(\"java.lang.Cloneable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractList.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.AbstractList\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Serializable.class, typeResolver)), ancestors.get(\"java.io.Serializable\"));\n    }\n\n    @Test\n    void testTypeParametersValues() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedReferenceType stream = new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Stream.class, typeResolver));\n        assertEquals(1, stream.typeParametersValues().size());\n        assertEquals(new ResolvedTypeVariable(new ReflectionInterfaceDeclaration(Stream.class, typeResolver).getTypeParameters().get(0)), stream.typeParametersValues().get(0));\n    }\n\n    @Test\n    void testReplaceTypeVariables() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedInterfaceDeclaration streamInterface = new ReflectionInterfaceDeclaration(Stream.class, typeResolver);\n        ResolvedReferenceType stream = new ReferenceTypeImpl(streamInterface);\n\n        ResolvedMethodDeclaration streamMap = streamInterface.getDeclaredMethods().stream().filter(m -> m.getName().equals(\"map\")).findFirst().get();\n        ResolvedTypeParameterDeclaration streamMapR = streamMap.findTypeParameter(\"T\").get();\n        ResolvedTypeVariable typeVariable = new ResolvedTypeVariable(streamMapR);\n        stream = stream.deriveTypeParameters(stream.typeParametersMap().toBuilder().setValue(stream.getTypeDeclaration().get().getTypeParameters().get(0), typeVariable).build());\n\n        ResolvedTypeParameterDeclaration tpToReplace = streamInterface.getTypeParameters().get(0);\n        ResolvedType replaced = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n\n        ResolvedType streamReplaced = stream.replaceTypeVariables(tpToReplace, replaced);\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", streamReplaced.describe());\n    }\n\n    @Test\n    void testReplaceTypeVariablesWithLambdaInBetween() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedInterfaceDeclaration streamInterface = new ReflectionInterfaceDeclaration(Stream.class, typeResolver);\n        ResolvedReferenceType stream = new ReferenceTypeImpl(streamInterface);\n\n        ResolvedMethodDeclaration streamMap = streamInterface.getDeclaredMethods().stream().filter(m -> m.getName().equals(\"map\")).findFirst().get();\n        ResolvedTypeParameterDeclaration streamMapR = streamMap.findTypeParameter(\"T\").get();\n        ResolvedTypeVariable typeVariable = new ResolvedTypeVariable(streamMapR);\n        stream = stream.deriveTypeParameters(stream.typeParametersMap().toBuilder().setValue(stream.getTypeDeclaration().get().getTypeParameters().get(0), typeVariable).build());\n\n        ResolvedTypeParameterDeclaration tpToReplace = streamInterface.getTypeParameters().get(0);\n        ResolvedType replaced = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n\n        ResolvedType streamReplaced = stream.replaceTypeVariables(tpToReplace, replaced);\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", streamReplaced.describe());\n    }\n\n    @Test\n    void testDirectAncestorsOfObject() {\n        assertEquals(0, object.getDirectAncestors().size());\n    }\n\n    @Test\n    void testDirectAncestorsOfInterface() {\n        ResolvedReferenceType iterableOfString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(Iterable.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        assertEquals(0, iterableOfString.getDirectAncestors().size());\n    }\n\n    @Test\n    void testDirectAncestorsOfInterfaceExtendingInterface() {\n        assertEquals(1, collectionOfString.getDirectAncestors().size());\n        ResolvedReferenceType ancestor1 = collectionOfString.getDirectAncestors().get(0);\n        assertEquals(\"java.lang.Iterable\", ancestor1.getQualifiedName());\n        assertEquals(1, ancestor1.getTypeParametersMap().size());\n        assertEquals(\"T\", ancestor1.getTypeParametersMap().get(0).a.getName());\n        assertEquals(\"java.lang.String\", ancestor1.getTypeParametersMap().get(0).b.describe());\n    }\n\n    @Test\n    void testDirectAncestorsOfClassWithoutSuperClassOrInterfaces() {\n        ResolvedReferenceType buffer = new ReferenceTypeImpl(new ReflectionClassDeclaration(Buffer.class, typeSolver));\n        Set<String> ancestors = buffer.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        assertThat(ancestors, equalTo(new HashSet<>(Arrays.asList(\"java.lang.Object\"))));\n    }\n\n    @Test\n    void testDirectAncestorsOfObjectClass() {\n        ResolvedReferenceType object = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));\n        Set<String> ancestors = object.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        assertEquals(new HashSet<>(), ancestors);\n    }\n\n    @Test\n    void testDirectAncestorsOfClassWithSuperClass() {\n        ResolvedReferenceType charbuffer = new ReferenceTypeImpl(new ReflectionClassDeclaration(CharBuffer.class, typeSolver));\n        Set<String> ancestors = charbuffer.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        assertThat(ancestors, containsInAnyOrder(\n                \"java.lang.CharSequence\",\n                \"java.lang.Appendable\",\n                \"java.nio.Buffer\",\n                \"java.lang.Readable\",\n                \"java.lang.Comparable<java.nio.CharBuffer>\"\n        ));\n    }\n\n    @Test\n    void testDirectAncestorsOfClassWithInterfaces() {\n        Set<String> ancestors = string.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        // FIXME: Remove this temporary fix which varies the test based on the detected JDK which is running these tests.\n        TestJdk currentJdk = TestJdk.getCurrentHostJdk();\n        if (currentJdk.getMajorVersion() < 12) {\n            // JDK 12 introduced \"java.lang.constant.Constable\"\n            assertThat(ancestors, containsInAnyOrder(\n                    \"java.lang.CharSequence\",\n                    \"java.lang.Object\",\n                    \"java.lang.Comparable<java.lang.String>\",\n                    \"java.io.Serializable\"\n            ));\n        } else {\n            // JDK 12 introduced \"java.lang.constant.Constable\"\n            assertThat(ancestors, containsInAnyOrder(\n                    \"java.lang.CharSequence\",\n                    \"java.lang.Object\",\n                    \"java.lang.Comparable<java.lang.String>\",\n                    \"java.io.Serializable\",\n                    \"java.lang.constant.Constable\",\n                    \"java.lang.constant.ConstantDesc\"\n            ));\n        }\n    }\n\n    @Test\n    void testDeclaredFields() {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        String code = \"class A { private int i; char c; public long l; } class B extends A { private float f; boolean b; };\";\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n        CompilationUnit cu = new JavaParser(parserConfiguration)\n                .parse(ParseStart.COMPILATION_UNIT, new StringProvider(code)).getResult().get();\n\n        ClassOrInterfaceDeclaration classA = cu.getClassByName(\"A\").get();\n        ClassOrInterfaceDeclaration classB = cu.getClassByName(\"B\").get();\n\n        ResolvedReferenceType rtA = new ReferenceTypeImpl(classA.resolve());\n        ResolvedReferenceType rtB = new ReferenceTypeImpl(classB.resolve());\n\n        assertEquals(3, rtA.getDeclaredFields().size());\n        assertTrue(rtA.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"i\")));\n        assertTrue(rtA.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"c\")));\n        assertTrue(rtA.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"l\")));\n\n        assertEquals(2, rtB.getDeclaredFields().size());\n        assertTrue(rtB.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"f\")));\n        assertTrue(rtB.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"b\")));\n    }\n\n    @Test\n    void testGetAllFieldsVisibleToInheritors() {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        String code = \"class A { private int i; char c; public long l; } class B extends A { private float f; boolean b; };\";\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n        CompilationUnit cu = new JavaParser(parserConfiguration)\n                .parse(ParseStart.COMPILATION_UNIT, new StringProvider(code)).getResult().get();\n\n        ClassOrInterfaceDeclaration classA = cu.getClassByName(\"A\").get();\n        ClassOrInterfaceDeclaration classB = cu.getClassByName(\"B\").get();\n\n        ResolvedReferenceType rtA = new ReferenceTypeImpl(classA.resolve());\n        ResolvedReferenceType rtB = new ReferenceTypeImpl(classB.resolve());\n\n        assertEquals(2, rtA.getAllFieldsVisibleToInheritors().size());\n        assertTrue(rtA.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"c\")));\n        assertTrue(rtA.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"l\")));\n\n        assertEquals(3, rtB.getAllFieldsVisibleToInheritors().size());\n        assertTrue(rtB.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"c\")));\n        assertTrue(rtB.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"l\")));\n        assertTrue(rtB.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"b\")));\n    }\n\n    @Test\n    void erasure_non_generic_type() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A {}\");\n        ResolvedType expected = types.get(0);\n        assertEquals(expected, types.get(0).erasure());\n    }\n\n    @Test\n    // The erasure of a parameterized type\n    void erasure_rawtype() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A<String> {}\");\n        ResolvedType rt = types.get(0);\n        String expected = \"A\";\n        ResolvedType erasedType = rt.erasure();\n        assertTrue(rt.asReferenceType().isRawType());\n        assertTrue(erasedType.asReferenceType().typeParametersValues().isEmpty());\n        assertEquals(expected, erasedType.describe());\n    }\n\n    @Test\n    // The erasure of an array type T[] is |T|[].\n    void erasure_arraytype() {\n        // create a type : List <String>\n        ResolvedType genericList = array(genericType(List.class.getCanonicalName(), String.class.getCanonicalName()));\n        String expected = \"java.util.List[]\";\n        assertEquals(expected, genericList.erasure().describe());\n    }\n\n    @Test\n    // The erasure of an array type T[] is |T|[].\n    void erasure_arraytype_with_bound() {\n        // create a type : List <T extends Serializable>\n        ResolvedTypeVariable typeArguments = parametrizedType(\"T\", Serializable.class.getCanonicalName());\n        ResolvedType genericList = array(genericType(List.class.getCanonicalName(), typeArguments));\n        String expected = \"java.util.List<java.io.Serializable>[]\";\n        assertEquals(expected, genericList.erasure().describe());\n    }\n\n    @Test\n    // The erasure of a type variable (\u00a74.4) is the erasure of its leftmost bound.\n    void erasure_type_variable() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A<T extends Number> {}\");\n        ResolvedType rt = types.get(0);\n        String expected =  \"A<java.lang.Number>\";\n        assertEquals(expected, rt.erasure().describe());\n    }\n\n    @Test\n    // The erasure of a nested type T.C is |T|.C.\n    void erasure_nested_type() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A<T> {\" +\n                        \"  class C{}\" +\n                        \"}\",\n                \"class A {\" +\n                        \"  class C{}\" +\n                        \"}\");\n        ResolvedType typeA = types.get(0);\n        ResolvedType typeC = types.get(1);\n        // ResolvedType expectedErasedAType= types.get(2);\n        ResolvedType expectedErasedCType = types.get(3);\n        String expectedA = \"A\";\n        String expectedC = \"A.C\";\n        assertEquals(expectedA, typeA.erasure().describe());\n        assertEquals(expectedC, typeC.erasure().describe());\n        // this type declaration are not equals because the type returned by typeA.erasure() always contains original\n        // typeParameters\n        // assertEquals(expectedErasedAType, typeA.erasure());\n        assertEquals(expectedErasedCType, typeC.erasure());\n    }\n\n    @Test\n    void extend_type() {\n    \tResolvedTypeVariable variable = parametrizedType(\"java.util.List\", \"java.lang.String\");\n    \tassertTrue(variable.asTypeParameter().hasUpperBound());\n    \tassertFalse(variable.asTypeParameter().hasLowerBound());\n    }\n\n    @Test\n    void super_type() {\n    \tResolvedTypeVariable variable = parametrizedTypeLowerBounded(\"java.util.List\", \"java.lang.String\");\n    \tassertTrue(variable.asTypeParameter().hasLowerBound());\n    \tassertFalse(variable.asTypeParameter().hasUpperBound());\n    }\n\n    // return a generic type with type arguments (arguments can be bounded)\n    private ResolvedType genericType(String type, ResolvedType... parameterTypes) {\n        return type(type, toList(parameterTypes));\n    }\n\n    // return a generic type with type arguments\n    private ResolvedType genericType(String type, String... parameterTypes) {\n        return new ReferenceTypeImpl(typeSolver.solveType(type), types(parameterTypes));\n    }\n\n    // return a list of types\n    private List<ResolvedType> types(String... types) {\n        return Arrays.stream(types).map(type -> type(type)).collect(Collectors.toList());\n    }\n\n    // return the specified type\n    private ResolvedType type(String type) {\n        return type(type, new ArrayList<>());\n    }\n\n    private ResolvedType type(String type, List<ResolvedType> typeArguments) {\n        return new ReferenceTypeImpl(typeSolver.solveType(type), typeArguments);\n    }\n\n    // return a type parameter\n    private ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n        return parametrizedTypeUpperBounded(type, parameterType);\n    }\n\n    private ResolvedTypeVariable parametrizedTypeUpperBounded(String type, String parameterType) {\n        return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n                Arrays.asList((extendBound(parameterType)))));\n    }\n\n    private ResolvedTypeVariable parametrizedTypeLowerBounded(String type, String parameterType) {\n        return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n                Arrays.asList((superBound(parameterType)))));\n    }\n\n    // return an extend bound\n    private Bound extendBound(String type) {\n        return Bound.extendsBound(type(type));\n    }\n\n    // return a super bound\n    private Bound superBound(String type) {\n        return Bound.superBound(type(type));\n    }\n\n    private Set<ResolvedType> toSet(ResolvedType... resolvedTypes) {\n        return new HashSet<>(toList(resolvedTypes));\n    }\n\n    private List<ResolvedType> toList(ResolvedType... resolvedTypes) {\n        return Arrays.asList(resolvedTypes);\n    }\n\n    // return an array type from the base type\n    private ResolvedType array(ResolvedType baseType) {\n        return new ResolvedArrayType(baseType);\n    }\n\n    // return a list of types from the declared types (using a static parser)\n    private List<ResolvedType> declaredTypes(String... lines) {\n        CompilationUnit tree = treeOf(lines);\n        List<ResolvedType> results = Lists.newLinkedList();\n        for (ClassOrInterfaceDeclaration classTree : tree.findAll(ClassOrInterfaceDeclaration.class)) {\n            results.add(new ReferenceTypeImpl(classTree.resolve()));\n        }\n        return results;\n    }\n\n    private CompilationUnit treeOf(String... lines) {\n        StringBuilder builder = new StringBuilder();\n        for (String line : lines) {\n            builder.append(line).append(System.lineSeparator());\n        }\n        return StaticJavaParser.parse(builder.toString());\n    }\n\n}\n", "diffSourceCodeSet": ["private ResolvedTypeVariable parametrizedTypeUpperBounded(String type, String parameterType) {\n        return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n                Arrays.asList((extendBound(parameterType)))));\n    }"], "invokedMethodSet": ["methodSignature: com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeTest#extendBound\n methodBody: private Bound extendBound(String type) {\nreturn Bound.extendsBound(type(type));\n}", "methodSignature: com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration#onType\n methodBody: static ResolvedTypeParameterDeclaration onType(final String name, String classQName, List<Bound> bounds) {\nreturn new ResolvedTypeParameterDeclaration(){\n  @Override public String getName(){\n    return name;\n  }\n  @Override public boolean declaredOnType(){\n    return true;\n  }\n  @Override public boolean declaredOnMethod(){\n    return false;\n  }\n  @Override public boolean declaredOnConstructor(){\n    return false;\n  }\n  @Override public String getContainerQualifiedName(){\n    return classQName;\n  }\n  @Override public String getContainerId(){\n    return classQName;\n  }\n  @Override public ResolvedTypeParametrizable getContainer(){\n    return null;\n  }\n  @Override public List<Bound> getBounds(){\n    return bounds;\n  }\n  @Override public String toString(){\n    return \"TypeParameter onType \" + name;\n  }\n  @Override public Optional<ResolvedReferenceTypeDeclaration> containerType(){\n    throw new UnsupportedOperationException();\n  }\n  @Override public ResolvedReferenceType object(){\n    throw new UnsupportedOperationException();\n  }\n}\n;\n}"], "sourceCodeAfterRefactoring": "private ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n        return parametrizedTypeUpperBounded(type, parameterType);\n    }\nprivate ResolvedTypeVariable parametrizedTypeUpperBounded(String type, String parameterType) {\n        return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n                Arrays.asList((extendBound(parameterType)))));\n    }", "diffSourceCode": "-  955:     private ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n-  956:         return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n-  957:                 Arrays.asList((extendBound(parameterType)))));\n-  958:     }\n-  971:     }\n-  972:     \n-  973:     // return an array type from the base type\n-  975:         return new ResolvedArrayType(baseType);\n-  976:     }\n-  977:     \n-  978:     // return a list of types from the declared types (using a static parser) \n+  955: \n+  956:     // return a list of types\n+  957:     private List<ResolvedType> types(String... types) {\n+  958:         return Arrays.stream(types).map(type -> type(type)).collect(Collectors.toList());\n+  971:     private ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n+  972:         return parametrizedTypeUpperBounded(type, parameterType);\n+  973:     }\n+  975:     private ResolvedTypeVariable parametrizedTypeUpperBounded(String type, String parameterType) {\n+  976:         return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n+  977:                 Arrays.asList((extendBound(parameterType)))));\n+  978:     }\n", "uniqueId": "cc159998ac7c83234e2665cbc479f85dcc27f5d0_955_958_975_978_971_973", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To refactor the provided method `parametrizedType`, we can extract the creation of the `ResolvedTypeParameterDeclaration` into a separate method. This will improve readability and maintainability by making the code more modular and easier to understand.\n\nHere\u2019s the refactored code:\n\n```java\nprivate ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n    return new ResolvedTypeVariable(createResolvedTypeParameterDeclaration(type, parameterType));\n}\n\nprivate ResolvedTypeParameterDeclaration createResolvedTypeParameterDeclaration(String type, String parameterType) {\n    return ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n            Arrays.asList(extendBound(parameterType)));\n}\n```\n\nThe `createResolvedTypeParameterDeclaration` method encapsulates the logic for creating a `ResolvedTypeParameterDeclaration`, making the `parametrizedType` method cleaner and more focused on its primary responsibility.\n\nHere\u2019s the output in the required format:\n\n##########################\n```java\nprivate ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n    return new ResolvedTypeVariable(createResolvedTypeParameterDeclaration(type, parameterType));\n}\n\nprivate ResolvedTypeParameterDeclaration createResolvedTypeParameterDeclaration(String type, String parameterType) {\n    return ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n            Arrays.asList(extendBound(parameterType)));\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n        return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n                Arrays.asList((extendBound(parameterType)))));\n    }\n\nClass content:\n/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.model.typesystem;\n\nimport com.github.javaparser.*;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.resolution.TypeSolver;\nimport com.github.javaparser.resolution.declarations.*;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.Bound;\nimport com.github.javaparser.resolution.model.typesystem.NullType;\nimport com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.resolution.types.*;\nimport com.github.javaparser.symbolsolver.AbstractSymbolResolutionTest;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.ProtocolException;\nimport java.nio.Buffer;\nimport java.nio.CharBuffer;\nimport java.nio.file.FileSystemException;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static org.hamcrest.CoreMatchers.*;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.collection.IsIterableContainingInAnyOrder.containsInAnyOrder;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass ReferenceTypeTest extends AbstractSymbolResolutionTest {\n\n    private ReferenceTypeImpl listOfA;\n    private ReferenceTypeImpl listOfStrings;\n    private ReferenceTypeImpl linkedListOfString;\n    private ReferenceTypeImpl collectionOfString;\n    private ReferenceTypeImpl listOfWildcardExtendsString;\n    private ReferenceTypeImpl listOfWildcardSuperString;\n    private ReferenceTypeImpl object;\n    private ReferenceTypeImpl string;\n    private TypeSolver typeSolver;\n    private ReferenceTypeImpl ioException;\n    private ResolvedType unionWithIOExceptionAsCommonAncestor;\n    private ResolvedType unionWithThrowableAsCommonAncestor;\n\n    @BeforeEach\n    void setup() {\n        typeSolver = new ReflectionTypeSolver();\n        object = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));\n        string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver));\n        listOfA = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(\"A\", \"foo.Bar\", Collections.emptyList()))));\n        listOfStrings = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        linkedListOfString = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(LinkedList.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        collectionOfString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(Collection.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        listOfWildcardExtendsString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(ResolvedWildcard.extendsBound(string)));\n        listOfWildcardSuperString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(ResolvedWildcard.superBound(string)));\n        ioException = new ReferenceTypeImpl(new ReflectionClassDeclaration(IOException.class, typeSolver));\n        unionWithIOExceptionAsCommonAncestor = new ResolvedUnionType(Arrays.asList(\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(ProtocolException.class, typeSolver)),\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(FileSystemException.class, typeSolver))\n        ));\n        unionWithThrowableAsCommonAncestor = new ResolvedUnionType(Arrays.asList(\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(ClassCastException.class, typeSolver)),\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(AssertionError.class, typeSolver))\n        ));\n        \n        // minimal initialization of JavaParser\n        ParserConfiguration configuration = new ParserConfiguration()\n                .setSymbolResolver(new JavaSymbolSolver(new ReflectionTypeSolver()));\n        // Setup parser\n        StaticJavaParser.setConfiguration(configuration);\n    }\n\n    @Test\n    void testDerivationOfTypeParameters() {\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl ref1 = new ReferenceTypeImpl(typeSolver.solveType(LinkedList.class.getCanonicalName()));\n        assertEquals(1, ref1.typeParametersValues().size());\n        assertEquals(true, ref1.typeParametersValues().get(0).isTypeVariable());\n        assertEquals(\"E\", ref1.typeParametersValues().get(0).asTypeParameter().getName());\n    }\n\n    @Test\n    void testIsArray() {\n        assertEquals(false, object.isArray());\n        assertEquals(false, string.isArray());\n        assertEquals(false, listOfA.isArray());\n        assertEquals(false, listOfStrings.isArray());\n    }\n\n    @Test\n    void testIsPrimitive() {\n        assertEquals(false, object.isPrimitive());\n        assertEquals(false, string.isPrimitive());\n        assertEquals(false, listOfA.isPrimitive());\n        assertEquals(false, listOfStrings.isPrimitive());\n    }\n\n    @Test\n    void testIsNull() {\n        assertEquals(false, object.isNull());\n        assertEquals(false, string.isNull());\n        assertEquals(false, listOfA.isNull());\n        assertEquals(false, listOfStrings.isNull());\n    }\n\n    @Test\n    void testIsReference() {\n        assertEquals(true, object.isReference());\n        assertEquals(true, string.isReference());\n        assertEquals(true, listOfA.isReference());\n        assertEquals(true, listOfStrings.isReference());\n    }\n\n    @Test\n    void testIsReferenceType() {\n        assertEquals(true, object.isReferenceType());\n        assertEquals(true, string.isReferenceType());\n        assertEquals(true, listOfA.isReferenceType());\n        assertEquals(true, listOfStrings.isReferenceType());\n    }\n\n    @Test\n    void testIsVoid() {\n        assertEquals(false, object.isVoid());\n        assertEquals(false, string.isVoid());\n        assertEquals(false, listOfA.isVoid());\n        assertEquals(false, listOfStrings.isVoid());\n    }\n\n    @Test\n    void testIsTypeVariable() {\n        assertEquals(false, object.isTypeVariable());\n        assertEquals(false, string.isTypeVariable());\n        assertEquals(false, listOfA.isTypeVariable());\n        assertEquals(false, listOfStrings.isTypeVariable());\n    }\n\n    @Test\n    void testAsReferenceTypeUsage() {\n        assertTrue(object == object.asReferenceType());\n        assertTrue(string == string.asReferenceType());\n        assertTrue(listOfA == listOfA.asReferenceType());\n        assertTrue(listOfStrings == listOfStrings.asReferenceType());\n    }\n\n    @Test\n    void testAsTypeParameter() {\n        assertThrows(UnsupportedOperationException.class, () -> object.asTypeParameter());\n    }\n\n    @Test\n    void testAsArrayTypeUsage() {\n        assertThrows(UnsupportedOperationException.class, () -> object.asArrayType());\n    }\n\n    @Test\n    void testAsDescribe() {\n        assertEquals(\"java.lang.Object\", object.describe());\n        assertEquals(\"java.lang.String\", string.describe());\n        assertEquals(\"java.util.List<A>\", listOfA.describe());\n        assertEquals(\"java.util.List<java.lang.String>\", listOfStrings.describe());\n    }\n\n    @Test\n    void testReplaceParam() {\n        ResolvedTypeParameterDeclaration tpA = ResolvedTypeParameterDeclaration.onType(\"A\", \"foo.Bar\", Collections.emptyList());\n        assertTrue(object == object.replaceTypeVariables(tpA, object));\n        assertTrue(string == string.replaceTypeVariables(tpA, object));\n        assertEquals(listOfStrings, listOfStrings.replaceTypeVariables(tpA, object));\n        assertEquals(listOfStrings, listOfA.replaceTypeVariables(tpA, string));\n    }\n\n    @Test\n    void testIsAssignableBySimple() {\n        assertEquals(true, object.isAssignableBy(string));\n        assertEquals(false, string.isAssignableBy(object));\n        assertEquals(false, listOfStrings.isAssignableBy(listOfA));\n        assertEquals(false, listOfA.isAssignableBy(listOfStrings));\n\n        assertEquals(false, object.isAssignableBy(ResolvedVoidType.INSTANCE));\n        assertEquals(false, string.isAssignableBy(ResolvedVoidType.INSTANCE));\n        assertEquals(false, listOfStrings.isAssignableBy(ResolvedVoidType.INSTANCE));\n        assertEquals(false, listOfA.isAssignableBy(ResolvedVoidType.INSTANCE));\n\n        assertEquals(true, object.isAssignableBy(NullType.INSTANCE));\n        assertEquals(true, string.isAssignableBy(NullType.INSTANCE));\n        assertEquals(true, listOfStrings.isAssignableBy(NullType.INSTANCE));\n        assertEquals(true, listOfA.isAssignableBy(NullType.INSTANCE));\n    }\n\n    @Test\n    void testIsAssignableByBoxedPrimitive() {\n        ResolvedReferenceType numberType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Number.class, typeSolver));\n        ResolvedReferenceType intType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Integer.class, typeSolver));\n        ResolvedReferenceType doubleType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Double.class, typeSolver));\n        ResolvedReferenceType byteType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Byte.class, typeSolver));\n        ResolvedReferenceType shortType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Short.class, typeSolver));\n        ResolvedReferenceType charType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Character.class, typeSolver));\n        ResolvedReferenceType longType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Long.class, typeSolver));\n        ResolvedReferenceType booleanType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Boolean.class, typeSolver));\n        ResolvedReferenceType floatType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Float.class, typeSolver));\n\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.INT));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.DOUBLE));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.SHORT));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.LONG));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.FLOAT));\n        assertEquals(false, numberType.isAssignableBy(ResolvedPrimitiveType.BOOLEAN));\n        assertEquals(true, intType.isAssignableBy(ResolvedPrimitiveType.INT));\n        assertEquals(true, doubleType.isAssignableBy(ResolvedPrimitiveType.DOUBLE));\n        assertEquals(true, byteType.isAssignableBy(ResolvedPrimitiveType.BYTE));\n        assertEquals(true, shortType.isAssignableBy(ResolvedPrimitiveType.SHORT));\n        assertEquals(true, charType.isAssignableBy(ResolvedPrimitiveType.CHAR));\n        assertEquals(true, longType.isAssignableBy(ResolvedPrimitiveType.LONG));\n        assertEquals(true, booleanType.isAssignableBy(ResolvedPrimitiveType.BOOLEAN));\n        assertEquals(true, floatType.isAssignableBy(ResolvedPrimitiveType.FLOAT));\n    }\n\n    @Test\n    void testIsCorresponding() {\n\n        // ResolvedReferenceTypeTester is defined to allow to test protected method isCorrespondingBoxingType(..)\n        class ResolvedReferenceTypeTester extends ReferenceTypeImpl {\n\n            public ResolvedReferenceTypeTester(ResolvedReferenceTypeDeclaration typeDeclaration,\n                                               TypeSolver typeSolver) {\n                super(typeDeclaration);\n            }\n\n            public boolean isCorrespondingBoxingType(String name) {\n                return super.isCorrespondingBoxingType(name);\n            }\n\n        }\n\n        ResolvedReferenceTypeTester numberType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Number.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester intType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Integer.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester doubleType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Double.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester byteType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Byte.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester shortType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Short.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester charType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Character.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester longType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Long.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester booleanType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Boolean.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester floatType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Float.class, typeSolver), typeSolver);\n\n        ResolvedReferenceTypeTester otherType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(String.class, typeSolver), typeSolver);\n\n        assertEquals(true, intType.isCorrespondingBoxingType(ResolvedPrimitiveType.INT.describe()));\n        assertEquals(true, doubleType.isCorrespondingBoxingType(ResolvedPrimitiveType.DOUBLE.describe()));\n        assertEquals(true, byteType.isCorrespondingBoxingType(ResolvedPrimitiveType.BYTE.describe()));\n        assertEquals(true, shortType.isCorrespondingBoxingType(ResolvedPrimitiveType.SHORT.describe()));\n        assertEquals(true, charType.isCorrespondingBoxingType(ResolvedPrimitiveType.CHAR.describe()));\n        assertEquals(true, longType.isCorrespondingBoxingType(ResolvedPrimitiveType.LONG.describe()));\n        assertEquals(true, booleanType.isCorrespondingBoxingType(ResolvedPrimitiveType.BOOLEAN.describe()));\n        assertEquals(true, floatType.isCorrespondingBoxingType(ResolvedPrimitiveType.FLOAT.describe()));\n\n        assertEquals(false, numberType.isCorrespondingBoxingType(ResolvedPrimitiveType.INT.describe()));\n\n        assertThrows(IllegalArgumentException.class, () -> {\n            intType.isCorrespondingBoxingType(\"String\");\n        });\n    }\n\n    @Test\n    void testIsAssignableByGenerics() {\n        assertEquals(false, listOfStrings.isAssignableBy(listOfWildcardExtendsString));\n        assertEquals(false, listOfStrings.isAssignableBy(listOfWildcardExtendsString));\n        assertEquals(true, listOfWildcardExtendsString.isAssignableBy(listOfStrings));\n        assertEquals(false, listOfWildcardExtendsString.isAssignableBy(listOfWildcardSuperString));\n        assertEquals(true, listOfWildcardSuperString.isAssignableBy(listOfStrings));\n        assertEquals(false, listOfWildcardSuperString.isAssignableBy(listOfWildcardExtendsString));\n    }\n\n    @Test\n    void testIsAssignableByGenericsInheritance() {\n        assertEquals(true, collectionOfString.isAssignableBy(collectionOfString));\n        assertEquals(true, collectionOfString.isAssignableBy(listOfStrings));\n        assertEquals(true, collectionOfString.isAssignableBy(linkedListOfString));\n\n        assertEquals(false, listOfStrings.isAssignableBy(collectionOfString));\n        assertEquals(true, listOfStrings.isAssignableBy(listOfStrings));\n        assertEquals(true, listOfStrings.isAssignableBy(linkedListOfString));\n\n        assertEquals(false, linkedListOfString.isAssignableBy(collectionOfString));\n        assertEquals(false, linkedListOfString.isAssignableBy(listOfStrings));\n        assertEquals(true, linkedListOfString.isAssignableBy(linkedListOfString));\n    }\n    \n    @Test\n    void testIsAssignableByUnionType() {\n        assertEquals(true, ioException.isAssignableBy(unionWithIOExceptionAsCommonAncestor));\n        assertEquals(false, ioException.isAssignableBy(unionWithThrowableAsCommonAncestor));\n    }\n\n    @Test\n    void testGetAllAncestorsConsideringTypeParameters() {\n        assertThat(linkedListOfString.getAllAncestors(), hasItem(object));\n        assertThat(linkedListOfString.getAllAncestors(), hasItem(listOfStrings));\n        assertThat(linkedListOfString.getAllAncestors(), hasItem(collectionOfString));\n        assertThat(linkedListOfString.getAllAncestors(), not(hasItem(listOfA)));\n    }\n\n    class Foo {\n\n    }\n\n    class Bar extends Foo {\n\n    }\n\n    class Bazzer<A, B, C> {\n\n    }\n\n    class MoreBazzing<A, B> extends Bazzer<B, String, A> {\n\n    }\n\n    @Test\n    void testGetAllAncestorsConsideringGenericsCases() {\n        ReferenceTypeImpl foo = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver));\n        ReferenceTypeImpl bar = new ReferenceTypeImpl(new ReflectionClassDeclaration(Bar.class, typeSolver));\n        ReferenceTypeImpl left, right;\n\n        //YES MoreBazzing<Foo, Bar> e1 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(foo, bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<? extends Foo, Bar> e2 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(ResolvedWildcard.extendsBound(foo), bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<Foo, ? extends Bar> e3 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(foo, ResolvedWildcard.extendsBound(bar)))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<? extends Foo, ? extends Foo> e4 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(ResolvedWildcard.extendsBound(foo), ResolvedWildcard.extendsBound(foo)))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<? extends Foo, ? extends Foo> e5 = new MoreBazzing<Bar, Bar>();\n        left = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                ImmutableList.of(ResolvedWildcard.extendsBound(foo), ResolvedWildcard.extendsBound(foo)));\n        right = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                ImmutableList.of(bar, bar));\n        assertEquals(true, left.isAssignableBy(right));\n\n        //YES Bazzer<Object, String, String> e6 = new MoreBazzing<String, Object>();\n        left = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                ImmutableList.of(object, string, string));\n        right = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                ImmutableList.of(string, object));\n\n        // To debug the following\n        List<ResolvedReferenceType> ancestors = right.getAllAncestors();\n        ResolvedReferenceType moreBazzingAncestor = ancestors.stream()\n                .filter(a -> a.getQualifiedName().endsWith(\"Bazzer\"))\n                .findFirst().get();\n\n        assertEquals(true, left.isAssignableBy(right));\n\n        //YES Bazzer<String,String,String> e7 = new MoreBazzing<String, String>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(string, string, string))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(string, string)))\n        );\n\n        //YES Bazzer<Bar,String,Foo> e8 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(bar, string, foo))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES Bazzer<Foo,String,Bar> e9 = new MoreBazzing<Bar, Foo>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(foo, string, bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n\n        //NO Bazzer<Bar,String,Foo> n1 = new MoreBazzing<Bar, Foo>();\n        assertEquals(false,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(bar, string, foo))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n\n        //NO Bazzer<Bar,String,Bar> n2 = new MoreBazzing<Bar, Foo>();\n        assertEquals(false,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(bar, string, foo))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n\n        //NO Bazzer<Foo,Object,Bar> n3 = new MoreBazzing<Bar, Foo>();\n        assertEquals(false,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(foo, object, bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n    }\n\n    @Test\n    void charSequenceIsAssignableToObject() {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl charSequence = new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(CharSequence.class, typeSolver));\n        ReferenceTypeImpl object = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));\n        assertEquals(false, charSequence.isAssignableBy(object));\n        assertEquals(true, object.isAssignableBy(charSequence));\n    }\n\n    @Test\n    void testGetFieldTypeExisting() {\n        class Foo<A> {\n\n            List<A> elements;\n        }\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver));\n\n        assertEquals(true, ref.getFieldType(\"elements\").isPresent());\n        assertEquals(true, ref.getFieldType(\"elements\").get().isReferenceType());\n        assertEquals(List.class.getCanonicalName(), ref.getFieldType(\"elements\").get().asReferenceType().getQualifiedName());\n        assertEquals(1, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().size());\n        assertEquals(true, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).isTypeVariable());\n        assertEquals(\"A\", ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).asTypeParameter().getName());\n\n        ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n\n        assertEquals(true, ref.getFieldType(\"elements\").isPresent());\n        assertEquals(true, ref.getFieldType(\"elements\").get().isReferenceType());\n        assertEquals(List.class.getCanonicalName(), ref.getFieldType(\"elements\").get().asReferenceType().getQualifiedName());\n        assertEquals(1, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().size());\n        assertEquals(true, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).isReferenceType());\n        assertEquals(String.class.getCanonicalName(), ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).asReferenceType().getQualifiedName());\n    }\n\n    @Test\n    void testGetFieldTypeUnexisting() {\n        class Foo<A> {\n\n            List<A> elements;\n        }\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver));\n\n        assertEquals(false, ref.getFieldType(\"bar\").isPresent());\n\n        ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n\n        assertEquals(false, ref.getFieldType(\"bar\").isPresent());\n    }\n\n    @Test\n    void testTypeParamValue() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration arraylist = new ReflectionClassDeclaration(ArrayList.class, typeResolver);\n        ResolvedClassDeclaration abstractList = new ReflectionClassDeclaration(AbstractList.class, typeResolver);\n        ResolvedClassDeclaration abstractCollection = new ReflectionClassDeclaration(AbstractCollection.class, typeResolver);\n        ResolvedInterfaceDeclaration list = new ReflectionInterfaceDeclaration(List.class, typeResolver);\n        ResolvedInterfaceDeclaration collection = new ReflectionInterfaceDeclaration(Collection.class, typeResolver);\n        ResolvedInterfaceDeclaration iterable = new ReflectionInterfaceDeclaration(Iterable.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType arrayListOfString = new ReferenceTypeImpl(arraylist, ImmutableList.of(string));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(arraylist.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(abstractList.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(abstractCollection.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(list.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(collection.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(iterable.getTypeParameters().get(0)));\n    }\n\n    @Test\n    void testGetAllAncestorsOnRawType() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration arraylist = new ReflectionClassDeclaration(ArrayList.class, typeResolver);\n        ResolvedReferenceType rawArrayList = new ReferenceTypeImpl(arraylist);\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        rawArrayList.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(9, ancestors.size());\n\n        ResolvedTypeVariable tv = new ResolvedTypeVariable(arraylist.getTypeParameters().get(0));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(RandomAccess.class, typeResolver)), ancestors.get(\"java.util.RandomAccess\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractCollection.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.AbstractCollection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(List.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.List\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Cloneable.class, typeResolver)), ancestors.get(\"java.lang.Cloneable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractList.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.AbstractList\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.lang.Iterable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Serializable.class, typeResolver)), ancestors.get(\"java.io.Serializable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForInterface() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedInterfaceDeclaration list = new ReflectionInterfaceDeclaration(List.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType listOfString = new ReferenceTypeImpl(list, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        listOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(2, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForClassAbstractCollection() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration abstractCollection = new ReflectionClassDeclaration(AbstractCollection.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType abstractCollectionOfString = new ReferenceTypeImpl(abstractCollection, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        abstractCollectionOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(3, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForClassAbstractList() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration abstractList = new ReflectionClassDeclaration(AbstractList.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType abstractListOfString = new ReferenceTypeImpl(abstractList, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        abstractListOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(5, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractCollection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.AbstractCollection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(List.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.List\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForClassArrayList() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration arraylist = new ReflectionClassDeclaration(ArrayList.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType arrayListOfString = new ReferenceTypeImpl(arraylist, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        arrayListOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(9, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(RandomAccess.class, typeResolver)), ancestors.get(\"java.util.RandomAccess\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractCollection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.AbstractCollection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(List.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.List\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Cloneable.class, typeResolver)), ancestors.get(\"java.lang.Cloneable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractList.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.AbstractList\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Serializable.class, typeResolver)), ancestors.get(\"java.io.Serializable\"));\n    }\n\n    @Test\n    void testTypeParametersValues() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedReferenceType stream = new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Stream.class, typeResolver));\n        assertEquals(1, stream.typeParametersValues().size());\n        assertEquals(new ResolvedTypeVariable(new ReflectionInterfaceDeclaration(Stream.class, typeResolver).getTypeParameters().get(0)), stream.typeParametersValues().get(0));\n    }\n\n    @Test\n    void testReplaceTypeVariables() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedInterfaceDeclaration streamInterface = new ReflectionInterfaceDeclaration(Stream.class, typeResolver);\n        ResolvedReferenceType stream = new ReferenceTypeImpl(streamInterface);\n\n        ResolvedMethodDeclaration streamMap = streamInterface.getDeclaredMethods().stream().filter(m -> m.getName().equals(\"map\")).findFirst().get();\n        ResolvedTypeParameterDeclaration streamMapR = streamMap.findTypeParameter(\"T\").get();\n        ResolvedTypeVariable typeVariable = new ResolvedTypeVariable(streamMapR);\n        stream = stream.deriveTypeParameters(stream.typeParametersMap().toBuilder().setValue(stream.getTypeDeclaration().get().getTypeParameters().get(0), typeVariable).build());\n\n        ResolvedTypeParameterDeclaration tpToReplace = streamInterface.getTypeParameters().get(0);\n        ResolvedType replaced = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n\n        ResolvedType streamReplaced = stream.replaceTypeVariables(tpToReplace, replaced);\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", streamReplaced.describe());\n    }\n\n    @Test\n    void testReplaceTypeVariablesWithLambdaInBetween() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedInterfaceDeclaration streamInterface = new ReflectionInterfaceDeclaration(Stream.class, typeResolver);\n        ResolvedReferenceType stream = new ReferenceTypeImpl(streamInterface);\n\n        ResolvedMethodDeclaration streamMap = streamInterface.getDeclaredMethods().stream().filter(m -> m.getName().equals(\"map\")).findFirst().get();\n        ResolvedTypeParameterDeclaration streamMapR = streamMap.findTypeParameter(\"T\").get();\n        ResolvedTypeVariable typeVariable = new ResolvedTypeVariable(streamMapR);\n        stream = stream.deriveTypeParameters(stream.typeParametersMap().toBuilder().setValue(stream.getTypeDeclaration().get().getTypeParameters().get(0), typeVariable).build());\n\n        ResolvedTypeParameterDeclaration tpToReplace = streamInterface.getTypeParameters().get(0);\n        ResolvedType replaced = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n\n        ResolvedType streamReplaced = stream.replaceTypeVariables(tpToReplace, replaced);\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", streamReplaced.describe());\n    }\n\n    @Test\n    void testDirectAncestorsOfObject() {\n        assertEquals(0, object.getDirectAncestors().size());\n    }\n\n    @Test\n    void testDirectAncestorsOfInterface() {\n        ResolvedReferenceType iterableOfString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(Iterable.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        assertEquals(0, iterableOfString.getDirectAncestors().size());\n    }\n\n    @Test\n    void testDirectAncestorsOfInterfaceExtendingInterface() {\n        assertEquals(1, collectionOfString.getDirectAncestors().size());\n        ResolvedReferenceType ancestor1 = collectionOfString.getDirectAncestors().get(0);\n        assertEquals(\"java.lang.Iterable\", ancestor1.getQualifiedName());\n        assertEquals(1, ancestor1.getTypeParametersMap().size());\n        assertEquals(\"T\", ancestor1.getTypeParametersMap().get(0).a.getName());\n        assertEquals(\"java.lang.String\", ancestor1.getTypeParametersMap().get(0).b.describe());\n    }\n\n    @Test\n    void testDirectAncestorsOfClassWithoutSuperClassOrInterfaces() {\n        ResolvedReferenceType buffer = new ReferenceTypeImpl(new ReflectionClassDeclaration(Buffer.class, typeSolver));\n        Set<String> ancestors = buffer.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        assertThat(ancestors, equalTo(new HashSet<>(Arrays.asList(\"java.lang.Object\"))));\n    }\n\n    @Test\n    void testDirectAncestorsOfObjectClass() {\n        ResolvedReferenceType object = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));\n        Set<String> ancestors = object.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        assertEquals(new HashSet<>(), ancestors);\n    }\n\n    @Test\n    void testDirectAncestorsOfClassWithSuperClass() {\n        ResolvedReferenceType charbuffer = new ReferenceTypeImpl(new ReflectionClassDeclaration(CharBuffer.class, typeSolver));\n        Set<String> ancestors = charbuffer.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        assertThat(ancestors, containsInAnyOrder(\n                \"java.lang.CharSequence\",\n                \"java.lang.Appendable\",\n                \"java.nio.Buffer\",\n                \"java.lang.Readable\",\n                \"java.lang.Comparable<java.nio.CharBuffer>\"\n        ));\n    }\n\n    @Test\n    void testDirectAncestorsOfClassWithInterfaces() {\n        Set<String> ancestors = string.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        // FIXME: Remove this temporary fix which varies the test based on the detected JDK which is running these tests.\n        TestJdk currentJdk = TestJdk.getCurrentHostJdk();\n        if (currentJdk.getMajorVersion() < 12) {\n            // JDK 12 introduced \"java.lang.constant.Constable\"\n            assertThat(ancestors, containsInAnyOrder(\n                    \"java.lang.CharSequence\",\n                    \"java.lang.Object\",\n                    \"java.lang.Comparable<java.lang.String>\",\n                    \"java.io.Serializable\"\n            ));\n        } else {\n            // JDK 12 introduced \"java.lang.constant.Constable\"\n            assertThat(ancestors, containsInAnyOrder(\n                    \"java.lang.CharSequence\",\n                    \"java.lang.Object\",\n                    \"java.lang.Comparable<java.lang.String>\",\n                    \"java.io.Serializable\",\n                    \"java.lang.constant.Constable\",\n                    \"java.lang.constant.ConstantDesc\"\n            ));\n        }\n    }\n\n    @Test\n    void testDeclaredFields() {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        String code = \"class A { private int i; char c; public long l; } class B extends A { private float f; boolean b; };\";\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n        CompilationUnit cu = new JavaParser(parserConfiguration)\n                .parse(ParseStart.COMPILATION_UNIT, new StringProvider(code)).getResult().get();\n\n        ClassOrInterfaceDeclaration classA = cu.getClassByName(\"A\").get();\n        ClassOrInterfaceDeclaration classB = cu.getClassByName(\"B\").get();\n\n        ResolvedReferenceType rtA = new ReferenceTypeImpl(classA.resolve());\n        ResolvedReferenceType rtB = new ReferenceTypeImpl(classB.resolve());\n\n        assertEquals(3, rtA.getDeclaredFields().size());\n        assertTrue(rtA.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"i\")));\n        assertTrue(rtA.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"c\")));\n        assertTrue(rtA.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"l\")));\n\n        assertEquals(2, rtB.getDeclaredFields().size());\n        assertTrue(rtB.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"f\")));\n        assertTrue(rtB.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"b\")));\n    }\n\n    @Test\n    void testGetAllFieldsVisibleToInheritors() {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        String code = \"class A { private int i; char c; public long l; } class B extends A { private float f; boolean b; };\";\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n        CompilationUnit cu = new JavaParser(parserConfiguration)\n                .parse(ParseStart.COMPILATION_UNIT, new StringProvider(code)).getResult().get();\n\n        ClassOrInterfaceDeclaration classA = cu.getClassByName(\"A\").get();\n        ClassOrInterfaceDeclaration classB = cu.getClassByName(\"B\").get();\n\n        ResolvedReferenceType rtA = new ReferenceTypeImpl(classA.resolve());\n        ResolvedReferenceType rtB = new ReferenceTypeImpl(classB.resolve());\n\n        assertEquals(2, rtA.getAllFieldsVisibleToInheritors().size());\n        assertTrue(rtA.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"c\")));\n        assertTrue(rtA.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"l\")));\n\n        assertEquals(3, rtB.getAllFieldsVisibleToInheritors().size());\n        assertTrue(rtB.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"c\")));\n        assertTrue(rtB.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"l\")));\n        assertTrue(rtB.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"b\")));\n    }\n    \n    @Test\n    void erasure_non_generic_type() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A {}\");\n        ResolvedType expected = types.get(0);\n        assertEquals(expected, types.get(0).erasure());\n    }\n    \n    @Test\n    // The erasure of a parameterized type\n    void erasure_rawtype() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A<String> {}\");\n        ResolvedType rt = types.get(0);\n        String expected = \"A\";\n        ResolvedType erasedType = rt.erasure();\n        assertTrue(rt.asReferenceType().isRawType());\n        assertTrue(erasedType.asReferenceType().typeParametersValues().isEmpty());\n        assertEquals(expected, erasedType.describe());\n    }\n\n    @Test\n    // The erasure of an array type T[] is |T|[].\n    void erasure_arraytype() {\n        // create a type : List <String>\n        ResolvedType genericList = array(genericType(List.class.getCanonicalName(), String.class.getCanonicalName()));\n        String expected = \"java.util.List[]\";\n        assertEquals(expected, genericList.erasure().describe());\n    }\n    \n    @Test\n    // The erasure of an array type T[] is |T|[].\n    void erasure_arraytype_with_bound() {\n        // create a type : List <T extends Serializable>\n        ResolvedTypeVariable typeArguments = parametrizedType(\"T\", Serializable.class.getCanonicalName());\n        ResolvedType genericList = array(genericType(List.class.getCanonicalName(), typeArguments));\n        String expected = \"java.util.List<java.io.Serializable>[]\";\n        assertEquals(expected, genericList.erasure().describe());\n    }\n    \n    @Test\n    // The erasure of a type variable (\u00a74.4) is the erasure of its leftmost bound.\n    void erasure_type_variable() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A<T extends Number> {}\");\n        ResolvedType rt = types.get(0);\n        String expected =  \"A<java.lang.Number>\";\n        assertEquals(expected, rt.erasure().describe());\n    }\n    \n    @Test\n    // The erasure of a nested type T.C is |T|.C.\n    void erasure_nested_type() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A<T> {\" +\n                        \"  class C{}\" +\n                        \"}\",\n                \"class A {\" +\n                        \"  class C{}\" +\n                        \"}\");\n        ResolvedType typeA = types.get(0);\n        ResolvedType typeC = types.get(1);\n        // ResolvedType expectedErasedAType= types.get(2);\n        ResolvedType expectedErasedCType = types.get(3);\n        String expectedA = \"A\";\n        String expectedC = \"A.C\";\n        assertEquals(expectedA, typeA.erasure().describe());\n        assertEquals(expectedC, typeC.erasure().describe());\n        // this type declaration are not equals because the type returned by typeA.erasure() always contains original\n        // typeParameters\n        // assertEquals(expectedErasedAType, typeA.erasure());\n        assertEquals(expectedErasedCType, typeC.erasure());\n    }\n    \n    // return a generic type with type arguments (arguments can be bounded)\n    private ResolvedType genericType(String type, ResolvedType... parameterTypes) {\n        return type(type, toList(parameterTypes));\n    }\n    \n    // return a generic type with type arguments\n    private ResolvedType genericType(String type, String... parameterTypes) {\n        return new ReferenceTypeImpl(typeSolver.solveType(type), types(parameterTypes));\n    }\n    \n    // return a list of types\n    private List<ResolvedType> types(String... types) {\n        return Arrays.stream(types).map(type -> type(type)).collect(Collectors.toList());\n    }\n\n    // return the specified type\n    private ResolvedType type(String type) {\n        return type(type, new ArrayList<>());\n    }\n    \n    private ResolvedType type(String type, List<ResolvedType> typeArguments) {\n        return new ReferenceTypeImpl(typeSolver.solveType(type), typeArguments);\n    }\n    \n    // return a type parameter\n    private ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n        return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n                Arrays.asList((extendBound(parameterType)))));\n    }\n\n    // rturn an extend bound\n    private Bound extendBound(String type) {\n        return Bound.extendsBound(type(type));\n    }\n\n    private Set<ResolvedType> toSet(ResolvedType... resolvedTypes) {\n        return new HashSet<>(toList(resolvedTypes));\n    }\n    \n    private List<ResolvedType> toList(ResolvedType... resolvedTypes) {\n        return Arrays.asList(resolvedTypes);\n    }\n    \n    // return an array type from the base type\n    private ResolvedType array(ResolvedType baseType) {\n        return new ResolvedArrayType(baseType);\n    }\n    \n    // return a list of types from the declared types (using a static parser) \n    private List<ResolvedType> declaredTypes(String... lines) {\n        CompilationUnit tree = treeOf(lines);\n        List<ResolvedType> results = Lists.newLinkedList();\n        for (ClassOrInterfaceDeclaration classTree : tree.findAll(ClassOrInterfaceDeclaration.class)) {\n            results.add(new ReferenceTypeImpl(classTree.resolve()));\n        }\n        return results;\n    }\n\n    private CompilationUnit treeOf(String... lines) {\n        StringBuilder builder = new StringBuilder();\n        for (String line : lines) {\n            builder.append(line).append(System.lineSeparator());\n        }\n        return StaticJavaParser.parse(builder.toString());\n    }\n    \n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate isSpaceOrTabElement(nodeText NodeText, i int) : boolean extracted from private defineEnforcingIndentationContext(nodeText NodeText, startIndex int) : EnforcingIndentationContext in class com.github.javaparser.printer.lexicalpreservation.Difference", "diffLocations": [{"filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java", "startLine": 282, "endLine": 321, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java", "startLine": 293, "endLine": 333, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java", "startLine": 338, "endLine": 340, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between \n     * the previous end of line and the next non whitespace (or tab) character\n     * @param nodeText List of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n     * The number of consecutive whitespace (or tab) characters\n     */\n    private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n    \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n    \t// compute space before startIndex value\n\t\tif (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n\t\t\t// at this stage startIndex points to the first element before the deleted one\n\t\t\tfor (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\tctx = new EnforcingIndentationContext(startIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.start = i;\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n\t\t// compute space after the deleted element\n\t\tif (nodeText.getTextElement(startIndex).isSpaceOrTab()) {\n\t\t\tfor (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n        \n        return ctx;\n    }", "filePathBefore": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java", "isPureRefactoring": true, "commitId": "c9adc2fe0111fdb3f926d2df2264a8dcf6335f11", "packageNameBefore": "com.github.javaparser.printer.lexicalpreservation", "classNameBefore": "com.github.javaparser.printer.lexicalpreservation.Difference", "methodNameBefore": "com.github.javaparser.printer.lexicalpreservation.Difference#defineEnforcingIndentationContext", "classSignatureBefore": "public class Difference ", "methodNameBeforeSet": ["com.github.javaparser.printer.lexicalpreservation.Difference#defineEnforcingIndentationContext"], "classNameBeforeSet": ["com.github.javaparser.printer.lexicalpreservation.Difference"], "classSignatureBeforeSet": ["public class Difference "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.printer.lexicalpreservation;\n\nimport com.github.javaparser.GeneratedJavaParserConstants;\nimport com.github.javaparser.JavaToken;\nimport com.github.javaparser.JavaToken.Kind;\nimport com.github.javaparser.TokenTypes;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.nodeTypes.NodeWithTypeArguments;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.printer.concretesyntaxmodel.*;\nimport com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator.CsmChild;\n\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.stream.IntStream;\n\nimport static com.github.javaparser.GeneratedJavaParserConstants.*;\n\n/**\n * A Difference should give me a sequence of elements I should find (to indicate the context) followed by a list of elements\n * to remove or to add and follow by another sequence of elements.\n *\n * I should later be able to apply such difference to a nodeText.\n */\npublic class Difference {\n\n    public static final int STANDARD_INDENTATION_SIZE = 4;\n\n    private final NodeText nodeText;\n\n    private final Node node;\n\n    private final List<DifferenceElement> diffElements;\n\n    private final List<TextElement> originalElements;\n\n    private int originalIndex = 0;\n\n    private int diffIndex = 0;\n\n    private final List<TextElement> indentation;\n\n    private boolean addedIndentation = false;\n\n    Difference(List<DifferenceElement> diffElements, NodeText nodeText, Node node) {\n        if (nodeText == null) {\n            throw new NullPointerException(\"nodeText can not be null\");\n        }\n        this.nodeText = nodeText;\n        this.node = node;\n        this.diffElements = diffElements;\n        this.originalElements = nodeText.getElements();\n        this.indentation = LexicalPreservingPrinter.findIndentation(node);\n    }\n\n    /*\n     * Returns the indentation used after the last line break\n     */\n    private List<TextElement> processIndentation(List<TextElement> indentation, List<TextElement> prevElements) {\n        int eolIndex = lastIndexOfEol(prevElements);\n        // Return \"indentation\" as is if no EOL element was found\n        if (eolIndex < 0)\n            return indentation;\n        // Find consecutive space characters after the EOL element\n        indentation = takeWhile(prevElements.subList(eolIndex + 1, prevElements.size()), element -> element.isWhiteSpace());\n        return indentation;\n    }\n    \n    /*\n     * returns only the elements that match the given predicate.\n     * takeWhile takes elements from the initial stream while the predicate holds true.\n     * Meaning that when an element is encountered that does not match the predicate, the rest of the list is discarded. \n     */\n    List<TextElement> takeWhile(List<TextElement> prevElements, Predicate<TextElement> predicate) {\n    \tList<TextElement> spaces = new ArrayList<>();\n    \tfor (TextElement element : prevElements) {\n    \t\tif (predicate.test(element)) {\n    \t\t\tspaces.add(element);\n                continue;\n            }\n            break;\n    \t}\n    \treturn spaces;\n    }\n    \n    \n    int lastIndexOfEol(List<TextElement> source) {\n        return IntStream.range(0, source.size())\n                       .map(i -> source.size() - i - 1)\n                       .filter(i -> source.get(i).isNewline())\n                       .findFirst()\n                       .orElse(-1);\n    }\n\n    /*\n     * Returns the position of the next element in the list starting from @{code fromIndex} which is a comment (Ignoring spaces)\n     * or -1 if it's not a comment.\n     */\n    private int posOfNextComment(int fromIndex, List<TextElement> elements) {\n        if (!isValidIndex(fromIndex, elements))\n            return -1;\n        ReadOnlyListIterator<TextElement> iterator = new ReadOnlyListIterator(elements, fromIndex);\n        // search for the next consecutive space characters\n        while (iterator.hasNext()) {\n            TextElement element = iterator.next();\n            if (element.isSpaceOrTab()) {\n                continue;\n            }\n            if (element.isComment()) {\n            \treturn iterator.index();\n            }\n            break;\n        }\n        return -1;\n    }\n    \n    /*\n     * Returns true if the next element in the list (starting from @{code fromIndex}) is a comment\n     */\n    private boolean isFollowedByComment(int fromIndex, List<TextElement> elements) {\n    \treturn posOfNextComment(fromIndex, elements) != -1;\n    }\n    \n    /*\n     * Removes all elements in the list starting from @{code fromIndex}) ending to @{code toIndex})\n     */\n    private void removeElements(int fromIndex, int toIndex, List<TextElement> elements) {\n    \tif (!(isValidIndex(fromIndex, elements) && isValidIndex(toIndex, elements) && fromIndex <= toIndex))\n            return;\n        ListIterator<TextElement> iterator = elements.listIterator(fromIndex);\n        // removing elements\n        int count = fromIndex;\n        while (iterator.hasNext() && count <= toIndex) {\n        \tTextElement element = iterator.next();\n            iterator.remove();\n            count++;\n        }\n    }\n    \n    private boolean isValidIndex(int index, List<?> elements) {\n    \treturn index >= 0 && index <= elements.size();\n    }\n\n    /*\n     * Returns the position of the last new line character or -1 if there is no eol in the specified list of TextElement \n     */\n    int lastIndexOfEolWithoutGPT(List<TextElement> source) {\n        ListIterator listIterator = source.listIterator(source.size());\n        int lastIndex = source.size() - 1;\n        while (listIterator.hasPrevious()) {\n            TextElement elem = (TextElement) listIterator.previous();\n            if (elem.isNewline()) {\n                return lastIndex;\n            }\n            lastIndex--;\n        }\n        return -1;\n    }\n\n    private List<TextElement> indentationBlock() {\n        List<TextElement> res = new LinkedList<>();\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        return res;\n    }\n\n    private boolean isAfterLBrace(NodeText nodeText, int nodeTextIndex) {\n        if (nodeTextIndex > 0 && nodeText.getTextElement(nodeTextIndex - 1).isToken(LBRACE)) {\n            return true;\n        }\n        if (nodeTextIndex > 0 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab()) {\n            return isAfterLBrace(nodeText, nodeTextIndex - 1);\n        }\n        return false;\n    }\n\n    /**\n     * If we are at the beginning of a line, with just spaces or tabs before/after the position of the deleted element\n     * we should force the space to be the same as the current indentation.\n     * This method handles the following case if we remove the modifier {@code public} ([ ] is an indent character)\n     * {@code \n     * [ ][ ]public[ ][ ][ ]void[ ]m{}\n     * <-1-->      <---2--->\n     * 1/ current indentation\n     * 2/ these whitespaces must be removed\n     * }\n     * should produce\n     * {@code \n     * [ ][ ]void[ ]m{} \n     * }\n     */\n    private int considerEnforcingIndentation(NodeText nodeText, int nodeTextIndex) {\n        return considerIndentation(nodeText, nodeTextIndex, indentation.size());\n    }\n    \n    private int considerRemovingIndentation(NodeText nodeText, int nodeTextIndex) {\n        return considerIndentation(nodeText, nodeTextIndex, 0);\n    }\n    \n    private int considerIndentation(NodeText nodeText, int nodeTextIndex, int numberOfCharactersToPreserve) {\n        EnforcingIndentationContext enforcingIndentationContext = defineEnforcingIndentationContext(nodeText, nodeTextIndex);\n        // the next position in the list (by default the current position)\n        int res = nodeTextIndex;\n        if (enforcingIndentationContext.extraCharacters > 0) {\n        \tint extraCharacters = enforcingIndentationContext.extraCharacters > numberOfCharactersToPreserve ? enforcingIndentationContext.extraCharacters - numberOfCharactersToPreserve : 0;\n            res = removeExtraCharacters(nodeText, enforcingIndentationContext.start, extraCharacters);\n            // The next position must take into account the indentation\n            res = extraCharacters > 0 ? res + numberOfCharactersToPreserve : res;\n        }\n        if (res < 0) {\n            throw new IllegalStateException();\n        }\n        return res;\n    }\n    \n    private boolean isEnforcingIndentationActivable(RemovedGroup removedGroup) {\n\t\treturn (diffIndex + 1 >= diffElements.size() || !(diffElements.get(diffIndex + 1).isAdded()))\n\t\t\t\t&& originalIndex < originalElements.size()\n\t\t\t\t&& !removedGroup.isACompleteLine();\n\t}\n\n    private boolean isRemovingIndentationActivable(RemovedGroup removedGroup) {\n\t\treturn (diffIndex + 1 >= diffElements.size() || !(diffElements.get(diffIndex + 1).isAdded())) \n\t\t\t\t&& originalIndex < originalElements.size()\n\t\t\t\t&& removedGroup.isACompleteLine();\n\t}\n    \n    /*\n     * This data structure class hold the starting position of the first whitespace char \n     * and the number of consecutive whitespace (or tab) characters\n     */\n    private class EnforcingIndentationContext {\n    \tint start;\n    \tint extraCharacters;\n    \tpublic EnforcingIndentationContext(int start) {\n    \t\tthis.start=start;\n    \t\tthis.extraCharacters=0;\n    \t}\n    }\n\n    /**\n     * Remove excess white space after deleting element.\n     * @param nodeText Contains a list of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return The current position in the list of the elements\n     */\n    private int removeExtraCharacters(NodeText nodeText, int nodeTextIndex, int extraCharacters) {\n        int count = 0;\n        while (nodeTextIndex >= 0 && nodeTextIndex < nodeText.numberOfElements() && count < extraCharacters) {\n            nodeText.removeElement(nodeTextIndex);\n            count++;\n        }\n        return nodeTextIndex;\n    }\n\n    /**\n     * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between \n     * the previous end of line and the next non whitespace (or tab) character\n     * @param nodeText List of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n     * The number of consecutive whitespace (or tab) characters\n     */\n    private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n    \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n    \t// compute space before startIndex value\n\t\tif (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n\t\t\t// at this stage startIndex points to the first element before the deleted one\n\t\t\tfor (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\tctx = new EnforcingIndentationContext(startIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.start = i;\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n\t\t// compute space after the deleted element\n\t\tif (nodeText.getTextElement(startIndex).isSpaceOrTab()) {\n\t\t\tfor (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n        \n        return ctx;\n    }\n\n    /**\n     * Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\n     * to the difference (adding and removing the elements provided).\n     */\n    void apply() {\n        extractReshuffledDiffElements(diffElements);\n        Map<Removed, RemovedGroup> removedGroups = combineRemovedElementsToRemovedGroups();\n        do {\n            boolean isLeftOverDiffElement = applyLeftOverDiffElements();\n            boolean isLeftOverOriginalElement = applyLeftOverOriginalElements();\n            if (!isLeftOverDiffElement && !isLeftOverOriginalElement) {\n                DifferenceElement diffElement = diffElements.get(diffIndex);\n                if (diffElement.isAdded()) {\n                    applyAddedDiffElement((Added) diffElement);\n                } else {\n                    TextElement originalElement = originalElements.get(originalIndex);\n                    boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n                    if (diffElement.isKept()) {\n                        applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else if (diffElement.isRemoved()) {\n                        Removed removed = (Removed) diffElement;\n                        applyRemovedDiffElement(removedGroups.get(removed), removed, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n    }\n\n    private boolean applyLeftOverOriginalElements() {\n        boolean isLeftOverElement = false;\n        if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n            TextElement originalElement = originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n            isLeftOverElement = true;\n        }\n        return isLeftOverElement;\n    }\n\n    private boolean applyLeftOverDiffElements() {\n        boolean isLeftOverElement = false;\n        if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n            DifferenceElement diffElement = diffElements.get(diffIndex);\n            if (diffElement.isKept()) {\n                diffIndex++;\n            } else if (diffElement.isAdded()) {\n                Added addedElement = (Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                // let's forget this element\n                diffIndex++;\n            }\n            isLeftOverElement = true;\n        }\n        return isLeftOverElement;\n    }\n\n    private void extractReshuffledDiffElements(List<DifferenceElement> diffElements) {\n        for (int index = 0; index < diffElements.size(); index++) {\n            DifferenceElement diffElement = diffElements.get(index);\n            if (diffElement instanceof Reshuffled) {\n                Reshuffled reshuffled = (Reshuffled) diffElement;\n                // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                CsmMix elementsFromPreviousOrder = reshuffled.getPreviousOrder();\n                CsmMix elementsFromNextOrder = reshuffled.getNextOrder();\n                // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                // We now find out which Node Text elements corresponds to the elements in the original CSM\n                List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                for (int i = 0; i < nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value = nodeTextIndexOfPreviousElements.get(i);\n                    if (value != -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                // Elements to be added at the end\n                List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n                Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                for (int ni = 0; ni < nextOrderElements.size(); ni++) {\n                    // If it has a mapping, then it is kept\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        // Ok, it is something new. Where to put it? Let's see what is the first following\n                        // element that has a mapping\n                        int originalCsmIndex = -1;\n                        for (int nj = ni + 1; nj < nextOrderElements.size() && originalCsmIndex == -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                            }\n                        }\n                        // it does not preceed anything, so it goes at the end\n                        if (originalCsmIndex == -1) {\n                            elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                        }\n                    }\n                }\n                // We go over the original node text elements, in the order they appear in the NodeText.\n                // Considering an original node text element (ONE)\n                // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                // we find the correspond OCE (Original CSM Element)\n                // * we first add new elements that are marked to be added before OCE\n                // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                // otherwise we add a removed element\n                // Remove the whole Reshuffled element\n                diffElements.remove(index);\n                int diffElIterator = index;\n                if (lastNodeTextIndex != -1) {\n                    for (int ntIndex = originalIndex; ntIndex <= lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        }\n                        // else we have a simple node text element, without associated csm element, just keep ignore it\n                    }\n                }\n                // Finally we look for the remaining new elements that were not yet added and\n                // add all of them\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            }\n        }\n    }\n\n    /**\n     * Maps all Removed elements as keys to their corresponding RemovedGroup.\n     * A RemovedGroup contains all consecutive Removed elements.\n     * <br>\n     * Example:\n     * <pre>\n     * Elements: Kept|Removed1|Removed2|Kept|Removed3|Added|Removed4\n     * Groups:        <----Group1---->       Group2         Group3\n     * Keys:          Removed1+Removed2      Removed3       Removed4\n     * </pre>\n     *\n     * @return Map with all Removed elements as keys to their corresponding RemovedGroup\n     */\n    private Map<Removed, RemovedGroup> combineRemovedElementsToRemovedGroups() {\n        Map<Integer, List<Removed>> removedElementsMap = groupConsecutiveRemovedElements();\n        List<RemovedGroup> removedGroups = new ArrayList<>();\n        for (Map.Entry<Integer, List<Removed>> entry : removedElementsMap.entrySet()) {\n            removedGroups.add(RemovedGroup.of(entry.getKey(), entry.getValue()));\n        }\n        Map<Removed, RemovedGroup> map = new HashMap<>();\n        for (RemovedGroup removedGroup : removedGroups) {\n            for (Removed index : removedGroup) {\n                map.put(index, removedGroup);\n            }\n        }\n        return map;\n    }\n\n    private Map<Integer, List<Removed>> groupConsecutiveRemovedElements() {\n        Map<Integer, List<Removed>> removedElementsMap = new HashMap<>();\n        Integer firstElement = null;\n        for (int i = 0; i < diffElements.size(); i++) {\n            DifferenceElement diffElement = diffElements.get(i);\n            if (diffElement.isRemoved()) {\n                if (firstElement == null) {\n                    firstElement = i;\n                }\n                removedElementsMap.computeIfAbsent(firstElement, key -> new ArrayList<>()).add((Removed) diffElement);\n            } else {\n                firstElement = null;\n            }\n        }\n        return removedElementsMap;\n    }\n\n    private void applyRemovedDiffElement(RemovedGroup removedGroup, Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n        if (removed.isChild() && originalElementIsChild) {\n            ChildTextElement originalElementChild = (ChildTextElement) originalElement;\n            if (originalElementChild.isComment()) {\n                // We expected to remove a proper node but we found a comment in between.\n                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                Comment comment = (Comment) originalElementChild.getChild();\n                if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n                    nodeText.removeElement(originalIndex);\n                } else {\n                    originalIndex++;\n                }\n            } else {\n                nodeText.removeElement(originalIndex);\n                // When we don't try to remove a complete line \n                // and removing the element is not the first action of a replacement (removal followed by addition)\n                // (in the latter case we keep the indentation)\n                // then we want to enforce the indentation.\n                if (isEnforcingIndentationActivable(removedGroup)) {\n                \t// Since the element has been deleted we try to start the analysis from the element following the one that was deleted\n                    originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                }\n                // If in front we have one space and before also we had space let's drop one space\n                if (originalElements.size() > originalIndex && originalIndex > 0) {\n                    if (originalElements.get(originalIndex).isWhiteSpace() && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                        // However we do not want to do that when we are about to adding or removing elements\n                        // The intention is not very clear maybe it should clarify this with examples!\n                        // Are we to understand that we can only do this if there is a single modification to process\n                        // OR or if the next change is to keep the element\n                        if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1).isKept())) {\n                            originalElements.remove(originalIndex--);\n                        }\n                    }\n                }\n                // We need to know if, in the original list of elements, the deleted child node is immediately followed by the same comment.\n                // If so, it should also be deleted.\n                if (isFollowedByComment(originalIndex, originalElements) ) {\n                \tint indexOfNextComment = posOfNextComment(originalIndex, originalElements);\n                \tremoveElements(originalIndex, indexOfNextComment, originalElements);\n                }\n                if (isRemovingIndentationActivable(removedGroup)) {\n                \t// Since the element has been deleted we try to start the analysis from the previous element\n                    originalIndex = considerRemovingIndentation(nodeText, originalIndex);\n                }\n                diffIndex++;\n            }\n        } else if (removed.isChild() && originalElement.isComment()) {\n        \t// removing the comment first\n        \tnodeText.removeElement(originalIndex);\n        \tif (isRemovingIndentationActivable(removedGroup)) {\n                originalIndex = considerRemovingIndentation(nodeText, originalIndex);\n            }\n        } else if (removed.isToken() && originalElementIsToken && (removed.getTokenType() == ((TokenTextElement) originalElement).getTokenKind() || // handle EOLs separately as their token kind might not be equal. This is because the 'removed'\n        // element always has the current operating system's EOL as type\n        (((TokenTextElement) originalElement).getToken().getCategory().isEndOfLine() && removed.isNewLine()))) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if ((removed.isWhiteSpaceNotEol() || removed.getElement() instanceof CsmIndent || removed.getElement() instanceof CsmUnindent)\n        \t\t&& originalElement.isSpaceOrTab()){\n        \t// remove the current space\n        \tnodeText.removeElement(originalIndex);\n        }else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n            originalIndex++;\n            // skip the newline token which may be generated unnecessarily by the concrete syntax pattern\n            if (removed.isNewLine()) { \n            \tdiffIndex++;\n            }\n        } else if (originalElement.isLiteral()) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if (removed.isPrimitiveType()) {\n            if (originalElement.isPrimitive()) {\n                nodeText.removeElement(originalIndex);\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n            }\n        } else if (removed.isWhiteSpace() || removed.getElement() instanceof CsmIndent || removed.getElement() instanceof CsmUnindent) {\n            diffIndex++;\n        } else if (originalElement.isWhiteSpace()) {\n            originalIndex++;\n        } else if (removed.isChild()) {\n            // see issue #3721 this case is linked for example to a change of type of variable declarator\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n        }\n        cleanTheLineOfLeftOverSpace(removedGroup, removed);\n    }\n\n    /**\n     * Cleans the line of left over space if there is unnecessary indentation and the element will not be replaced\n     */\n    private void cleanTheLineOfLeftOverSpace(RemovedGroup removedGroup, Removed removed) {\n        if (originalIndex >= originalElements.size()) {\n            // if all elements were already processed there is nothing to do\n            return;\n        }\n        // we dont want to remove the indentation if the last removed element is a newline\n        // because in this case we are trying to remove the indentation of the next child element\n        if (!removedGroup.isProcessed() \n        \t\t&& removedGroup.isLastElement(removed) \n        \t\t&& removedGroup.isACompleteLine()\n        \t\t&& !removed.isNewLine()) {\n            Integer lastElementIndex = removedGroup.getLastElementIndex();\n            Optional<Integer> indentation = removedGroup.getIndentation();\n            if (indentation.isPresent() && !isReplaced(lastElementIndex)) {\n                for (int i = 0; i < indentation.get(); i++) {\n                    if (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        // If the current element is a space, remove it\n                        nodeText.removeElement(originalIndex);\n                    } else if (originalIndex >= 1 && originalElements.get(originalIndex - 1).isSpaceOrTab()) {\n                        // If the current element is not a space itself we remove the space in front of (before) it\n                        nodeText.removeElement(originalIndex - 1);\n                        originalIndex--;\n                    }\n                    // Remove remaining newline character if needed\n                    if (nodeText.getTextElement(originalIndex).isNewline()) {\n                    \tnodeText.removeElement(originalIndex);\n                    \toriginalIndex = originalIndex > 0 ? originalIndex-- : 0;\n                    }\n                }\n            }\n            // Mark RemovedGroup as processed\n            removedGroup.processed();\n        }\n    }\n\n    // note:\n    // increment originalIndex if we want to keep the original element\n    // increment diffIndex if we want to skip the diff element\n    private void applyKeptDiffElement(Kept kept, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n\t\tif (originalElement.isComment()) {\n\t\t\toriginalIndex++;\n        } else if (kept.isChild() && ((CsmChild) kept.getElement()).getChild() instanceof Comment) {\n            diffIndex++;\n        } else if (kept.isChild() && originalElementIsChild) {\n            diffIndex++;\n            originalIndex++;\n        } else if (kept.isChild() && originalElementIsToken) {\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else if (originalElement.isIdentifier() && isNodeWithTypeArguments(kept)) {\n                diffIndex++;\n                // skip all token related to node with type argument declaration\n                // for example:\n                // List i : in this case originalElement is \"List\" and the next token is space. There is nothing to skip. in the originalElements list.\n                // List<String> i : in this case originalElement is \"List\" and the next token is\n                // \"<\" so we have to skip all the tokens which are used in the typed argument declaration [<][String][>](3 tokens) in the originalElements list.\n                // List<List<String>> i : in this case originalElement is \"List\" and the next\n                // token is \"<\" so we have to skip all the tokens which are used in the typed arguments declaration [<][List][<][String][>][>](6 tokens) in the originalElements list.\n                int step = getIndexToNextTokenElement((TokenTextElement) originalElement, 0);\n                originalIndex += step;\n                originalIndex++;\n            } else if (originalElement.isIdentifier() && isTypeWithFullyQualifiedName(kept)) {\n                diffIndex++;\n                // skip all token related to node with the fully qualified name\n                // for example:\n                // java.lang.Object is represented in originalElement as a list of tokens \"java\", \".\", \"lang\", \".\", \"Object\".\n                // So we have to skip 5 tokens.\n                int step = getIndexToNextTokenElement((TokenTextElement) originalElement, kept);\n                originalIndex += step;\n                // positioning on the next token\n                originalIndex++;\n            } else if ((originalElement.isIdentifier() || originalElement.isKeyword()) && isArrayType(kept)) {\n                int tokenToSkip = getIndexToNextTokenElementInArrayType((TokenTextElement) originalElement, getArrayLevel(kept));\n                diffIndex++;\n                originalIndex += tokenToSkip;\n                originalIndex++;\n            } else if (originalElement.isIdentifier()) {\n                originalIndex++;\n                diffIndex++;\n            } else {\n                if (kept.isPrimitiveType()) {\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                }\n            }\n        } else if (kept.isToken() && originalElementIsToken) {\n            TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n            if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n                originalIndex++;\n                diffIndex++;\n            } else if (kept.isNewLine() && originalTextToken.isNewline()) {\n                originalIndex++;\n                diffIndex++;\n            } else if (kept.isNewLine() && originalTextToken.isSpaceOrTab()) {\n                originalIndex++;\n            } else if (kept.isWhiteSpaceOrComment()) {\n                diffIndex++;\n            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else if (!kept.isNewLine() && originalTextToken.isSeparator()) {\n                // case where originalTextToken is a separator like \";\" and\n                // kept is not a new line or whitespace for example \"}\"\n                // see issue 2351\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n            }\n        } else if (kept.isToken() && originalElementIsChild) {\n            diffIndex++;\n        } else if (kept.isWhiteSpace()) {\n            diffIndex++;\n        } else if (kept.isIndent()) {\n            diffIndex++;\n        } else if (kept.isUnindent()) {\n            // Nothing to do\n            diffIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n        }\n    }\n\n    /*\n     * Returns the array level if the DifferenceElement is a CsmChild representing an ArrayType else 0\n     */\n    private int getArrayLevel(DifferenceElement element) {\n        CsmElement csmElem = element.getElement();\n        if (isArrayType(element)) {\n            Node child = ((LexicalDifferenceCalculator.CsmChild) csmElem).getChild();\n            return ((ArrayType) child).getArrayLevel();\n        }\n        return 0;\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild representing an ArrayType\n     */\n    private boolean isArrayType(DifferenceElement element) {\n        CsmElement csmElem = element.getElement();\n        return csmElem instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild) csmElem).getChild() instanceof ArrayType;\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild which represents a type with fully qualified name\n     */\n    private boolean isTypeWithFullyQualifiedName(DifferenceElement element) {\n        if (!element.isChild())\n            return false;\n        CsmChild child = (CsmChild) element.getElement();\n        if (!ClassOrInterfaceType.class.isAssignableFrom(child.getChild().getClass()))\n            return false;\n        return ((ClassOrInterfaceType) child.getChild()).getScope().isPresent();\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild with type arguments\n     */\n    private boolean isNodeWithTypeArguments(DifferenceElement element) {\n        if (!element.isChild())\n            return false;\n        CsmChild child = (CsmChild) element.getElement();\n        if (!NodeWithTypeArguments.class.isAssignableFrom(child.getChild().getClass()))\n            return false;\n        Optional<NodeList<Type>> typeArgs = ((NodeWithTypeArguments) child.getChild()).getTypeArguments();\n        return typeArgs.isPresent() && typeArgs.get().size() > 0;\n    }\n\n    /*\n     * Try to resolve the number of token to skip in the original list to match \n     * a ClassOrInterfaceType with a list of tokens like \"java\", \".\", \"lang\", \".\", \"Object\"\n     */\n    private int getIndexToNextTokenElement(TokenTextElement element, DifferenceElement kept) {\n        // number of token to skip\n        int step = 0;\n        // verify if the DifferenceElement is a ClassOrInterfaceType with a fully qualified name\n        if (!isTypeWithFullyQualifiedName(kept))\n            return 0;\n        CsmChild child = (CsmChild) kept.getElement();\n        // split the type fully qualified node name to an array of tokens\n        String[] parts = ((ClassOrInterfaceType) child.getChild()).getNameWithScope().split(\"\\\\.\");\n        JavaToken token = element.getToken();\n        for (String part : parts) {\n            if (part.equals(token.asString())) {\n                // get 'dot' token\n                token = token.getNextToken().get();\n                if (!token.asString().equals(\".\"))\n                    break;\n                // get the next part\n                token = token.getNextToken().get();\n                step += 2;\n                continue;\n            }\n            // there is no match so we don't have token to skip\n            step = 0;\n            break;\n        }\n        return step;\n    }\n\n    /*\n     * Returns the number of tokens to skip in originalElements list to synchronize it with the DiffElements list\n     * This is due to the fact that types are considered as token in the originalElements list.\n     * For example,\n     * List<String> is represented by 4 tokens ([List][<][String][>]) while it's a CsmChild element in the DiffElements list\n     * So in this case, getIndexToNextTokenElement(..) on the [List] token returns 3 because we have to skip 3 tokens ([<][String][>]) to synchronize\n     * DiffElements list and originalElements list\n     * The end of recursivity is reached when there is no next token or if the nested diamond operators are totally managed, to take into account this type of declaration\n     * List <List<String>> l\n     * Be careful, this method must be call only if diamond operator could be found in the sequence\n     *\n     * @Param TokenTextElement the token currently analyzed\n     * @Param int the number of nested diamond operators\n     * @return the number of token to skip in originalElements list\n     */\n    private int getIndexToNextTokenElement(TokenTextElement element, int nestedDiamondOperator) {\n        // number of token to skip\n        int step = 0;\n        Optional<JavaToken> next = element.getToken().getNextToken();\n        if (!next.isPresent())\n            return step;\n        // because there is a token, first we need to increment the number of token to skip\n        step++;\n        // manage nested diamond operators by incrementing the level on LT token and decrementing on GT\n        JavaToken nextToken = next.get();\n        Kind kind = Kind.valueOf(nextToken.getKind());\n        if (isDiamondOperator(kind)) {\n            if (kind.GT.equals(kind))\n                nestedDiamondOperator--;\n            else\n                nestedDiamondOperator++;\n        }\n        // manage the fact where the first token is not a diamond operator but a whitespace\n        // and the end of the token sequence to skip\n        // for example in this declaration List <String> a;\n        if (nestedDiamondOperator == 0 && !nextToken.getCategory().isWhitespace())\n            return step;\n        // recursively analyze token to skip\n        return step += getIndexToNextTokenElement(new TokenTextElement(nextToken), nestedDiamondOperator);\n    }\n\n    /*\n     * Returns the number of tokens to skip in originalElements list to synchronize it with the DiffElements list\n     */\n    private int getIndexToNextTokenElementInArrayType(TokenTextElement element, int arrayLevel) {\n        // number of token to skip\n        int step = 0;\n        Optional<JavaToken> next = element.getToken().getNextToken();\n        if (!next.isPresent())\n            return step;\n        // because there is a token, first we need to increment the number of token to skip\n        step++;\n        // manage array Level by decrementing the level on right bracket token\n        JavaToken nextToken = next.get();\n        Kind kind = Kind.valueOf(nextToken.getKind());\n        if (isBracket(kind)) {\n            if (kind.RBRACKET.equals(kind))\n                arrayLevel--;\n        }\n        // manage the fact where the first token is not a diamond operator but a whitespace\n        // and the end of the token sequence to skip\n        // for example in this declaration int [] a;\n        if (arrayLevel == 0 && !nextToken.getCategory().isWhitespace())\n            return step;\n        // recursively analyze token to skip\n        return step += getIndexToNextTokenElementInArrayType(new TokenTextElement(nextToken), arrayLevel);\n    }\n\n    /*\n     * Returns true if the token is possibly a diamond operator\n     */\n    private boolean isDiamondOperator(Kind kind) {\n        return kind.GT.equals(kind) || kind.LT.equals(kind);\n    }\n\n    /*\n     * Returns true if the token is a bracket\n     */\n    private boolean isBracket(Kind kind) {\n        return kind.LBRACKET.equals(kind) || kind.RBRACKET.equals(kind);\n    }\n\n    private boolean openBraceWasOnSameLine() {\n        int index = originalIndex;\n        while (index >= 0 && !nodeText.getTextElement(index).isNewline()) {\n            if (nodeText.getTextElement(index).isToken(LBRACE)) {\n                return true;\n            }\n            index--;\n        }\n        return false;\n    }\n\n    private boolean wasSpaceBetweenBraces() {\n        return nodeText.getTextElement(originalIndex).isToken(RBRACE) && doWeHaveLeftBraceFollowedBySpace(originalIndex - 1) && (diffIndex < 2 || !diffElements.get(diffIndex - 2).isRemoved());\n    }\n\n    private boolean doWeHaveLeftBraceFollowedBySpace(int index) {\n        index = rewindSpace(index);\n        return nodeText.getTextElement(index).isToken(LBRACE);\n    }\n\n    private int rewindSpace(int index) {\n        if (index <= 0) {\n            return index;\n        }\n        if (nodeText.getTextElement(index).isWhiteSpace()) {\n            return rewindSpace(index - 1);\n        } else {\n            return index;\n        }\n    }\n\n    private boolean nextIsRightBrace(int index) {\n        List<TextElement> elements = originalElements.subList(index, originalElements.size());\n        for (TextElement element : elements) {\n            if (!element.isSpaceOrTab()) {\n                return element.isToken(RBRACE);\n            }\n        }\n        return false;\n    }\n\n    private void applyAddedDiffElement(Added added) {\n        if (added.isIndent()) {\n            for (int i = 0; i < STANDARD_INDENTATION_SIZE; i++) {\n                indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n            }\n            addedIndentation = true;\n            diffIndex++;\n            return;\n        }\n        if (added.isUnindent()) {\n            for (int i = 0; i < STANDARD_INDENTATION_SIZE && !indentation.isEmpty(); i++) {\n                indentation.remove(indentation.size() - 1);\n            }\n            addedIndentation = false;\n            diffIndex++;\n            return;\n        }\n        TextElement addedTextElement = added.toTextElement();\n        boolean used = false;\n        boolean isPreviousElementNewline = (originalIndex > 0) && originalElements.get(originalIndex - 1).isNewline();\n        if (isPreviousElementNewline) {\n            List<TextElement> elements = processIndentation(indentation, originalElements.subList(0, originalIndex - 1));\n            boolean nextIsRightBrace = nextIsRightBrace(originalIndex);\n            for (TextElement e : elements) {\n                if (!nextIsRightBrace && e instanceof TokenTextElement && originalElements.get(originalIndex).isToken(((TokenTextElement) e).getTokenKind())) {\n                    originalIndex++;\n                } else {\n                    nodeText.addElement(originalIndex++, e);\n                }\n            }\n        } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n            if (addedTextElement.isNewline()) {\n                used = true;\n            }\n            nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n            // This remove the space in \"{ }\" when adding a new line\n            while (originalIndex >= 2 && originalElements.get(originalIndex - 2).isSpaceOrTab()) {\n                originalElements.remove(originalIndex - 2);\n                originalIndex--;\n            }\n            for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                nodeText.addElement(originalIndex++, e);\n            }\n            // Indentation is painful...\n            // Sometimes we want to force indentation: this is the case when indentation was expected but\n            // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n            // not there, so when adding new elements we force it. However if the indentation has been\n            // inserted by us in this transformation we do not want to insert it again\n            if (!addedIndentation) {\n                for (TextElement e : indentationBlock()) {\n                    nodeText.addElement(originalIndex++, e);\n                }\n            }\n        }\n        if (!used) {\n            // Handling trailing comments\n            boolean sufficientTokensRemainToSkip = nodeText.numberOfElements() > originalIndex + 2;\n            boolean currentIsAComment = nodeText.getTextElement(originalIndex).isComment();\n            boolean previousIsAComment = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isComment();\n            boolean currentIsNewline = nodeText.getTextElement(originalIndex).isNewline();\n            boolean isFirstElement = originalIndex == 0;\n            boolean previousIsWhiteSpace = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isWhiteSpace();\n\t\t\tboolean commentIsBeforeAddedElement = currentIsAComment && addedTextElement.getRange().isPresent()\n\t\t\t\t\t&& nodeText.getTextElement(originalIndex).getRange()\n\t\t\t\t\t\t\t.map(range -> range.isBefore(addedTextElement.getRange().get())).orElse(false);\n            if (sufficientTokensRemainToSkip && currentIsAComment && commentIsBeforeAddedElement) {\n                // Need to get behind the comment:\n                // FIXME: Why 2? This comment and the next newline?\n                originalIndex += 2;\n                // Defer originalIndex increment\n                nodeText.addElement(originalIndex, addedTextElement);\n                // We want to adjust the indentation while considering the new element that we added\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);\n                // Now we can increment\n                originalIndex++;\n            } else if (currentIsNewline && previousIsAComment) {\n                /*\n                 * Manage the case where we want to add an element, after an expression which is followed by a comment on the same line.\n                 * This is not the same case as the one who handles the trailing comments, because in this case the node text element is a new line (not a comment)\n                 * For example : {@code private String a; // this is a }\n                 */\n                // Insert after the new line which follows this comment.\n                originalIndex++;\n                // We want to adjust the indentation while considering the new element that we added\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);\n                // Defer originalIndex increment\n                nodeText.addElement(originalIndex, addedTextElement);\n                // Now we can increment.\n                originalIndex++;\n            } else if (currentIsNewline && addedTextElement.isChild()) {\n                // here we want to place the new child element after the current new line character.\n                // Except if indentation has been inserted just before this step (in the case where isPreviousElementNewline is true)\n                // or if the previous character is a space (it could be the case if we want to replace a statement)\n                // Example 1 : if we insert a statement (a duplicated method call expression ) after this one <code>  value();\\n\\n</code>\n                // we want to have this result <code>  value();\\n  value();\\n</code> not <code>  value();\\n  \\nvalue();</code>\n                // Example 2 : if we want to insert a statement after this one <code>  \\n</code> we want to have <code>  value();\\n</code>\n                // not <code>  \\nvalue();</code> --> this case appears on member replacement for example\n                if (!isPreviousElementNewline && !isFirstElement && !previousIsWhiteSpace) {\n                    // Insert after the new line\n                    originalIndex++;\n                }\n                nodeText.addElement(originalIndex, addedTextElement);\n                originalIndex++;\n            } else {\n                nodeText.addElement(originalIndex, addedTextElement);\n                originalIndex++;\n            }\n        }\n        if (addedTextElement.isNewline()) {\n            boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n            boolean nextIsRightBrace = nextIsRightBrace(originalIndex);\n            boolean nextIsNewLine = originalElements.get(originalIndex).isNewline();\n            if ((!nextIsNewLine && !nextIsRightBrace) || followedByUnindent) {\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n            }\n        }\n        diffIndex++;\n    }\n\n    private String tokenDescription(int kind) {\n        return GeneratedJavaParserConstants.tokenImage[kind];\n    }\n\n\t/*\n\t * Considering that the lists of elements are ordered, We can find the common\n\t * elements by starting with the list before the modifications and, for each\n\t * element, by going through the list of elements containing the modifications.\n\t * \n\t * We can find the common elements by starting with the list before the\n\t * modifications (L1) and, for each element, by going through the list of elements\n\t * containing the modifications (L2).\n\t * \n\t * If element A in list L1 is not found in list L2, it is a deleted element. \n\t * If element A of list L1 is found in list L2, it is a kept element. In this\n\t * case the search for the next element of the list L1 must start from the\n\t * position of the last element kept {@code syncNextIndex}.\n\t */\n\tprivate Map<Integer, Integer> getCorrespondanceBetweenNextOrderAndPreviousOrder(CsmMix elementsFromPreviousOrder,\n\t\t\tCsmMix elementsFromNextOrder) {\n\t\tMap<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n\t\tReadOnlyListIterator<CsmElement> previousOrderElementsIterator = new ReadOnlyListIterator(\n\t\t\t\telementsFromPreviousOrder.getElements());\n\t\tint syncNextIndex = 0;\n\t\twhile (previousOrderElementsIterator.hasNext()) {\n\t\t\tCsmElement pe = previousOrderElementsIterator.next();\n\t\t\tReadOnlyListIterator<CsmElement> nextOrderElementsIterator = new ReadOnlyListIterator(\n\t\t\t\t\telementsFromNextOrder.getElements(), syncNextIndex);\n\t\t\twhile (nextOrderElementsIterator.hasNext()) {\n\t\t\t\tCsmElement ne = nextOrderElementsIterator.next();\n\t\t\t\tif (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(previousOrderElementsIterator.index())\n\t\t\t\t\t\t&& DifferenceElementCalculator.matching(ne, pe)) {\n\t\t\t\t\tcorrespondanceBetweenNextOrderAndPreviousOrder.put(nextOrderElementsIterator.index(),\n\t\t\t\t\t\t\tpreviousOrderElementsIterator.index());\n\t\t\t\t\t// set the position to start on the next {@code nextOrderElementsIterator} iteration\n\t\t\t\t\tsyncNextIndex = nextOrderElementsIterator.index(); \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn correspondanceBetweenNextOrderAndPreviousOrder;\n\t}\n    \n    /*\n     * A list iterator which does not allow to modify the list \n     * and which provides a method to know the current positioning \n     */\n    private class ReadOnlyListIterator<T> implements ListIterator<T> {\n    \tListIterator<T> elements;\n    \tpublic ReadOnlyListIterator(List<T> elements) {\n    \t\tthis(elements, 0);\n    \t}\n    \t\n    \tpublic ReadOnlyListIterator(List<T> elements, int index) {\n    \t\tthis.elements = elements.listIterator(index);\n    \t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn elements.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic T next() {\n\t\t\treturn elements.next();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasPrevious() {\n\t\t\treturn elements.hasPrevious();\n\t\t}\n\n\t\t@Override\n\t\tpublic T previous() {\n\t\t\treturn elements.previous();\n\t\t}\n\n\t\t@Override\n\t\tpublic int nextIndex() {\n\t\t\treturn elements.nextIndex();\n\t\t}\n\n\t\t@Override\n\t\tpublic int previousIndex() {\n\t\t\treturn elements.previousIndex();\n\t\t}\n\t\t\n\t\t/*\n\t\t * Returns the current index in the underlying list\n\t\t */\n\t\tpublic int index() {\n\t\t\treturn elements.nextIndex() - 1;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void set(T e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void add(T e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n    \t\n    }\n\n    /*\n     * Returns true if the next element in the list is an added element of type CsmUnindent\n     */\n    private boolean isFollowedByUnindent(List<DifferenceElement> diffElements, int diffIndex) {\n        int nextIndexValue = diffIndex + 1;\n        return (nextIndexValue) < diffElements.size() && diffElements.get(nextIndexValue).isAdded() && diffElements.get(nextIndexValue).getElement() instanceof CsmUnindent;\n    }\n\n    private List<Integer> findIndexOfCorrespondingNodeTextElement(List<CsmElement> elements, NodeText nodeText, int startIndex, Node node) {\n        List<Integer> correspondingIndices = new ArrayList<>();\n        for (ListIterator<CsmElement> csmElementListIterator = elements.listIterator(); csmElementListIterator.hasNext(); ) {\n            int previousCsmElementIndex = csmElementListIterator.previousIndex();\n            CsmElement csmElement = csmElementListIterator.next();\n            int nextCsmElementIndex = csmElementListIterator.nextIndex();\n            Map<MatchClassification, Integer> potentialMatches = new EnumMap<>(MatchClassification.class);\n            for (int i = startIndex; i < nodeText.numberOfElements(); i++) {\n                if (!correspondingIndices.contains(i)) {\n                    TextElement textElement = nodeText.getTextElement(i);\n                    boolean isCorresponding = isCorrespondingElement(textElement, csmElement, node);\n                    if (isCorresponding) {\n                        boolean hasSamePreviousElement = false;\n                        if (i > 0 && previousCsmElementIndex > -1) {\n                            TextElement previousTextElement = nodeText.getTextElement(i - 1);\n                            hasSamePreviousElement = isCorrespondingElement(previousTextElement, elements.get(previousCsmElementIndex), node);\n                        }\n                        boolean hasSameNextElement = false;\n                        if (i < nodeText.numberOfElements() - 1 && nextCsmElementIndex < elements.size()) {\n                            TextElement nextTextElement = nodeText.getTextElement(i + 1);\n                            hasSameNextElement = isCorrespondingElement(nextTextElement, elements.get(nextCsmElementIndex), node);\n                        }\n                        if (hasSamePreviousElement && hasSameNextElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.ALL, i);\n                        } else if (hasSamePreviousElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.PREVIOUS_AND_SAME, i);\n                        } else if (hasSameNextElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.NEXT_AND_SAME, i);\n                        } else {\n                            potentialMatches.putIfAbsent(MatchClassification.SAME_ONLY, i);\n                        }\n                    } else if (isAlmostCorrespondingElement(textElement, csmElement, node)) {\n                        potentialMatches.putIfAbsent(MatchClassification.ALMOST, i);\n                    }\n                }\n            }\n            // Prioritize the matches from best to worst\n            Optional<MatchClassification> bestMatchKey = potentialMatches.keySet().stream().min(Comparator.comparing(MatchClassification::getPriority));\n            if (bestMatchKey.isPresent()) {\n                correspondingIndices.add(potentialMatches.get(bestMatchKey.get()));\n            } else {\n                correspondingIndices.add(-1);\n            }\n        }\n        return correspondingIndices;\n    }\n\n    private enum MatchClassification {\n\n        ALL(1), PREVIOUS_AND_SAME(2), NEXT_AND_SAME(3), SAME_ONLY(4), ALMOST(5);\n\n        private final int priority;\n\n        MatchClassification(int priority) {\n            this.priority = priority;\n        }\n\n        int getPriority() {\n            return priority;\n        }\n    }\n\n    private boolean isCorrespondingElement(TextElement textElement, CsmElement csmElement, Node node) {\n        if (csmElement instanceof CsmToken) {\n            CsmToken csmToken = (CsmToken) csmElement;\n            if (textElement instanceof TokenTextElement) {\n                TokenTextElement tokenTextElement = (TokenTextElement) textElement;\n                return tokenTextElement.getTokenKind() == csmToken.getTokenType() && tokenTextElement.getText().equals(csmToken.getContent(node));\n            }\n        } else if (csmElement instanceof CsmChild) {\n            CsmChild csmChild = (CsmChild) csmElement;\n            if (textElement instanceof ChildTextElement) {\n                ChildTextElement childTextElement = (ChildTextElement) textElement;\n                return childTextElement.getChild() == csmChild.getChild();\n            }\n        } else if (csmElement instanceof CsmIndent) {\n        \tCsmIndent csmIndent = (CsmIndent) csmElement;\n            if (textElement instanceof TokenTextElement) {\n            \tTokenTextElement tokenTextElement = (TokenTextElement) textElement;\n                return tokenTextElement.isSpaceOrTab();\n            }\n        } else {\n            throw new UnsupportedOperationException();\n        }\n        return false;\n    }\n\n    private boolean isAlmostCorrespondingElement(TextElement textElement, CsmElement csmElement, Node node) {\n        if (isCorrespondingElement(textElement, csmElement, node)) {\n            return false;\n        }\n        return textElement.isWhiteSpace() && csmElement instanceof CsmToken && ((CsmToken) csmElement).isWhiteSpace();\n    }\n\n    private int adjustIndentation(List<TextElement> indentation, NodeText nodeText, int nodeTextIndex, boolean followedByUnindent) {\n        List<TextElement> indentationAdj = processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1));\n        if (nodeTextIndex < nodeText.numberOfElements() && nodeText.getTextElement(nodeTextIndex).isToken(RBRACE)) {\n            indentationAdj = indentationAdj.subList(0, indentationAdj.size() - Math.min(STANDARD_INDENTATION_SIZE, indentationAdj.size()));\n        } else if (followedByUnindent) {\n            indentationAdj = indentationAdj.subList(0, Math.max(0, indentationAdj.size() - STANDARD_INDENTATION_SIZE));\n        }\n        for (TextElement e : indentationAdj) {\n            if ((nodeTextIndex < nodeText.numberOfElements()) && nodeText.getTextElement(nodeTextIndex).isSpaceOrTab()) {\n                nodeTextIndex++;\n            } else {\n                nodeText.getElements().add(nodeTextIndex++, e);\n            }\n        }\n        if (nodeTextIndex < 0) {\n            throw new IllegalStateException();\n        }\n        return nodeTextIndex;\n    }\n\n    /*\n     * Returns true if the current <code>Added</code> element is preceded by a <code>Removed</code> element.\n     */\n    private boolean isAReplacement(int diffIndex) {\n        return (diffIndex > 0) && diffElements.get(diffIndex).isAdded() && diffElements.get(diffIndex - 1).isRemoved();\n    }\n\n    /*\n     * Returns true if the current <code>Removed</code> element is followed by a <code>Added</code> element.\n     */\n    private boolean isReplaced(int diffIndex) {\n        return (diffIndex < diffElements.size() - 1) && diffElements.get(diffIndex + 1).isAdded() && diffElements.get(diffIndex).isRemoved();\n    }\n\n    @Override\n    public String toString() {\n        return \"Difference{\" + diffElements + '}';\n    }\n}\n", "filePathAfter": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.printer.lexicalpreservation;\n\nimport static com.github.javaparser.GeneratedJavaParserConstants.*;\n\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.stream.IntStream;\n\nimport com.github.javaparser.GeneratedJavaParserConstants;\nimport com.github.javaparser.JavaToken;\nimport com.github.javaparser.JavaToken.Kind;\nimport com.github.javaparser.TokenTypes;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.nodeTypes.NodeWithTypeArguments;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.printer.concretesyntaxmodel.*;\nimport com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator.CsmChild;\n\n/**\n * A Difference should give me a sequence of elements I should find (to indicate the context) followed by a list of elements\n * to remove or to add and follow by another sequence of elements.\n *\n * I should later be able to apply such difference to a nodeText.\n */\npublic class Difference {\n\n    public static final int STANDARD_INDENTATION_SIZE = 4;\n\n    private final NodeText nodeText;\n\n    private final Node node;\n\n    private final List<DifferenceElement> diffElements;\n\n    private final List<TextElement> originalElements;\n\n    private int originalIndex = 0;\n\n    private int diffIndex = 0;\n\n    private final List<TextElement> indentation;\n\n    private boolean addedIndentation = false;\n\n    Difference(List<DifferenceElement> diffElements, NodeText nodeText, Node node) {\n        if (nodeText == null) {\n            throw new NullPointerException(\"nodeText can not be null\");\n        }\n        this.nodeText = nodeText;\n        this.node = node;\n        this.diffElements = diffElements;\n        this.originalElements = nodeText.getElements();\n        this.indentation = LexicalPreservingPrinter.findIndentation(node);\n    }\n\n    /*\n     * Returns the indentation used after the last line break\n     */\n    private List<TextElement> processIndentation(List<TextElement> indentation, List<TextElement> prevElements) {\n        int eolIndex = lastIndexOfEol(prevElements);\n        // Return \"indentation\" as is if no EOL element was found\n        if (eolIndex < 0)\n            return indentation;\n        // Find consecutive space characters after the EOL element\n        indentation = takeWhile(prevElements.subList(eolIndex + 1, prevElements.size()), element -> element.isWhiteSpace());\n        return indentation;\n    }\n\n    /*\n     * returns only the elements that match the given predicate.\n     * takeWhile takes elements from the initial stream while the predicate holds true.\n     * Meaning that when an element is encountered that does not match the predicate, the rest of the list is discarded.\n     */\n    List<TextElement> takeWhile(List<TextElement> prevElements, Predicate<TextElement> predicate) {\n    \tList<TextElement> spaces = new ArrayList<>();\n    \tfor (TextElement element : prevElements) {\n    \t\tif (predicate.test(element)) {\n    \t\t\tspaces.add(element);\n                continue;\n            }\n            break;\n    \t}\n    \treturn spaces;\n    }\n\n\n    int lastIndexOfEol(List<TextElement> source) {\n        return IntStream.range(0, source.size())\n                       .map(i -> source.size() - i - 1)\n                       .filter(i -> source.get(i).isNewline())\n                       .findFirst()\n                       .orElse(-1);\n    }\n\n    /*\n     * Returns the position of the next element in the list starting from @{code fromIndex} which is a comment (Ignoring spaces)\n     * or -1 if it's not a comment.\n     */\n    private int posOfNextComment(int fromIndex, List<TextElement> elements) {\n        if (!isValidIndex(fromIndex, elements))\n            return -1;\n        ReadOnlyListIterator<TextElement> iterator = new ReadOnlyListIterator(elements, fromIndex);\n        // search for the next consecutive space characters\n        while (iterator.hasNext()) {\n            TextElement element = iterator.next();\n            if (element.isSpaceOrTab()) {\n                continue;\n            }\n            if (element.isComment()) {\n            \treturn iterator.index();\n            }\n            break;\n        }\n        return -1;\n    }\n\n    /*\n     * Returns true if the next element in the list (starting from @{code fromIndex}) is a comment\n     */\n    private boolean isFollowedByComment(int fromIndex, List<TextElement> elements) {\n    \treturn posOfNextComment(fromIndex, elements) != -1;\n    }\n\n    /*\n     * Removes all elements in the list starting from @{code fromIndex}) ending to @{code toIndex})\n     */\n    private void removeElements(int fromIndex, int toIndex, List<TextElement> elements) {\n    \tif (!(isValidIndex(fromIndex, elements) && isValidIndex(toIndex, elements) && fromIndex <= toIndex))\n            return;\n        ListIterator<TextElement> iterator = elements.listIterator(fromIndex);\n        // removing elements\n        int count = fromIndex;\n        while (iterator.hasNext() && count <= toIndex) {\n        \tTextElement element = iterator.next();\n            iterator.remove();\n            count++;\n        }\n    }\n\n    private boolean isValidIndex(int index, List<?> elements) {\n    \treturn index >= 0 && index <= elements.size();\n    }\n\n    /*\n     * Returns the position of the last new line character or -1 if there is no eol in the specified list of TextElement\n     */\n    int lastIndexOfEolWithoutGPT(List<TextElement> source) {\n        ListIterator listIterator = source.listIterator(source.size());\n        int lastIndex = source.size() - 1;\n        while (listIterator.hasPrevious()) {\n            TextElement elem = (TextElement) listIterator.previous();\n            if (elem.isNewline()) {\n                return lastIndex;\n            }\n            lastIndex--;\n        }\n        return -1;\n    }\n\n    private List<TextElement> indentationBlock() {\n        List<TextElement> res = new LinkedList<>();\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        return res;\n    }\n\n    private boolean isAfterLBrace(NodeText nodeText, int nodeTextIndex) {\n        if (nodeTextIndex > 0 && nodeText.getTextElement(nodeTextIndex - 1).isToken(LBRACE)) {\n            return true;\n        }\n        if (nodeTextIndex > 0 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab()) {\n            return isAfterLBrace(nodeText, nodeTextIndex - 1);\n        }\n        return false;\n    }\n\n    /**\n     * If we are at the beginning of a line, with just spaces or tabs before/after the position of the deleted element\n     * we should force the space to be the same as the current indentation.\n     * This method handles the following case if we remove the modifier {@code public} ([ ] is an indent character)\n     * {@code\n     * [ ][ ]public[ ][ ][ ]void[ ]m{}\n     * <-1-->      <---2--->\n     * 1/ current indentation\n     * 2/ these whitespaces must be removed\n     * }\n     * should produce\n     * {@code\n     * [ ][ ]void[ ]m{}\n     * }\n     */\n    private int considerEnforcingIndentation(NodeText nodeText, int nodeTextIndex) {\n        return considerIndentation(nodeText, nodeTextIndex, indentation.size());\n    }\n\n    private int considerRemovingIndentation(NodeText nodeText, int nodeTextIndex) {\n        return considerIndentation(nodeText, nodeTextIndex, 0);\n    }\n\n    private int considerIndentation(NodeText nodeText, int nodeTextIndex, int numberOfCharactersToPreserve) {\n        EnforcingIndentationContext enforcingIndentationContext = defineEnforcingIndentationContext(nodeText, nodeTextIndex);\n        // the next position in the list (by default the current position)\n        int res = nodeTextIndex;\n        if (enforcingIndentationContext.extraCharacters > 0) {\n        \tint extraCharacters = enforcingIndentationContext.extraCharacters > numberOfCharactersToPreserve ? enforcingIndentationContext.extraCharacters - numberOfCharactersToPreserve : 0;\n            res = removeExtraCharacters(nodeText, enforcingIndentationContext.start, extraCharacters);\n            // The next position must take into account the indentation\n            res = extraCharacters > 0 ? res + numberOfCharactersToPreserve : res;\n        }\n        if (res < 0) {\n            throw new IllegalStateException();\n        }\n        return res;\n    }\n\n    private boolean isEnforcingIndentationActivable(RemovedGroup removedGroup) {\n\t\treturn (isLastElement(diffElements, diffIndex) || !(nextDiffElement(diffElements,diffIndex).isAdded()))\n\t\t\t\t&& originalIndex < originalElements.size()\n\t\t\t\t&& !removedGroup.isACompleteLine();\n\t}\n\n    private boolean isRemovingIndentationActivable(RemovedGroup removedGroup) {\n\t\treturn (isLastElement(diffElements, diffIndex) || !(nextDiffElement(diffElements,diffIndex).isAdded()))\n\t\t\t\t&& originalIndex < originalElements.size()\n\t\t\t\t&& removedGroup.isACompleteLine();\n\t}\n\n    private boolean isLastElement(List<?> list, int index) {\n\t\treturn index + 1 >= list.size();\n\t}\n\n    private DifferenceElement nextDiffElement(List<DifferenceElement> list, int index) {\n    \treturn list.get(index + 1);\n    }\n\n    /*\n     * This data structure class hold the starting position of the first whitespace char\n     * and the number of consecutive whitespace (or tab) characters\n     */\n    private class EnforcingIndentationContext {\n    \tint start;\n    \tint extraCharacters;\n    \tpublic EnforcingIndentationContext(int start) {\n    \t\tthis(start,0);\n    \t}\n    \tpublic EnforcingIndentationContext(int start, int extraCharacters) {\n    \t\tthis.start=start;\n    \t\tthis.extraCharacters=extraCharacters;\n    \t}\n    }\n\n    /**\n     * Remove excess white space after deleting element.\n     * @param nodeText Contains a list of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return The current position in the list of the elements\n     */\n    private int removeExtraCharacters(NodeText nodeText, int nodeTextIndex, int extraCharacters) {\n        int count = 0;\n        while (nodeTextIndex >= 0 && nodeTextIndex < nodeText.numberOfElements() && count < extraCharacters) {\n            nodeText.removeElement(nodeTextIndex);\n            count++;\n        }\n        return nodeTextIndex;\n    }\n\n    /**\n     * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between\n     * the previous end of line and the next non whitespace (or tab) character\n     * @param nodeText List of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n     * The number of consecutive whitespace (or tab) characters\n     */\n    private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n    \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n    \t// compute space before startIndex value\n\t\tif (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n\t\t\t// at this stage startIndex points to the first element before the deleted one\n\t\t\tfor (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!isSpaceOrTabElement(nodeText, i)) {\n\t\t\t\t\tctx = new EnforcingIndentationContext(startIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.start = i;\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n\t\t// compute space after the deleted element\n\t\tif (isSpaceOrTabElement(nodeText, startIndex)) {\n//\t\t\tint startingFromIndex = startIndex == 0 ? startIndex : startIndex + 1;\n\t\t\tfor (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!isSpaceOrTabElement(nodeText, i)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n\n        return ctx;\n    }\n\n    /*\n     * Returns true if the indexed element is a space or a tab\n     */\n\tprivate boolean isSpaceOrTabElement(NodeText nodeText, int i) {\n\t\treturn nodeText.getTextElement(i).isSpaceOrTab();\n\t}\n\n    /**\n     * Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\n     * to the difference (adding and removing the elements provided).\n     */\n    void apply() {\n        extractReshuffledDiffElements(diffElements);\n        Map<Removed, RemovedGroup> removedGroups = combineRemovedElementsToRemovedGroups();\n        do {\n            boolean isLeftOverDiffElement = applyLeftOverDiffElements();\n            boolean isLeftOverOriginalElement = applyLeftOverOriginalElements();\n            if (!isLeftOverDiffElement && !isLeftOverOriginalElement) {\n                DifferenceElement diffElement = diffElements.get(diffIndex);\n                if (diffElement.isAdded()) {\n                    applyAddedDiffElement((Added) diffElement);\n                } else {\n                    TextElement originalElement = originalElements.get(originalIndex);\n                    boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n                    if (diffElement.isKept()) {\n                        applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else if (diffElement.isRemoved()) {\n                        Removed removed = (Removed) diffElement;\n                        applyRemovedDiffElement(removedGroups.get(removed), removed, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n    }\n\n    private boolean applyLeftOverOriginalElements() {\n        boolean isLeftOverElement = false;\n        if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n            TextElement originalElement = originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n            isLeftOverElement = true;\n        }\n        return isLeftOverElement;\n    }\n\n    private boolean applyLeftOverDiffElements() {\n        boolean isLeftOverElement = false;\n        if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n            DifferenceElement diffElement = diffElements.get(diffIndex);\n            if (diffElement.isKept()) {\n                diffIndex++;\n            } else if (diffElement.isAdded()) {\n                Added addedElement = (Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                // let's forget this element\n                diffIndex++;\n            }\n            isLeftOverElement = true;\n        }\n        return isLeftOverElement;\n    }\n\n    private void extractReshuffledDiffElements(List<DifferenceElement> diffElements) {\n        for (int index = 0; index < diffElements.size(); index++) {\n            DifferenceElement diffElement = diffElements.get(index);\n            if (diffElement instanceof Reshuffled) {\n                Reshuffled reshuffled = (Reshuffled) diffElement;\n                // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                CsmMix elementsFromPreviousOrder = reshuffled.getPreviousOrder();\n                CsmMix elementsFromNextOrder = reshuffled.getNextOrder();\n                // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                // We now find out which Node Text elements corresponds to the elements in the original CSM\n                List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                for (int i = 0; i < nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value = nodeTextIndexOfPreviousElements.get(i);\n                    if (value != -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                // Elements to be added at the end\n                List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n                Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                for (int ni = 0; ni < nextOrderElements.size(); ni++) {\n                    // If it has a mapping, then it is kept\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        // Ok, it is something new. Where to put it? Let's see what is the first following\n                        // element that has a mapping\n                        int originalCsmIndex = -1;\n                        for (int nj = ni + 1; nj < nextOrderElements.size() && originalCsmIndex == -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                            }\n                        }\n                        // it does not preceed anything, so it goes at the end\n                        if (originalCsmIndex == -1) {\n                            elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                        }\n                    }\n                }\n                // We go over the original node text elements, in the order they appear in the NodeText.\n                // Considering an original node text element (ONE)\n                // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                // we find the correspond OCE (Original CSM Element)\n                // * we first add new elements that are marked to be added before OCE\n                // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                // otherwise we add a removed element\n                // Remove the whole Reshuffled element\n                diffElements.remove(index);\n                int diffElIterator = index;\n                if (lastNodeTextIndex != -1) {\n                    for (int ntIndex = originalIndex; ntIndex <= lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        }\n                        // else we have a simple node text element, without associated csm element, just keep ignore it\n                    }\n                }\n                // Finally we look for the remaining new elements that were not yet added and\n                // add all of them\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            }\n        }\n    }\n\n    /**\n     * Maps all Removed elements as keys to their corresponding RemovedGroup.\n     * A RemovedGroup contains all consecutive Removed elements.\n     * <br>\n     * Example:\n     * <pre>\n     * Elements: Kept|Removed1|Removed2|Kept|Removed3|Added|Removed4\n     * Groups:        <----Group1---->       Group2         Group3\n     * Keys:          Removed1+Removed2      Removed3       Removed4\n     * </pre>\n     *\n     * @return Map with all Removed elements as keys to their corresponding RemovedGroup\n     */\n    private Map<Removed, RemovedGroup> combineRemovedElementsToRemovedGroups() {\n        Map<Integer, List<Removed>> removedElementsMap = groupConsecutiveRemovedElements();\n        List<RemovedGroup> removedGroups = new ArrayList<>();\n        for (Map.Entry<Integer, List<Removed>> entry : removedElementsMap.entrySet()) {\n            removedGroups.add(RemovedGroup.of(entry.getKey(), entry.getValue()));\n        }\n        Map<Removed, RemovedGroup> map = new HashMap<>();\n        for (RemovedGroup removedGroup : removedGroups) {\n            for (Removed index : removedGroup) {\n                map.put(index, removedGroup);\n            }\n        }\n        return map;\n    }\n\n    private Map<Integer, List<Removed>> groupConsecutiveRemovedElements() {\n        Map<Integer, List<Removed>> removedElementsMap = new HashMap<>();\n        Integer firstElement = null;\n        for (int i = 0; i < diffElements.size(); i++) {\n            DifferenceElement diffElement = diffElements.get(i);\n            if (diffElement.isRemoved()) {\n                if (firstElement == null) {\n                    firstElement = i;\n                }\n                removedElementsMap.computeIfAbsent(firstElement, key -> new ArrayList<>()).add((Removed) diffElement);\n            } else {\n                firstElement = null;\n            }\n        }\n        return removedElementsMap;\n    }\n\n    private void applyRemovedDiffElement(RemovedGroup removedGroup, Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n        if (removed.isChild() && originalElementIsChild) {\n            ChildTextElement originalElementChild = (ChildTextElement) originalElement;\n            if (originalElementChild.isComment()) {\n                // We expected to remove a proper node but we found a comment in between.\n                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                Comment comment = (Comment) originalElementChild.getChild();\n                if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n                    nodeText.removeElement(originalIndex);\n                } else {\n                    originalIndex++;\n                }\n            } else {\n                nodeText.removeElement(originalIndex);\n                // When we don't try to remove a complete line\n                // and removing the element is not the first action of a replacement (removal followed by addition)\n                // (in the latter case we keep the indentation)\n                // then we want to enforce the indentation.\n                if (isEnforcingIndentationActivable(removedGroup)) {\n                \t// Since the element has been deleted we try to start the analysis from the element following the one that was deleted\n                    originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                }\n                // If in front we have one space and before also we had space let's drop one space\n                if (originalElements.size() > originalIndex && originalIndex > 0) {\n                    if (originalElements.get(originalIndex).isWhiteSpace() && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                        // However we do not want to do that when we are about to adding or removing elements\n                        // The intention is not very clear maybe it should clarify this with examples!\n                        // Are we to understand that we can only do this if there is a single modification to process\n                        // OR or if the next change is to keep the element\n                        if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1).isKept())) {\n                            originalElements.remove(originalIndex--);\n                        }\n                    }\n                }\n                // We need to know if, in the original list of elements, the deleted child node is immediately followed by the same comment.\n                // If so, it should also be deleted.\n                if (isFollowedByComment(originalIndex, originalElements) ) {\n                \tint indexOfNextComment = posOfNextComment(originalIndex, originalElements);\n                \tremoveElements(originalIndex, indexOfNextComment, originalElements);\n                }\n                if (isRemovingIndentationActivable(removedGroup)) {\n                \t// Since the element has been deleted we try to start the analysis from the previous element\n                    originalIndex = considerRemovingIndentation(nodeText, originalIndex);\n                }\n                diffIndex++;\n            }\n        } else if (removed.isChild() && originalElement.isComment()) {\n        \t// removing the comment first\n        \tnodeText.removeElement(originalIndex);\n        \tif (isRemovingIndentationActivable(removedGroup)) {\n                originalIndex = considerRemovingIndentation(nodeText, originalIndex);\n            }\n        } else if (removed.isToken() && originalElementIsToken && (removed.getTokenType() == ((TokenTextElement) originalElement).getTokenKind() || // handle EOLs separately as their token kind might not be equal. This is because the 'removed'\n        // element always has the current operating system's EOL as type\n        (((TokenTextElement) originalElement).getToken().getCategory().isEndOfLine() && removed.isNewLine()))) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if ((removed.isWhiteSpaceNotEol() || removed.getElement() instanceof CsmIndent || removed.getElement() instanceof CsmUnindent)\n        \t\t&& originalElement.isSpaceOrTab()){\n        \t// remove the current space\n        \tnodeText.removeElement(originalIndex);\n        }else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n            originalIndex++;\n            // skip the newline token which may be generated unnecessarily by the concrete syntax pattern\n            if (removed.isNewLine()) {\n            \tdiffIndex++;\n            }\n        } else if (originalElement.isLiteral()) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if (removed.isPrimitiveType()) {\n            if (originalElement.isPrimitive()) {\n                nodeText.removeElement(originalIndex);\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n            }\n        } else if (removed.isWhiteSpace() || removed.getElement() instanceof CsmIndent || removed.getElement() instanceof CsmUnindent) {\n            diffIndex++;\n        } else if (originalElement.isWhiteSpace()) {\n            originalIndex++;\n        } else if (removed.isChild()) {\n            // see issue #3721 this case is linked for example to a change of type of variable declarator\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n        }\n        cleanTheLineOfLeftOverSpace(removedGroup, removed);\n    }\n\n    /**\n     * Cleans the line of left over space if there is unnecessary indentation and the element will not be replaced\n     */\n    private void cleanTheLineOfLeftOverSpace(RemovedGroup removedGroup, Removed removed) {\n        if (originalIndex >= originalElements.size()) {\n            // if all elements were already processed there is nothing to do\n            return;\n        }\n        // we dont want to remove the indentation if the last removed element is a newline\n        // because in this case we are trying to remove the indentation of the next child element\n        if (!removedGroup.isProcessed()\n        \t\t&& removedGroup.isLastElement(removed)\n        \t\t&& removedGroup.isACompleteLine()\n        \t\t&& !removed.isNewLine()) {\n            Integer lastElementIndex = removedGroup.getLastElementIndex();\n            Optional<Integer> indentation = removedGroup.getIndentation();\n            if (indentation.isPresent() && !isReplaced(lastElementIndex)) {\n                for (int i = 0; i < indentation.get(); i++) {\n                    if (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        // If the current element is a space, remove it\n                        nodeText.removeElement(originalIndex);\n                    } else if (originalIndex >= 1 && originalElements.get(originalIndex - 1).isSpaceOrTab()) {\n                        // If the current element is not a space itself we remove the space in front of (before) it\n                        nodeText.removeElement(originalIndex - 1);\n                        originalIndex--;\n                    }\n                    // Remove remaining newline character if needed\n                    if (nodeText.getTextElement(originalIndex).isNewline()) {\n                    \tnodeText.removeElement(originalIndex);\n                    \toriginalIndex = originalIndex > 0 ? originalIndex-- : 0;\n                    }\n                }\n            }\n            // Mark RemovedGroup as processed\n            removedGroup.processed();\n        }\n    }\n\n    // note:\n    // increment originalIndex if we want to keep the original element\n    // increment diffIndex if we want to skip the diff element\n    private void applyKeptDiffElement(Kept kept, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n\t\tif (originalElement.isComment()) {\n\t\t\toriginalIndex++;\n        } else if (kept.isChild() && ((CsmChild) kept.getElement()).getChild() instanceof Comment) {\n            diffIndex++;\n        } else if (kept.isChild() && originalElementIsChild) {\n            diffIndex++;\n            originalIndex++;\n        } else if (kept.isChild() && originalElementIsToken) {\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else if (originalElement.isIdentifier() && isNodeWithTypeArguments(kept)) {\n                diffIndex++;\n                // skip all token related to node with type argument declaration\n                // for example:\n                // List i : in this case originalElement is \"List\" and the next token is space. There is nothing to skip. in the originalElements list.\n                // List<String> i : in this case originalElement is \"List\" and the next token is\n                // \"<\" so we have to skip all the tokens which are used in the typed argument declaration [<][String][>](3 tokens) in the originalElements list.\n                // List<List<String>> i : in this case originalElement is \"List\" and the next\n                // token is \"<\" so we have to skip all the tokens which are used in the typed arguments declaration [<][List][<][String][>][>](6 tokens) in the originalElements list.\n                int step = getIndexToNextTokenElement((TokenTextElement) originalElement, 0);\n                originalIndex += step;\n                originalIndex++;\n            } else if (originalElement.isIdentifier() && isTypeWithFullyQualifiedName(kept)) {\n                diffIndex++;\n                // skip all token related to node with the fully qualified name\n                // for example:\n                // java.lang.Object is represented in originalElement as a list of tokens \"java\", \".\", \"lang\", \".\", \"Object\".\n                // So we have to skip 5 tokens.\n                int step = getIndexToNextTokenElement((TokenTextElement) originalElement, kept);\n                originalIndex += step;\n                // positioning on the next token\n                originalIndex++;\n            } else if ((originalElement.isIdentifier() || originalElement.isKeyword()) && isArrayType(kept)) {\n                int tokenToSkip = getIndexToNextTokenElementInArrayType((TokenTextElement) originalElement, getArrayLevel(kept));\n                diffIndex++;\n                originalIndex += tokenToSkip;\n                originalIndex++;\n            } else if (originalElement.isIdentifier()) {\n                originalIndex++;\n                diffIndex++;\n            } else {\n                if (kept.isPrimitiveType()) {\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                }\n            }\n        } else if (kept.isToken() && originalElementIsToken) {\n            TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n            if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n                originalIndex++;\n                diffIndex++;\n            } else if (kept.isNewLine() && originalTextToken.isNewline()) {\n                originalIndex++;\n                diffIndex++;\n            } else if (kept.isNewLine() && originalTextToken.isSpaceOrTab()) {\n                originalIndex++;\n            } else if (kept.isWhiteSpaceOrComment()) {\n                diffIndex++;\n            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else if (!kept.isNewLine() && originalTextToken.isSeparator()) {\n                // case where originalTextToken is a separator like \";\" and\n                // kept is not a new line or whitespace for example \"}\"\n                // see issue 2351\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n            }\n        } else if (kept.isToken() && originalElementIsChild) {\n            diffIndex++;\n        } else if (kept.isWhiteSpace()) {\n            diffIndex++;\n        } else if (kept.isIndent()) {\n            diffIndex++;\n        } else if (kept.isUnindent()) {\n            // Nothing to do\n            diffIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n        }\n    }\n\n    /*\n     * Returns the array level if the DifferenceElement is a CsmChild representing an ArrayType else 0\n     */\n    private int getArrayLevel(DifferenceElement element) {\n        CsmElement csmElem = element.getElement();\n        if (isArrayType(element)) {\n            Node child = ((LexicalDifferenceCalculator.CsmChild) csmElem).getChild();\n            return ((ArrayType) child).getArrayLevel();\n        }\n        return 0;\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild representing an ArrayType\n     */\n    private boolean isArrayType(DifferenceElement element) {\n        CsmElement csmElem = element.getElement();\n        return csmElem instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild) csmElem).getChild() instanceof ArrayType;\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild which represents a type with fully qualified name\n     */\n    private boolean isTypeWithFullyQualifiedName(DifferenceElement element) {\n        if (!element.isChild())\n            return false;\n        CsmChild child = (CsmChild) element.getElement();\n        if (!ClassOrInterfaceType.class.isAssignableFrom(child.getChild().getClass()))\n            return false;\n        return ((ClassOrInterfaceType) child.getChild()).getScope().isPresent();\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild with type arguments\n     */\n    private boolean isNodeWithTypeArguments(DifferenceElement element) {\n        if (!element.isChild())\n            return false;\n        CsmChild child = (CsmChild) element.getElement();\n        if (!NodeWithTypeArguments.class.isAssignableFrom(child.getChild().getClass()))\n            return false;\n        Optional<NodeList<Type>> typeArgs = ((NodeWithTypeArguments) child.getChild()).getTypeArguments();\n        return typeArgs.isPresent() && typeArgs.get().size() > 0;\n    }\n\n    /*\n     * Try to resolve the number of token to skip in the original list to match\n     * a ClassOrInterfaceType with a list of tokens like \"java\", \".\", \"lang\", \".\", \"Object\"\n     */\n    private int getIndexToNextTokenElement(TokenTextElement element, DifferenceElement kept) {\n        // number of token to skip\n        int step = 0;\n        // verify if the DifferenceElement is a ClassOrInterfaceType with a fully qualified name\n        if (!isTypeWithFullyQualifiedName(kept))\n            return 0;\n        CsmChild child = (CsmChild) kept.getElement();\n        // split the type fully qualified node name to an array of tokens\n        String[] parts = ((ClassOrInterfaceType) child.getChild()).getNameWithScope().split(\"\\\\.\");\n        JavaToken token = element.getToken();\n        for (String part : parts) {\n            if (part.equals(token.asString())) {\n                // get 'dot' token\n                token = token.getNextToken().get();\n                if (!token.asString().equals(\".\"))\n                    break;\n                // get the next part\n                token = token.getNextToken().get();\n                step += 2;\n                continue;\n            }\n            // there is no match so we don't have token to skip\n            step = 0;\n            break;\n        }\n        return step;\n    }\n\n    /*\n     * Returns the number of tokens to skip in originalElements list to synchronize it with the DiffElements list\n     * This is due to the fact that types are considered as token in the originalElements list.\n     * For example,\n     * List<String> is represented by 4 tokens ([List][<][String][>]) while it's a CsmChild element in the DiffElements list\n     * So in this case, getIndexToNextTokenElement(..) on the [List] token returns 3 because we have to skip 3 tokens ([<][String][>]) to synchronize\n     * DiffElements list and originalElements list\n     * The end of recursivity is reached when there is no next token or if the nested diamond operators are totally managed, to take into account this type of declaration\n     * List <List<String>> l\n     * Be careful, this method must be call only if diamond operator could be found in the sequence\n     *\n     * @Param TokenTextElement the token currently analyzed\n     * @Param int the number of nested diamond operators\n     * @return the number of token to skip in originalElements list\n     */\n    private int getIndexToNextTokenElement(TokenTextElement element, int nestedDiamondOperator) {\n        // number of token to skip\n        int step = 0;\n        Optional<JavaToken> next = element.getToken().getNextToken();\n        if (!next.isPresent())\n            return step;\n        // because there is a token, first we need to increment the number of token to skip\n        step++;\n        // manage nested diamond operators by incrementing the level on LT token and decrementing on GT\n        JavaToken nextToken = next.get();\n        Kind kind = Kind.valueOf(nextToken.getKind());\n        if (isDiamondOperator(kind)) {\n            if (kind.GT.equals(kind))\n                nestedDiamondOperator--;\n            else\n                nestedDiamondOperator++;\n        }\n        // manage the fact where the first token is not a diamond operator but a whitespace\n        // and the end of the token sequence to skip\n        // for example in this declaration List <String> a;\n        if (nestedDiamondOperator == 0 && !nextToken.getCategory().isWhitespace())\n            return step;\n        // recursively analyze token to skip\n        return step += getIndexToNextTokenElement(new TokenTextElement(nextToken), nestedDiamondOperator);\n    }\n\n    /*\n     * Returns the number of tokens to skip in originalElements list to synchronize it with the DiffElements list\n     */\n    private int getIndexToNextTokenElementInArrayType(TokenTextElement element, int arrayLevel) {\n        // number of token to skip\n        int step = 0;\n        Optional<JavaToken> next = element.getToken().getNextToken();\n        if (!next.isPresent())\n            return step;\n        // because there is a token, first we need to increment the number of token to skip\n        step++;\n        // manage array Level by decrementing the level on right bracket token\n        JavaToken nextToken = next.get();\n        Kind kind = Kind.valueOf(nextToken.getKind());\n        if (isBracket(kind)) {\n            if (kind.RBRACKET.equals(kind))\n                arrayLevel--;\n        }\n        // manage the fact where the first token is not a diamond operator but a whitespace\n        // and the end of the token sequence to skip\n        // for example in this declaration int [] a;\n        if (arrayLevel == 0 && !nextToken.getCategory().isWhitespace())\n            return step;\n        // recursively analyze token to skip\n        return step += getIndexToNextTokenElementInArrayType(new TokenTextElement(nextToken), arrayLevel);\n    }\n\n    /*\n     * Returns true if the token is possibly a diamond operator\n     */\n    private boolean isDiamondOperator(Kind kind) {\n        return kind.GT.equals(kind) || kind.LT.equals(kind);\n    }\n\n    /*\n     * Returns true if the token is a bracket\n     */\n    private boolean isBracket(Kind kind) {\n        return kind.LBRACKET.equals(kind) || kind.RBRACKET.equals(kind);\n    }\n\n    private boolean openBraceWasOnSameLine() {\n        int index = originalIndex;\n        while (index >= 0 && !nodeText.getTextElement(index).isNewline()) {\n            if (nodeText.getTextElement(index).isToken(LBRACE)) {\n                return true;\n            }\n            index--;\n        }\n        return false;\n    }\n\n    private boolean wasSpaceBetweenBraces() {\n        return nodeText.getTextElement(originalIndex).isToken(RBRACE) && doWeHaveLeftBraceFollowedBySpace(originalIndex - 1) && (diffIndex < 2 || !diffElements.get(diffIndex - 2).isRemoved());\n    }\n\n    private boolean doWeHaveLeftBraceFollowedBySpace(int index) {\n        index = rewindSpace(index);\n        return nodeText.getTextElement(index).isToken(LBRACE);\n    }\n\n    private int rewindSpace(int index) {\n        if (index <= 0) {\n            return index;\n        }\n        if (nodeText.getTextElement(index).isWhiteSpace()) {\n            return rewindSpace(index - 1);\n        } else {\n            return index;\n        }\n    }\n\n    private boolean nextIsRightBrace(int index) {\n        List<TextElement> elements = originalElements.subList(index, originalElements.size());\n        for (TextElement element : elements) {\n            if (!element.isSpaceOrTab()) {\n                return element.isToken(RBRACE);\n            }\n        }\n        return false;\n    }\n\n    private void applyAddedDiffElement(Added added) {\n        if (added.isIndent()) {\n            for (int i = 0; i < STANDARD_INDENTATION_SIZE; i++) {\n                indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n            }\n            addedIndentation = true;\n            diffIndex++;\n            return;\n        }\n        if (added.isUnindent()) {\n            for (int i = 0; i < STANDARD_INDENTATION_SIZE && !indentation.isEmpty(); i++) {\n                indentation.remove(indentation.size() - 1);\n            }\n            addedIndentation = false;\n            diffIndex++;\n            return;\n        }\n        TextElement addedTextElement = added.toTextElement();\n        boolean used = false;\n        boolean isPreviousElementNewline = (originalIndex > 0) && originalElements.get(originalIndex - 1).isNewline();\n        if (isPreviousElementNewline) {\n            List<TextElement> elements = processIndentation(indentation, originalElements.subList(0, originalIndex - 1));\n            boolean nextIsRightBrace = nextIsRightBrace(originalIndex);\n            for (TextElement e : elements) {\n                if (!nextIsRightBrace && e instanceof TokenTextElement && originalElements.get(originalIndex).isToken(((TokenTextElement) e).getTokenKind())) {\n                    originalIndex++;\n                } else {\n                    nodeText.addElement(originalIndex++, e);\n                }\n            }\n        } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n            if (addedTextElement.isNewline()) {\n                used = true;\n            }\n            nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n            // This remove the space in \"{ }\" when adding a new line\n            while (originalIndex >= 2 && originalElements.get(originalIndex - 2).isSpaceOrTab()) {\n                originalElements.remove(originalIndex - 2);\n                originalIndex--;\n            }\n            for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                nodeText.addElement(originalIndex++, e);\n            }\n            // Indentation is painful...\n            // Sometimes we want to force indentation: this is the case when indentation was expected but\n            // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n            // not there, so when adding new elements we force it. However if the indentation has been\n            // inserted by us in this transformation we do not want to insert it again\n            if (!addedIndentation) {\n                for (TextElement e : indentationBlock()) {\n                    nodeText.addElement(originalIndex++, e);\n                }\n            }\n        }\n        if (!used) {\n            // Handling trailing comments\n            boolean sufficientTokensRemainToSkip = nodeText.numberOfElements() > originalIndex + 2;\n            boolean currentIsAComment = nodeText.getTextElement(originalIndex).isComment();\n            boolean previousIsAComment = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isComment();\n            boolean currentIsNewline = nodeText.getTextElement(originalIndex).isNewline();\n            boolean isFirstElement = originalIndex == 0;\n            boolean previousIsWhiteSpace = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isWhiteSpace();\n\t\t\tboolean commentIsBeforeAddedElement = currentIsAComment && addedTextElement.getRange().isPresent()\n\t\t\t\t\t&& nodeText.getTextElement(originalIndex).getRange()\n\t\t\t\t\t\t\t.map(range -> range.isBefore(addedTextElement.getRange().get())).orElse(false);\n            if (sufficientTokensRemainToSkip && currentIsAComment && commentIsBeforeAddedElement) {\n                // Need to get behind the comment:\n                // FIXME: Why 2? This comment and the next newline?\n                originalIndex += 2;\n                // Defer originalIndex increment\n                nodeText.addElement(originalIndex, addedTextElement);\n                // We want to adjust the indentation while considering the new element that we added\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);\n                // Now we can increment\n                originalIndex++;\n            } else if (currentIsNewline && previousIsAComment) {\n                /*\n                 * Manage the case where we want to add an element, after an expression which is followed by a comment on the same line.\n                 * This is not the same case as the one who handles the trailing comments, because in this case the node text element is a new line (not a comment)\n                 * For example : {@code private String a; // this is a }\n                 */\n                // Insert after the new line which follows this comment.\n                originalIndex++;\n                // We want to adjust the indentation while considering the new element that we added\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);\n                // Defer originalIndex increment\n                nodeText.addElement(originalIndex, addedTextElement);\n                // Now we can increment.\n                originalIndex++;\n            } else if (currentIsNewline && addedTextElement.isChild()) {\n                // here we want to place the new child element after the current new line character.\n                // Except if indentation has been inserted just before this step (in the case where isPreviousElementNewline is true)\n                // or if the previous character is a space (it could be the case if we want to replace a statement)\n                // Example 1 : if we insert a statement (a duplicated method call expression ) after this one <code>  value();\\n\\n</code>\n                // we want to have this result <code>  value();\\n  value();\\n</code> not <code>  value();\\n  \\nvalue();</code>\n                // Example 2 : if we want to insert a statement after this one <code>  \\n</code> we want to have <code>  value();\\n</code>\n                // not <code>  \\nvalue();</code> --> this case appears on member replacement for example\n                if (!isPreviousElementNewline && !isFirstElement && !previousIsWhiteSpace) {\n                    // Insert after the new line\n                    originalIndex++;\n                }\n                nodeText.addElement(originalIndex, addedTextElement);\n                originalIndex++;\n            } else {\n                nodeText.addElement(originalIndex, addedTextElement);\n                originalIndex++;\n            }\n        }\n        if (addedTextElement.isNewline()) {\n            boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n            boolean nextIsRightBrace = nextIsRightBrace(originalIndex);\n            boolean nextIsNewLine = originalElements.get(originalIndex).isNewline();\n            if ((!nextIsNewLine && !nextIsRightBrace) || followedByUnindent) {\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n            }\n        }\n        diffIndex++;\n    }\n\n    private String tokenDescription(int kind) {\n        return GeneratedJavaParserConstants.tokenImage[kind];\n    }\n\n\t/*\n\t * Considering that the lists of elements are ordered, We can find the common\n\t * elements by starting with the list before the modifications and, for each\n\t * element, by going through the list of elements containing the modifications.\n\t *\n\t * We can find the common elements by starting with the list before the\n\t * modifications (L1) and, for each element, by going through the list of elements\n\t * containing the modifications (L2).\n\t *\n\t * If element A in list L1 is not found in list L2, it is a deleted element.\n\t * If element A of list L1 is found in list L2, it is a kept element. In this\n\t * case the search for the next element of the list L1 must start from the\n\t * position of the last element kept {@code syncNextIndex}.\n\t */\n\tprivate Map<Integer, Integer> getCorrespondanceBetweenNextOrderAndPreviousOrder(CsmMix elementsFromPreviousOrder,\n\t\t\tCsmMix elementsFromNextOrder) {\n\t\tMap<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n\t\tReadOnlyListIterator<CsmElement> previousOrderElementsIterator = new ReadOnlyListIterator(\n\t\t\t\telementsFromPreviousOrder.getElements());\n\t\tint syncNextIndex = 0;\n\t\twhile (previousOrderElementsIterator.hasNext()) {\n\t\t\tCsmElement pe = previousOrderElementsIterator.next();\n\t\t\tReadOnlyListIterator<CsmElement> nextOrderElementsIterator = new ReadOnlyListIterator(\n\t\t\t\t\telementsFromNextOrder.getElements(), syncNextIndex);\n\t\t\twhile (nextOrderElementsIterator.hasNext()) {\n\t\t\t\tCsmElement ne = nextOrderElementsIterator.next();\n\t\t\t\tif (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(previousOrderElementsIterator.index())\n\t\t\t\t\t\t&& DifferenceElementCalculator.matching(ne, pe)) {\n\t\t\t\t\tcorrespondanceBetweenNextOrderAndPreviousOrder.put(nextOrderElementsIterator.index(),\n\t\t\t\t\t\t\tpreviousOrderElementsIterator.index());\n\t\t\t\t\t// set the position to start on the next {@code nextOrderElementsIterator} iteration\n\t\t\t\t\tsyncNextIndex = nextOrderElementsIterator.index();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn correspondanceBetweenNextOrderAndPreviousOrder;\n\t}\n\n    /*\n     * A list iterator which does not allow to modify the list\n     * and which provides a method to know the current positioning\n     */\n    private class ReadOnlyListIterator<T> implements ListIterator<T> {\n    \tListIterator<T> elements;\n    \tpublic ReadOnlyListIterator(List<T> elements) {\n    \t\tthis(elements, 0);\n    \t}\n\n    \tpublic ReadOnlyListIterator(List<T> elements, int index) {\n    \t\tthis.elements = elements.listIterator(index);\n    \t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn elements.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic T next() {\n\t\t\treturn elements.next();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasPrevious() {\n\t\t\treturn elements.hasPrevious();\n\t\t}\n\n\t\t@Override\n\t\tpublic T previous() {\n\t\t\treturn elements.previous();\n\t\t}\n\n\t\t@Override\n\t\tpublic int nextIndex() {\n\t\t\treturn elements.nextIndex();\n\t\t}\n\n\t\t@Override\n\t\tpublic int previousIndex() {\n\t\t\treturn elements.previousIndex();\n\t\t}\n\n\t\t/*\n\t\t * Returns the current index in the underlying list\n\t\t */\n\t\tpublic int index() {\n\t\t\treturn elements.nextIndex() - 1;\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void set(T e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void add(T e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n    }\n\n    /*\n     * Returns true if the next element in the list is an added element of type CsmUnindent\n     */\n    private boolean isFollowedByUnindent(List<DifferenceElement> diffElements, int diffIndex) {\n        int nextIndexValue = diffIndex + 1;\n        return (nextIndexValue) < diffElements.size() && diffElements.get(nextIndexValue).isAdded() && diffElements.get(nextIndexValue).getElement() instanceof CsmUnindent;\n    }\n\n    private List<Integer> findIndexOfCorrespondingNodeTextElement(List<CsmElement> elements, NodeText nodeText, int startIndex, Node node) {\n        List<Integer> correspondingIndices = new ArrayList<>();\n        for (ListIterator<CsmElement> csmElementListIterator = elements.listIterator(); csmElementListIterator.hasNext(); ) {\n            int previousCsmElementIndex = csmElementListIterator.previousIndex();\n            CsmElement csmElement = csmElementListIterator.next();\n            int nextCsmElementIndex = csmElementListIterator.nextIndex();\n            Map<MatchClassification, Integer> potentialMatches = new EnumMap<>(MatchClassification.class);\n            for (int i = startIndex; i < nodeText.numberOfElements(); i++) {\n                if (!correspondingIndices.contains(i)) {\n                    TextElement textElement = nodeText.getTextElement(i);\n                    boolean isCorresponding = isCorrespondingElement(textElement, csmElement, node);\n                    if (isCorresponding) {\n                        boolean hasSamePreviousElement = false;\n                        if (i > 0 && previousCsmElementIndex > -1) {\n                            TextElement previousTextElement = nodeText.getTextElement(i - 1);\n                            hasSamePreviousElement = isCorrespondingElement(previousTextElement, elements.get(previousCsmElementIndex), node);\n                        }\n                        boolean hasSameNextElement = false;\n                        if (i < nodeText.numberOfElements() - 1 && nextCsmElementIndex < elements.size()) {\n                            TextElement nextTextElement = nodeText.getTextElement(i + 1);\n                            hasSameNextElement = isCorrespondingElement(nextTextElement, elements.get(nextCsmElementIndex), node);\n                        }\n                        if (hasSamePreviousElement && hasSameNextElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.ALL, i);\n                        } else if (hasSamePreviousElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.PREVIOUS_AND_SAME, i);\n                        } else if (hasSameNextElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.NEXT_AND_SAME, i);\n                        } else {\n                            potentialMatches.putIfAbsent(MatchClassification.SAME_ONLY, i);\n                        }\n                    } else if (isAlmostCorrespondingElement(textElement, csmElement, node)) {\n                        potentialMatches.putIfAbsent(MatchClassification.ALMOST, i);\n                    }\n                }\n            }\n            // Prioritize the matches from best to worst\n            Optional<MatchClassification> bestMatchKey = potentialMatches.keySet().stream().min(Comparator.comparing(MatchClassification::getPriority));\n            if (bestMatchKey.isPresent()) {\n                correspondingIndices.add(potentialMatches.get(bestMatchKey.get()));\n            } else {\n                correspondingIndices.add(-1);\n            }\n        }\n        return correspondingIndices;\n    }\n\n    private enum MatchClassification {\n\n        ALL(1), PREVIOUS_AND_SAME(2), NEXT_AND_SAME(3), SAME_ONLY(4), ALMOST(5);\n\n        private final int priority;\n\n        MatchClassification(int priority) {\n            this.priority = priority;\n        }\n\n        int getPriority() {\n            return priority;\n        }\n    }\n\n    private boolean isCorrespondingElement(TextElement textElement, CsmElement csmElement, Node node) {\n        if (csmElement instanceof CsmToken) {\n            CsmToken csmToken = (CsmToken) csmElement;\n            if (textElement instanceof TokenTextElement) {\n                TokenTextElement tokenTextElement = (TokenTextElement) textElement;\n                return tokenTextElement.getTokenKind() == csmToken.getTokenType() && tokenTextElement.getText().equals(csmToken.getContent(node));\n            }\n        } else if (csmElement instanceof CsmChild) {\n            CsmChild csmChild = (CsmChild) csmElement;\n            if (textElement instanceof ChildTextElement) {\n                ChildTextElement childTextElement = (ChildTextElement) textElement;\n                return childTextElement.getChild() == csmChild.getChild();\n            }\n        } else if (csmElement instanceof CsmIndent) {\n        \tCsmIndent csmIndent = (CsmIndent) csmElement;\n            if (textElement instanceof TokenTextElement) {\n            \tTokenTextElement tokenTextElement = (TokenTextElement) textElement;\n                return tokenTextElement.isSpaceOrTab();\n            }\n        } else {\n            throw new UnsupportedOperationException();\n        }\n        return false;\n    }\n\n    private boolean isAlmostCorrespondingElement(TextElement textElement, CsmElement csmElement, Node node) {\n        if (isCorrespondingElement(textElement, csmElement, node)) {\n            return false;\n        }\n        return textElement.isWhiteSpace() && csmElement instanceof CsmToken && ((CsmToken) csmElement).isWhiteSpace();\n    }\n\n    private int adjustIndentation(List<TextElement> indentation, NodeText nodeText, int nodeTextIndex, boolean followedByUnindent) {\n        List<TextElement> indentationAdj = processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1));\n        if (nodeTextIndex < nodeText.numberOfElements() && nodeText.getTextElement(nodeTextIndex).isToken(RBRACE)) {\n            indentationAdj = indentationAdj.subList(0, indentationAdj.size() - Math.min(STANDARD_INDENTATION_SIZE, indentationAdj.size()));\n        } else if (followedByUnindent) {\n            indentationAdj = indentationAdj.subList(0, Math.max(0, indentationAdj.size() - STANDARD_INDENTATION_SIZE));\n        }\n        for (TextElement e : indentationAdj) {\n            if ((nodeTextIndex < nodeText.numberOfElements()) && nodeText.getTextElement(nodeTextIndex).isSpaceOrTab()) {\n                nodeTextIndex++;\n            } else {\n                nodeText.getElements().add(nodeTextIndex++, e);\n            }\n        }\n        if (nodeTextIndex < 0) {\n            throw new IllegalStateException();\n        }\n        return nodeTextIndex;\n    }\n\n    /*\n     * Returns true if the current <code>Added</code> element is preceded by a <code>Removed</code> element.\n     */\n    private boolean isAReplacement(int diffIndex) {\n        return (diffIndex > 0) && diffElements.get(diffIndex).isAdded() && diffElements.get(diffIndex - 1).isRemoved();\n    }\n\n    /*\n     * Returns true if the current <code>Removed</code> element is followed by a <code>Added</code> element.\n     */\n    private boolean isReplaced(int diffIndex) {\n        return (diffIndex < diffElements.size() - 1) && diffElements.get(diffIndex + 1).isAdded() && diffElements.get(diffIndex).isRemoved();\n    }\n\n    @Override\n    public String toString() {\n        return \"Difference{\" + diffElements + '}';\n    }\n}\n", "diffSourceCodeSet": ["private boolean isSpaceOrTabElement(NodeText nodeText, int i) {\n\t\treturn nodeText.getTextElement(i).isSpaceOrTab();\n\t}"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between\n     * the previous end of line and the next non whitespace (or tab) character\n     * @param nodeText List of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n     * The number of consecutive whitespace (or tab) characters\n     */\n    private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n    \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n    \t// compute space before startIndex value\n\t\tif (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n\t\t\t// at this stage startIndex points to the first element before the deleted one\n\t\t\tfor (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!isSpaceOrTabElement(nodeText, i)) {\n\t\t\t\t\tctx = new EnforcingIndentationContext(startIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.start = i;\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n\t\t// compute space after the deleted element\n\t\tif (isSpaceOrTabElement(nodeText, startIndex)) {\n//\t\t\tint startingFromIndex = startIndex == 0 ? startIndex : startIndex + 1;\n\t\t\tfor (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!isSpaceOrTabElement(nodeText, i)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n\n        return ctx;\n    }\nprivate boolean isSpaceOrTabElement(NodeText nodeText, int i) {\n\t\treturn nodeText.getTextElement(i).isSpaceOrTab();\n\t}", "diffSourceCode": "-  282:     /**\n-  283:      * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between \n-  284:      * the previous end of line and the next non whitespace (or tab) character\n-  285:      * @param nodeText List of elements to analyze\n-  286:      * @param nodeTextIndex Starting position in the input list\n-  287:      * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n-  288:      * The number of consecutive whitespace (or tab) characters\n-  289:      */\n-  290:     private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n-  291:     \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n-  292:     \t// compute space before startIndex value\n-  293: \t\tif (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n-  294: \t\t\t// at this stage startIndex points to the first element before the deleted one\n-  295: \t\t\tfor (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n-  296: \t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n-  297: \t\t\t\t\tbreak;\n-  298: \t\t\t\t}\n-  299: \t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n-  300: \t\t\t\t\tctx = new EnforcingIndentationContext(startIndex);\n-  301: \t\t\t\t\tbreak;\n-  302: \t\t\t\t}\n-  303: \t\t\t\tctx.start = i;\n-  304: \t\t\t\tctx.extraCharacters++;\n-  305: \t\t\t}\n-  306: \t\t}\n-  307: \t\t// compute space after the deleted element\n-  308: \t\tif (nodeText.getTextElement(startIndex).isSpaceOrTab()) {\n-  309: \t\t\tfor (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n-  310: \t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n-  311: \t\t\t\t\tbreak;\n-  312: \t\t\t\t}\n-  313: \t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n-  314: \t\t\t\t\tbreak;\n-  315: \t\t\t\t}\n-  316: \t\t\t\tctx.extraCharacters++;\n-  317: \t\t\t}\n-  318: \t\t}\n-  319:         \n-  320:         return ctx;\n-  321:     }\n-  322: \n-  323:     /**\n-  324:      * Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\n-  325:      * to the difference (adding and removing the elements provided).\n-  326:      */\n-  327:     void apply() {\n-  328:         extractReshuffledDiffElements(diffElements);\n-  329:         Map<Removed, RemovedGroup> removedGroups = combineRemovedElementsToRemovedGroups();\n-  330:         do {\n-  331:             boolean isLeftOverDiffElement = applyLeftOverDiffElements();\n-  332:             boolean isLeftOverOriginalElement = applyLeftOverOriginalElements();\n-  333:             if (!isLeftOverDiffElement && !isLeftOverOriginalElement) {\n-  338:                     TextElement originalElement = originalElements.get(originalIndex);\n-  339:                     boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n-  340:                     boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n+  282:      * @return The current position in the list of the elements\n+  283:      */\n+  284:     private int removeExtraCharacters(NodeText nodeText, int nodeTextIndex, int extraCharacters) {\n+  285:         int count = 0;\n+  286:         while (nodeTextIndex >= 0 && nodeTextIndex < nodeText.numberOfElements() && count < extraCharacters) {\n+  287:             nodeText.removeElement(nodeTextIndex);\n+  288:             count++;\n+  289:         }\n+  290:         return nodeTextIndex;\n+  291:     }\n+  292: \n+  293:     /**\n+  294:      * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between\n+  295:      * the previous end of line and the next non whitespace (or tab) character\n+  296:      * @param nodeText List of elements to analyze\n+  297:      * @param nodeTextIndex Starting position in the input list\n+  298:      * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n+  299:      * The number of consecutive whitespace (or tab) characters\n+  300:      */\n+  301:     private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n+  302:     \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n+  303:     \t// compute space before startIndex value\n+  304: \t\tif (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n+  305: \t\t\t// at this stage startIndex points to the first element before the deleted one\n+  306: \t\t\tfor (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n+  307: \t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n+  308: \t\t\t\t\tbreak;\n+  309: \t\t\t\t}\n+  310: \t\t\t\tif (!isSpaceOrTabElement(nodeText, i)) {\n+  311: \t\t\t\t\tctx = new EnforcingIndentationContext(startIndex);\n+  312: \t\t\t\t\tbreak;\n+  313: \t\t\t\t}\n+  314: \t\t\t\tctx.start = i;\n+  315: \t\t\t\tctx.extraCharacters++;\n+  316: \t\t\t}\n+  317: \t\t}\n+  318: \t\t// compute space after the deleted element\n+  319: \t\tif (isSpaceOrTabElement(nodeText, startIndex)) {\n+  320: //\t\t\tint startingFromIndex = startIndex == 0 ? startIndex : startIndex + 1;\n+  321: \t\t\tfor (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n+  322: \t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n+  323: \t\t\t\t\tbreak;\n+  324: \t\t\t\t}\n+  325: \t\t\t\tif (!isSpaceOrTabElement(nodeText, i)) {\n+  326: \t\t\t\t\tbreak;\n+  327: \t\t\t\t}\n+  328: \t\t\t\tctx.extraCharacters++;\n+  329: \t\t\t}\n+  330: \t\t}\n+  331: \n+  332:         return ctx;\n+  333:     }\n+  338: \tprivate boolean isSpaceOrTabElement(NodeText nodeText, int i) {\n+  339: \t\treturn nodeText.getTextElement(i).isSpaceOrTab();\n+  340: \t}\n", "uniqueId": "c9adc2fe0111fdb3f926d2df2264a8dcf6335f11_282_321_338_340_293_333", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 86}, "BRANCH": {"missed": 5, "covered": 17}, "LINE": {"missed": 0, "covered": 18}, "COMPLEXITY": {"missed": 5, "covered": 7}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `defineEnforcingIndentationContext` method, we can extract the logic for computing spaces before and after the specified index into separate methods. This will make the code cleaner and easier to understand.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\nprivate EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n    EnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n    \n    if (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n        computeSpaceBefore(ctx, nodeText, startIndex);\n    }\n    \n    if (nodeText.getTextElement(startIndex).isSpaceOrTab()) {\n        computeSpaceAfter(ctx, nodeText, startIndex);\n    }\n    \n    return ctx;\n}\n\nprivate void computeSpaceBefore(EnforcingIndentationContext ctx, NodeText nodeText, int startIndex) {\n    for (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n        if (nodeText.getTextElement(i).isNewline()) {\n            break;\n        }\n        if (!nodeText.getTextElement(i).isSpaceOrTab()) {\n            ctx.start = startIndex;\n            ctx.extraCharacters = 0;\n            break;\n        }\n        ctx.start = i;\n        ctx.extraCharacters++;\n    }\n}\n\nprivate void computeSpaceAfter(EnforcingIndentationContext ctx, NodeText nodeText, int startIndex) {\n    for (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n        if (nodeText.getTextElement(i).isNewline()) {\n            break;\n        }\n        if (!nodeText.getTextElement(i).isSpaceOrTab()) {\n            break;\n        }\n        ctx.extraCharacters++;\n    }\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Method Extraction**: The logic for computing spaces before and after the specified index has been extracted into two separate methods: `computeSpaceBefore` and `computeSpaceAfter`. This reduces the complexity of the `defineEnforcingIndentationContext` method and makes it easier to read.\n\n2. **Improved Readability**: Each method now has a clear purpose, which improves the overall readability of the code. The main method (`defineEnforcingIndentationContext`) now clearly outlines the steps taken to determine the enforcing indentation context.\n\n3. **Maintainability**: By breaking down the logic into smaller methods, it becomes easier to test and maintain each part of the logic independently. If changes are needed in the future, they can be made in a more localized manner.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between \n     * the previous end of line and the next non whitespace (or tab) character\n     * @param nodeText List of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n     * The number of consecutive whitespace (or tab) characters\n     */\n    private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n    \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n    \t// compute space before startIndex value\n\t\tif (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n\t\t\t// at this stage startIndex points to the first element before the deleted one\n\t\t\tfor (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\tctx = new EnforcingIndentationContext(startIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.start = i;\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n\t\t// compute space after the deleted element\n\t\tif (nodeText.getTextElement(startIndex).isSpaceOrTab()) {\n\t\t\tfor (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n        \n        return ctx;\n    }\n\nClass content:\n/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.printer.lexicalpreservation;\n\nimport com.github.javaparser.GeneratedJavaParserConstants;\nimport com.github.javaparser.JavaToken;\nimport com.github.javaparser.JavaToken.Kind;\nimport com.github.javaparser.TokenTypes;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.nodeTypes.NodeWithTypeArguments;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.printer.concretesyntaxmodel.*;\nimport com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator.CsmChild;\n\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.stream.IntStream;\n\nimport static com.github.javaparser.GeneratedJavaParserConstants.*;\n\n/**\n * A Difference should give me a sequence of elements I should find (to indicate the context) followed by a list of elements\n * to remove or to add and follow by another sequence of elements.\n *\n * I should later be able to apply such difference to a nodeText.\n */\npublic class Difference {\n\n    public static final int STANDARD_INDENTATION_SIZE = 4;\n\n    private final NodeText nodeText;\n\n    private final Node node;\n\n    private final List<DifferenceElement> diffElements;\n\n    private final List<TextElement> originalElements;\n\n    private int originalIndex = 0;\n\n    private int diffIndex = 0;\n\n    private final List<TextElement> indentation;\n\n    private boolean addedIndentation = false;\n\n    Difference(List<DifferenceElement> diffElements, NodeText nodeText, Node node) {\n        if (nodeText == null) {\n            throw new NullPointerException(\"nodeText can not be null\");\n        }\n        this.nodeText = nodeText;\n        this.node = node;\n        this.diffElements = diffElements;\n        this.originalElements = nodeText.getElements();\n        this.indentation = LexicalPreservingPrinter.findIndentation(node);\n    }\n\n    /*\n     * Returns the indentation used after the last line break\n     */\n    private List<TextElement> processIndentation(List<TextElement> indentation, List<TextElement> prevElements) {\n        int eolIndex = lastIndexOfEol(prevElements);\n        // Return \"indentation\" as is if no EOL element was found\n        if (eolIndex < 0)\n            return indentation;\n        // Find consecutive space characters after the EOL element\n        indentation = takeWhile(prevElements.subList(eolIndex + 1, prevElements.size()), element -> element.isWhiteSpace());\n        return indentation;\n    }\n    \n    /*\n     * returns only the elements that match the given predicate.\n     * takeWhile takes elements from the initial stream while the predicate holds true.\n     * Meaning that when an element is encountered that does not match the predicate, the rest of the list is discarded. \n     */\n    List<TextElement> takeWhile(List<TextElement> prevElements, Predicate<TextElement> predicate) {\n    \tList<TextElement> spaces = new ArrayList<>();\n    \tfor (TextElement element : prevElements) {\n    \t\tif (predicate.test(element)) {\n    \t\t\tspaces.add(element);\n                continue;\n            }\n            break;\n    \t}\n    \treturn spaces;\n    }\n    \n    \n    int lastIndexOfEol(List<TextElement> source) {\n        return IntStream.range(0, source.size())\n                       .map(i -> source.size() - i - 1)\n                       .filter(i -> source.get(i).isNewline())\n                       .findFirst()\n                       .orElse(-1);\n    }\n\n    /*\n     * Returns the position of the next element in the list starting from @{code fromIndex} which is a comment (Ignoring spaces)\n     * or -1 if it's not a comment.\n     */\n    private int posOfNextComment(int fromIndex, List<TextElement> elements) {\n        if (!isValidIndex(fromIndex, elements))\n            return -1;\n        ReadOnlyListIterator<TextElement> iterator = new ReadOnlyListIterator(elements, fromIndex);\n        // search for the next consecutive space characters\n        while (iterator.hasNext()) {\n            TextElement element = iterator.next();\n            if (element.isSpaceOrTab()) {\n                continue;\n            }\n            if (element.isComment()) {\n            \treturn iterator.index();\n            }\n            break;\n        }\n        return -1;\n    }\n    \n    /*\n     * Returns true if the next element in the list (starting from @{code fromIndex}) is a comment\n     */\n    private boolean isFollowedByComment(int fromIndex, List<TextElement> elements) {\n    \treturn posOfNextComment(fromIndex, elements) != -1;\n    }\n    \n    /*\n     * Removes all elements in the list starting from @{code fromIndex}) ending to @{code toIndex})\n     */\n    private void removeElements(int fromIndex, int toIndex, List<TextElement> elements) {\n    \tif (!(isValidIndex(fromIndex, elements) && isValidIndex(toIndex, elements) && fromIndex <= toIndex))\n            return;\n        ListIterator<TextElement> iterator = elements.listIterator(fromIndex);\n        // removing elements\n        int count = fromIndex;\n        while (iterator.hasNext() && count <= toIndex) {\n        \tTextElement element = iterator.next();\n            iterator.remove();\n            count++;\n        }\n    }\n    \n    private boolean isValidIndex(int index, List<?> elements) {\n    \treturn index >= 0 && index <= elements.size();\n    }\n\n    /*\n     * Returns the position of the last new line character or -1 if there is no eol in the specified list of TextElement \n     */\n    int lastIndexOfEolWithoutGPT(List<TextElement> source) {\n        ListIterator listIterator = source.listIterator(source.size());\n        int lastIndex = source.size() - 1;\n        while (listIterator.hasPrevious()) {\n            TextElement elem = (TextElement) listIterator.previous();\n            if (elem.isNewline()) {\n                return lastIndex;\n            }\n            lastIndex--;\n        }\n        return -1;\n    }\n\n    private List<TextElement> indentationBlock() {\n        List<TextElement> res = new LinkedList<>();\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        return res;\n    }\n\n    private boolean isAfterLBrace(NodeText nodeText, int nodeTextIndex) {\n        if (nodeTextIndex > 0 && nodeText.getTextElement(nodeTextIndex - 1).isToken(LBRACE)) {\n            return true;\n        }\n        if (nodeTextIndex > 0 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab()) {\n            return isAfterLBrace(nodeText, nodeTextIndex - 1);\n        }\n        return false;\n    }\n\n    /**\n     * If we are at the beginning of a line, with just spaces or tabs before/after the position of the deleted element\n     * we should force the space to be the same as the current indentation.\n     * This method handles the following case if we remove the modifier {@code public} ([ ] is an indent character)\n     * {@code \n     * [ ][ ]public[ ][ ][ ]void[ ]m{}\n     * <-1-->      <---2--->\n     * 1/ current indentation\n     * 2/ these whitespaces must be removed\n     * }\n     * should produce\n     * {@code \n     * [ ][ ]void[ ]m{} \n     * }\n     */\n    private int considerEnforcingIndentation(NodeText nodeText, int nodeTextIndex) {\n        return considerIndentation(nodeText, nodeTextIndex, indentation.size());\n    }\n    \n    private int considerRemovingIndentation(NodeText nodeText, int nodeTextIndex) {\n        return considerIndentation(nodeText, nodeTextIndex, 0);\n    }\n    \n    private int considerIndentation(NodeText nodeText, int nodeTextIndex, int numberOfCharactersToPreserve) {\n        EnforcingIndentationContext enforcingIndentationContext = defineEnforcingIndentationContext(nodeText, nodeTextIndex);\n        // the next position in the list (by default the current position)\n        int res = nodeTextIndex;\n        if (enforcingIndentationContext.extraCharacters > 0) {\n        \tint extraCharacters = enforcingIndentationContext.extraCharacters > numberOfCharactersToPreserve ? enforcingIndentationContext.extraCharacters - numberOfCharactersToPreserve : 0;\n            res = removeExtraCharacters(nodeText, enforcingIndentationContext.start, extraCharacters);\n            // The next position must take into account the indentation\n            res = extraCharacters > 0 ? res + numberOfCharactersToPreserve : res;\n        }\n        if (res < 0) {\n            throw new IllegalStateException();\n        }\n        return res;\n    }\n    \n    private boolean isEnforcingIndentationActivable(RemovedGroup removedGroup) {\n\t\treturn (diffIndex + 1 >= diffElements.size() || !(diffElements.get(diffIndex + 1).isAdded()))\n\t\t\t\t&& originalIndex < originalElements.size()\n\t\t\t\t&& !removedGroup.isACompleteLine();\n\t}\n\n    private boolean isRemovingIndentationActivable(RemovedGroup removedGroup) {\n\t\treturn (diffIndex + 1 >= diffElements.size() || !(diffElements.get(diffIndex + 1).isAdded())) \n\t\t\t\t&& originalIndex < originalElements.size()\n\t\t\t\t&& removedGroup.isACompleteLine();\n\t}\n    \n    /*\n     * This data structure class hold the starting position of the first whitespace char \n     * and the number of consecutive whitespace (or tab) characters\n     */\n    private class EnforcingIndentationContext {\n    \tint start;\n    \tint extraCharacters;\n    \tpublic EnforcingIndentationContext(int start) {\n    \t\tthis.start=start;\n    \t\tthis.extraCharacters=0;\n    \t}\n    }\n\n    /**\n     * Remove excess white space after deleting element.\n     * @param nodeText Contains a list of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return The current position in the list of the elements\n     */\n    private int removeExtraCharacters(NodeText nodeText, int nodeTextIndex, int extraCharacters) {\n        int count = 0;\n        while (nodeTextIndex >= 0 && nodeTextIndex < nodeText.numberOfElements() && count < extraCharacters) {\n            nodeText.removeElement(nodeTextIndex);\n            count++;\n        }\n        return nodeTextIndex;\n    }\n\n    /**\n     * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between \n     * the previous end of line and the next non whitespace (or tab) character\n     * @param nodeText List of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n     * The number of consecutive whitespace (or tab) characters\n     */\n    private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n    \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n    \t// compute space before startIndex value\n\t\tif (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n\t\t\t// at this stage startIndex points to the first element before the deleted one\n\t\t\tfor (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\tctx = new EnforcingIndentationContext(startIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.start = i;\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n\t\t// compute space after the deleted element\n\t\tif (nodeText.getTextElement(startIndex).isSpaceOrTab()) {\n\t\t\tfor (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n        \n        return ctx;\n    }\n\n    /**\n     * Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\n     * to the difference (adding and removing the elements provided).\n     */\n    void apply() {\n        extractReshuffledDiffElements(diffElements);\n        Map<Removed, RemovedGroup> removedGroups = combineRemovedElementsToRemovedGroups();\n        do {\n            boolean isLeftOverDiffElement = applyLeftOverDiffElements();\n            boolean isLeftOverOriginalElement = applyLeftOverOriginalElements();\n            if (!isLeftOverDiffElement && !isLeftOverOriginalElement) {\n                DifferenceElement diffElement = diffElements.get(diffIndex);\n                if (diffElement.isAdded()) {\n                    applyAddedDiffElement((Added) diffElement);\n                } else {\n                    TextElement originalElement = originalElements.get(originalIndex);\n                    boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n                    if (diffElement.isKept()) {\n                        applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else if (diffElement.isRemoved()) {\n                        Removed removed = (Removed) diffElement;\n                        applyRemovedDiffElement(removedGroups.get(removed), removed, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n    }\n\n    private boolean applyLeftOverOriginalElements() {\n        boolean isLeftOverElement = false;\n        if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n            TextElement originalElement = originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n            isLeftOverElement = true;\n        }\n        return isLeftOverElement;\n    }\n\n    private boolean applyLeftOverDiffElements() {\n        boolean isLeftOverElement = false;\n        if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n            DifferenceElement diffElement = diffElements.get(diffIndex);\n            if (diffElement.isKept()) {\n                diffIndex++;\n            } else if (diffElement.isAdded()) {\n                Added addedElement = (Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                // let's forget this element\n                diffIndex++;\n            }\n            isLeftOverElement = true;\n        }\n        return isLeftOverElement;\n    }\n\n    private void extractReshuffledDiffElements(List<DifferenceElement> diffElements) {\n        for (int index = 0; index < diffElements.size(); index++) {\n            DifferenceElement diffElement = diffElements.get(index);\n            if (diffElement instanceof Reshuffled) {\n                Reshuffled reshuffled = (Reshuffled) diffElement;\n                // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                CsmMix elementsFromPreviousOrder = reshuffled.getPreviousOrder();\n                CsmMix elementsFromNextOrder = reshuffled.getNextOrder();\n                // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                // We now find out which Node Text elements corresponds to the elements in the original CSM\n                List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                for (int i = 0; i < nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value = nodeTextIndexOfPreviousElements.get(i);\n                    if (value != -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                // Elements to be added at the end\n                List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n                Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                for (int ni = 0; ni < nextOrderElements.size(); ni++) {\n                    // If it has a mapping, then it is kept\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        // Ok, it is something new. Where to put it? Let's see what is the first following\n                        // element that has a mapping\n                        int originalCsmIndex = -1;\n                        for (int nj = ni + 1; nj < nextOrderElements.size() && originalCsmIndex == -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                            }\n                        }\n                        // it does not preceed anything, so it goes at the end\n                        if (originalCsmIndex == -1) {\n                            elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                        }\n                    }\n                }\n                // We go over the original node text elements, in the order they appear in the NodeText.\n                // Considering an original node text element (ONE)\n                // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                // we find the correspond OCE (Original CSM Element)\n                // * we first add new elements that are marked to be added before OCE\n                // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                // otherwise we add a removed element\n                // Remove the whole Reshuffled element\n                diffElements.remove(index);\n                int diffElIterator = index;\n                if (lastNodeTextIndex != -1) {\n                    for (int ntIndex = originalIndex; ntIndex <= lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        }\n                        // else we have a simple node text element, without associated csm element, just keep ignore it\n                    }\n                }\n                // Finally we look for the remaining new elements that were not yet added and\n                // add all of them\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            }\n        }\n    }\n\n    /**\n     * Maps all Removed elements as keys to their corresponding RemovedGroup.\n     * A RemovedGroup contains all consecutive Removed elements.\n     * <br>\n     * Example:\n     * <pre>\n     * Elements: Kept|Removed1|Removed2|Kept|Removed3|Added|Removed4\n     * Groups:        <----Group1---->       Group2         Group3\n     * Keys:          Removed1+Removed2      Removed3       Removed4\n     * </pre>\n     *\n     * @return Map with all Removed elements as keys to their corresponding RemovedGroup\n     */\n    private Map<Removed, RemovedGroup> combineRemovedElementsToRemovedGroups() {\n        Map<Integer, List<Removed>> removedElementsMap = groupConsecutiveRemovedElements();\n        List<RemovedGroup> removedGroups = new ArrayList<>();\n        for (Map.Entry<Integer, List<Removed>> entry : removedElementsMap.entrySet()) {\n            removedGroups.add(RemovedGroup.of(entry.getKey(), entry.getValue()));\n        }\n        Map<Removed, RemovedGroup> map = new HashMap<>();\n        for (RemovedGroup removedGroup : removedGroups) {\n            for (Removed index : removedGroup) {\n                map.put(index, removedGroup);\n            }\n        }\n        return map;\n    }\n\n    private Map<Integer, List<Removed>> groupConsecutiveRemovedElements() {\n        Map<Integer, List<Removed>> removedElementsMap = new HashMap<>();\n        Integer firstElement = null;\n        for (int i = 0; i < diffElements.size(); i++) {\n            DifferenceElement diffElement = diffElements.get(i);\n            if (diffElement.isRemoved()) {\n                if (firstElement == null) {\n                    firstElement = i;\n                }\n                removedElementsMap.computeIfAbsent(firstElement, key -> new ArrayList<>()).add((Removed) diffElement);\n            } else {\n                firstElement = null;\n            }\n        }\n        return removedElementsMap;\n    }\n\n    private void applyRemovedDiffElement(RemovedGroup removedGroup, Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n        if (removed.isChild() && originalElementIsChild) {\n            ChildTextElement originalElementChild = (ChildTextElement) originalElement;\n            if (originalElementChild.isComment()) {\n                // We expected to remove a proper node but we found a comment in between.\n                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                Comment comment = (Comment) originalElementChild.getChild();\n                if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n                    nodeText.removeElement(originalIndex);\n                } else {\n                    originalIndex++;\n                }\n            } else {\n                nodeText.removeElement(originalIndex);\n                // When we don't try to remove a complete line \n                // and removing the element is not the first action of a replacement (removal followed by addition)\n                // (in the latter case we keep the indentation)\n                // then we want to enforce the indentation.\n                if (isEnforcingIndentationActivable(removedGroup)) {\n                \t// Since the element has been deleted we try to start the analysis from the element following the one that was deleted\n                    originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                }\n                // If in front we have one space and before also we had space let's drop one space\n                if (originalElements.size() > originalIndex && originalIndex > 0) {\n                    if (originalElements.get(originalIndex).isWhiteSpace() && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                        // However we do not want to do that when we are about to adding or removing elements\n                        // The intention is not very clear maybe it should clarify this with examples!\n                        // Are we to understand that we can only do this if there is a single modification to process\n                        // OR or if the next change is to keep the element\n                        if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1).isKept())) {\n                            originalElements.remove(originalIndex--);\n                        }\n                    }\n                }\n                // We need to know if, in the original list of elements, the deleted child node is immediately followed by the same comment.\n                // If so, it should also be deleted.\n                if (isFollowedByComment(originalIndex, originalElements) ) {\n                \tint indexOfNextComment = posOfNextComment(originalIndex, originalElements);\n                \tremoveElements(originalIndex, indexOfNextComment, originalElements);\n                }\n                if (isRemovingIndentationActivable(removedGroup)) {\n                \t// Since the element has been deleted we try to start the analysis from the previous element\n                    originalIndex = considerRemovingIndentation(nodeText, originalIndex);\n                }\n                diffIndex++;\n            }\n        } else if (removed.isChild() && originalElement.isComment()) {\n        \t// removing the comment first\n        \tnodeText.removeElement(originalIndex);\n        \tif (isRemovingIndentationActivable(removedGroup)) {\n                originalIndex = considerRemovingIndentation(nodeText, originalIndex);\n            }\n        } else if (removed.isToken() && originalElementIsToken && (removed.getTokenType() == ((TokenTextElement) originalElement).getTokenKind() || // handle EOLs separately as their token kind might not be equal. This is because the 'removed'\n        // element always has the current operating system's EOL as type\n        (((TokenTextElement) originalElement).getToken().getCategory().isEndOfLine() && removed.isNewLine()))) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if ((removed.isWhiteSpaceNotEol() || removed.getElement() instanceof CsmIndent || removed.getElement() instanceof CsmUnindent)\n        \t\t&& originalElement.isSpaceOrTab()){\n        \t// remove the current space\n        \tnodeText.removeElement(originalIndex);\n        }else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n            originalIndex++;\n            // skip the newline token which may be generated unnecessarily by the concrete syntax pattern\n            if (removed.isNewLine()) { \n            \tdiffIndex++;\n            }\n        } else if (originalElement.isLiteral()) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if (removed.isPrimitiveType()) {\n            if (originalElement.isPrimitive()) {\n                nodeText.removeElement(originalIndex);\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n            }\n        } else if (removed.isWhiteSpace() || removed.getElement() instanceof CsmIndent || removed.getElement() instanceof CsmUnindent) {\n            diffIndex++;\n        } else if (originalElement.isWhiteSpace()) {\n            originalIndex++;\n        } else if (removed.isChild()) {\n            // see issue #3721 this case is linked for example to a change of type of variable declarator\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n        }\n        cleanTheLineOfLeftOverSpace(removedGroup, removed);\n    }\n\n    /**\n     * Cleans the line of left over space if there is unnecessary indentation and the element will not be replaced\n     */\n    private void cleanTheLineOfLeftOverSpace(RemovedGroup removedGroup, Removed removed) {\n        if (originalIndex >= originalElements.size()) {\n            // if all elements were already processed there is nothing to do\n            return;\n        }\n        // we dont want to remove the indentation if the last removed element is a newline\n        // because in this case we are trying to remove the indentation of the next child element\n        if (!removedGroup.isProcessed() \n        \t\t&& removedGroup.isLastElement(removed) \n        \t\t&& removedGroup.isACompleteLine()\n        \t\t&& !removed.isNewLine()) {\n            Integer lastElementIndex = removedGroup.getLastElementIndex();\n            Optional<Integer> indentation = removedGroup.getIndentation();\n            if (indentation.isPresent() && !isReplaced(lastElementIndex)) {\n                for (int i = 0; i < indentation.get(); i++) {\n                    if (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        // If the current element is a space, remove it\n                        nodeText.removeElement(originalIndex);\n                    } else if (originalIndex >= 1 && originalElements.get(originalIndex - 1).isSpaceOrTab()) {\n                        // If the current element is not a space itself we remove the space in front of (before) it\n                        nodeText.removeElement(originalIndex - 1);\n                        originalIndex--;\n                    }\n                    // Remove remaining newline character if needed\n                    if (nodeText.getTextElement(originalIndex).isNewline()) {\n                    \tnodeText.removeElement(originalIndex);\n                    \toriginalIndex = originalIndex > 0 ? originalIndex-- : 0;\n                    }\n                }\n            }\n            // Mark RemovedGroup as processed\n            removedGroup.processed();\n        }\n    }\n\n    // note:\n    // increment originalIndex if we want to keep the original element\n    // increment diffIndex if we want to skip the diff element\n    private void applyKeptDiffElement(Kept kept, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n\t\tif (originalElement.isComment()) {\n\t\t\toriginalIndex++;\n        } else if (kept.isChild() && ((CsmChild) kept.getElement()).getChild() instanceof Comment) {\n            diffIndex++;\n        } else if (kept.isChild() && originalElementIsChild) {\n            diffIndex++;\n            originalIndex++;\n        } else if (kept.isChild() && originalElementIsToken) {\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else if (originalElement.isIdentifier() && isNodeWithTypeArguments(kept)) {\n                diffIndex++;\n                // skip all token related to node with type argument declaration\n                // for example:\n                // List i : in this case originalElement is \"List\" and the next token is space. There is nothing to skip. in the originalElements list.\n                // List<String> i : in this case originalElement is \"List\" and the next token is\n                // \"<\" so we have to skip all the tokens which are used in the typed argument declaration [<][String][>](3 tokens) in the originalElements list.\n                // List<List<String>> i : in this case originalElement is \"List\" and the next\n                // token is \"<\" so we have to skip all the tokens which are used in the typed arguments declaration [<][List][<][String][>][>](6 tokens) in the originalElements list.\n                int step = getIndexToNextTokenElement((TokenTextElement) originalElement, 0);\n                originalIndex += step;\n                originalIndex++;\n            } else if (originalElement.isIdentifier() && isTypeWithFullyQualifiedName(kept)) {\n                diffIndex++;\n                // skip all token related to node with the fully qualified name\n                // for example:\n                // java.lang.Object is represented in originalElement as a list of tokens \"java\", \".\", \"lang\", \".\", \"Object\".\n                // So we have to skip 5 tokens.\n                int step = getIndexToNextTokenElement((TokenTextElement) originalElement, kept);\n                originalIndex += step;\n                // positioning on the next token\n                originalIndex++;\n            } else if ((originalElement.isIdentifier() || originalElement.isKeyword()) && isArrayType(kept)) {\n                int tokenToSkip = getIndexToNextTokenElementInArrayType((TokenTextElement) originalElement, getArrayLevel(kept));\n                diffIndex++;\n                originalIndex += tokenToSkip;\n                originalIndex++;\n            } else if (originalElement.isIdentifier()) {\n                originalIndex++;\n                diffIndex++;\n            } else {\n                if (kept.isPrimitiveType()) {\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                }\n            }\n        } else if (kept.isToken() && originalElementIsToken) {\n            TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n            if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n                originalIndex++;\n                diffIndex++;\n            } else if (kept.isNewLine() && originalTextToken.isNewline()) {\n                originalIndex++;\n                diffIndex++;\n            } else if (kept.isNewLine() && originalTextToken.isSpaceOrTab()) {\n                originalIndex++;\n            } else if (kept.isWhiteSpaceOrComment()) {\n                diffIndex++;\n            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else if (!kept.isNewLine() && originalTextToken.isSeparator()) {\n                // case where originalTextToken is a separator like \";\" and\n                // kept is not a new line or whitespace for example \"}\"\n                // see issue 2351\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n            }\n        } else if (kept.isToken() && originalElementIsChild) {\n            diffIndex++;\n        } else if (kept.isWhiteSpace()) {\n            diffIndex++;\n        } else if (kept.isIndent()) {\n            diffIndex++;\n        } else if (kept.isUnindent()) {\n            // Nothing to do\n            diffIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n        }\n    }\n\n    /*\n     * Returns the array level if the DifferenceElement is a CsmChild representing an ArrayType else 0\n     */\n    private int getArrayLevel(DifferenceElement element) {\n        CsmElement csmElem = element.getElement();\n        if (isArrayType(element)) {\n            Node child = ((LexicalDifferenceCalculator.CsmChild) csmElem).getChild();\n            return ((ArrayType) child).getArrayLevel();\n        }\n        return 0;\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild representing an ArrayType\n     */\n    private boolean isArrayType(DifferenceElement element) {\n        CsmElement csmElem = element.getElement();\n        return csmElem instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild) csmElem).getChild() instanceof ArrayType;\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild which represents a type with fully qualified name\n     */\n    private boolean isTypeWithFullyQualifiedName(DifferenceElement element) {\n        if (!element.isChild())\n            return false;\n        CsmChild child = (CsmChild) element.getElement();\n        if (!ClassOrInterfaceType.class.isAssignableFrom(child.getChild().getClass()))\n            return false;\n        return ((ClassOrInterfaceType) child.getChild()).getScope().isPresent();\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild with type arguments\n     */\n    private boolean isNodeWithTypeArguments(DifferenceElement element) {\n        if (!element.isChild())\n            return false;\n        CsmChild child = (CsmChild) element.getElement();\n        if (!NodeWithTypeArguments.class.isAssignableFrom(child.getChild().getClass()))\n            return false;\n        Optional<NodeList<Type>> typeArgs = ((NodeWithTypeArguments) child.getChild()).getTypeArguments();\n        return typeArgs.isPresent() && typeArgs.get().size() > 0;\n    }\n\n    /*\n     * Try to resolve the number of token to skip in the original list to match \n     * a ClassOrInterfaceType with a list of tokens like \"java\", \".\", \"lang\", \".\", \"Object\"\n     */\n    private int getIndexToNextTokenElement(TokenTextElement element, DifferenceElement kept) {\n        // number of token to skip\n        int step = 0;\n        // verify if the DifferenceElement is a ClassOrInterfaceType with a fully qualified name\n        if (!isTypeWithFullyQualifiedName(kept))\n            return 0;\n        CsmChild child = (CsmChild) kept.getElement();\n        // split the type fully qualified node name to an array of tokens\n        String[] parts = ((ClassOrInterfaceType) child.getChild()).getNameWithScope().split(\"\\\\.\");\n        JavaToken token = element.getToken();\n        for (String part : parts) {\n            if (part.equals(token.asString())) {\n                // get 'dot' token\n                token = token.getNextToken().get();\n                if (!token.asString().equals(\".\"))\n                    break;\n                // get the next part\n                token = token.getNextToken().get();\n                step += 2;\n                continue;\n            }\n            // there is no match so we don't have token to skip\n            step = 0;\n            break;\n        }\n        return step;\n    }\n\n    /*\n     * Returns the number of tokens to skip in originalElements list to synchronize it with the DiffElements list\n     * This is due to the fact that types are considered as token in the originalElements list.\n     * For example,\n     * List<String> is represented by 4 tokens ([List][<][String][>]) while it's a CsmChild element in the DiffElements list\n     * So in this case, getIndexToNextTokenElement(..) on the [List] token returns 3 because we have to skip 3 tokens ([<][String][>]) to synchronize\n     * DiffElements list and originalElements list\n     * The end of recursivity is reached when there is no next token or if the nested diamond operators are totally managed, to take into account this type of declaration\n     * List <List<String>> l\n     * Be careful, this method must be call only if diamond operator could be found in the sequence\n     *\n     * @Param TokenTextElement the token currently analyzed\n     * @Param int the number of nested diamond operators\n     * @return the number of token to skip in originalElements list\n     */\n    private int getIndexToNextTokenElement(TokenTextElement element, int nestedDiamondOperator) {\n        // number of token to skip\n        int step = 0;\n        Optional<JavaToken> next = element.getToken().getNextToken();\n        if (!next.isPresent())\n            return step;\n        // because there is a token, first we need to increment the number of token to skip\n        step++;\n        // manage nested diamond operators by incrementing the level on LT token and decrementing on GT\n        JavaToken nextToken = next.get();\n        Kind kind = Kind.valueOf(nextToken.getKind());\n        if (isDiamondOperator(kind)) {\n            if (kind.GT.equals(kind))\n                nestedDiamondOperator--;\n            else\n                nestedDiamondOperator++;\n        }\n        // manage the fact where the first token is not a diamond operator but a whitespace\n        // and the end of the token sequence to skip\n        // for example in this declaration List <String> a;\n        if (nestedDiamondOperator == 0 && !nextToken.getCategory().isWhitespace())\n            return step;\n        // recursively analyze token to skip\n        return step += getIndexToNextTokenElement(new TokenTextElement(nextToken), nestedDiamondOperator);\n    }\n\n    /*\n     * Returns the number of tokens to skip in originalElements list to synchronize it with the DiffElements list\n     */\n    private int getIndexToNextTokenElementInArrayType(TokenTextElement element, int arrayLevel) {\n        // number of token to skip\n        int step = 0;\n        Optional<JavaToken> next = element.getToken().getNextToken();\n        if (!next.isPresent())\n            return step;\n        // because there is a token, first we need to increment the number of token to skip\n        step++;\n        // manage array Level by decrementing the level on right bracket token\n        JavaToken nextToken = next.get();\n        Kind kind = Kind.valueOf(nextToken.getKind());\n        if (isBracket(kind)) {\n            if (kind.RBRACKET.equals(kind))\n                arrayLevel--;\n        }\n        // manage the fact where the first token is not a diamond operator but a whitespace\n        // and the end of the token sequence to skip\n        // for example in this declaration int [] a;\n        if (arrayLevel == 0 && !nextToken.getCategory().isWhitespace())\n            return step;\n        // recursively analyze token to skip\n        return step += getIndexToNextTokenElementInArrayType(new TokenTextElement(nextToken), arrayLevel);\n    }\n\n    /*\n     * Returns true if the token is possibly a diamond operator\n     */\n    private boolean isDiamondOperator(Kind kind) {\n        return kind.GT.equals(kind) || kind.LT.equals(kind);\n    }\n\n    /*\n     * Returns true if the token is a bracket\n     */\n    private boolean isBracket(Kind kind) {\n        return kind.LBRACKET.equals(kind) || kind.RBRACKET.equals(kind);\n    }\n\n    private boolean openBraceWasOnSameLine() {\n        int index = originalIndex;\n        while (index >= 0 && !nodeText.getTextElement(index).isNewline()) {\n            if (nodeText.getTextElement(index).isToken(LBRACE)) {\n                return true;\n            }\n            index--;\n        }\n        return false;\n    }\n\n    private boolean wasSpaceBetweenBraces() {\n        return nodeText.getTextElement(originalIndex).isToken(RBRACE) && doWeHaveLeftBraceFollowedBySpace(originalIndex - 1) && (diffIndex < 2 || !diffElements.get(diffIndex - 2).isRemoved());\n    }\n\n    private boolean doWeHaveLeftBraceFollowedBySpace(int index) {\n        index = rewindSpace(index);\n        return nodeText.getTextElement(index).isToken(LBRACE);\n    }\n\n    private int rewindSpace(int index) {\n        if (index <= 0) {\n            return index;\n        }\n        if (nodeText.getTextElement(index).isWhiteSpace()) {\n            return rewindSpace(index - 1);\n        } else {\n            return index;\n        }\n    }\n\n    private boolean nextIsRightBrace(int index) {\n        List<TextElement> elements = originalElements.subList(index, originalElements.size());\n        for (TextElement element : elements) {\n            if (!element.isSpaceOrTab()) {\n                return element.isToken(RBRACE);\n            }\n        }\n        return false;\n    }\n\n    private void applyAddedDiffElement(Added added) {\n        if (added.isIndent()) {\n            for (int i = 0; i < STANDARD_INDENTATION_SIZE; i++) {\n                indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n            }\n            addedIndentation = true;\n            diffIndex++;\n            return;\n        }\n        if (added.isUnindent()) {\n            for (int i = 0; i < STANDARD_INDENTATION_SIZE && !indentation.isEmpty(); i++) {\n                indentation.remove(indentation.size() - 1);\n            }\n            addedIndentation = false;\n            diffIndex++;\n            return;\n        }\n        TextElement addedTextElement = added.toTextElement();\n        boolean used = false;\n        boolean isPreviousElementNewline = (originalIndex > 0) && originalElements.get(originalIndex - 1).isNewline();\n        if (isPreviousElementNewline) {\n            List<TextElement> elements = processIndentation(indentation, originalElements.subList(0, originalIndex - 1));\n            boolean nextIsRightBrace = nextIsRightBrace(originalIndex);\n            for (TextElement e : elements) {\n                if (!nextIsRightBrace && e instanceof TokenTextElement && originalElements.get(originalIndex).isToken(((TokenTextElement) e).getTokenKind())) {\n                    originalIndex++;\n                } else {\n                    nodeText.addElement(originalIndex++, e);\n                }\n            }\n        } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n            if (addedTextElement.isNewline()) {\n                used = true;\n            }\n            nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n            // This remove the space in \"{ }\" when adding a new line\n            while (originalIndex >= 2 && originalElements.get(originalIndex - 2).isSpaceOrTab()) {\n                originalElements.remove(originalIndex - 2);\n                originalIndex--;\n            }\n            for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                nodeText.addElement(originalIndex++, e);\n            }\n            // Indentation is painful...\n            // Sometimes we want to force indentation: this is the case when indentation was expected but\n            // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n            // not there, so when adding new elements we force it. However if the indentation has been\n            // inserted by us in this transformation we do not want to insert it again\n            if (!addedIndentation) {\n                for (TextElement e : indentationBlock()) {\n                    nodeText.addElement(originalIndex++, e);\n                }\n            }\n        }\n        if (!used) {\n            // Handling trailing comments\n            boolean sufficientTokensRemainToSkip = nodeText.numberOfElements() > originalIndex + 2;\n            boolean currentIsAComment = nodeText.getTextElement(originalIndex).isComment();\n            boolean previousIsAComment = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isComment();\n            boolean currentIsNewline = nodeText.getTextElement(originalIndex).isNewline();\n            boolean isFirstElement = originalIndex == 0;\n            boolean previousIsWhiteSpace = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isWhiteSpace();\n\t\t\tboolean commentIsBeforeAddedElement = currentIsAComment && addedTextElement.getRange().isPresent()\n\t\t\t\t\t&& nodeText.getTextElement(originalIndex).getRange()\n\t\t\t\t\t\t\t.map(range -> range.isBefore(addedTextElement.getRange().get())).orElse(false);\n            if (sufficientTokensRemainToSkip && currentIsAComment && commentIsBeforeAddedElement) {\n                // Need to get behind the comment:\n                // FIXME: Why 2? This comment and the next newline?\n                originalIndex += 2;\n                // Defer originalIndex increment\n                nodeText.addElement(originalIndex, addedTextElement);\n                // We want to adjust the indentation while considering the new element that we added\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);\n                // Now we can increment\n                originalIndex++;\n            } else if (currentIsNewline && previousIsAComment) {\n                /*\n                 * Manage the case where we want to add an element, after an expression which is followed by a comment on the same line.\n                 * This is not the same case as the one who handles the trailing comments, because in this case the node text element is a new line (not a comment)\n                 * For example : {@code private String a; // this is a }\n                 */\n                // Insert after the new line which follows this comment.\n                originalIndex++;\n                // We want to adjust the indentation while considering the new element that we added\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);\n                // Defer originalIndex increment\n                nodeText.addElement(originalIndex, addedTextElement);\n                // Now we can increment.\n                originalIndex++;\n            } else if (currentIsNewline && addedTextElement.isChild()) {\n                // here we want to place the new child element after the current new line character.\n                // Except if indentation has been inserted just before this step (in the case where isPreviousElementNewline is true)\n                // or if the previous character is a space (it could be the case if we want to replace a statement)\n                // Example 1 : if we insert a statement (a duplicated method call expression ) after this one <code>  value();\\n\\n</code>\n                // we want to have this result <code>  value();\\n  value();\\n</code> not <code>  value();\\n  \\nvalue();</code>\n                // Example 2 : if we want to insert a statement after this one <code>  \\n</code> we want to have <code>  value();\\n</code>\n                // not <code>  \\nvalue();</code> --> this case appears on member replacement for example\n                if (!isPreviousElementNewline && !isFirstElement && !previousIsWhiteSpace) {\n                    // Insert after the new line\n                    originalIndex++;\n                }\n                nodeText.addElement(originalIndex, addedTextElement);\n                originalIndex++;\n            } else {\n                nodeText.addElement(originalIndex, addedTextElement);\n                originalIndex++;\n            }\n        }\n        if (addedTextElement.isNewline()) {\n            boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n            boolean nextIsRightBrace = nextIsRightBrace(originalIndex);\n            boolean nextIsNewLine = originalElements.get(originalIndex).isNewline();\n            if ((!nextIsNewLine && !nextIsRightBrace) || followedByUnindent) {\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n            }\n        }\n        diffIndex++;\n    }\n\n    private String tokenDescription(int kind) {\n        return GeneratedJavaParserConstants.tokenImage[kind];\n    }\n\n\t/*\n\t * Considering that the lists of elements are ordered, We can find the common\n\t * elements by starting with the list before the modifications and, for each\n\t * element, by going through the list of elements containing the modifications.\n\t * \n\t * We can find the common elements by starting with the list before the\n\t * modifications (L1) and, for each element, by going through the list of elements\n\t * containing the modifications (L2).\n\t * \n\t * If element A in list L1 is not found in list L2, it is a deleted element. \n\t * If element A of list L1 is found in list L2, it is a kept element. In this\n\t * case the search for the next element of the list L1 must start from the\n\t * position of the last element kept {@code syncNextIndex}.\n\t */\n\tprivate Map<Integer, Integer> getCorrespondanceBetweenNextOrderAndPreviousOrder(CsmMix elementsFromPreviousOrder,\n\t\t\tCsmMix elementsFromNextOrder) {\n\t\tMap<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n\t\tReadOnlyListIterator<CsmElement> previousOrderElementsIterator = new ReadOnlyListIterator(\n\t\t\t\telementsFromPreviousOrder.getElements());\n\t\tint syncNextIndex = 0;\n\t\twhile (previousOrderElementsIterator.hasNext()) {\n\t\t\tCsmElement pe = previousOrderElementsIterator.next();\n\t\t\tReadOnlyListIterator<CsmElement> nextOrderElementsIterator = new ReadOnlyListIterator(\n\t\t\t\t\telementsFromNextOrder.getElements(), syncNextIndex);\n\t\t\twhile (nextOrderElementsIterator.hasNext()) {\n\t\t\t\tCsmElement ne = nextOrderElementsIterator.next();\n\t\t\t\tif (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(previousOrderElementsIterator.index())\n\t\t\t\t\t\t&& DifferenceElementCalculator.matching(ne, pe)) {\n\t\t\t\t\tcorrespondanceBetweenNextOrderAndPreviousOrder.put(nextOrderElementsIterator.index(),\n\t\t\t\t\t\t\tpreviousOrderElementsIterator.index());\n\t\t\t\t\t// set the position to start on the next {@code nextOrderElementsIterator} iteration\n\t\t\t\t\tsyncNextIndex = nextOrderElementsIterator.index(); \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn correspondanceBetweenNextOrderAndPreviousOrder;\n\t}\n    \n    /*\n     * A list iterator which does not allow to modify the list \n     * and which provides a method to know the current positioning \n     */\n    private class ReadOnlyListIterator<T> implements ListIterator<T> {\n    \tListIterator<T> elements;\n    \tpublic ReadOnlyListIterator(List<T> elements) {\n    \t\tthis(elements, 0);\n    \t}\n    \t\n    \tpublic ReadOnlyListIterator(List<T> elements, int index) {\n    \t\tthis.elements = elements.listIterator(index);\n    \t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn elements.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic T next() {\n\t\t\treturn elements.next();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasPrevious() {\n\t\t\treturn elements.hasPrevious();\n\t\t}\n\n\t\t@Override\n\t\tpublic T previous() {\n\t\t\treturn elements.previous();\n\t\t}\n\n\t\t@Override\n\t\tpublic int nextIndex() {\n\t\t\treturn elements.nextIndex();\n\t\t}\n\n\t\t@Override\n\t\tpublic int previousIndex() {\n\t\t\treturn elements.previousIndex();\n\t\t}\n\t\t\n\t\t/*\n\t\t * Returns the current index in the underlying list\n\t\t */\n\t\tpublic int index() {\n\t\t\treturn elements.nextIndex() - 1;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void set(T e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void add(T e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n    \t\n    }\n\n    /*\n     * Returns true if the next element in the list is an added element of type CsmUnindent\n     */\n    private boolean isFollowedByUnindent(List<DifferenceElement> diffElements, int diffIndex) {\n        int nextIndexValue = diffIndex + 1;\n        return (nextIndexValue) < diffElements.size() && diffElements.get(nextIndexValue).isAdded() && diffElements.get(nextIndexValue).getElement() instanceof CsmUnindent;\n    }\n\n    private List<Integer> findIndexOfCorrespondingNodeTextElement(List<CsmElement> elements, NodeText nodeText, int startIndex, Node node) {\n        List<Integer> correspondingIndices = new ArrayList<>();\n        for (ListIterator<CsmElement> csmElementListIterator = elements.listIterator(); csmElementListIterator.hasNext(); ) {\n            int previousCsmElementIndex = csmElementListIterator.previousIndex();\n            CsmElement csmElement = csmElementListIterator.next();\n            int nextCsmElementIndex = csmElementListIterator.nextIndex();\n            Map<MatchClassification, Integer> potentialMatches = new EnumMap<>(MatchClassification.class);\n            for (int i = startIndex; i < nodeText.numberOfElements(); i++) {\n                if (!correspondingIndices.contains(i)) {\n                    TextElement textElement = nodeText.getTextElement(i);\n                    boolean isCorresponding = isCorrespondingElement(textElement, csmElement, node);\n                    if (isCorresponding) {\n                        boolean hasSamePreviousElement = false;\n                        if (i > 0 && previousCsmElementIndex > -1) {\n                            TextElement previousTextElement = nodeText.getTextElement(i - 1);\n                            hasSamePreviousElement = isCorrespondingElement(previousTextElement, elements.get(previousCsmElementIndex), node);\n                        }\n                        boolean hasSameNextElement = false;\n                        if (i < nodeText.numberOfElements() - 1 && nextCsmElementIndex < elements.size()) {\n                            TextElement nextTextElement = nodeText.getTextElement(i + 1);\n                            hasSameNextElement = isCorrespondingElement(nextTextElement, elements.get(nextCsmElementIndex), node);\n                        }\n                        if (hasSamePreviousElement && hasSameNextElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.ALL, i);\n                        } else if (hasSamePreviousElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.PREVIOUS_AND_SAME, i);\n                        } else if (hasSameNextElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.NEXT_AND_SAME, i);\n                        } else {\n                            potentialMatches.putIfAbsent(MatchClassification.SAME_ONLY, i);\n                        }\n                    } else if (isAlmostCorrespondingElement(textElement, csmElement, node)) {\n                        potentialMatches.putIfAbsent(MatchClassification.ALMOST, i);\n                    }\n                }\n            }\n            // Prioritize the matches from best to worst\n            Optional<MatchClassification> bestMatchKey = potentialMatches.keySet().stream().min(Comparator.comparing(MatchClassification::getPriority));\n            if (bestMatchKey.isPresent()) {\n                correspondingIndices.add(potentialMatches.get(bestMatchKey.get()));\n            } else {\n                correspondingIndices.add(-1);\n            }\n        }\n        return correspondingIndices;\n    }\n\n    private enum MatchClassification {\n\n        ALL(1), PREVIOUS_AND_SAME(2), NEXT_AND_SAME(3), SAME_ONLY(4), ALMOST(5);\n\n        private final int priority;\n\n        MatchClassification(int priority) {\n            this.priority = priority;\n        }\n\n        int getPriority() {\n            return priority;\n        }\n    }\n\n    private boolean isCorrespondingElement(TextElement textElement, CsmElement csmElement, Node node) {\n        if (csmElement instanceof CsmToken) {\n            CsmToken csmToken = (CsmToken) csmElement;\n            if (textElement instanceof TokenTextElement) {\n                TokenTextElement tokenTextElement = (TokenTextElement) textElement;\n                return tokenTextElement.getTokenKind() == csmToken.getTokenType() && tokenTextElement.getText().equals(csmToken.getContent(node));\n            }\n        } else if (csmElement instanceof CsmChild) {\n            CsmChild csmChild = (CsmChild) csmElement;\n            if (textElement instanceof ChildTextElement) {\n                ChildTextElement childTextElement = (ChildTextElement) textElement;\n                return childTextElement.getChild() == csmChild.getChild();\n            }\n        } else if (csmElement instanceof CsmIndent) {\n        \tCsmIndent csmIndent = (CsmIndent) csmElement;\n            if (textElement instanceof TokenTextElement) {\n            \tTokenTextElement tokenTextElement = (TokenTextElement) textElement;\n                return tokenTextElement.isSpaceOrTab();\n            }\n        } else {\n            throw new UnsupportedOperationException();\n        }\n        return false;\n    }\n\n    private boolean isAlmostCorrespondingElement(TextElement textElement, CsmElement csmElement, Node node) {\n        if (isCorrespondingElement(textElement, csmElement, node)) {\n            return false;\n        }\n        return textElement.isWhiteSpace() && csmElement instanceof CsmToken && ((CsmToken) csmElement).isWhiteSpace();\n    }\n\n    private int adjustIndentation(List<TextElement> indentation, NodeText nodeText, int nodeTextIndex, boolean followedByUnindent) {\n        List<TextElement> indentationAdj = processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1));\n        if (nodeTextIndex < nodeText.numberOfElements() && nodeText.getTextElement(nodeTextIndex).isToken(RBRACE)) {\n            indentationAdj = indentationAdj.subList(0, indentationAdj.size() - Math.min(STANDARD_INDENTATION_SIZE, indentationAdj.size()));\n        } else if (followedByUnindent) {\n            indentationAdj = indentationAdj.subList(0, Math.max(0, indentationAdj.size() - STANDARD_INDENTATION_SIZE));\n        }\n        for (TextElement e : indentationAdj) {\n            if ((nodeTextIndex < nodeText.numberOfElements()) && nodeText.getTextElement(nodeTextIndex).isSpaceOrTab()) {\n                nodeTextIndex++;\n            } else {\n                nodeText.getElements().add(nodeTextIndex++, e);\n            }\n        }\n        if (nodeTextIndex < 0) {\n            throw new IllegalStateException();\n        }\n        return nodeTextIndex;\n    }\n\n    /*\n     * Returns true if the current <code>Added</code> element is preceded by a <code>Removed</code> element.\n     */\n    private boolean isAReplacement(int diffIndex) {\n        return (diffIndex > 0) && diffElements.get(diffIndex).isAdded() && diffElements.get(diffIndex - 1).isRemoved();\n    }\n\n    /*\n     * Returns true if the current <code>Removed</code> element is followed by a <code>Added</code> element.\n     */\n    private boolean isReplaced(int diffIndex) {\n        return (diffIndex < diffElements.size() - 1) && diffElements.get(diffIndex + 1).isAdded() && diffElements.get(diffIndex).isRemoved();\n    }\n\n    @Override\n    public String toString() {\n        return \"Difference{\" + diffElements + '}';\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract And Move Method", "description": "Extract And Move Method\tpublic of() : LeastUpperBoundLogic extracted from public leastUpperBound(types Set<ResolvedType>) : ResolvedType in class com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper & moved to class com.github.javaparser.symbolsolver.resolution.typeinference.LeastUpperBoundLogic", "diffLocations": [{"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java", "startLine": 203, "endLine": 211, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java", "startLine": 203, "endLine": 211, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java", "startLine": 25, "endLine": 27, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * See JLS 4.10.4. Least Upper Bound.\n     * The least upper bound, or \"lub\", of a set of reference types is a shared supertype that is more specific than\n     * any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound).\n     */\n    public static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n    \tLeastUpperBoundLogic logic = new LeastUpperBoundLogic();\n    \treturn logic.lub(types);\n    }", "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java", "isPureRefactoring": true, "commitId": "2b503c32229deae7d432f59dab710839ecf76c4c", "packageNameBefore": "com.github.javaparser.symbolsolver.resolution.typeinference", "classNameBefore": "com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper", "methodNameBefore": "com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper#leastUpperBound", "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.resolution.typeinference.LeastUpperBoundLogic#lub\n methodBody: public ResolvedType lub(Set<ResolvedType> types) {\nif(types.isEmpty()){throw new IllegalArgumentException();\n}Set<ResolvedType> resolvedTypes=types.stream().filter(type -> !(type instanceof NullType)).collect(Collectors.toSet());\nif(resolvedTypes.size() == 1){return resolvedTypes.stream().findFirst().get();\n}List<Set<ResolvedType>> supertypes=supertypes(resolvedTypes);\nList<Set<ResolvedType>> erasedSupertypes=erased(supertypes);\nList<ResolvedType> erasedCandidates=intersection(erasedSupertypes);\nList<ResolvedType> minimalErasedCandidates=minimalCandidates(erasedCandidates);\nif(minimalErasedCandidates.isEmpty()){return null;\n}Multimap<ResolvedType,ResolvedType> relevantParameterizations=relevantParameterizations(minimalErasedCandidates,supertypes);\nResolvedType erasedBest=best(minimalErasedCandidates);\nCollection<ResolvedType> erasedTypeParameterizations=relevantParameterizations.get(erasedBest);\nif(erasedTypeParameterizations != null && !erasedTypeParameterizations.contains(erasedBest)){Set<ResolvedType> searchedTypes=new HashSet<>(resolvedTypes);\nif(!lubCache.contains(searchedTypes)){lubCache.add(searchedTypes);\nreturn leastContainingParameterization(new ArrayList<>(erasedTypeParameterizations));\n}}return erasedBest;\n}", "classSignatureBefore": "public class TypeHelper ", "methodNameBeforeSet": ["com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper#leastUpperBound"], "classNameBeforeSet": ["com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper"], "classSignatureBeforeSet": ["public class TypeHelper "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.resolution.typeinference;\n\nimport java.util.*;\n\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.TypeSolver;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.resolution.model.SymbolReference;\nimport com.github.javaparser.resolution.model.typesystem.LazyType;\nimport com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.resolution.types.*;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.utils.Pair;\n\n/**\n * The term \"type\" is used loosely in this chapter to include type-like syntax that contains inference variables.\n *\n * Assertions that involve inference\n * variables are assertions about every proper type that can be produced by replacing each inference variable with\n * a proper type.\n *\n * @author Federico Tomassetti\n */\npublic class TypeHelper {\n\n    /**\n     * The term proper type excludes such \"types\" that mention inference variables.\n     */\n    public static boolean isProperType(ResolvedType type) {\n        if (type instanceof InferenceVariable) {\n            return false;\n        }\n        if (type instanceof ResolvedReferenceType) {\n            ResolvedReferenceType referenceType = (ResolvedReferenceType) type;\n            return referenceType.typeParametersValues().stream().allMatch(it -> isProperType(it));\n        }\n        if (type instanceof LazyType) {\n            return type.asReferenceType().typeParametersValues().stream().allMatch(it -> isProperType(it));\n        }\n        if (type instanceof ResolvedWildcard) {\n            ResolvedWildcard wildcard = (ResolvedWildcard)type;\n            if (wildcard.isBounded()) {\n                return isProperType(wildcard.getBoundedType());\n            } else {\n                return true;\n            }\n        }\n        if (type.isPrimitive()) {\n            return true;\n        }\n        if (type.isTypeVariable()) {\n            // FIXME I am not sure...\n            return false;\n        }\n        if (type.isArray()) {\n            return isProperType(type.asArrayType().getComponentType());\n        }\n        throw new UnsupportedOperationException(type.toString());\n    }\n\n    /**\n     * see https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\n     * @param expression\n     * @param t\n     * @return\n     */\n    public static boolean isCompatibleInAStrictInvocationContext(Expression expression, ResolvedType t) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * see https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\n     * @param expression\n     * @param t\n     * @return\n     */\n    public static boolean isCompatibleInALooseInvocationContext(TypeSolver typeSolver, Expression expression, ResolvedType t) {\n        //throw new UnsupportedOperationException(\"Unable to determine if \" + expression + \" is compatible in a loose invocation context with type \" + t);\n        return isCompatibleInALooseInvocationContext(JavaParserFacade.get(typeSolver).getType(expression), t);\n    }\n\n    /**\n     * see https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\n     * @param s\n     * @param t\n     * @return\n     */\n    public static boolean isCompatibleInALooseInvocationContext(ResolvedType s, ResolvedType t) {\n        // Loose invocation contexts allow a more permissive set of conversions, because they are only used for a\n        // particular invocation if no applicable declaration can be found using strict invocation contexts. Loose\n        // invocation contexts allow the use of one of the following:\n        //\n        // - an identity conversion (\u00a75.1.1)\n\n        if (s.equals(t)) {\n            return true;\n        }\n\n        // - a widening primitive conversion (\u00a75.1.2)\n\n        if (s.isPrimitive() && t.isPrimitive() && areCompatibleThroughWideningPrimitiveConversion(s, t)) {\n            return true;\n        }\n\n        // - a widening reference conversion (\u00a75.1.5)\n\n        if (s.isReferenceType() && t.isReferenceType() && areCompatibleThroughWideningReferenceConversion(s, t)) {\n            return true;\n        }\n\n        // - a boxing conversion (\u00a75.1.7) optionally followed by widening reference conversion\n\n        if (s.isPrimitive() && t.isReferenceType() &&\n                areCompatibleThroughWideningReferenceConversion(toBoxedType(s.asPrimitive()), t)) {\n            return true;\n        }\n\n        // - an unboxing conversion (\u00a75.1.8) optionally followed by a widening primitive conversion\n\n        if (s.isReferenceType() && s.asReferenceType().isUnboxable() && t.isPrimitive() &&\n                areCompatibleThroughWideningPrimitiveConversion(s.asReferenceType().toUnboxedType().get(), t)) {\n            return true;\n        }\n\n        // If, after the conversions listed for an invocation context have been applied, the resulting type is a raw\n        // type (\u00a74.8), an unchecked conversion (\u00a75.1.9) may then be applied.\n        //\n        // A value of the null type (the null reference is the only such value) may be assigned to any reference type\n        if (s.isNull() && t.isReferenceType()) {\n            return true;\n        }\n\n        //throw new UnsupportedOperationException(\"isCompatibleInALooseInvocationContext unable to decide on s=\" + s + \", t=\" + t);\n        // TODO FIXME\n        return t.isAssignableBy(s);\n    }\n\n    public static ResolvedType toBoxedType(ResolvedPrimitiveType primitiveType) {\n        throw new UnsupportedOperationException();\n    }\n\n    // get the resolved boxed type of the specified primitive type\n    public static ResolvedType toBoxedType(ResolvedPrimitiveType primitiveType, TypeSolver typeSolver ) {\n        SymbolReference<ResolvedReferenceTypeDeclaration> typeDeclaration =  typeSolver.tryToSolveType(primitiveType.getBoxTypeQName());\n        return new ReferenceTypeImpl(typeDeclaration.getCorrespondingDeclaration());\n    }\n\n    public static boolean areCompatibleThroughWideningReferenceConversion(ResolvedType s, ResolvedType t) {\n        Optional<ResolvedPrimitiveType> correspondingPrimitiveTypeForS = Arrays.stream(ResolvedPrimitiveType.values()).filter(pt -> pt.getBoxTypeQName().equals(s.asReferenceType().getQualifiedName())).findFirst();\n        if (!correspondingPrimitiveTypeForS.isPresent()) {\n            return false;\n        }\n        throw new UnsupportedOperationException(\"areCompatibleThroughWideningReferenceConversion s=\"+s+\", t=\" + t);\n    }\n\n    public static boolean areCompatibleThroughWideningPrimitiveConversion(ResolvedType s, ResolvedType t) {\n        if (s.isPrimitive() && t.isPrimitive()) {\n            return s.isAssignableBy(t);\n        } else {\n            return false;\n        }\n    }\n\n    public static Set<InferenceVariable> usedInferenceVariables(ResolvedType type) {\n        if (type.isInferenceVariable()) {\n            return new HashSet<>(Arrays.asList((InferenceVariable) type));\n        }\n        if (type.isReferenceType()) {\n            Set<InferenceVariable> res = new HashSet<>();\n            for (ResolvedType tp : type.asReferenceType().typeParametersValues()) {\n                res.addAll(usedInferenceVariables(tp));\n            }\n            return res;\n        }\n        throw new UnsupportedOperationException(type.toString());\n    }\n\n    /**\n     * See JLS 4.10.4. Least Upper Bound.\n     * The least upper bound, or \"lub\", of a set of reference types is a shared supertype that is more specific than\n     * any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound).\n     */\n    public static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n    \tLeastUpperBoundLogic logic = new LeastUpperBoundLogic();\n    \treturn logic.lub(types);\n    }\n\n    /**\n     * See JLS 15.27.3. Type of a Lambda Expression\n     * @return\n     */\n    public static Pair<ResolvedType, Boolean> groundTargetTypeOfLambda(LambdaExpr lambdaExpr, ResolvedType T, TypeSolver typeSolver) {\n        // The ground target type is derived from T as follows:\n        //\n        boolean used18_5_3 = false;\n\n        boolean wildcardParameterized = T.asReferenceType().typeParametersValues().stream()\n                .anyMatch(tp -> tp.isWildcard());\n        if (wildcardParameterized) {\n            // - If T is a wildcard-parameterized functional interface type and the lambda expression is explicitly typed,\n            //   then the ground target type is inferred as described in \u00a718.5.3.\n\n            if (ExpressionHelper.isExplicitlyTyped(lambdaExpr)) {\n                used18_5_3 = true;\n                throw new UnsupportedOperationException();\n            }\n\n            // - If T is a wildcard-parameterized functional interface type and the lambda expression is implicitly typed,\n            //   then the ground target type is the non-wildcard parameterization (\u00a79.9) of T.\n\n            else {\n                return new Pair<>(nonWildcardParameterizationOf(T.asReferenceType(), typeSolver), used18_5_3);\n            }\n        }\n\n        // - Otherwise, the ground target type is T.\n        return new Pair<>(T, used18_5_3);\n    }\n\n    /**\n     * See JLS 9.9\n     */\n    private static ResolvedReferenceType nonWildcardParameterizationOf(ResolvedReferenceType originalType, TypeSolver typeSolver) {\n        ResolvedReferenceTypeDeclaration originalTypeDeclaration = originalType.getTypeDeclaration().orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"));\n\n        List<ResolvedType> TIs = new LinkedList<>();\n        List<ResolvedType> AIs = originalType.typeParametersValues();\n        List<ResolvedTypeParameterDeclaration> TPs = originalTypeDeclaration.getTypeParameters();\n\n        // Let P1...Pn be the type parameters of I with corresponding bounds B1...Bn. For all i (1 \u2264 i \u2264 n),\n        // Ti is derived according to the form of Ai:\n\n        ResolvedReferenceType object = new ReferenceTypeImpl(typeSolver.getSolvedJavaLangObject());\n\n        for (int i=0;i<AIs.size();i++) {\n            ResolvedType Ai = AIs.get(i);\n            ResolvedType Ti = null;\n\n            // - If Ai is a type, then Ti = Ai.\n\n            if (!Ai.isWildcard()) {\n                Ti = Ai;\n            }\n\n            // - If Ai is a wildcard, and the corresponding type parameter's bound, Bi, mentions one of P1...Pn, then\n            //   Ti is undefined and there is no function type.\n\n            if (Ti == null && Ai.isWildcard() && Ai.asWildcard().mention(originalTypeDeclaration.getTypeParameters())) {\n                throw new IllegalArgumentException();\n            }\n\n            // - Otherwise:\n\n            if (Ti == null) {\n\n                ResolvedType Bi = TPs.get(i).hasLowerBound() ? TPs.get(i).getLowerBound() : object;\n\n                //   - If Ai is an unbound wildcard ?, then Ti = Bi.\n\n                if (Ai.isWildcard() && !Ai.asWildcard().isBounded()) {\n                    Ti = Bi;\n                }\n\n                //   - If Ai is a upper-bounded wildcard ? extends Ui, then Ti = glb(Ui, Bi) (\u00a75.1.10).\n\n                else if (Ai.isWildcard() && Ai.asWildcard().isUpperBounded()) {\n                    ResolvedType Ui = Ai.asWildcard().getBoundedType();\n                    Ti = glb(new HashSet<>(Arrays.asList(Ui, Bi)));\n                }\n\n                //   - If Ai is a lower-bounded wildcard ? super Li, then Ti = Li.\n\n                else if (Ai.isWildcard() && Ai.asWildcard().isLowerBounded()) {\n                    Ti = Ai.asWildcard().getBoundedType();\n                }\n\n                else {\n                    throw new RuntimeException(\"This should not happen\");\n                }\n            }\n\n            TIs.add(Ti);\n        }\n\n        return new ReferenceTypeImpl(originalTypeDeclaration, TIs);\n    }\n\n    public static MethodType getFunctionType(ResolvedType type) {\n        Optional<MethodUsage> mu = FunctionalInterfaceLogic.getFunctionalMethod(type);\n        if (mu.isPresent()) {\n            return MethodType.fromMethodUsage(mu.get());\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    /**\n     * See JLS 5.1.10. Capture Conversion.\n     */\n    public static ResolvedType glb(Set<ResolvedType> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException();\n        }\n        if (types.size() == 1) {\n            return types.iterator().next();\n        }\n        return new ResolvedIntersectionType(types);\n    }\n}\n", "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.resolution.typeinference;\n\nimport java.util.*;\n\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.TypeSolver;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.resolution.model.SymbolReference;\nimport com.github.javaparser.resolution.model.typesystem.LazyType;\nimport com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.resolution.types.*;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.utils.Pair;\n\n/**\n * The term \"type\" is used loosely in this chapter to include type-like syntax that contains inference variables.\n *\n * Assertions that involve inference\n * variables are assertions about every proper type that can be produced by replacing each inference variable with\n * a proper type.\n *\n * @author Federico Tomassetti\n */\npublic class TypeHelper {\n\n    /**\n     * The term proper type excludes such \"types\" that mention inference variables.\n     */\n    public static boolean isProperType(ResolvedType type) {\n        if (type instanceof InferenceVariable) {\n            return false;\n        }\n        if (type instanceof ResolvedReferenceType) {\n            ResolvedReferenceType referenceType = (ResolvedReferenceType) type;\n            return referenceType.typeParametersValues().stream().allMatch(it -> isProperType(it));\n        }\n        if (type instanceof LazyType) {\n            return type.asReferenceType().typeParametersValues().stream().allMatch(it -> isProperType(it));\n        }\n        if (type instanceof ResolvedWildcard) {\n            ResolvedWildcard wildcard = (ResolvedWildcard)type;\n            if (wildcard.isBounded()) {\n                return isProperType(wildcard.getBoundedType());\n            } else {\n                return true;\n            }\n        }\n        if (type.isPrimitive()) {\n            return true;\n        }\n        if (type.isTypeVariable()) {\n            // FIXME I am not sure...\n            return false;\n        }\n        if (type.isArray()) {\n            return isProperType(type.asArrayType().getComponentType());\n        }\n        throw new UnsupportedOperationException(type.toString());\n    }\n\n    /**\n     * see https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\n     * @param expression\n     * @param t\n     * @return\n     */\n    public static boolean isCompatibleInAStrictInvocationContext(Expression expression, ResolvedType t) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * see https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\n     * @param expression\n     * @param t\n     * @return\n     */\n    public static boolean isCompatibleInALooseInvocationContext(TypeSolver typeSolver, Expression expression, ResolvedType t) {\n        //throw new UnsupportedOperationException(\"Unable to determine if \" + expression + \" is compatible in a loose invocation context with type \" + t);\n        return isCompatibleInALooseInvocationContext(JavaParserFacade.get(typeSolver).getType(expression), t);\n    }\n\n    /**\n     * see https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\n     * @param s\n     * @param t\n     * @return\n     */\n    public static boolean isCompatibleInALooseInvocationContext(ResolvedType s, ResolvedType t) {\n        // Loose invocation contexts allow a more permissive set of conversions, because they are only used for a\n        // particular invocation if no applicable declaration can be found using strict invocation contexts. Loose\n        // invocation contexts allow the use of one of the following:\n        //\n        // - an identity conversion (\u00a75.1.1)\n\n        if (s.equals(t)) {\n            return true;\n        }\n\n        // - a widening primitive conversion (\u00a75.1.2)\n\n        if (s.isPrimitive() && t.isPrimitive() && areCompatibleThroughWideningPrimitiveConversion(s, t)) {\n            return true;\n        }\n\n        // - a widening reference conversion (\u00a75.1.5)\n\n        if (s.isReferenceType() && t.isReferenceType() && areCompatibleThroughWideningReferenceConversion(s, t)) {\n            return true;\n        }\n\n        // - a boxing conversion (\u00a75.1.7) optionally followed by widening reference conversion\n\n        if (s.isPrimitive() && t.isReferenceType() &&\n                areCompatibleThroughWideningReferenceConversion(toBoxedType(s.asPrimitive()), t)) {\n            return true;\n        }\n\n        // - an unboxing conversion (\u00a75.1.8) optionally followed by a widening primitive conversion\n\n        if (s.isReferenceType() && s.asReferenceType().isUnboxable() && t.isPrimitive() &&\n                areCompatibleThroughWideningPrimitiveConversion(s.asReferenceType().toUnboxedType().get(), t)) {\n            return true;\n        }\n\n        // If, after the conversions listed for an invocation context have been applied, the resulting type is a raw\n        // type (\u00a74.8), an unchecked conversion (\u00a75.1.9) may then be applied.\n        //\n        // A value of the null type (the null reference is the only such value) may be assigned to any reference type\n        if (s.isNull() && t.isReferenceType()) {\n            return true;\n        }\n\n        //throw new UnsupportedOperationException(\"isCompatibleInALooseInvocationContext unable to decide on s=\" + s + \", t=\" + t);\n        // TODO FIXME\n        return t.isAssignableBy(s);\n    }\n\n    public static ResolvedType toBoxedType(ResolvedPrimitiveType primitiveType) {\n        throw new UnsupportedOperationException();\n    }\n\n    // get the resolved boxed type of the specified primitive type\n    public static ResolvedType toBoxedType(ResolvedPrimitiveType primitiveType, TypeSolver typeSolver ) {\n        SymbolReference<ResolvedReferenceTypeDeclaration> typeDeclaration =  typeSolver.tryToSolveType(primitiveType.getBoxTypeQName());\n        return new ReferenceTypeImpl(typeDeclaration.getCorrespondingDeclaration());\n    }\n\n    public static boolean areCompatibleThroughWideningReferenceConversion(ResolvedType s, ResolvedType t) {\n        Optional<ResolvedPrimitiveType> correspondingPrimitiveTypeForS = Arrays.stream(ResolvedPrimitiveType.values()).filter(pt -> pt.getBoxTypeQName().equals(s.asReferenceType().getQualifiedName())).findFirst();\n        if (!correspondingPrimitiveTypeForS.isPresent()) {\n            return false;\n        }\n        throw new UnsupportedOperationException(\"areCompatibleThroughWideningReferenceConversion s=\"+s+\", t=\" + t);\n    }\n\n    public static boolean areCompatibleThroughWideningPrimitiveConversion(ResolvedType s, ResolvedType t) {\n        if (s.isPrimitive() && t.isPrimitive()) {\n            return s.isAssignableBy(t);\n        } else {\n            return false;\n        }\n    }\n\n    public static Set<InferenceVariable> usedInferenceVariables(ResolvedType type) {\n        if (type.isInferenceVariable()) {\n            return new HashSet<>(Arrays.asList((InferenceVariable) type));\n        }\n        if (type.isReferenceType()) {\n            Set<InferenceVariable> res = new HashSet<>();\n            for (ResolvedType tp : type.asReferenceType().typeParametersValues()) {\n                res.addAll(usedInferenceVariables(tp));\n            }\n            return res;\n        }\n        throw new UnsupportedOperationException(type.toString());\n    }\n\n    /**\n     * See JLS 4.10.4. Least Upper Bound.\n     * The least upper bound, or \"lub\", of a set of reference types is a shared supertype that is more specific than\n     * any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound).\n     */\n    public static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n    \tLeastUpperBoundLogic logic = LeastUpperBoundLogic.of();\n    \treturn logic.lub(types);\n    }\n\n    /**\n     * See JLS 15.27.3. Type of a Lambda Expression\n     * @return\n     */\n    public static Pair<ResolvedType, Boolean> groundTargetTypeOfLambda(LambdaExpr lambdaExpr, ResolvedType T, TypeSolver typeSolver) {\n        // The ground target type is derived from T as follows:\n        //\n        boolean used18_5_3 = false;\n\n        boolean wildcardParameterized = T.asReferenceType().typeParametersValues().stream()\n                .anyMatch(tp -> tp.isWildcard());\n        if (wildcardParameterized) {\n            // - If T is a wildcard-parameterized functional interface type and the lambda expression is explicitly typed,\n            //   then the ground target type is inferred as described in \u00a718.5.3.\n\n            if (ExpressionHelper.isExplicitlyTyped(lambdaExpr)) {\n                used18_5_3 = true;\n                throw new UnsupportedOperationException();\n            }\n\n            // - If T is a wildcard-parameterized functional interface type and the lambda expression is implicitly typed,\n            //   then the ground target type is the non-wildcard parameterization (\u00a79.9) of T.\n\n            else {\n                return new Pair<>(nonWildcardParameterizationOf(T.asReferenceType(), typeSolver), used18_5_3);\n            }\n        }\n\n        // - Otherwise, the ground target type is T.\n        return new Pair<>(T, used18_5_3);\n    }\n\n    /**\n     * See JLS 9.9\n     */\n    private static ResolvedReferenceType nonWildcardParameterizationOf(ResolvedReferenceType originalType, TypeSolver typeSolver) {\n        ResolvedReferenceTypeDeclaration originalTypeDeclaration = originalType.getTypeDeclaration().orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"));\n\n        List<ResolvedType> TIs = new LinkedList<>();\n        List<ResolvedType> AIs = originalType.typeParametersValues();\n        List<ResolvedTypeParameterDeclaration> TPs = originalTypeDeclaration.getTypeParameters();\n\n        // Let P1...Pn be the type parameters of I with corresponding bounds B1...Bn. For all i (1 \u2264 i \u2264 n),\n        // Ti is derived according to the form of Ai:\n\n        ResolvedReferenceType object = new ReferenceTypeImpl(typeSolver.getSolvedJavaLangObject());\n\n        for (int i=0;i<AIs.size();i++) {\n            ResolvedType Ai = AIs.get(i);\n            ResolvedType Ti = null;\n\n            // - If Ai is a type, then Ti = Ai.\n\n            if (!Ai.isWildcard()) {\n                Ti = Ai;\n            }\n\n            // - If Ai is a wildcard, and the corresponding type parameter's bound, Bi, mentions one of P1...Pn, then\n            //   Ti is undefined and there is no function type.\n\n            if (Ti == null && Ai.isWildcard() && Ai.asWildcard().mention(originalTypeDeclaration.getTypeParameters())) {\n                throw new IllegalArgumentException();\n            }\n\n            // - Otherwise:\n\n            if (Ti == null) {\n\n                ResolvedType Bi = TPs.get(i).hasLowerBound() ? TPs.get(i).getLowerBound() : object;\n\n                //   - If Ai is an unbound wildcard ?, then Ti = Bi.\n\n                if (Ai.isWildcard() && !Ai.asWildcard().isBounded()) {\n                    Ti = Bi;\n                }\n\n                //   - If Ai is a upper-bounded wildcard ? extends Ui, then Ti = glb(Ui, Bi) (\u00a75.1.10).\n\n                else if (Ai.isWildcard() && Ai.asWildcard().isUpperBounded()) {\n                    ResolvedType Ui = Ai.asWildcard().getBoundedType();\n                    Ti = glb(new HashSet<>(Arrays.asList(Ui, Bi)));\n                }\n\n                //   - If Ai is a lower-bounded wildcard ? super Li, then Ti = Li.\n\n                else if (Ai.isWildcard() && Ai.asWildcard().isLowerBounded()) {\n                    Ti = Ai.asWildcard().getBoundedType();\n                }\n\n                else {\n                    throw new RuntimeException(\"This should not happen\");\n                }\n            }\n\n            TIs.add(Ti);\n        }\n\n        return new ReferenceTypeImpl(originalTypeDeclaration, TIs);\n    }\n\n    public static MethodType getFunctionType(ResolvedType type) {\n        Optional<MethodUsage> mu = FunctionalInterfaceLogic.getFunctionalMethod(type);\n        if (mu.isPresent()) {\n            return MethodType.fromMethodUsage(mu.get());\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    /**\n     * See JLS 5.1.10. Capture Conversion.\n     */\n    public static ResolvedType glb(Set<ResolvedType> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException();\n        }\n        if (types.size() == 1) {\n            return types.iterator().next();\n        }\n        return new ResolvedIntersectionType(types);\n    }\n}\n", "diffSourceCodeSet": ["import com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.LambdaExpr;"], "invokedMethodSet": ["methodSignature: com.github.javaparser.symbolsolver.resolution.typeinference.LeastUpperBoundLogic#lub\n methodBody: public ResolvedType lub(Set<ResolvedType> types) {\nif(types.isEmpty()){throw new IllegalArgumentException();\n}Set<ResolvedType> resolvedTypes=types.stream().filter(type -> !(type instanceof NullType)).collect(Collectors.toSet());\nif(resolvedTypes.size() == 1){return resolvedTypes.stream().findFirst().get();\n}List<Set<ResolvedType>> supertypes=supertypes(resolvedTypes);\nList<Set<ResolvedType>> erasedSupertypes=erased(supertypes);\nList<ResolvedType> erasedCandidates=intersection(erasedSupertypes);\nList<ResolvedType> minimalErasedCandidates=minimalCandidates(erasedCandidates);\nif(minimalErasedCandidates.isEmpty()){return null;\n}Multimap<ResolvedType,ResolvedType> relevantParameterizations=relevantParameterizations(minimalErasedCandidates,supertypes);\nResolvedType erasedBest=best(minimalErasedCandidates);\nCollection<ResolvedType> erasedTypeParameterizations=relevantParameterizations.get(erasedBest);\nif(erasedTypeParameterizations != null && !erasedTypeParameterizations.contains(erasedBest)){Set<ResolvedType> searchedTypes=new HashSet<>(resolvedTypes);\nif(!lubCache.contains(searchedTypes)){lubCache.add(searchedTypes);\nreturn leastContainingParameterization(new ArrayList<>(erasedTypeParameterizations));\n}}return erasedBest;\n}"], "sourceCodeAfterRefactoring": "/**\n     * See JLS 4.10.4. Least Upper Bound.\n     * The least upper bound, or \"lub\", of a set of reference types is a shared supertype that is more specific than\n     * any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound).\n     */\n    public static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n    \tLeastUpperBoundLogic logic = LeastUpperBoundLogic.of();\n    \treturn logic.lub(types);\n    }\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.LambdaExpr;", "diffSourceCode": "    25: \n    26: import com.github.javaparser.ast.expr.Expression;\n    27: import com.github.javaparser.ast.expr.LambdaExpr;\n   203:     /**\n   204:      * See JLS 4.10.4. Least Upper Bound.\n   205:      * The least upper bound, or \"lub\", of a set of reference types is a shared supertype that is more specific than\n   206:      * any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound).\n   207:      */\n   208:     public static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n-  209:     \tLeastUpperBoundLogic logic = new LeastUpperBoundLogic();\n+  209:     \tLeastUpperBoundLogic logic = LeastUpperBoundLogic.of();\n   210:     \treturn logic.lub(types);\n   211:     }\n", "uniqueId": "2b503c32229deae7d432f59dab710839ecf76c4c_203_211_25_27_203_211", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 8}, "LINE": {"missed": 0, "covered": 2}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To refactor the provided code, we will extract the `leastUpperBound` method from the `TypeHelper` class and move it to the `LeastUpperBoundLogic` class, which seems to be the appropriate place for this logic based on its name. \n\n### Step 1: Analyze the Code\nThe `leastUpperBound` method is a utility function that calculates the least upper bound of a set of reference types. This functionality logically belongs to the `LeastUpperBoundLogic` class, which is already instantiated in the `TypeHelper` class.\n\n### Step 2: Extract and Move Method\nWe will extract the `leastUpperBound` method and move it to the `LeastUpperBoundLogic` class.\n\n### Step 3: Update the Refactored Method\nAfter moving the method, we will update the `TypeHelper` class to call the new method in `LeastUpperBoundLogic`.\n\n### Target File Path\nThe target file path for the extracted method will be:\n```\njavaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/LeastUpperBoundLogic.java\n```\n\n### Extracted Method Code\nHere is the extracted method code that will be moved to `LeastUpperBoundLogic`:\n```java\npublic static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n    return lub(types);\n}\n```\n\n### Refactored Method Code\nHere is the refactored method code in the `TypeHelper` class:\n```java\npublic static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n    return LeastUpperBoundLogic.leastUpperBound(types);\n}\n```\n\n### Final Output\nHere is the complete output as per the requested format:\n\n##########################\njavaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/LeastUpperBoundLogic.java\n##########################\npublic static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n    return lub(types);\n}\n##########################\npublic static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n    return LeastUpperBoundLogic.leastUpperBound(types);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * See JLS 4.10.4. Least Upper Bound.\n     * The least upper bound, or \"lub\", of a set of reference types is a shared supertype that is more specific than\n     * any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound).\n     */\n    public static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n    \tLeastUpperBoundLogic logic = new LeastUpperBoundLogic();\n    \treturn logic.lub(types);\n    }\n\nClass content:\n/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.resolution.typeinference;\n\nimport java.util.*;\n\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.TypeSolver;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.resolution.model.SymbolReference;\nimport com.github.javaparser.resolution.model.typesystem.LazyType;\nimport com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.resolution.types.*;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.utils.Pair;\n\n/**\n * The term \"type\" is used loosely in this chapter to include type-like syntax that contains inference variables.\n *\n * Assertions that involve inference\n * variables are assertions about every proper type that can be produced by replacing each inference variable with\n * a proper type.\n *\n * @author Federico Tomassetti\n */\npublic class TypeHelper {\n\n    /**\n     * The term proper type excludes such \"types\" that mention inference variables.\n     */\n    public static boolean isProperType(ResolvedType type) {\n        if (type instanceof InferenceVariable) {\n            return false;\n        }\n        if (type instanceof ResolvedReferenceType) {\n            ResolvedReferenceType referenceType = (ResolvedReferenceType) type;\n            return referenceType.typeParametersValues().stream().allMatch(it -> isProperType(it));\n        }\n        if (type instanceof LazyType) {\n            return type.asReferenceType().typeParametersValues().stream().allMatch(it -> isProperType(it));\n        }\n        if (type instanceof ResolvedWildcard) {\n            ResolvedWildcard wildcard = (ResolvedWildcard)type;\n            if (wildcard.isBounded()) {\n                return isProperType(wildcard.getBoundedType());\n            } else {\n                return true;\n            }\n        }\n        if (type.isPrimitive()) {\n            return true;\n        }\n        if (type.isTypeVariable()) {\n            // FIXME I am not sure...\n            return false;\n        }\n        if (type.isArray()) {\n            return isProperType(type.asArrayType().getComponentType());\n        }\n        throw new UnsupportedOperationException(type.toString());\n    }\n\n    /**\n     * see https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\n     * @param expression\n     * @param t\n     * @return\n     */\n    public static boolean isCompatibleInAStrictInvocationContext(Expression expression, ResolvedType t) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * see https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\n     * @param expression\n     * @param t\n     * @return\n     */\n    public static boolean isCompatibleInALooseInvocationContext(TypeSolver typeSolver, Expression expression, ResolvedType t) {\n        //throw new UnsupportedOperationException(\"Unable to determine if \" + expression + \" is compatible in a loose invocation context with type \" + t);\n        return isCompatibleInALooseInvocationContext(JavaParserFacade.get(typeSolver).getType(expression), t);\n    }\n\n    /**\n     * see https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\n     * @param s\n     * @param t\n     * @return\n     */\n    public static boolean isCompatibleInALooseInvocationContext(ResolvedType s, ResolvedType t) {\n        // Loose invocation contexts allow a more permissive set of conversions, because they are only used for a\n        // particular invocation if no applicable declaration can be found using strict invocation contexts. Loose\n        // invocation contexts allow the use of one of the following:\n        //\n        // - an identity conversion (\u00a75.1.1)\n\n        if (s.equals(t)) {\n            return true;\n        }\n\n        // - a widening primitive conversion (\u00a75.1.2)\n\n        if (s.isPrimitive() && t.isPrimitive() && areCompatibleThroughWideningPrimitiveConversion(s, t)) {\n            return true;\n        }\n\n        // - a widening reference conversion (\u00a75.1.5)\n\n        if (s.isReferenceType() && t.isReferenceType() && areCompatibleThroughWideningReferenceConversion(s, t)) {\n            return true;\n        }\n\n        // - a boxing conversion (\u00a75.1.7) optionally followed by widening reference conversion\n\n        if (s.isPrimitive() && t.isReferenceType() &&\n                areCompatibleThroughWideningReferenceConversion(toBoxedType(s.asPrimitive()), t)) {\n            return true;\n        }\n\n        // - an unboxing conversion (\u00a75.1.8) optionally followed by a widening primitive conversion\n\n        if (s.isReferenceType() && s.asReferenceType().isUnboxable() && t.isPrimitive() &&\n                areCompatibleThroughWideningPrimitiveConversion(s.asReferenceType().toUnboxedType().get(), t)) {\n            return true;\n        }\n\n        // If, after the conversions listed for an invocation context have been applied, the resulting type is a raw\n        // type (\u00a74.8), an unchecked conversion (\u00a75.1.9) may then be applied.\n        //\n        // A value of the null type (the null reference is the only such value) may be assigned to any reference type\n        if (s.isNull() && t.isReferenceType()) {\n            return true;\n        }\n\n        //throw new UnsupportedOperationException(\"isCompatibleInALooseInvocationContext unable to decide on s=\" + s + \", t=\" + t);\n        // TODO FIXME\n        return t.isAssignableBy(s);\n    }\n\n    public static ResolvedType toBoxedType(ResolvedPrimitiveType primitiveType) {\n        throw new UnsupportedOperationException();\n    }\n\n    // get the resolved boxed type of the specified primitive type\n    public static ResolvedType toBoxedType(ResolvedPrimitiveType primitiveType, TypeSolver typeSolver ) {\n        SymbolReference<ResolvedReferenceTypeDeclaration> typeDeclaration =  typeSolver.tryToSolveType(primitiveType.getBoxTypeQName());\n        return new ReferenceTypeImpl(typeDeclaration.getCorrespondingDeclaration());\n    }\n\n    public static boolean areCompatibleThroughWideningReferenceConversion(ResolvedType s, ResolvedType t) {\n        Optional<ResolvedPrimitiveType> correspondingPrimitiveTypeForS = Arrays.stream(ResolvedPrimitiveType.values()).filter(pt -> pt.getBoxTypeQName().equals(s.asReferenceType().getQualifiedName())).findFirst();\n        if (!correspondingPrimitiveTypeForS.isPresent()) {\n            return false;\n        }\n        throw new UnsupportedOperationException(\"areCompatibleThroughWideningReferenceConversion s=\"+s+\", t=\" + t);\n    }\n\n    public static boolean areCompatibleThroughWideningPrimitiveConversion(ResolvedType s, ResolvedType t) {\n        if (s.isPrimitive() && t.isPrimitive()) {\n            return s.isAssignableBy(t);\n        } else {\n            return false;\n        }\n    }\n\n    public static Set<InferenceVariable> usedInferenceVariables(ResolvedType type) {\n        if (type.isInferenceVariable()) {\n            return new HashSet<>(Arrays.asList((InferenceVariable) type));\n        }\n        if (type.isReferenceType()) {\n            Set<InferenceVariable> res = new HashSet<>();\n            for (ResolvedType tp : type.asReferenceType().typeParametersValues()) {\n                res.addAll(usedInferenceVariables(tp));\n            }\n            return res;\n        }\n        throw new UnsupportedOperationException(type.toString());\n    }\n\n    /**\n     * See JLS 4.10.4. Least Upper Bound.\n     * The least upper bound, or \"lub\", of a set of reference types is a shared supertype that is more specific than\n     * any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound).\n     */\n    public static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n    \tLeastUpperBoundLogic logic = new LeastUpperBoundLogic();\n    \treturn logic.lub(types);\n    }\n\n    /**\n     * See JLS 15.27.3. Type of a Lambda Expression\n     * @return\n     */\n    public static Pair<ResolvedType, Boolean> groundTargetTypeOfLambda(LambdaExpr lambdaExpr, ResolvedType T, TypeSolver typeSolver) {\n        // The ground target type is derived from T as follows:\n        //\n        boolean used18_5_3 = false;\n\n        boolean wildcardParameterized = T.asReferenceType().typeParametersValues().stream()\n                .anyMatch(tp -> tp.isWildcard());\n        if (wildcardParameterized) {\n            // - If T is a wildcard-parameterized functional interface type and the lambda expression is explicitly typed,\n            //   then the ground target type is inferred as described in \u00a718.5.3.\n\n            if (ExpressionHelper.isExplicitlyTyped(lambdaExpr)) {\n                used18_5_3 = true;\n                throw new UnsupportedOperationException();\n            }\n\n            // - If T is a wildcard-parameterized functional interface type and the lambda expression is implicitly typed,\n            //   then the ground target type is the non-wildcard parameterization (\u00a79.9) of T.\n\n            else {\n                return new Pair<>(nonWildcardParameterizationOf(T.asReferenceType(), typeSolver), used18_5_3);\n            }\n        }\n\n        // - Otherwise, the ground target type is T.\n        return new Pair<>(T, used18_5_3);\n    }\n\n    /**\n     * See JLS 9.9\n     */\n    private static ResolvedReferenceType nonWildcardParameterizationOf(ResolvedReferenceType originalType, TypeSolver typeSolver) {\n        ResolvedReferenceTypeDeclaration originalTypeDeclaration = originalType.getTypeDeclaration().orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"));\n\n        List<ResolvedType> TIs = new LinkedList<>();\n        List<ResolvedType> AIs = originalType.typeParametersValues();\n        List<ResolvedTypeParameterDeclaration> TPs = originalTypeDeclaration.getTypeParameters();\n\n        // Let P1...Pn be the type parameters of I with corresponding bounds B1...Bn. For all i (1 \u2264 i \u2264 n),\n        // Ti is derived according to the form of Ai:\n\n        ResolvedReferenceType object = new ReferenceTypeImpl(typeSolver.getSolvedJavaLangObject());\n\n        for (int i=0;i<AIs.size();i++) {\n            ResolvedType Ai = AIs.get(i);\n            ResolvedType Ti = null;\n\n            // - If Ai is a type, then Ti = Ai.\n\n            if (!Ai.isWildcard()) {\n                Ti = Ai;\n            }\n\n            // - If Ai is a wildcard, and the corresponding type parameter's bound, Bi, mentions one of P1...Pn, then\n            //   Ti is undefined and there is no function type.\n\n            if (Ti == null && Ai.isWildcard() && Ai.asWildcard().mention(originalTypeDeclaration.getTypeParameters())) {\n                throw new IllegalArgumentException();\n            }\n\n            // - Otherwise:\n\n            if (Ti == null) {\n\n                ResolvedType Bi = TPs.get(i).hasLowerBound() ? TPs.get(i).getLowerBound() : object;\n\n                //   - If Ai is an unbound wildcard ?, then Ti = Bi.\n\n                if (Ai.isWildcard() && !Ai.asWildcard().isBounded()) {\n                    Ti = Bi;\n                }\n\n                //   - If Ai is a upper-bounded wildcard ? extends Ui, then Ti = glb(Ui, Bi) (\u00a75.1.10).\n\n                else if (Ai.isWildcard() && Ai.asWildcard().isUpperBounded()) {\n                    ResolvedType Ui = Ai.asWildcard().getBoundedType();\n                    Ti = glb(new HashSet<>(Arrays.asList(Ui, Bi)));\n                }\n\n                //   - If Ai is a lower-bounded wildcard ? super Li, then Ti = Li.\n\n                else if (Ai.isWildcard() && Ai.asWildcard().isLowerBounded()) {\n                    Ti = Ai.asWildcard().getBoundedType();\n                }\n\n                else {\n                    throw new RuntimeException(\"This should not happen\");\n                }\n            }\n\n            TIs.add(Ti);\n        }\n\n        return new ReferenceTypeImpl(originalTypeDeclaration, TIs);\n    }\n\n    public static MethodType getFunctionType(ResolvedType type) {\n        Optional<MethodUsage> mu = FunctionalInterfaceLogic.getFunctionalMethod(type);\n        if (mu.isPresent()) {\n            return MethodType.fromMethodUsage(mu.get());\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    /**\n     * See JLS 5.1.10. Capture Conversion.\n     */\n    public static ResolvedType glb(Set<ResolvedType> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException();\n        }\n        if (types.size() == 1) {\n            return types.iterator().next();\n        }\n        return new ResolvedIntersectionType(types);\n    }\n}\n\nRefactoring Operation:\nExtract And Move Method\n\nProject Structure:\n['javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/JavaSymbolSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/SourceFileInfoExtractor.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/cache/Cache.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/cache/GuavaCache.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/cache/InMemoryCache.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/cache/NoCache.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/core/resolution/MethodUsageResolutionCapability.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/core/resolution/SymbolResolutionCapability.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/core/resolution/TypeVariableResolutionCapability.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/declarations/common/MethodDeclarationCommonLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparser/package-info.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/DefaultVisitorAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/FailureHandler.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFactory.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractJavaParserContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractMethodLikeDeclarationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AnnotationDeclarationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AnonymousClassDeclarationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ArrayAccessExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BinaryExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/CatchClauseContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ClassOrInterfaceDeclarationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ClassOrInterfaceDeclarationExtendsContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/CompilationUnitContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ConstructorContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ContextHelper.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/EnclosedExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/EnumDeclarationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/FieldAccessContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ForEachStatementContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ForStatementContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/IfStatementContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/InstanceOfExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/JavaParserTypeDeclarationAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodReferenceExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ObjectCreationContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/StatementContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/SwitchEntryContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/TryWithResourceContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/UnaryExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/VariableDeclarationExprContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/VariableDeclaratorContext.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/AstResolutionUtils.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/DefaultConstructorDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnnotationDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnnotationMemberDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnonymousClassDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserConstructorDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumConstantDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserFieldDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserMethodDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserParameterDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserPatternDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserSymbolDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeParameter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeVariableDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserVariableDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/AbstractSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/FieldSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/NoSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/ParameterSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/PatternSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/VariableSymbolDeclarator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/package-info.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationMemberDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistConstructorDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumConstantDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistFactory.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistFieldDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistInterfaceDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodLikeDeclarationAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistParameterDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeParameter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistUtils.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/package-info.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/AbstractClassDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/AbstractTypeDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/ObjectProvider.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationMemberDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassAdapter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionConstructorDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionEnumConstantDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionEnumDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionFactory.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionFieldDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionInterfaceDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionMethodDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionMethodResolutionLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionParameterDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionPatternDeclaration.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionTypeParameter.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/comparators/ClassComparator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/comparators/MethodComparator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/comparators/ParameterComparator.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/package-info.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/SymbolSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameCategory.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameRole.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/promotion/BooleanConditionalExprHandler.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/promotion/ConditionalExprResolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/promotion/NumericConditionalExprHandler.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/promotion/ReferenceConditionalExprHandler.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/Bound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ConstraintFormula.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ConstraintFormulaSet.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ControlFlowLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ExpressionHelper.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/InferenceVariable.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/InferenceVariableSubstitution.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/Instantiation.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/InstantiationSet.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/LeastUpperBoundLogic.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/MethodType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ProperLowerBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ProperUpperBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/Substitution.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInference.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInferenceCache.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/CapturesBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/FalseBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/SameAsBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/SubtypeOfBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/ThrowsBound.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/ExpressionCompatibleWithType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/LambdaThrowsCompatibleWithType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/MethodReferenceThrowsCompatibleWithType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeCompatibleWithType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeContainedByType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeSameAsType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeSubtypeOfType.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/AarTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/ClassLoaderTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/CombinedTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/JarTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/JavaParserTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/MemoryTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/ReflectionTypeSolver.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/TypeSolverBuilder.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/utils/FileUtils.java', 'javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/utils/SymbolSolverCollectionStrategy.java']\n\nFile Path Before Refactoring:\njavaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, and you need move the extracted method to another existing java file, output the target file path, extracted method code, refactored method code after refactoring.\nThe extracted method code should be the public static method.\nThe refactored method code should use the moved class to call the extracted method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\ntarget_file_path\n##########################\nextracted_method_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n\n\n"}]