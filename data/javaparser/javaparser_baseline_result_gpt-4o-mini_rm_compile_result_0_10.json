[{"type": "Extract Method", "description": "Extract Method\tprivate assertCompilationFails(s String) : void extracted from package record_cannotExtend() : void in class com.github.javaparser.ast.body.RecordDeclarationTest", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 95, "endLine": 104, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 96, "endLine": 103, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 307, "endLine": 311, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_cannotExtend", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#record_cannotExtend"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": ["private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\nprivate void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }", "diffSourceCode": "-   95:     /**\n-   96:      * https://openjdk.java.net/jeps/395#Restrictions-on-record\n-   97:      */\n-   98:     @Test\n-   99:     void record_cannotExtend() {\n-  100:         String s = \"record Point(int x, int y) extends OtherThing { }\";\n-  101:         assertThrows(AssertionFailedError.class, () -> {\n-  102:             CompilationUnit cu = parseCompilationUnit(s);\n-  103:         });\n-  104:     }\n-  307:         // test parameters (none)\n-  308:     }\n-  309: }\n+   95: \n+   96:     /**\n+   97:      * https://openjdk.java.net/jeps/395#Restrictions-on-record\n+   98:      */\n+   99:     @Test\n+  100:     void record_cannotExtend() {\n+  101:         String s = \"record Point(int x, int y) extends OtherThing { }\";\n+  102:         assertCompilationFails(s);\n+  103:     }\n+  104: \n+  307:     private void assertCompilationFails(String s) {\n+  308:         assertThrows(AssertionFailedError.class, () -> {\n+  309:             CompilationUnit cu = parseCompilationUnit(s);\n+  310:         });\n+  311:     }\n", "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_95_104_307_311_96_103", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `record_cannotExtend` test method, we can extract the logic of parsing the compilation unit into a separate method. This will help reduce duplication and make the test easier to read.\n\nHere's the refactored method code:\n\n```java\n##########################\nprivate void assertRecordCannotExtend(String recordDeclaration) {\n    assertThrows(AssertionFailedError.class, () -> {\n        CompilationUnit cu = parseCompilationUnit(recordDeclaration);\n    });\n}\n\n@Test\nvoid record_cannotExtend() {\n    String s = \"record Point(int x, int y) extends OtherThing { }\";\n    assertRecordCannotExtend(s);\n}\n##########################\n```\n\nIn this refactoring:\n- We created a new private method `assertRecordCannotExtend` that encapsulates the logic of asserting that a record cannot extend another class.\n- The original test method `record_cannotExtend` now simply calls this new method, passing the record declaration string as an argument. This makes the test more concise and focused on its purpose.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package basicGrammar() : void in class com.github.javaparser.ast.body.RecordDeclarationTest", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 50, "endLine": 78, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 49, "endLine": 78, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 313, "endLine": 316, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammar", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammar"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": ["private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }", "diffSourceCode": "-   49: \n-   50:     @Test\n-   51:     void basicGrammar() {\n-   52:         /* https://openjdk.java.net/jeps/395#Description */\n-   53:         String s = \"record Point(int x, int y) { }\";\n-   54:         CompilationUnit cu = parseCompilationUnit(s);\n-   55: \n-   56:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-   57:         assertEquals(1, recordDeclarations.size());\n-   58: \n-   59:         RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n+   49:     /**\n+   50:      * https://openjdk.java.net/jeps/395#Description\n+   51:      */\n+   52:     @Test\n+   53:     void basicGrammar() {\n+   54:         String s = \"record Point(int x, int y) { }\";\n+   55:         CompilationUnit cu = parseCompilationUnit(s);\n+   56:         assertOneRecordDeclaration(cu);\n+   57: \n+   58:         RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n+   59: \n    60:         assertTrue(recordDeclaration.isRecordDeclaration());\n    61:         assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n    62:         assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n    63:         assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n    64:         assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n    65:         assertTrue(recordDeclaration.isRecordDeclaration());\n    66: \n    67:         NodeList<Parameter> parameters = recordDeclaration.getParameters();\n    68:         assertEquals(2, parameters.size());\n    69: \n    70:         Parameter parameter0 = parameters.get(0);\n    71:         assertEquals(\"x\", parameter0.getNameAsString());\n    72:         assertEquals(\"int\", parameter0.getTypeAsString());\n    73:         Parameter parameter1 = parameters.get(1);\n    74:         assertEquals(\"y\", parameter1.getNameAsString());\n    75:         assertEquals(\"int\", parameter1.getTypeAsString());\n    76: \n    77:         assertEquals(0, recordDeclaration.getMembers().size());\n    78:     }\n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n", "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_50_78_313_316_49_78", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `basicGrammar` test method, we can extract the logic that verifies the properties of the `RecordDeclaration` into a separate method. This will help to reduce the complexity of the test and make it easier to understand what is being tested.\n\nHere\u2019s the refactored code with the extracted method:\n\n```java\n@Test\nvoid basicGrammar() {\n    /* https://openjdk.java.net/jeps/395#Description */\n    String s = \"record Point(int x, int y) { }\";\n    CompilationUnit cu = parseCompilationUnit(s);\n\n    List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n    assertEquals(1, recordDeclarations.size());\n\n    verifyRecordDeclaration(recordDeclarations.get(0), \"Point\", 2);\n}\n\nprivate void verifyRecordDeclaration(RecordDeclaration recordDeclaration, String expectedName, int expectedParameterCount) {\n    assertTrue(recordDeclaration.isRecordDeclaration());\n    assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n    assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n    assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n    assertEquals(expectedName, recordDeclaration.getFullyQualifiedName().get());\n    \n    NodeList<Parameter> parameters = recordDeclaration.getParameters();\n    assertEquals(expectedParameterCount, parameters.size());\n\n    for (int i = 0; i < expectedParameterCount; i++) {\n        Parameter parameter = parameters.get(i);\n        assertEquals(\"x\", parameter.getNameAsString());\n        assertEquals(\"int\", parameter.getTypeAsString());\n    }\n\n    assertEquals(0, recordDeclaration.getMembers().size());\n}\n```\n\nThe extracted method `verifyRecordDeclaration` encapsulates the logic for verifying the properties of a `RecordDeclaration`, making the `basicGrammar` method cleaner and more focused on the high-level test logic.\n\nHere\u2019s the output in the requested format:\n\n##########################\n```java\nprivate void verifyRecordDeclaration(RecordDeclaration recordDeclaration, String expectedName, int expectedParameterCount) {\n    assertTrue(recordDeclaration.isRecordDeclaration());\n    assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n    assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n    assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n    assertEquals(expectedName, recordDeclaration.getFullyQualifiedName().get());\n    \n    NodeList<Parameter> parameters = recordDeclaration.getParameters();\n    assertEquals(expectedParameterCount, parameters.size());\n\n    for (int i = 0; i < expectedParameterCount; i++) {\n        Parameter parameter = parameters.get(i);\n        assertEquals(\"x\", parameter.getNameAsString());\n        assertEquals(\"int\", parameter.getTypeAsString());\n    }\n\n    assertEquals(0, recordDeclaration.getMembers().size());\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package basicGrammarCompiles() : void in class com.github.javaparser.ast.body.RecordDeclarationTest", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 40, "endLine": 48, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 40, "endLine": 47, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 313, "endLine": 316, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammarCompiles", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammarCompiles"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": ["private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }", "diffSourceCode": "-   40:     @Test\n-   41:     void basicGrammarCompiles() {\n-   42:         /* https://openjdk.java.net/jeps/395#Description */\n-   43:         String s = \"record Point(int x, int y) { }\";\n-   44:         CompilationUnit cu = parseCompilationUnit(s);\n-   45: \n-   46:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-   47:         assertEquals(1, recordDeclarations.size());\n-   48:     }\n+   40:     /**\n+   41:      * https://openjdk.java.net/jeps/395#Description\n+   42:      */\n+   43:     @Test\n+   44:     void basicGrammarCompiles() {\n+   45:         String s = \"record Point(int x, int y) { }\";\n+   46:         assertOneRecordDeclaration(parseCompilationUnit(s));\n+   47:     }\n+   48: \n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n", "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_40_48_313_316_40_47", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `basicGrammarCompiles` test method, we can extract the logic that parses the compilation unit and checks for record declarations into a separate method. This will help reduce duplication and make the test methods more focused on their specific assertions.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\nprivate void assertSingleRecordDeclaration(String source) {\n    CompilationUnit cu = parseCompilationUnit(source);\n    List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n    assertEquals(1, recordDeclarations.size());\n}\n\n@Test\nvoid basicGrammarCompiles() {\n    /* https://openjdk.java.net/jeps/395#Description */\n    String s = \"record Point(int x, int y) { }\";\n    assertSingleRecordDeclaration(s);\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The logic for parsing the compilation unit and asserting the number of record declarations has been moved to a new method called `assertSingleRecordDeclaration`.\n2. **Simplified Test Method**: The `basicGrammarCompiles` method now simply calls this new method, making it clearer and more concise.\n3. **Reusability**: The new method can be reused in other test cases if needed, promoting DRY (Don't Repeat Yourself) principles. \n\nThis refactoring enhances the modularity and readability of the test class.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprotected createDefaultPrinter(configuration PrinterConfiguration) : Printer extracted from protected createDefaultPrinter() : Printer in class com.github.javaparser.ast.Node", "diffLocations": [{"filePath": "javaparser-core/src/main/java/com/github/javaparser/ast/Node.java", "startLine": 225, "endLine": 228, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core/src/main/java/com/github/javaparser/ast/Node.java", "startLine": 222, "endLine": 224, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core/src/main/java/com/github/javaparser/ast/Node.java", "startLine": 226, "endLine": 228, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "protected Printer createDefaultPrinter() {\n        PrinterConfiguration configuration = getDefaultPrinterConfiguration();\n        return new DefaultPrettyPrinter(configuration);\n    }", "filePathBefore": "javaparser-core/src/main/java/com/github/javaparser/ast/Node.java", "isPureRefactoring": true, "commitId": "9d8184e1a607dcfcd3733b8a40587459f2a583d1", "packageNameBefore": "com.github.javaparser.ast", "classNameBefore": "com.github.javaparser.ast.Node", "methodNameBefore": "com.github.javaparser.ast.Node#createDefaultPrinter", "invokedMethod": "methodSignature: com.github.javaparser.ast.Node#getDefaultPrinterConfiguration\n methodBody: protected  PrinterConfiguration getDefaultPrinterConfiguration() {\nreturn new DefaultPrinterConfiguration();\n}", "classSignatureBefore": "public abstract class Node implements Cloneable, HasParentNode<Node>, Visitable, NodeWithRange<Node>, NodeWithTokenRange<Node> ", "methodNameBeforeSet": ["com.github.javaparser.ast.Node#createDefaultPrinter"], "classNameBeforeSet": ["com.github.javaparser.ast.Node"], "classSignatureBeforeSet": ["public abstract class Node implements Cloneable, HasParentNode<Node>, Visitable, NodeWithRange<Node>, NodeWithTokenRange<Node> "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.ast;\n\nimport static com.github.javaparser.ast.Node.Parsedness.PARSED;\nimport static com.github.javaparser.ast.Node.TreeTraversal.PREORDER;\nimport static java.util.Collections.emptySet;\nimport static java.util.Collections.unmodifiableList;\nimport static java.util.Spliterator.DISTINCT;\nimport static java.util.Spliterator.NONNULL;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.Spliterators;\nimport java.util.Stack;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport com.github.javaparser.HasParentNode;\nimport com.github.javaparser.Position;\nimport com.github.javaparser.Range;\nimport com.github.javaparser.TokenRange;\nimport com.github.javaparser.ast.comments.BlockComment;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.comments.LineComment;\nimport com.github.javaparser.ast.nodeTypes.NodeWithRange;\nimport com.github.javaparser.ast.nodeTypes.NodeWithTokenRange;\nimport com.github.javaparser.ast.observer.AstObserver;\nimport com.github.javaparser.ast.observer.ObservableProperty;\nimport com.github.javaparser.ast.observer.PropagatingAstObserver;\nimport com.github.javaparser.ast.visitor.CloneVisitor;\nimport com.github.javaparser.ast.visitor.EqualsVisitor;\nimport com.github.javaparser.ast.visitor.HashCodeVisitor;\nimport com.github.javaparser.ast.visitor.Visitable;\nimport com.github.javaparser.metamodel.InternalProperty;\nimport com.github.javaparser.metamodel.JavaParserMetaModel;\nimport com.github.javaparser.metamodel.NodeMetaModel;\nimport com.github.javaparser.metamodel.OptionalProperty;\nimport com.github.javaparser.metamodel.PropertyMetaModel;\nimport com.github.javaparser.printer.DefaultPrettyPrinter;\nimport com.github.javaparser.printer.Printer;\nimport com.github.javaparser.printer.configuration.PrinterConfiguration;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration.ConfigOption;\nimport com.github.javaparser.resolution.SymbolResolver;\nimport com.github.javaparser.utils.LineSeparator;\n\n/**\n * Base class for all nodes of the abstract syntax tree.\n * <h2>Construction</h2>\n * <p>The tree is built by instantiating the required nodes, then adding them to other nodes.\n * If it is the parser who is building the tree, it will use the largest constructor,\n * the one with \"range\" as the first parameter.\n * If you want to manually instantiate nodes, we suggest to...\n * <ul>\n * <li>use a convenience method, like \"addStatement(...)\", or if none are available...</li>\n * <li>use a convenient constructor, like ClassOrInterfaceType(String name), or if none are available...</li>\n * <li>use the default constructor.</li>\n * <li>Alternatively, use one of the JavaParser.parse(snippet) methods.</li>\n * </ul>\n * ... and use the various methods on the node to initialize it further, if needed.\n * <h2>Parent/child</h2>\n * <p>The parent node field is managed automatically and can be seen as read only.\n * Note that there is only one parent,\n * and trying to use the same node in two places will lead to unexpected behaviour.\n * It is advised to clone() a node before moving it around.\n * <h2>Comments</h2>\n * <p>Each Node can have one associated comment which describes it and\n * a number of \"orphan comments\" which it contains but are not specifically\n * associated to any child.\n * <h2>Positions</h2>\n * <p>When the parser creates nodes, it sets their source code position in the \"range\" field.\n * When you manually instantiate nodes, their range is not set.\n * The top left character is position 1, 1.\n * Note that since this is an <i>abstract</i> syntax tree,\n * it leaves out a lot of text from the original source file,\n * like where braces or comma's are exactly.\n * Therefore there is no position information on everything in the original source file.\n * <h2>Observers</h2>\n * <p>It is possible to add observers to the the tree.\n * Any change in the tree is sent as an event to any observers watching.\n * <h2>Visitors</h2>\n * <p>The most comfortable way of working with an abstract syntax tree is using visitors.\n * You can use one of the visitors in the visitor package, or extend one of them.\n * A visitor can be \"run\" by calling accept on a node:\n * <pre>node.accept(visitor, argument);</pre>\n * where argument is an object of your choice (often simply null.)\n *\n * @author Julio Vilmar Gesser\n */\npublic abstract class Node implements Cloneable, HasParentNode<Node>, Visitable, NodeWithRange<Node>, NodeWithTokenRange<Node> {\n\n    /**\n     * Different registration mode for observers on nodes.\n     */\n    public enum ObserverRegistrationMode {\n\n        /**\n         * Notify exclusively for changes happening on this node alone.\n         */\n        JUST_THIS_NODE,\n        /**\n         * Notify for changes happening on this node and all its descendants existing at the moment in\n         * which the observer was registered. Nodes attached later will not be observed.\n         */\n        THIS_NODE_AND_EXISTING_DESCENDANTS,\n        /**\n         * Notify for changes happening on this node and all its descendants. The descendants existing at the moment in\n         * which the observer was registered will be observed immediately. As new nodes are attached later they are\n         * automatically registered to be observed.\n         */\n        SELF_PROPAGATING\n    }\n\n    public enum Parsedness {\n\n        PARSED, UNPARSABLE\n    }\n\n    /**\n     * This can be used to sort nodes on position.\n     */\n    public static Comparator<NodeWithRange<?>> NODE_BY_BEGIN_POSITION = (a, b) -> {\n        if (a.hasRange() && b.hasRange()) {\n            return a.getRange().get().begin.compareTo(b.getRange().get().begin);\n        }\n        if (a.hasRange() || b.hasRange()) {\n            if (a.hasRange()) {\n                return 1;\n            }\n            return -1;\n        }\n        return 0;\n    };\n\n    protected static final PrinterConfiguration prettyPrinterNoCommentsConfiguration = new DefaultPrinterConfiguration().removeOption(ConfigOption.PRINT_COMMENTS);\n    \n    @InternalProperty\n    private Range range;\n\n    @InternalProperty\n    private TokenRange tokenRange;\n\n    @InternalProperty\n    private Node parentNode;\n\n    @InternalProperty\n    private List<Node> childNodes = new LinkedList<>();\n\n    @InternalProperty\n    private List<Comment> orphanComments = new LinkedList<>();\n\n    @InternalProperty\n    private IdentityHashMap<DataKey<?>, Object> data = null;\n\n    @OptionalProperty\n    private Comment comment;\n\n    @InternalProperty\n    private Set<AstObserver> observers = new HashSet<>();\n\n    @InternalProperty\n    private Parsedness parsed = PARSED;\n\n    protected Node(TokenRange tokenRange) {\n        setTokenRange(tokenRange);\n    }\n\n    /**\n     * Called in every constructor for node specific code.\n     * It can't be written in the constructor itself because it will\n     * be overwritten during code generation.\n     */\n    protected void customInitialization() {\n    }\n    \n    /*\n     * If there is a printer defined in CompilationUnit, returns it\n     * else create a new DefaultPrettyPrinter with default parameters\n     */\n    protected Printer getPrinter() {\n        Optional<CompilationUnit> cu = findCompilationUnit();\n        if (!cu.isPresent()) {\n            return createDefaultPrinter();\n        }\n        return cu.get().getPrinter();\n    }\n    \n    /*\n     * Return the printer initialized with the specified configuration\n     */\n    protected Printer getPrinter(PrinterConfiguration configuration) {\n        return getPrinter().setConfiguration(configuration);\n    }\n    \n    protected Printer createDefaultPrinter() {\n        PrinterConfiguration configuration = getDefaultPrinterConfiguration();\n        return new DefaultPrettyPrinter(configuration);\n    }\n    \n    /*\n     * returns a default printer configuration\n     */\n    protected  PrinterConfiguration getDefaultPrinterConfiguration() {\n        return new DefaultPrinterConfiguration();\n    }\n\n    /**\n     * This is a comment associated with this node.\n     *\n     * @return comment property\n     */\n    @Generated(\"com.github.javaparser.generator.core.node.PropertyGenerator\")\n    public Optional<Comment> getComment() {\n        return Optional.ofNullable(comment);\n    }\n\n    /**\n     * @return the range of characters in the source code that this node covers.\n     */\n    public Optional<Range> getRange() {\n        return Optional.ofNullable(range);\n    }\n\n    /**\n     * @return the range of tokens that this node covers.\n     */\n    public Optional<TokenRange> getTokenRange() {\n        return Optional.ofNullable(tokenRange);\n    }\n\n    public Node setTokenRange(TokenRange tokenRange) {\n        this.tokenRange = tokenRange;\n        if (tokenRange == null || !(tokenRange.getBegin().hasRange() && tokenRange.getEnd().hasRange())) {\n            range = null;\n        } else {\n            range = new Range(tokenRange.getBegin().getRange().get().begin, tokenRange.getEnd().getRange().get().end);\n        }\n        return this;\n    }\n\n    /**\n     * @param range the range of characters in the source code that this node covers. null can be used to indicate that\n     *              no range information is known, or that it is not of interest.\n     */\n    public Node setRange(Range range) {\n        if (this.range == range) {\n            return this;\n        }\n        notifyPropertyChange(ObservableProperty.RANGE, this.range, range);\n        this.range = range;\n        return this;\n    }\n\n    /**\n     * Use this to store additional information to this node.\n     *\n     * @param comment to be set\n     */\n    public Node setComment(final Comment comment) {\n        if (this.comment == comment) {\n            return this;\n        }\n        notifyPropertyChange(ObservableProperty.COMMENT, this.comment, comment);\n        if (this.comment != null) {\n            this.comment.setCommentedNode(null);\n        }\n        this.comment = comment;\n        if (comment != null) {\n            this.comment.setCommentedNode(this);\n        }\n        return this;\n    }\n\n    /**\n     * Use this to store additional information to this node.\n     *\n     * @param comment to be set\n     */\n    public final Node setLineComment(String comment) {\n        return setComment(new LineComment(comment));\n    }\n\n    /**\n     * Use this to store additional information to this node.\n     *\n     * @param comment to be set\n     */\n    public final Node setBlockComment(String comment) {\n        return setComment(new BlockComment(comment));\n    }\n\n    /**\n     * @return pretty printed source code for this node and its children.\n     */\n    @Override\n    public final String toString() {\n        if (containsData(LINE_SEPARATOR_KEY)) {\n            LineSeparator lineSeparator = getLineEndingStyleOrDefault(LineSeparator.SYSTEM);\n            PrinterConfiguration config = getDefaultPrinterConfiguration();\n            config.addOption(ConfigOption.END_OF_LINE_CHARACTER.value(lineSeparator.asRawString()));\n            return getPrinter(config).print(this);\n        }\n        return getPrinter().print(this);\n    }\n\n    /**\n     * @return pretty printed source code for this node and its children.\n     * Formatting can be configured with parameter PrinterConfiguration.\n     */\n    public final String toString(PrinterConfiguration configuration) {\n        return getPrinter(configuration).print(this);\n    }\n\n    @Override\n    public final int hashCode() {\n        return HashCodeVisitor.hashCode(this);\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == null || !(obj instanceof Node)) {\n            return false;\n        }\n        return EqualsVisitor.equals(this, (Node) obj);\n    }\n\n    @Override\n    public Optional<Node> getParentNode() {\n        return Optional.ofNullable(parentNode);\n    }\n\n    /**\n     * Contains all nodes that have this node set as their parent.\n     * You can add and remove nodes from this list by adding or removing nodes from the fields of this node.\n     *\n     * @return all nodes that have this node as their parent.\n     */\n    public List<Node> getChildNodes() {\n        return unmodifiableList(childNodes);\n    }\n\n    public void addOrphanComment(Comment comment) {\n        orphanComments.add(comment);\n        comment.setParentNode(this);\n    }\n\n    public boolean removeOrphanComment(Comment comment) {\n        boolean removed = orphanComments.remove(comment);\n        if (removed) {\n            notifyPropertyChange(ObservableProperty.COMMENT, comment, null);\n            comment.setParentNode(null);\n        }\n        return removed;\n    }\n\n    /**\n     * This is a list of Comment which are inside the node and are not associated\n     * with any meaningful AST Node.\n     * <p>\n     * For example, comments at the end of methods (immediately before the parenthesis)\n     * or at the end of CompilationUnit are orphan comments.\n     * <p>\n     * When more than one comment preceeds a statement, the one immediately preceding it\n     * it is associated with the statements, while the others are orphans.\n     * <p>\n     * Changes to this list are not persisted.\n     *\n     * @return all comments that cannot be attributed to a concept\n     */\n    public List<Comment> getOrphanComments() {\n        return new LinkedList<>(orphanComments);\n    }\n\n    /**\n     * This is the list of Comment which are contained in the Node either because\n     * they are properly associated to one of its children or because they are floating\n     * around inside the Node\n     *\n     * @return all Comments within the node as a list\n     */\n    public List<Comment> getAllContainedComments() {\n        List<Comment> comments = new LinkedList<>();\n        comments.addAll(getOrphanComments());\n        for (Node child : getChildNodes()) {\n            child.getComment().ifPresent(comments::add);\n            comments.addAll(child.getAllContainedComments());\n        }\n        return comments;\n    }\n\n    /**\n     * Assign a new parent to this node, removing it\n     * from the list of children of the previous parent, if any.\n     *\n     * @param newParentNode node to be set as parent\n     */\n    @Override\n    public Node setParentNode(Node newParentNode) {\n        if (newParentNode == parentNode) {\n            return this;\n        }\n        observers.forEach(o -> o.parentChange(this, parentNode, newParentNode));\n        // remove from old parent, if any\n        if (parentNode != null) {\n            final List<Node> parentChildNodes = parentNode.childNodes;\n            for (int i = 0; i < parentChildNodes.size(); i++) {\n                if (parentChildNodes.get(i) == this) {\n                    parentChildNodes.remove(i);\n                }\n            }\n        }\n        parentNode = newParentNode;\n        // add to new parent, if any\n        if (parentNode != null) {\n            parentNode.childNodes.add(this);\n        }\n        return this;\n    }\n\n    protected void setAsParentNodeOf(Node childNode) {\n        if (childNode != null) {\n            childNode.setParentNode(getParentNodeForChildren());\n        }\n    }\n\n    /**\n     * @deprecated Use {@link Position#ABSOLUTE_BEGIN_LINE}\n     */\n    @Deprecated\n    public static final int ABSOLUTE_BEGIN_LINE = Position.ABSOLUTE_BEGIN_LINE;\n\n    /**\n     * @deprecated Use {@link Position#ABSOLUTE_END_LINE}\n     */\n    @Deprecated\n    public static final int ABSOLUTE_END_LINE = Position.ABSOLUTE_END_LINE;\n\n    public void tryAddImportToParentCompilationUnit(Class<?> clazz) {\n        findAncestor(CompilationUnit.class).ifPresent(p -> p.addImport(clazz));\n    }\n\n    /**\n     * Recursively finds all nodes of a certain type.\n     *\n     * @param clazz the type of node to find.\n     * @deprecated use {@link Node#findAll(Class)} but be aware that findAll also considers the initial node.\n     */\n    @Deprecated\n    public <N extends Node> List<N> getChildNodesByType(Class<N> clazz) {\n        List<N> nodes = new ArrayList<>();\n        for (Node child : getChildNodes()) {\n            if (clazz.isInstance(child)) {\n                nodes.add(clazz.cast(child));\n            }\n            nodes.addAll(child.getChildNodesByType(clazz));\n        }\n        return nodes;\n    }\n\n    /**\n     * @deprecated use {@link Node#findAll(Class)} but be aware that findAll also considers the initial node.\n     */\n    @Deprecated\n    public <N extends Node> List<N> getNodesByType(Class<N> clazz) {\n        return getChildNodesByType(clazz);\n    }\n\n    /**\n     * Gets data for this node using the given key.\n     *\n     * @param <M> The type of the data.\n     * @param key The key for the data\n     * @return The data.\n     * @throws IllegalStateException if the key was not set in this node.\n     * @see Node#containsData(DataKey)\n     * @see DataKey\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <M> M getData(final DataKey<M> key) {\n        if (data == null) {\n            throw new IllegalStateException(\"No data of this type found. Use containsData to check for this first.\");\n        }\n        M value = (M) data.get(key);\n        if (value == null) {\n            throw new IllegalStateException(\"No data of this type found. Use containsData to check for this first.\");\n        }\n        return value;\n    }\n\n    /**\n     * This method was added to support the clone method.\n     *\n     * @return all known data keys.\n     */\n    public Set<DataKey<?>> getDataKeys() {\n        if (data == null) {\n            return emptySet();\n        }\n        return data.keySet();\n    }\n\n    /**\n     * Sets data for this node using the given key.\n     * For information on creating DataKey, see {@link DataKey}.\n     *\n     * @param <M>    The type of data\n     * @param key    The singleton key for the data\n     * @param object The data object\n     * @see DataKey\n     */\n    public <M> void setData(DataKey<M> key, M object) {\n        if (data == null) {\n            data = new IdentityHashMap<>();\n        }\n        data.put(key, object);\n    }\n\n    /**\n     * @return does this node have data for this key?\n     * @see DataKey\n     */\n    public boolean containsData(DataKey<?> key) {\n        if (data == null) {\n            return false;\n        }\n        return data.containsKey(key);\n    }\n\n    /**\n     * Remove data by key.\n     *\n     * @see DataKey\n     */\n    public void removeData(DataKey<?> key) {\n        if (data != null) {\n            data.remove(key);\n        }\n    }\n\n    /**\n     * Try to remove this node from the parent\n     *\n     * @return true if removed, false if it is a required property of the parent, or if the parent isn't set.\n     * @throws RuntimeException if it fails in an unexpected way\n     */\n    public boolean remove() {\n        if (parentNode == null) {\n            return false;\n        }\n        return parentNode.remove(this);\n    }\n\n    /**\n     * Try to replace this node in the parent with the supplied node.\n     *\n     * @return true if removed, or if the parent isn't set.\n     * @throws RuntimeException if it fails in an unexpected way\n     */\n    public boolean replace(Node node) {\n        if (parentNode == null) {\n            return false;\n        }\n        return parentNode.replace(this, node);\n    }\n\n    /**\n     * Forcibly removes this node from the AST.\n     * If it cannot be removed from the parent with remove(),\n     * it will try to remove its parent instead,\n     * until it finds a node that can be removed,\n     * or no parent can be found.\n     * <p>\n     * Since everything at CompilationUnit level is removable,\n     * this method will only (silently) fail when the node is in a detached AST fragment.\n     */\n    public void removeForced() {\n        if (!remove()) {\n            getParentNode().ifPresent(Node::remove);\n        }\n    }\n\n    @Override\n    public Node getParentNodeForChildren() {\n        return this;\n    }\n\n    protected void setAsParentNodeOf(NodeList<? extends Node> list) {\n        if (list != null) {\n            list.setParentNode(getParentNodeForChildren());\n        }\n    }\n\n    public <P> void notifyPropertyChange(ObservableProperty property, P oldValue, P newValue) {\n        this.observers.forEach(o -> o.propertyChange(this, property, oldValue, newValue));\n    }\n\n    @Override\n    public void unregister(AstObserver observer) {\n        this.observers.remove(observer);\n    }\n\n    @Override\n    public void register(AstObserver observer) {\n        this.observers.add(observer);\n    }\n\n    /**\n     * Register a new observer for the given node. Depending on the mode specified also descendants, existing\n     * and new, could be observed. For more details see <i>ObserverRegistrationMode</i>.\n     */\n    public void register(AstObserver observer, ObserverRegistrationMode mode) {\n        if (mode == null) {\n            throw new IllegalArgumentException(\"Mode should be not null\");\n        }\n        switch(mode) {\n            case JUST_THIS_NODE:\n                register(observer);\n                break;\n            case THIS_NODE_AND_EXISTING_DESCENDANTS:\n                registerForSubtree(observer);\n                break;\n            case SELF_PROPAGATING:\n                registerForSubtree(PropagatingAstObserver.transformInPropagatingObserver(observer));\n                break;\n            default:\n                throw new UnsupportedOperationException(\"This mode is not supported: \" + mode);\n        }\n    }\n\n    /**\n     * Register the observer for the current node and all the contained node and nodelists, recursively.\n     */\n    public void registerForSubtree(AstObserver observer) {\n        register(observer);\n        this.getChildNodes().forEach(c -> c.registerForSubtree(observer));\n        for (PropertyMetaModel property : getMetaModel().getAllPropertyMetaModels()) {\n            if (property.isNodeList()) {\n                NodeList<?> nodeList = (NodeList<?>) property.getValue(this);\n                if (nodeList != null)\n                    nodeList.register(observer);\n            }\n        }\n    }\n\n    @Override\n    public boolean isRegistered(AstObserver observer) {\n        return this.observers.contains(observer);\n    }\n\n    @Generated(\"com.github.javaparser.generator.core.node.RemoveMethodGenerator\")\n    public boolean remove(Node node) {\n        if (node == null)\n            return false;\n        if (comment != null) {\n            if (node == comment) {\n                removeComment();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Generated(\"com.github.javaparser.generator.core.node.RemoveMethodGenerator\")\n    public Node removeComment() {\n        return setComment((Comment) null);\n    }\n\n    @Override\n    @Generated(\"com.github.javaparser.generator.core.node.CloneGenerator\")\n    public Node clone() {\n        return (Node) accept(new CloneVisitor(), null);\n    }\n\n    /**\n     * @return get JavaParser specific node introspection information.\n     */\n    @Generated(\"com.github.javaparser.generator.core.node.GetMetaModelGenerator\")\n    public NodeMetaModel getMetaModel() {\n        return JavaParserMetaModel.nodeMetaModel;\n    }\n\n    /**\n     * @return whether this node was successfully parsed or not.\n     * If it was not, only the range and tokenRange fields will be valid.\n     */\n    public Parsedness getParsed() {\n        return parsed;\n    }\n\n    /**\n     * Used by the parser to flag unparsable nodes.\n     */\n    public Node setParsed(Parsedness parsed) {\n        this.parsed = parsed;\n        return this;\n    }\n\n    @Generated(\"com.github.javaparser.generator.core.node.ReplaceMethodGenerator\")\n    public boolean replace(Node node, Node replacementNode) {\n        if (node == null)\n            return false;\n        if (comment != null) {\n            if (node == comment) {\n                setComment((Comment) replacementNode);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Finds the root node of this AST by finding the topmost parent.\n     */\n    public Node findRootNode() {\n        Node n = this;\n        while (n.getParentNode().isPresent()) {\n            n = n.getParentNode().get();\n        }\n        return n;\n    }\n\n    /**\n     * @return the containing CompilationUnit, or empty if this node is not inside a compilation unit.\n     */\n    public Optional<CompilationUnit> findCompilationUnit() {\n        Node rootNode = findRootNode();\n        if (rootNode instanceof CompilationUnit) {\n            return Optional.of((CompilationUnit) rootNode);\n        }\n        return Optional.empty();\n    }\n\n    public LineSeparator getLineEndingStyleOrDefault(LineSeparator defaultLineSeparator) {\n        if (getLineEndingStyle().isStandardEol()) {\n            return getLineEndingStyle();\n        }\n        return defaultLineSeparator;\n    }\n\n    public LineSeparator getLineEndingStyle() {\n        Node current = this;\n        // First check this node\n        if (current.containsData(Node.LINE_SEPARATOR_KEY)) {\n            LineSeparator lineSeparator = current.getData(Node.LINE_SEPARATOR_KEY);\n            return lineSeparator;\n        }\n        // Then check parent/ancestor nodes\n        while (current.getParentNode().isPresent()) {\n            current = current.getParentNode().get();\n            if (current.containsData(Node.LINE_SEPARATOR_KEY)) {\n                return current.getData(Node.LINE_SEPARATOR_KEY);\n            }\n        }\n        // Default to the system line separator if it's not already set within the parsed node/code.\n        return LineSeparator.SYSTEM;\n    }\n\n    protected SymbolResolver getSymbolResolver() {\n        return findCompilationUnit().map(cu -> {\n            if (cu.containsData(SYMBOL_RESOLVER_KEY)) {\n                return cu.getData(SYMBOL_RESOLVER_KEY);\n            } else {\n                throw new IllegalStateException(\"Symbol resolution not configured: to configure consider setting a SymbolResolver in the ParserConfiguration\");\n            }\n        }).orElseThrow(() -> new IllegalStateException(\"The node is not inserted in a CompilationUnit\"));\n    }\n\n    // We need to expose it because we will need to use it to inject the SymbolSolver\n    public static final DataKey<SymbolResolver> SYMBOL_RESOLVER_KEY = new DataKey<SymbolResolver>() {\n    };\n\n    public static final DataKey<LineSeparator> LINE_SEPARATOR_KEY = new DataKey<LineSeparator>() {\n    };\n\n    public enum TreeTraversal {\n\n        PREORDER, BREADTHFIRST, POSTORDER, PARENTS, DIRECT_CHILDREN\n    }\n\n    private Iterator<Node> treeIterator(TreeTraversal traversal) {\n        switch(traversal) {\n            case BREADTHFIRST:\n                return new BreadthFirstIterator(this);\n            case POSTORDER:\n                return new PostOrderIterator(this);\n            case PREORDER:\n                return new PreOrderIterator(this);\n            case DIRECT_CHILDREN:\n                return new DirectChildrenIterator(this);\n            case PARENTS:\n                return new ParentsVisitor(this);\n            default:\n                throw new IllegalArgumentException(\"Unknown traversal choice.\");\n        }\n    }\n\n    private Iterable<Node> treeIterable(TreeTraversal traversal) {\n        return () -> treeIterator(traversal);\n    }\n\n    /**\n     * Make a stream of nodes using traversal algorithm \"traversal\".\n     */\n    public Stream<Node> stream(TreeTraversal traversal) {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(treeIterator(traversal), NONNULL | DISTINCT), false);\n    }\n\n    /**\n     * Make a stream of nodes using pre-order traversal.\n     */\n    public Stream<Node> stream() {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(treeIterator(PREORDER), NONNULL | DISTINCT), false);\n    }\n\n    /**\n     * Walks the AST, calling the consumer for every node, with traversal algorithm \"traversal\".\n     * <br>This is the most general walk method. All other walk and findAll methods are based on this.\n     */\n    public void walk(TreeTraversal traversal, Consumer<Node> consumer) {\n        // Could be implemented as a call to the above walk method, but this is a little more efficient.\n        for (Node node : treeIterable(traversal)) {\n            consumer.accept(node);\n        }\n    }\n\n    /**\n     * Walks the AST, calling the consumer for every node with pre-order traversal.\n     */\n    public void walk(Consumer<Node> consumer) {\n        walk(PREORDER, consumer);\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, calling the consumer for every node of type \"nodeType\".\n     */\n    public <T extends Node> void walk(Class<T> nodeType, Consumer<T> consumer) {\n        walk(TreeTraversal.PREORDER, node -> {\n            if (nodeType.isAssignableFrom(node.getClass())) {\n                consumer.accept(nodeType.cast(node));\n            }\n        });\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning all nodes of type \"nodeType\".\n     */\n    public <T extends Node> List<T> findAll(Class<T> nodeType) {\n        final List<T> found = new ArrayList<>();\n        walk(nodeType, found::add);\n        return found;\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning all nodes of type \"nodeType\" that match the predicate.\n     */\n    public <T extends Node> List<T> findAll(Class<T> nodeType, Predicate<T> predicate) {\n        final List<T> found = new ArrayList<>();\n        walk(nodeType, n -> {\n            if (predicate.test(n))\n                found.add(n);\n        });\n        return found;\n    }\n\n    /**\n     * Walks the AST, applying the function for every node, with traversal algorithm \"traversal\". If the function\n     * returns something else than null, the traversal is stopped and the function result is returned. <br>This is the\n     * most general findFirst method. All other findFirst methods are based on this.\n     */\n    public <T> Optional<T> findFirst(TreeTraversal traversal, Function<Node, Optional<T>> consumer) {\n        for (Node node : treeIterable(traversal)) {\n            final Optional<T> result = consumer.apply(node);\n            if (result.isPresent()) {\n                return result;\n            }\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning the first node of type \"nodeType\" or empty() if none is found.\n     */\n    public <N extends Node> Optional<N> findFirst(Class<N> nodeType) {\n        return findFirst(TreeTraversal.PREORDER, node -> {\n            if (nodeType.isAssignableFrom(node.getClass())) {\n                return Optional.of(nodeType.cast(node));\n            }\n            return Optional.empty();\n        });\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning the first node of type \"nodeType\" that matches \"predicate\" or empty() if none is\n     * found.\n     */\n    public <N extends Node> Optional<N> findFirst(Class<N> nodeType, Predicate<N> predicate) {\n        return findFirst(TreeTraversal.PREORDER, node -> {\n            if (nodeType.isAssignableFrom(node.getClass())) {\n                final N castNode = nodeType.cast(node);\n                if (predicate.test(castNode)) {\n                    return Optional.of(castNode);\n                }\n            }\n            return Optional.empty();\n        });\n    }\n\n    /**\n     * Determines whether this node is an ancestor of the given node. A node is <i>not</i> an ancestor of itself.\n     *\n     * @param descendant the node for which to determine whether it has this node as an ancestor.\n     * @return {@code true} if this node is an ancestor of the given node, and {@code false} otherwise.\n     * @see HasParentNode#isDescendantOf(Node)\n     */\n    public boolean isAncestorOf(Node descendant) {\n        return this != descendant && findFirst(Node.class, n -> n == descendant).isPresent();\n    }\n\n    /**\n     * Performs a breadth-first node traversal starting with a given node.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\">Breadth-first traversal</a>\n     */\n    public static class BreadthFirstIterator implements Iterator<Node> {\n\n        private final Queue<Node> queue = new LinkedList<>();\n\n        public BreadthFirstIterator(Node node) {\n            queue.add(node);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !queue.isEmpty();\n        }\n\n        @Override\n        public Node next() {\n            Node next = queue.remove();\n            queue.addAll(next.getChildNodes());\n            return next;\n        }\n    }\n\n    /**\n     * Performs a simple traversal over all nodes that have the passed node as their parent.\n     */\n    public static class DirectChildrenIterator implements Iterator<Node> {\n\n        private final Iterator<Node> childrenIterator;\n\n        public DirectChildrenIterator(Node node) {\n            childrenIterator = new ArrayList<>(node.getChildNodes()).iterator();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return childrenIterator.hasNext();\n        }\n\n        @Override\n        public Node next() {\n            return childrenIterator.next();\n        }\n    }\n\n    /**\n     * Iterates over the parent of the node, then the parent's parent, then the parent's parent's parent, until running\n     * out of parents.\n     */\n    public static class ParentsVisitor implements Iterator<Node> {\n\n        private Node node;\n\n        public ParentsVisitor(Node node) {\n            this.node = node;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return node.getParentNode().isPresent();\n        }\n\n        @Override\n        public Node next() {\n            node = node.getParentNode().orElse(null);\n            return node;\n        }\n    }\n\n    /**\n     * Performs a pre-order (or depth-first) node traversal starting with a given node.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Pre-order\">Pre-order traversal</a>\n     */\n    public static class PreOrderIterator implements Iterator<Node> {\n\n        private final Stack<Node> stack = new Stack<>();\n\n        public PreOrderIterator(Node node) {\n            stack.add(node);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !stack.isEmpty();\n        }\n\n        @Override\n        public Node next() {\n            Node next = stack.pop();\n            List<Node> children = next.getChildNodes();\n            for (int i = children.size() - 1; i >= 0; i--) {\n                stack.add(children.get(i));\n            }\n            return next;\n        }\n    }\n\n    /**\n     * Performs a post-order (or leaves-first) node traversal starting with a given node.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Post-order\">Post-order traversal</a>\n     */\n    public static class PostOrderIterator implements Iterator<Node> {\n\n        private final Stack<List<Node>> nodesStack = new Stack<>();\n\n        private final Stack<Integer> cursorStack = new Stack<>();\n\n        private final Node root;\n\n        private boolean hasNext = true;\n\n        public PostOrderIterator(Node root) {\n            this.root = root;\n            fillStackToLeaf(root);\n        }\n\n        private void fillStackToLeaf(Node node) {\n            while (true) {\n                List<Node> childNodes = new ArrayList<>(node.getChildNodes());\n                if (childNodes.isEmpty()) {\n                    break;\n                }\n                nodesStack.push(childNodes);\n                cursorStack.push(0);\n                node = childNodes.get(0);\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            return hasNext;\n        }\n\n        @Override\n        public Node next() {\n            final List<Node> nodes = nodesStack.peek();\n            final int cursor = cursorStack.peek();\n            final boolean levelHasNext = cursor < nodes.size();\n            if (levelHasNext) {\n                Node node = nodes.get(cursor);\n                fillStackToLeaf(node);\n                return nextFromLevel();\n            } else {\n                nodesStack.pop();\n                cursorStack.pop();\n                hasNext = !nodesStack.empty();\n                if (hasNext) {\n                    return nextFromLevel();\n                }\n                return root;\n            }\n        }\n\n        private Node nextFromLevel() {\n            final List<Node> nodes = nodesStack.peek();\n            final int cursor = cursorStack.pop();\n            cursorStack.push(cursor + 1);\n            return nodes.get(cursor);\n        }\n    }\n}\n", "filePathAfter": "javaparser-core/src/main/java/com/github/javaparser/ast/Node.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.ast;\n\nimport static com.github.javaparser.ast.Node.Parsedness.PARSED;\nimport static com.github.javaparser.ast.Node.TreeTraversal.PREORDER;\nimport static java.util.Collections.emptySet;\nimport static java.util.Collections.unmodifiableList;\nimport static java.util.Spliterator.DISTINCT;\nimport static java.util.Spliterator.NONNULL;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.Spliterators;\nimport java.util.Stack;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport com.github.javaparser.HasParentNode;\nimport com.github.javaparser.Position;\nimport com.github.javaparser.Range;\nimport com.github.javaparser.TokenRange;\nimport com.github.javaparser.ast.comments.BlockComment;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.comments.LineComment;\nimport com.github.javaparser.ast.nodeTypes.NodeWithRange;\nimport com.github.javaparser.ast.nodeTypes.NodeWithTokenRange;\nimport com.github.javaparser.ast.observer.AstObserver;\nimport com.github.javaparser.ast.observer.ObservableProperty;\nimport com.github.javaparser.ast.observer.PropagatingAstObserver;\nimport com.github.javaparser.ast.visitor.CloneVisitor;\nimport com.github.javaparser.ast.visitor.EqualsVisitor;\nimport com.github.javaparser.ast.visitor.HashCodeVisitor;\nimport com.github.javaparser.ast.visitor.Visitable;\nimport com.github.javaparser.metamodel.InternalProperty;\nimport com.github.javaparser.metamodel.JavaParserMetaModel;\nimport com.github.javaparser.metamodel.NodeMetaModel;\nimport com.github.javaparser.metamodel.OptionalProperty;\nimport com.github.javaparser.metamodel.PropertyMetaModel;\nimport com.github.javaparser.printer.DefaultPrettyPrinter;\nimport com.github.javaparser.printer.Printer;\nimport com.github.javaparser.printer.configuration.ConfigurationOption;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration.ConfigOption;\nimport com.github.javaparser.printer.configuration.PrinterConfiguration;\nimport com.github.javaparser.resolution.SymbolResolver;\nimport com.github.javaparser.utils.LineSeparator;\n\n/**\n * Base class for all nodes of the abstract syntax tree.\n * <h2>Construction</h2>\n * <p>The tree is built by instantiating the required nodes, then adding them to other nodes.\n * If it is the parser who is building the tree, it will use the largest constructor,\n * the one with \"range\" as the first parameter.\n * If you want to manually instantiate nodes, we suggest to...\n * <ul>\n * <li>use a convenience method, like \"addStatement(...)\", or if none are available...</li>\n * <li>use a convenient constructor, like ClassOrInterfaceType(String name), or if none are available...</li>\n * <li>use the default constructor.</li>\n * <li>Alternatively, use one of the JavaParser.parse(snippet) methods.</li>\n * </ul>\n * ... and use the various methods on the node to initialize it further, if needed.\n * <h2>Parent/child</h2>\n * <p>The parent node field is managed automatically and can be seen as read only.\n * Note that there is only one parent,\n * and trying to use the same node in two places will lead to unexpected behaviour.\n * It is advised to clone() a node before moving it around.\n * <h2>Comments</h2>\n * <p>Each Node can have one associated comment which describes it and\n * a number of \"orphan comments\" which it contains but are not specifically\n * associated to any child.\n * <h2>Positions</h2>\n * <p>When the parser creates nodes, it sets their source code position in the \"range\" field.\n * When you manually instantiate nodes, their range is not set.\n * The top left character is position 1, 1.\n * Note that since this is an <i>abstract</i> syntax tree,\n * it leaves out a lot of text from the original source file,\n * like where braces or comma's are exactly.\n * Therefore there is no position information on everything in the original source file.\n * <h2>Observers</h2>\n * <p>It is possible to add observers to the the tree.\n * Any change in the tree is sent as an event to any observers watching.\n * <h2>Visitors</h2>\n * <p>The most comfortable way of working with an abstract syntax tree is using visitors.\n * You can use one of the visitors in the visitor package, or extend one of them.\n * A visitor can be \"run\" by calling accept on a node:\n * <pre>node.accept(visitor, argument);</pre>\n * where argument is an object of your choice (often simply null.)\n *\n * @author Julio Vilmar Gesser\n */\npublic abstract class Node implements Cloneable, HasParentNode<Node>, Visitable, NodeWithRange<Node>, NodeWithTokenRange<Node> {\n\n    /**\n     * Different registration mode for observers on nodes.\n     */\n    public enum ObserverRegistrationMode {\n\n        /**\n         * Notify exclusively for changes happening on this node alone.\n         */\n        JUST_THIS_NODE,\n        /**\n         * Notify for changes happening on this node and all its descendants existing at the moment in\n         * which the observer was registered. Nodes attached later will not be observed.\n         */\n        THIS_NODE_AND_EXISTING_DESCENDANTS,\n        /**\n         * Notify for changes happening on this node and all its descendants. The descendants existing at the moment in\n         * which the observer was registered will be observed immediately. As new nodes are attached later they are\n         * automatically registered to be observed.\n         */\n        SELF_PROPAGATING\n    }\n\n    public enum Parsedness {\n\n        PARSED, UNPARSABLE\n    }\n\n    /**\n     * This can be used to sort nodes on position.\n     */\n    public static Comparator<NodeWithRange<?>> NODE_BY_BEGIN_POSITION = (a, b) -> {\n        if (a.hasRange() && b.hasRange()) {\n            return a.getRange().get().begin.compareTo(b.getRange().get().begin);\n        }\n        if (a.hasRange() || b.hasRange()) {\n            if (a.hasRange()) {\n                return 1;\n            }\n            return -1;\n        }\n        return 0;\n    };\n\n    protected static final PrinterConfiguration prettyPrinterNoCommentsConfiguration = new DefaultPrinterConfiguration().removeOption(new ConfigurationOption(ConfigOption.PRINT_COMMENTS));\n    \n    @InternalProperty\n    private Range range;\n\n    @InternalProperty\n    private TokenRange tokenRange;\n\n    @InternalProperty\n    private Node parentNode;\n\n    @InternalProperty\n    private List<Node> childNodes = new LinkedList<>();\n\n    @InternalProperty\n    private List<Comment> orphanComments = new LinkedList<>();\n\n    @InternalProperty\n    private IdentityHashMap<DataKey<?>, Object> data = null;\n\n    @OptionalProperty\n    private Comment comment;\n\n    @InternalProperty\n    private Set<AstObserver> observers = new HashSet<>();\n\n    @InternalProperty\n    private Parsedness parsed = PARSED;\n\n    protected Node(TokenRange tokenRange) {\n        setTokenRange(tokenRange);\n    }\n\n    /**\n     * Called in every constructor for node specific code.\n     * It can't be written in the constructor itself because it will\n     * be overwritten during code generation.\n     */\n    protected void customInitialization() {\n    }\n    \n    /*\n     * If there is a printer defined in CompilationUnit, returns it\n     * else create a new DefaultPrettyPrinter with default parameters\n     */\n    protected Printer getPrinter() {\n        return findCompilationUnit().map(c-> c.getPrinter()).orElse(createDefaultPrinter());\n    }\n    \n    /*\n     * Return the printer initialized with the specified configuration\n     */\n    protected Printer getPrinter(PrinterConfiguration configuration) {\n        return findCompilationUnit().map(c-> c.getPrinter(configuration)).orElse(createDefaultPrinter(configuration));\n    }\n    \n    protected Printer createDefaultPrinter() {\n        return createDefaultPrinter(getDefaultPrinterConfiguration());\n    }\n    \n    protected Printer createDefaultPrinter(PrinterConfiguration configuration) {\n        return new DefaultPrettyPrinter(configuration);\n    }\n    \n    /*\n     * returns a default printer configuration\n     */\n    protected  PrinterConfiguration getDefaultPrinterConfiguration() {\n        return new DefaultPrinterConfiguration();\n    }\n    \n    /**\n     * This is a comment associated with this node.\n     *\n     * @return comment property\n     */\n    @Generated(\"com.github.javaparser.generator.core.node.PropertyGenerator\")\n    public Optional<Comment> getComment() {\n        return Optional.ofNullable(comment);\n    }\n\n    /**\n     * @return the range of characters in the source code that this node covers.\n     */\n    public Optional<Range> getRange() {\n        return Optional.ofNullable(range);\n    }\n\n    /**\n     * @return the range of tokens that this node covers.\n     */\n    public Optional<TokenRange> getTokenRange() {\n        return Optional.ofNullable(tokenRange);\n    }\n\n    public Node setTokenRange(TokenRange tokenRange) {\n        this.tokenRange = tokenRange;\n        if (tokenRange == null || !(tokenRange.getBegin().hasRange() && tokenRange.getEnd().hasRange())) {\n            range = null;\n        } else {\n            range = new Range(tokenRange.getBegin().getRange().get().begin, tokenRange.getEnd().getRange().get().end);\n        }\n        return this;\n    }\n\n    /**\n     * @param range the range of characters in the source code that this node covers. null can be used to indicate that\n     *              no range information is known, or that it is not of interest.\n     */\n    public Node setRange(Range range) {\n        if (this.range == range) {\n            return this;\n        }\n        notifyPropertyChange(ObservableProperty.RANGE, this.range, range);\n        this.range = range;\n        return this;\n    }\n\n    /**\n     * Use this to store additional information to this node.\n     *\n     * @param comment to be set\n     */\n    public Node setComment(final Comment comment) {\n        if (this.comment == comment) {\n            return this;\n        }\n        notifyPropertyChange(ObservableProperty.COMMENT, this.comment, comment);\n        if (this.comment != null) {\n            this.comment.setCommentedNode(null);\n        }\n        this.comment = comment;\n        if (comment != null) {\n            this.comment.setCommentedNode(this);\n        }\n        return this;\n    }\n\n    /**\n     * Use this to store additional information to this node.\n     *\n     * @param comment to be set\n     */\n    public final Node setLineComment(String comment) {\n        return setComment(new LineComment(comment));\n    }\n\n    /**\n     * Use this to store additional information to this node.\n     *\n     * @param comment to be set\n     */\n    public final Node setBlockComment(String comment) {\n        return setComment(new BlockComment(comment));\n    }\n\n    /**\n     * @return pretty printed source code for this node and its children.\n     */\n    @Override\n    public final String toString() {\n        if (containsData(LINE_SEPARATOR_KEY)) {\n            LineSeparator lineSeparator = getLineEndingStyleOrDefault(LineSeparator.SYSTEM);\n            PrinterConfiguration config = getDefaultPrinterConfiguration();\n            config.addOption(new ConfigurationOption(ConfigOption.END_OF_LINE_CHARACTER, lineSeparator.asRawString()));\n            return getPrinter(config).print(this);\n        }\n        return getPrinter().print(this);\n    }\n\n    /**\n     * @return pretty printed source code for this node and its children.\n     * Formatting can be configured with parameter PrinterConfiguration.\n     */\n    public final String toString(PrinterConfiguration configuration) {\n        return getPrinter(configuration).print(this);\n    }\n\n    @Override\n    public final int hashCode() {\n        return HashCodeVisitor.hashCode(this);\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == null || !(obj instanceof Node)) {\n            return false;\n        }\n        return EqualsVisitor.equals(this, (Node) obj);\n    }\n\n    @Override\n    public Optional<Node> getParentNode() {\n        return Optional.ofNullable(parentNode);\n    }\n\n    /**\n     * Contains all nodes that have this node set as their parent.\n     * You can add and remove nodes from this list by adding or removing nodes from the fields of this node.\n     *\n     * @return all nodes that have this node as their parent.\n     */\n    public List<Node> getChildNodes() {\n        return unmodifiableList(childNodes);\n    }\n\n    public void addOrphanComment(Comment comment) {\n        orphanComments.add(comment);\n        comment.setParentNode(this);\n    }\n\n    public boolean removeOrphanComment(Comment comment) {\n        boolean removed = orphanComments.remove(comment);\n        if (removed) {\n            notifyPropertyChange(ObservableProperty.COMMENT, comment, null);\n            comment.setParentNode(null);\n        }\n        return removed;\n    }\n\n    /**\n     * This is a list of Comment which are inside the node and are not associated\n     * with any meaningful AST Node.\n     * <p>\n     * For example, comments at the end of methods (immediately before the parenthesis)\n     * or at the end of CompilationUnit are orphan comments.\n     * <p>\n     * When more than one comment preceeds a statement, the one immediately preceding it\n     * it is associated with the statements, while the others are orphans.\n     * <p>\n     * Changes to this list are not persisted.\n     *\n     * @return all comments that cannot be attributed to a concept\n     */\n    public List<Comment> getOrphanComments() {\n        return new LinkedList<>(orphanComments);\n    }\n\n    /**\n     * This is the list of Comment which are contained in the Node either because\n     * they are properly associated to one of its children or because they are floating\n     * around inside the Node\n     *\n     * @return all Comments within the node as a list\n     */\n    public List<Comment> getAllContainedComments() {\n        List<Comment> comments = new LinkedList<>();\n        comments.addAll(getOrphanComments());\n        for (Node child : getChildNodes()) {\n            child.getComment().ifPresent(comments::add);\n            comments.addAll(child.getAllContainedComments());\n        }\n        return comments;\n    }\n\n    /**\n     * Assign a new parent to this node, removing it\n     * from the list of children of the previous parent, if any.\n     *\n     * @param newParentNode node to be set as parent\n     */\n    @Override\n    public Node setParentNode(Node newParentNode) {\n        if (newParentNode == parentNode) {\n            return this;\n        }\n        observers.forEach(o -> o.parentChange(this, parentNode, newParentNode));\n        // remove from old parent, if any\n        if (parentNode != null) {\n            final List<Node> parentChildNodes = parentNode.childNodes;\n            for (int i = 0; i < parentChildNodes.size(); i++) {\n                if (parentChildNodes.get(i) == this) {\n                    parentChildNodes.remove(i);\n                }\n            }\n        }\n        parentNode = newParentNode;\n        // add to new parent, if any\n        if (parentNode != null) {\n            parentNode.childNodes.add(this);\n        }\n        return this;\n    }\n\n    protected void setAsParentNodeOf(Node childNode) {\n        if (childNode != null) {\n            childNode.setParentNode(getParentNodeForChildren());\n        }\n    }\n\n    /**\n     * @deprecated Use {@link Position#ABSOLUTE_BEGIN_LINE}\n     */\n    @Deprecated\n    public static final int ABSOLUTE_BEGIN_LINE = Position.ABSOLUTE_BEGIN_LINE;\n\n    /**\n     * @deprecated Use {@link Position#ABSOLUTE_END_LINE}\n     */\n    @Deprecated\n    public static final int ABSOLUTE_END_LINE = Position.ABSOLUTE_END_LINE;\n\n    public void tryAddImportToParentCompilationUnit(Class<?> clazz) {\n        findAncestor(CompilationUnit.class).ifPresent(p -> p.addImport(clazz));\n    }\n\n    /**\n     * Recursively finds all nodes of a certain type.\n     *\n     * @param clazz the type of node to find.\n     * @deprecated use {@link Node#findAll(Class)} but be aware that findAll also considers the initial node.\n     */\n    @Deprecated\n    public <N extends Node> List<N> getChildNodesByType(Class<N> clazz) {\n        List<N> nodes = new ArrayList<>();\n        for (Node child : getChildNodes()) {\n            if (clazz.isInstance(child)) {\n                nodes.add(clazz.cast(child));\n            }\n            nodes.addAll(child.getChildNodesByType(clazz));\n        }\n        return nodes;\n    }\n\n    /**\n     * @deprecated use {@link Node#findAll(Class)} but be aware that findAll also considers the initial node.\n     */\n    @Deprecated\n    public <N extends Node> List<N> getNodesByType(Class<N> clazz) {\n        return getChildNodesByType(clazz);\n    }\n\n    /**\n     * Gets data for this node using the given key.\n     *\n     * @param <M> The type of the data.\n     * @param key The key for the data\n     * @return The data.\n     * @throws IllegalStateException if the key was not set in this node.\n     * @see Node#containsData(DataKey)\n     * @see DataKey\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <M> M getData(final DataKey<M> key) {\n        if (data == null) {\n            throw new IllegalStateException(\"No data of this type found. Use containsData to check for this first.\");\n        }\n        M value = (M) data.get(key);\n        if (value == null) {\n            throw new IllegalStateException(\"No data of this type found. Use containsData to check for this first.\");\n        }\n        return value;\n    }\n\n    /**\n     * This method was added to support the clone method.\n     *\n     * @return all known data keys.\n     */\n    public Set<DataKey<?>> getDataKeys() {\n        if (data == null) {\n            return emptySet();\n        }\n        return data.keySet();\n    }\n\n    /**\n     * Sets data for this node using the given key.\n     * For information on creating DataKey, see {@link DataKey}.\n     *\n     * @param <M>    The type of data\n     * @param key    The singleton key for the data\n     * @param object The data object\n     * @see DataKey\n     */\n    public <M> void setData(DataKey<M> key, M object) {\n        if (data == null) {\n            data = new IdentityHashMap<>();\n        }\n        data.put(key, object);\n    }\n\n    /**\n     * @return does this node have data for this key?\n     * @see DataKey\n     */\n    public boolean containsData(DataKey<?> key) {\n        if (data == null) {\n            return false;\n        }\n        return data.containsKey(key);\n    }\n\n    /**\n     * Remove data by key.\n     *\n     * @see DataKey\n     */\n    public void removeData(DataKey<?> key) {\n        if (data != null) {\n            data.remove(key);\n        }\n    }\n\n    /**\n     * Try to remove this node from the parent\n     *\n     * @return true if removed, false if it is a required property of the parent, or if the parent isn't set.\n     * @throws RuntimeException if it fails in an unexpected way\n     */\n    public boolean remove() {\n        if (parentNode == null) {\n            return false;\n        }\n        return parentNode.remove(this);\n    }\n\n    /**\n     * Try to replace this node in the parent with the supplied node.\n     *\n     * @return true if removed, or if the parent isn't set.\n     * @throws RuntimeException if it fails in an unexpected way\n     */\n    public boolean replace(Node node) {\n        if (parentNode == null) {\n            return false;\n        }\n        return parentNode.replace(this, node);\n    }\n\n    /**\n     * Forcibly removes this node from the AST.\n     * If it cannot be removed from the parent with remove(),\n     * it will try to remove its parent instead,\n     * until it finds a node that can be removed,\n     * or no parent can be found.\n     * <p>\n     * Since everything at CompilationUnit level is removable,\n     * this method will only (silently) fail when the node is in a detached AST fragment.\n     */\n    public void removeForced() {\n        if (!remove()) {\n            getParentNode().ifPresent(Node::remove);\n        }\n    }\n\n    @Override\n    public Node getParentNodeForChildren() {\n        return this;\n    }\n\n    protected void setAsParentNodeOf(NodeList<? extends Node> list) {\n        if (list != null) {\n            list.setParentNode(getParentNodeForChildren());\n        }\n    }\n\n    public <P> void notifyPropertyChange(ObservableProperty property, P oldValue, P newValue) {\n        this.observers.forEach(o -> o.propertyChange(this, property, oldValue, newValue));\n    }\n\n    @Override\n    public void unregister(AstObserver observer) {\n        this.observers.remove(observer);\n    }\n\n    @Override\n    public void register(AstObserver observer) {\n        this.observers.add(observer);\n    }\n\n    /**\n     * Register a new observer for the given node. Depending on the mode specified also descendants, existing\n     * and new, could be observed. For more details see <i>ObserverRegistrationMode</i>.\n     */\n    public void register(AstObserver observer, ObserverRegistrationMode mode) {\n        if (mode == null) {\n            throw new IllegalArgumentException(\"Mode should be not null\");\n        }\n        switch(mode) {\n            case JUST_THIS_NODE:\n                register(observer);\n                break;\n            case THIS_NODE_AND_EXISTING_DESCENDANTS:\n                registerForSubtree(observer);\n                break;\n            case SELF_PROPAGATING:\n                registerForSubtree(PropagatingAstObserver.transformInPropagatingObserver(observer));\n                break;\n            default:\n                throw new UnsupportedOperationException(\"This mode is not supported: \" + mode);\n        }\n    }\n\n    /**\n     * Register the observer for the current node and all the contained node and nodelists, recursively.\n     */\n    public void registerForSubtree(AstObserver observer) {\n        register(observer);\n        this.getChildNodes().forEach(c -> c.registerForSubtree(observer));\n        for (PropertyMetaModel property : getMetaModel().getAllPropertyMetaModels()) {\n            if (property.isNodeList()) {\n                NodeList<?> nodeList = (NodeList<?>) property.getValue(this);\n                if (nodeList != null)\n                    nodeList.register(observer);\n            }\n        }\n    }\n\n    @Override\n    public boolean isRegistered(AstObserver observer) {\n        return this.observers.contains(observer);\n    }\n\n    @Generated(\"com.github.javaparser.generator.core.node.RemoveMethodGenerator\")\n    public boolean remove(Node node) {\n        if (node == null)\n            return false;\n        if (comment != null) {\n            if (node == comment) {\n                removeComment();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Generated(\"com.github.javaparser.generator.core.node.RemoveMethodGenerator\")\n    public Node removeComment() {\n        return setComment((Comment) null);\n    }\n\n    @Override\n    @Generated(\"com.github.javaparser.generator.core.node.CloneGenerator\")\n    public Node clone() {\n        return (Node) accept(new CloneVisitor(), null);\n    }\n\n    /**\n     * @return get JavaParser specific node introspection information.\n     */\n    @Generated(\"com.github.javaparser.generator.core.node.GetMetaModelGenerator\")\n    public NodeMetaModel getMetaModel() {\n        return JavaParserMetaModel.nodeMetaModel;\n    }\n\n    /**\n     * @return whether this node was successfully parsed or not.\n     * If it was not, only the range and tokenRange fields will be valid.\n     */\n    public Parsedness getParsed() {\n        return parsed;\n    }\n\n    /**\n     * Used by the parser to flag unparsable nodes.\n     */\n    public Node setParsed(Parsedness parsed) {\n        this.parsed = parsed;\n        return this;\n    }\n\n    @Generated(\"com.github.javaparser.generator.core.node.ReplaceMethodGenerator\")\n    public boolean replace(Node node, Node replacementNode) {\n        if (node == null)\n            return false;\n        if (comment != null) {\n            if (node == comment) {\n                setComment((Comment) replacementNode);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Finds the root node of this AST by finding the topmost parent.\n     */\n    public Node findRootNode() {\n        Node n = this;\n        while (n.getParentNode().isPresent()) {\n            n = n.getParentNode().get();\n        }\n        return n;\n    }\n\n    /**\n     * @return the containing CompilationUnit, or empty if this node is not inside a compilation unit.\n     */\n    public Optional<CompilationUnit> findCompilationUnit() {\n        Node rootNode = findRootNode();\n        if (rootNode instanceof CompilationUnit) {\n            return Optional.of((CompilationUnit) rootNode);\n        }\n        return Optional.empty();\n    }\n\n    public LineSeparator getLineEndingStyleOrDefault(LineSeparator defaultLineSeparator) {\n        if (getLineEndingStyle().isStandardEol()) {\n            return getLineEndingStyle();\n        }\n        return defaultLineSeparator;\n    }\n\n    public LineSeparator getLineEndingStyle() {\n        Node current = this;\n        // First check this node\n        if (current.containsData(Node.LINE_SEPARATOR_KEY)) {\n            LineSeparator lineSeparator = current.getData(Node.LINE_SEPARATOR_KEY);\n            return lineSeparator;\n        }\n        // Then check parent/ancestor nodes\n        while (current.getParentNode().isPresent()) {\n            current = current.getParentNode().get();\n            if (current.containsData(Node.LINE_SEPARATOR_KEY)) {\n                return current.getData(Node.LINE_SEPARATOR_KEY);\n            }\n        }\n        // Default to the system line separator if it's not already set within the parsed node/code.\n        return LineSeparator.SYSTEM;\n    }\n\n    protected SymbolResolver getSymbolResolver() {\n        return findCompilationUnit().map(cu -> {\n            if (cu.containsData(SYMBOL_RESOLVER_KEY)) {\n                return cu.getData(SYMBOL_RESOLVER_KEY);\n            } else {\n                throw new IllegalStateException(\"Symbol resolution not configured: to configure consider setting a SymbolResolver in the ParserConfiguration\");\n            }\n        }).orElseThrow(() -> new IllegalStateException(\"The node is not inserted in a CompilationUnit\"));\n    }\n\n    // We need to expose it because we will need to use it to inject the SymbolSolver\n    public static final DataKey<SymbolResolver> SYMBOL_RESOLVER_KEY = new DataKey<SymbolResolver>() {\n    };\n\n    public static final DataKey<LineSeparator> LINE_SEPARATOR_KEY = new DataKey<LineSeparator>() {\n    };\n\n    public enum TreeTraversal {\n\n        PREORDER, BREADTHFIRST, POSTORDER, PARENTS, DIRECT_CHILDREN\n    }\n\n    private Iterator<Node> treeIterator(TreeTraversal traversal) {\n        switch(traversal) {\n            case BREADTHFIRST:\n                return new BreadthFirstIterator(this);\n            case POSTORDER:\n                return new PostOrderIterator(this);\n            case PREORDER:\n                return new PreOrderIterator(this);\n            case DIRECT_CHILDREN:\n                return new DirectChildrenIterator(this);\n            case PARENTS:\n                return new ParentsVisitor(this);\n            default:\n                throw new IllegalArgumentException(\"Unknown traversal choice.\");\n        }\n    }\n\n    private Iterable<Node> treeIterable(TreeTraversal traversal) {\n        return () -> treeIterator(traversal);\n    }\n\n    /**\n     * Make a stream of nodes using traversal algorithm \"traversal\".\n     */\n    public Stream<Node> stream(TreeTraversal traversal) {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(treeIterator(traversal), NONNULL | DISTINCT), false);\n    }\n\n    /**\n     * Make a stream of nodes using pre-order traversal.\n     */\n    public Stream<Node> stream() {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(treeIterator(PREORDER), NONNULL | DISTINCT), false);\n    }\n\n    /**\n     * Walks the AST, calling the consumer for every node, with traversal algorithm \"traversal\".\n     * <br>This is the most general walk method. All other walk and findAll methods are based on this.\n     */\n    public void walk(TreeTraversal traversal, Consumer<Node> consumer) {\n        // Could be implemented as a call to the above walk method, but this is a little more efficient.\n        for (Node node : treeIterable(traversal)) {\n            consumer.accept(node);\n        }\n    }\n\n    /**\n     * Walks the AST, calling the consumer for every node with pre-order traversal.\n     */\n    public void walk(Consumer<Node> consumer) {\n        walk(PREORDER, consumer);\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, calling the consumer for every node of type \"nodeType\".\n     */\n    public <T extends Node> void walk(Class<T> nodeType, Consumer<T> consumer) {\n        walk(TreeTraversal.PREORDER, node -> {\n            if (nodeType.isAssignableFrom(node.getClass())) {\n                consumer.accept(nodeType.cast(node));\n            }\n        });\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning all nodes of type \"nodeType\".\n     */\n    public <T extends Node> List<T> findAll(Class<T> nodeType) {\n        final List<T> found = new ArrayList<>();\n        walk(nodeType, found::add);\n        return found;\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning all nodes of type \"nodeType\" that match the predicate.\n     */\n    public <T extends Node> List<T> findAll(Class<T> nodeType, Predicate<T> predicate) {\n        final List<T> found = new ArrayList<>();\n        walk(nodeType, n -> {\n            if (predicate.test(n))\n                found.add(n);\n        });\n        return found;\n    }\n\n    /**\n     * Walks the AST, applying the function for every node, with traversal algorithm \"traversal\". If the function\n     * returns something else than null, the traversal is stopped and the function result is returned. <br>This is the\n     * most general findFirst method. All other findFirst methods are based on this.\n     */\n    public <T> Optional<T> findFirst(TreeTraversal traversal, Function<Node, Optional<T>> consumer) {\n        for (Node node : treeIterable(traversal)) {\n            final Optional<T> result = consumer.apply(node);\n            if (result.isPresent()) {\n                return result;\n            }\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning the first node of type \"nodeType\" or empty() if none is found.\n     */\n    public <N extends Node> Optional<N> findFirst(Class<N> nodeType) {\n        return findFirst(TreeTraversal.PREORDER, node -> {\n            if (nodeType.isAssignableFrom(node.getClass())) {\n                return Optional.of(nodeType.cast(node));\n            }\n            return Optional.empty();\n        });\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning the first node of type \"nodeType\" that matches \"predicate\" or empty() if none is\n     * found.\n     */\n    public <N extends Node> Optional<N> findFirst(Class<N> nodeType, Predicate<N> predicate) {\n        return findFirst(TreeTraversal.PREORDER, node -> {\n            if (nodeType.isAssignableFrom(node.getClass())) {\n                final N castNode = nodeType.cast(node);\n                if (predicate.test(castNode)) {\n                    return Optional.of(castNode);\n                }\n            }\n            return Optional.empty();\n        });\n    }\n\n    /**\n     * Determines whether this node is an ancestor of the given node. A node is <i>not</i> an ancestor of itself.\n     *\n     * @param descendant the node for which to determine whether it has this node as an ancestor.\n     * @return {@code true} if this node is an ancestor of the given node, and {@code false} otherwise.\n     * @see HasParentNode#isDescendantOf(Node)\n     */\n    public boolean isAncestorOf(Node descendant) {\n        return this != descendant && findFirst(Node.class, n -> n == descendant).isPresent();\n    }\n\n    /**\n     * Performs a breadth-first node traversal starting with a given node.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\">Breadth-first traversal</a>\n     */\n    public static class BreadthFirstIterator implements Iterator<Node> {\n\n        private final Queue<Node> queue = new LinkedList<>();\n\n        public BreadthFirstIterator(Node node) {\n            queue.add(node);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !queue.isEmpty();\n        }\n\n        @Override\n        public Node next() {\n            Node next = queue.remove();\n            queue.addAll(next.getChildNodes());\n            return next;\n        }\n    }\n\n    /**\n     * Performs a simple traversal over all nodes that have the passed node as their parent.\n     */\n    public static class DirectChildrenIterator implements Iterator<Node> {\n\n        private final Iterator<Node> childrenIterator;\n\n        public DirectChildrenIterator(Node node) {\n            childrenIterator = new ArrayList<>(node.getChildNodes()).iterator();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return childrenIterator.hasNext();\n        }\n\n        @Override\n        public Node next() {\n            return childrenIterator.next();\n        }\n    }\n\n    /**\n     * Iterates over the parent of the node, then the parent's parent, then the parent's parent's parent, until running\n     * out of parents.\n     */\n    public static class ParentsVisitor implements Iterator<Node> {\n\n        private Node node;\n\n        public ParentsVisitor(Node node) {\n            this.node = node;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return node.getParentNode().isPresent();\n        }\n\n        @Override\n        public Node next() {\n            node = node.getParentNode().orElse(null);\n            return node;\n        }\n    }\n\n    /**\n     * Performs a pre-order (or depth-first) node traversal starting with a given node.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Pre-order\">Pre-order traversal</a>\n     */\n    public static class PreOrderIterator implements Iterator<Node> {\n\n        private final Stack<Node> stack = new Stack<>();\n\n        public PreOrderIterator(Node node) {\n            stack.add(node);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !stack.isEmpty();\n        }\n\n        @Override\n        public Node next() {\n            Node next = stack.pop();\n            List<Node> children = next.getChildNodes();\n            for (int i = children.size() - 1; i >= 0; i--) {\n                stack.add(children.get(i));\n            }\n            return next;\n        }\n    }\n\n    /**\n     * Performs a post-order (or leaves-first) node traversal starting with a given node.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Post-order\">Post-order traversal</a>\n     */\n    public static class PostOrderIterator implements Iterator<Node> {\n\n        private final Stack<List<Node>> nodesStack = new Stack<>();\n\n        private final Stack<Integer> cursorStack = new Stack<>();\n\n        private final Node root;\n\n        private boolean hasNext = true;\n\n        public PostOrderIterator(Node root) {\n            this.root = root;\n            fillStackToLeaf(root);\n        }\n\n        private void fillStackToLeaf(Node node) {\n            while (true) {\n                List<Node> childNodes = new ArrayList<>(node.getChildNodes());\n                if (childNodes.isEmpty()) {\n                    break;\n                }\n                nodesStack.push(childNodes);\n                cursorStack.push(0);\n                node = childNodes.get(0);\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            return hasNext;\n        }\n\n        @Override\n        public Node next() {\n            final List<Node> nodes = nodesStack.peek();\n            final int cursor = cursorStack.peek();\n            final boolean levelHasNext = cursor < nodes.size();\n            if (levelHasNext) {\n                Node node = nodes.get(cursor);\n                fillStackToLeaf(node);\n                return nextFromLevel();\n            } else {\n                nodesStack.pop();\n                cursorStack.pop();\n                hasNext = !nodesStack.empty();\n                if (hasNext) {\n                    return nextFromLevel();\n                }\n                return root;\n            }\n        }\n\n        private Node nextFromLevel() {\n            final List<Node> nodes = nodesStack.peek();\n            final int cursor = cursorStack.pop();\n            cursorStack.push(cursor + 1);\n            return nodes.get(cursor);\n        }\n    }\n}\n", "diffSourceCodeSet": ["protected Printer createDefaultPrinter(PrinterConfiguration configuration) {\n        return new DefaultPrettyPrinter(configuration);\n    }"], "invokedMethodSet": ["methodSignature: com.github.javaparser.ast.Node#getDefaultPrinterConfiguration\n methodBody: protected  PrinterConfiguration getDefaultPrinterConfiguration() {\nreturn new DefaultPrinterConfiguration();\n}"], "sourceCodeAfterRefactoring": "protected Printer createDefaultPrinter() {\n        return createDefaultPrinter(getDefaultPrinterConfiguration());\n    }\nprotected Printer createDefaultPrinter(PrinterConfiguration configuration) {\n        return new DefaultPrettyPrinter(configuration);\n    }", "diffSourceCode": "-  222:         return getPrinter().setConfiguration(configuration);\n-  223:     }\n-  224:     \n-  225:     protected Printer createDefaultPrinter() {\n-  226:         PrinterConfiguration configuration = getDefaultPrinterConfiguration();\n+  222:     protected Printer createDefaultPrinter() {\n+  223:         return createDefaultPrinter(getDefaultPrinterConfiguration());\n+  224:     }\n+  225:     \n+  226:     protected Printer createDefaultPrinter(PrinterConfiguration configuration) {\n   227:         return new DefaultPrettyPrinter(configuration);\n   228:     }\n", "uniqueId": "9d8184e1a607dcfcd3733b8a40587459f2a583d1_225_228_226_228_222_224", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 8}, "LINE": {"missed": 0, "covered": 2}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `createDefaultPrinter` method, we can extract the logic for creating a `DefaultPrettyPrinter` into a separate method. This will make the code more modular and easier to understand.\n\nHere\u2019s the refactored code:\n\n```java\nprotected Printer createDefaultPrinter() {\n    return createPrinterWithConfiguration(getDefaultPrinterConfiguration());\n}\n\nprivate Printer createPrinterWithConfiguration(PrinterConfiguration configuration) {\n    return new DefaultPrettyPrinter(configuration);\n}\n```\n\nIn this refactoring, the `createPrinterWithConfiguration` method encapsulates the logic for creating a `DefaultPrettyPrinter` with a given configuration. This makes the `createDefaultPrinter` method cleaner and more focused on its primary responsibility.\n\nHere\u2019s the output in the requested format:\n\n##########################\n```java\nprotected Printer createDefaultPrinter() {\n    return createPrinterWithConfiguration(getDefaultPrinterConfiguration());\n}\n\nprivate Printer createPrinterWithConfiguration(PrinterConfiguration configuration) {\n    return new DefaultPrettyPrinter(configuration);\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprotected Printer createDefaultPrinter() {\n        PrinterConfiguration configuration = getDefaultPrinterConfiguration();\n        return new DefaultPrettyPrinter(configuration);\n    }\n\nClass content:\n/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.ast;\n\nimport static com.github.javaparser.ast.Node.Parsedness.PARSED;\nimport static com.github.javaparser.ast.Node.TreeTraversal.PREORDER;\nimport static java.util.Collections.emptySet;\nimport static java.util.Collections.unmodifiableList;\nimport static java.util.Spliterator.DISTINCT;\nimport static java.util.Spliterator.NONNULL;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.Spliterators;\nimport java.util.Stack;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport com.github.javaparser.HasParentNode;\nimport com.github.javaparser.Position;\nimport com.github.javaparser.Range;\nimport com.github.javaparser.TokenRange;\nimport com.github.javaparser.ast.comments.BlockComment;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.comments.LineComment;\nimport com.github.javaparser.ast.nodeTypes.NodeWithRange;\nimport com.github.javaparser.ast.nodeTypes.NodeWithTokenRange;\nimport com.github.javaparser.ast.observer.AstObserver;\nimport com.github.javaparser.ast.observer.ObservableProperty;\nimport com.github.javaparser.ast.observer.PropagatingAstObserver;\nimport com.github.javaparser.ast.visitor.CloneVisitor;\nimport com.github.javaparser.ast.visitor.EqualsVisitor;\nimport com.github.javaparser.ast.visitor.HashCodeVisitor;\nimport com.github.javaparser.ast.visitor.Visitable;\nimport com.github.javaparser.metamodel.InternalProperty;\nimport com.github.javaparser.metamodel.JavaParserMetaModel;\nimport com.github.javaparser.metamodel.NodeMetaModel;\nimport com.github.javaparser.metamodel.OptionalProperty;\nimport com.github.javaparser.metamodel.PropertyMetaModel;\nimport com.github.javaparser.printer.DefaultPrettyPrinter;\nimport com.github.javaparser.printer.Printer;\nimport com.github.javaparser.printer.configuration.PrinterConfiguration;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration.ConfigOption;\nimport com.github.javaparser.resolution.SymbolResolver;\nimport com.github.javaparser.utils.LineSeparator;\n\n/**\n * Base class for all nodes of the abstract syntax tree.\n * <h2>Construction</h2>\n * <p>The tree is built by instantiating the required nodes, then adding them to other nodes.\n * If it is the parser who is building the tree, it will use the largest constructor,\n * the one with \"range\" as the first parameter.\n * If you want to manually instantiate nodes, we suggest to...\n * <ul>\n * <li>use a convenience method, like \"addStatement(...)\", or if none are available...</li>\n * <li>use a convenient constructor, like ClassOrInterfaceType(String name), or if none are available...</li>\n * <li>use the default constructor.</li>\n * <li>Alternatively, use one of the JavaParser.parse(snippet) methods.</li>\n * </ul>\n * ... and use the various methods on the node to initialize it further, if needed.\n * <h2>Parent/child</h2>\n * <p>The parent node field is managed automatically and can be seen as read only.\n * Note that there is only one parent,\n * and trying to use the same node in two places will lead to unexpected behaviour.\n * It is advised to clone() a node before moving it around.\n * <h2>Comments</h2>\n * <p>Each Node can have one associated comment which describes it and\n * a number of \"orphan comments\" which it contains but are not specifically\n * associated to any child.\n * <h2>Positions</h2>\n * <p>When the parser creates nodes, it sets their source code position in the \"range\" field.\n * When you manually instantiate nodes, their range is not set.\n * The top left character is position 1, 1.\n * Note that since this is an <i>abstract</i> syntax tree,\n * it leaves out a lot of text from the original source file,\n * like where braces or comma's are exactly.\n * Therefore there is no position information on everything in the original source file.\n * <h2>Observers</h2>\n * <p>It is possible to add observers to the the tree.\n * Any change in the tree is sent as an event to any observers watching.\n * <h2>Visitors</h2>\n * <p>The most comfortable way of working with an abstract syntax tree is using visitors.\n * You can use one of the visitors in the visitor package, or extend one of them.\n * A visitor can be \"run\" by calling accept on a node:\n * <pre>node.accept(visitor, argument);</pre>\n * where argument is an object of your choice (often simply null.)\n *\n * @author Julio Vilmar Gesser\n */\npublic abstract class Node implements Cloneable, HasParentNode<Node>, Visitable, NodeWithRange<Node>, NodeWithTokenRange<Node> {\n\n    /**\n     * Different registration mode for observers on nodes.\n     */\n    public enum ObserverRegistrationMode {\n\n        /**\n         * Notify exclusively for changes happening on this node alone.\n         */\n        JUST_THIS_NODE,\n        /**\n         * Notify for changes happening on this node and all its descendants existing at the moment in\n         * which the observer was registered. Nodes attached later will not be observed.\n         */\n        THIS_NODE_AND_EXISTING_DESCENDANTS,\n        /**\n         * Notify for changes happening on this node and all its descendants. The descendants existing at the moment in\n         * which the observer was registered will be observed immediately. As new nodes are attached later they are\n         * automatically registered to be observed.\n         */\n        SELF_PROPAGATING\n    }\n\n    public enum Parsedness {\n\n        PARSED, UNPARSABLE\n    }\n\n    /**\n     * This can be used to sort nodes on position.\n     */\n    public static Comparator<NodeWithRange<?>> NODE_BY_BEGIN_POSITION = (a, b) -> {\n        if (a.hasRange() && b.hasRange()) {\n            return a.getRange().get().begin.compareTo(b.getRange().get().begin);\n        }\n        if (a.hasRange() || b.hasRange()) {\n            if (a.hasRange()) {\n                return 1;\n            }\n            return -1;\n        }\n        return 0;\n    };\n\n    protected static final PrinterConfiguration prettyPrinterNoCommentsConfiguration = new DefaultPrinterConfiguration().removeOption(ConfigOption.PRINT_COMMENTS);\n    \n    @InternalProperty\n    private Range range;\n\n    @InternalProperty\n    private TokenRange tokenRange;\n\n    @InternalProperty\n    private Node parentNode;\n\n    @InternalProperty\n    private List<Node> childNodes = new LinkedList<>();\n\n    @InternalProperty\n    private List<Comment> orphanComments = new LinkedList<>();\n\n    @InternalProperty\n    private IdentityHashMap<DataKey<?>, Object> data = null;\n\n    @OptionalProperty\n    private Comment comment;\n\n    @InternalProperty\n    private Set<AstObserver> observers = new HashSet<>();\n\n    @InternalProperty\n    private Parsedness parsed = PARSED;\n\n    protected Node(TokenRange tokenRange) {\n        setTokenRange(tokenRange);\n    }\n\n    /**\n     * Called in every constructor for node specific code.\n     * It can't be written in the constructor itself because it will\n     * be overwritten during code generation.\n     */\n    protected void customInitialization() {\n    }\n    \n    /*\n     * If there is a printer defined in CompilationUnit, returns it\n     * else create a new DefaultPrettyPrinter with default parameters\n     */\n    protected Printer getPrinter() {\n        Optional<CompilationUnit> cu = findCompilationUnit();\n        if (!cu.isPresent()) {\n            return createDefaultPrinter();\n        }\n        return cu.get().getPrinter();\n    }\n    \n    /*\n     * Return the printer initialized with the specified configuration\n     */\n    protected Printer getPrinter(PrinterConfiguration configuration) {\n        return getPrinter().setConfiguration(configuration);\n    }\n    \n    protected Printer createDefaultPrinter() {\n        PrinterConfiguration configuration = getDefaultPrinterConfiguration();\n        return new DefaultPrettyPrinter(configuration);\n    }\n    \n    /*\n     * returns a default printer configuration\n     */\n    protected  PrinterConfiguration getDefaultPrinterConfiguration() {\n        return new DefaultPrinterConfiguration();\n    }\n\n    /**\n     * This is a comment associated with this node.\n     *\n     * @return comment property\n     */\n    @Generated(\"com.github.javaparser.generator.core.node.PropertyGenerator\")\n    public Optional<Comment> getComment() {\n        return Optional.ofNullable(comment);\n    }\n\n    /**\n     * @return the range of characters in the source code that this node covers.\n     */\n    public Optional<Range> getRange() {\n        return Optional.ofNullable(range);\n    }\n\n    /**\n     * @return the range of tokens that this node covers.\n     */\n    public Optional<TokenRange> getTokenRange() {\n        return Optional.ofNullable(tokenRange);\n    }\n\n    public Node setTokenRange(TokenRange tokenRange) {\n        this.tokenRange = tokenRange;\n        if (tokenRange == null || !(tokenRange.getBegin().hasRange() && tokenRange.getEnd().hasRange())) {\n            range = null;\n        } else {\n            range = new Range(tokenRange.getBegin().getRange().get().begin, tokenRange.getEnd().getRange().get().end);\n        }\n        return this;\n    }\n\n    /**\n     * @param range the range of characters in the source code that this node covers. null can be used to indicate that\n     *              no range information is known, or that it is not of interest.\n     */\n    public Node setRange(Range range) {\n        if (this.range == range) {\n            return this;\n        }\n        notifyPropertyChange(ObservableProperty.RANGE, this.range, range);\n        this.range = range;\n        return this;\n    }\n\n    /**\n     * Use this to store additional information to this node.\n     *\n     * @param comment to be set\n     */\n    public Node setComment(final Comment comment) {\n        if (this.comment == comment) {\n            return this;\n        }\n        notifyPropertyChange(ObservableProperty.COMMENT, this.comment, comment);\n        if (this.comment != null) {\n            this.comment.setCommentedNode(null);\n        }\n        this.comment = comment;\n        if (comment != null) {\n            this.comment.setCommentedNode(this);\n        }\n        return this;\n    }\n\n    /**\n     * Use this to store additional information to this node.\n     *\n     * @param comment to be set\n     */\n    public final Node setLineComment(String comment) {\n        return setComment(new LineComment(comment));\n    }\n\n    /**\n     * Use this to store additional information to this node.\n     *\n     * @param comment to be set\n     */\n    public final Node setBlockComment(String comment) {\n        return setComment(new BlockComment(comment));\n    }\n\n    /**\n     * @return pretty printed source code for this node and its children.\n     */\n    @Override\n    public final String toString() {\n        if (containsData(LINE_SEPARATOR_KEY)) {\n            LineSeparator lineSeparator = getLineEndingStyleOrDefault(LineSeparator.SYSTEM);\n            PrinterConfiguration config = getDefaultPrinterConfiguration();\n            config.addOption(ConfigOption.END_OF_LINE_CHARACTER.value(lineSeparator.asRawString()));\n            return getPrinter(config).print(this);\n        }\n        return getPrinter().print(this);\n    }\n\n    /**\n     * @return pretty printed source code for this node and its children.\n     * Formatting can be configured with parameter PrinterConfiguration.\n     */\n    public final String toString(PrinterConfiguration configuration) {\n        return getPrinter(configuration).print(this);\n    }\n\n    @Override\n    public final int hashCode() {\n        return HashCodeVisitor.hashCode(this);\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == null || !(obj instanceof Node)) {\n            return false;\n        }\n        return EqualsVisitor.equals(this, (Node) obj);\n    }\n\n    @Override\n    public Optional<Node> getParentNode() {\n        return Optional.ofNullable(parentNode);\n    }\n\n    /**\n     * Contains all nodes that have this node set as their parent.\n     * You can add and remove nodes from this list by adding or removing nodes from the fields of this node.\n     *\n     * @return all nodes that have this node as their parent.\n     */\n    public List<Node> getChildNodes() {\n        return unmodifiableList(childNodes);\n    }\n\n    public void addOrphanComment(Comment comment) {\n        orphanComments.add(comment);\n        comment.setParentNode(this);\n    }\n\n    public boolean removeOrphanComment(Comment comment) {\n        boolean removed = orphanComments.remove(comment);\n        if (removed) {\n            notifyPropertyChange(ObservableProperty.COMMENT, comment, null);\n            comment.setParentNode(null);\n        }\n        return removed;\n    }\n\n    /**\n     * This is a list of Comment which are inside the node and are not associated\n     * with any meaningful AST Node.\n     * <p>\n     * For example, comments at the end of methods (immediately before the parenthesis)\n     * or at the end of CompilationUnit are orphan comments.\n     * <p>\n     * When more than one comment preceeds a statement, the one immediately preceding it\n     * it is associated with the statements, while the others are orphans.\n     * <p>\n     * Changes to this list are not persisted.\n     *\n     * @return all comments that cannot be attributed to a concept\n     */\n    public List<Comment> getOrphanComments() {\n        return new LinkedList<>(orphanComments);\n    }\n\n    /**\n     * This is the list of Comment which are contained in the Node either because\n     * they are properly associated to one of its children or because they are floating\n     * around inside the Node\n     *\n     * @return all Comments within the node as a list\n     */\n    public List<Comment> getAllContainedComments() {\n        List<Comment> comments = new LinkedList<>();\n        comments.addAll(getOrphanComments());\n        for (Node child : getChildNodes()) {\n            child.getComment().ifPresent(comments::add);\n            comments.addAll(child.getAllContainedComments());\n        }\n        return comments;\n    }\n\n    /**\n     * Assign a new parent to this node, removing it\n     * from the list of children of the previous parent, if any.\n     *\n     * @param newParentNode node to be set as parent\n     */\n    @Override\n    public Node setParentNode(Node newParentNode) {\n        if (newParentNode == parentNode) {\n            return this;\n        }\n        observers.forEach(o -> o.parentChange(this, parentNode, newParentNode));\n        // remove from old parent, if any\n        if (parentNode != null) {\n            final List<Node> parentChildNodes = parentNode.childNodes;\n            for (int i = 0; i < parentChildNodes.size(); i++) {\n                if (parentChildNodes.get(i) == this) {\n                    parentChildNodes.remove(i);\n                }\n            }\n        }\n        parentNode = newParentNode;\n        // add to new parent, if any\n        if (parentNode != null) {\n            parentNode.childNodes.add(this);\n        }\n        return this;\n    }\n\n    protected void setAsParentNodeOf(Node childNode) {\n        if (childNode != null) {\n            childNode.setParentNode(getParentNodeForChildren());\n        }\n    }\n\n    /**\n     * @deprecated Use {@link Position#ABSOLUTE_BEGIN_LINE}\n     */\n    @Deprecated\n    public static final int ABSOLUTE_BEGIN_LINE = Position.ABSOLUTE_BEGIN_LINE;\n\n    /**\n     * @deprecated Use {@link Position#ABSOLUTE_END_LINE}\n     */\n    @Deprecated\n    public static final int ABSOLUTE_END_LINE = Position.ABSOLUTE_END_LINE;\n\n    public void tryAddImportToParentCompilationUnit(Class<?> clazz) {\n        findAncestor(CompilationUnit.class).ifPresent(p -> p.addImport(clazz));\n    }\n\n    /**\n     * Recursively finds all nodes of a certain type.\n     *\n     * @param clazz the type of node to find.\n     * @deprecated use {@link Node#findAll(Class)} but be aware that findAll also considers the initial node.\n     */\n    @Deprecated\n    public <N extends Node> List<N> getChildNodesByType(Class<N> clazz) {\n        List<N> nodes = new ArrayList<>();\n        for (Node child : getChildNodes()) {\n            if (clazz.isInstance(child)) {\n                nodes.add(clazz.cast(child));\n            }\n            nodes.addAll(child.getChildNodesByType(clazz));\n        }\n        return nodes;\n    }\n\n    /**\n     * @deprecated use {@link Node#findAll(Class)} but be aware that findAll also considers the initial node.\n     */\n    @Deprecated\n    public <N extends Node> List<N> getNodesByType(Class<N> clazz) {\n        return getChildNodesByType(clazz);\n    }\n\n    /**\n     * Gets data for this node using the given key.\n     *\n     * @param <M> The type of the data.\n     * @param key The key for the data\n     * @return The data.\n     * @throws IllegalStateException if the key was not set in this node.\n     * @see Node#containsData(DataKey)\n     * @see DataKey\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <M> M getData(final DataKey<M> key) {\n        if (data == null) {\n            throw new IllegalStateException(\"No data of this type found. Use containsData to check for this first.\");\n        }\n        M value = (M) data.get(key);\n        if (value == null) {\n            throw new IllegalStateException(\"No data of this type found. Use containsData to check for this first.\");\n        }\n        return value;\n    }\n\n    /**\n     * This method was added to support the clone method.\n     *\n     * @return all known data keys.\n     */\n    public Set<DataKey<?>> getDataKeys() {\n        if (data == null) {\n            return emptySet();\n        }\n        return data.keySet();\n    }\n\n    /**\n     * Sets data for this node using the given key.\n     * For information on creating DataKey, see {@link DataKey}.\n     *\n     * @param <M>    The type of data\n     * @param key    The singleton key for the data\n     * @param object The data object\n     * @see DataKey\n     */\n    public <M> void setData(DataKey<M> key, M object) {\n        if (data == null) {\n            data = new IdentityHashMap<>();\n        }\n        data.put(key, object);\n    }\n\n    /**\n     * @return does this node have data for this key?\n     * @see DataKey\n     */\n    public boolean containsData(DataKey<?> key) {\n        if (data == null) {\n            return false;\n        }\n        return data.containsKey(key);\n    }\n\n    /**\n     * Remove data by key.\n     *\n     * @see DataKey\n     */\n    public void removeData(DataKey<?> key) {\n        if (data != null) {\n            data.remove(key);\n        }\n    }\n\n    /**\n     * Try to remove this node from the parent\n     *\n     * @return true if removed, false if it is a required property of the parent, or if the parent isn't set.\n     * @throws RuntimeException if it fails in an unexpected way\n     */\n    public boolean remove() {\n        if (parentNode == null) {\n            return false;\n        }\n        return parentNode.remove(this);\n    }\n\n    /**\n     * Try to replace this node in the parent with the supplied node.\n     *\n     * @return true if removed, or if the parent isn't set.\n     * @throws RuntimeException if it fails in an unexpected way\n     */\n    public boolean replace(Node node) {\n        if (parentNode == null) {\n            return false;\n        }\n        return parentNode.replace(this, node);\n    }\n\n    /**\n     * Forcibly removes this node from the AST.\n     * If it cannot be removed from the parent with remove(),\n     * it will try to remove its parent instead,\n     * until it finds a node that can be removed,\n     * or no parent can be found.\n     * <p>\n     * Since everything at CompilationUnit level is removable,\n     * this method will only (silently) fail when the node is in a detached AST fragment.\n     */\n    public void removeForced() {\n        if (!remove()) {\n            getParentNode().ifPresent(Node::remove);\n        }\n    }\n\n    @Override\n    public Node getParentNodeForChildren() {\n        return this;\n    }\n\n    protected void setAsParentNodeOf(NodeList<? extends Node> list) {\n        if (list != null) {\n            list.setParentNode(getParentNodeForChildren());\n        }\n    }\n\n    public <P> void notifyPropertyChange(ObservableProperty property, P oldValue, P newValue) {\n        this.observers.forEach(o -> o.propertyChange(this, property, oldValue, newValue));\n    }\n\n    @Override\n    public void unregister(AstObserver observer) {\n        this.observers.remove(observer);\n    }\n\n    @Override\n    public void register(AstObserver observer) {\n        this.observers.add(observer);\n    }\n\n    /**\n     * Register a new observer for the given node. Depending on the mode specified also descendants, existing\n     * and new, could be observed. For more details see <i>ObserverRegistrationMode</i>.\n     */\n    public void register(AstObserver observer, ObserverRegistrationMode mode) {\n        if (mode == null) {\n            throw new IllegalArgumentException(\"Mode should be not null\");\n        }\n        switch(mode) {\n            case JUST_THIS_NODE:\n                register(observer);\n                break;\n            case THIS_NODE_AND_EXISTING_DESCENDANTS:\n                registerForSubtree(observer);\n                break;\n            case SELF_PROPAGATING:\n                registerForSubtree(PropagatingAstObserver.transformInPropagatingObserver(observer));\n                break;\n            default:\n                throw new UnsupportedOperationException(\"This mode is not supported: \" + mode);\n        }\n    }\n\n    /**\n     * Register the observer for the current node and all the contained node and nodelists, recursively.\n     */\n    public void registerForSubtree(AstObserver observer) {\n        register(observer);\n        this.getChildNodes().forEach(c -> c.registerForSubtree(observer));\n        for (PropertyMetaModel property : getMetaModel().getAllPropertyMetaModels()) {\n            if (property.isNodeList()) {\n                NodeList<?> nodeList = (NodeList<?>) property.getValue(this);\n                if (nodeList != null)\n                    nodeList.register(observer);\n            }\n        }\n    }\n\n    @Override\n    public boolean isRegistered(AstObserver observer) {\n        return this.observers.contains(observer);\n    }\n\n    @Generated(\"com.github.javaparser.generator.core.node.RemoveMethodGenerator\")\n    public boolean remove(Node node) {\n        if (node == null)\n            return false;\n        if (comment != null) {\n            if (node == comment) {\n                removeComment();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Generated(\"com.github.javaparser.generator.core.node.RemoveMethodGenerator\")\n    public Node removeComment() {\n        return setComment((Comment) null);\n    }\n\n    @Override\n    @Generated(\"com.github.javaparser.generator.core.node.CloneGenerator\")\n    public Node clone() {\n        return (Node) accept(new CloneVisitor(), null);\n    }\n\n    /**\n     * @return get JavaParser specific node introspection information.\n     */\n    @Generated(\"com.github.javaparser.generator.core.node.GetMetaModelGenerator\")\n    public NodeMetaModel getMetaModel() {\n        return JavaParserMetaModel.nodeMetaModel;\n    }\n\n    /**\n     * @return whether this node was successfully parsed or not.\n     * If it was not, only the range and tokenRange fields will be valid.\n     */\n    public Parsedness getParsed() {\n        return parsed;\n    }\n\n    /**\n     * Used by the parser to flag unparsable nodes.\n     */\n    public Node setParsed(Parsedness parsed) {\n        this.parsed = parsed;\n        return this;\n    }\n\n    @Generated(\"com.github.javaparser.generator.core.node.ReplaceMethodGenerator\")\n    public boolean replace(Node node, Node replacementNode) {\n        if (node == null)\n            return false;\n        if (comment != null) {\n            if (node == comment) {\n                setComment((Comment) replacementNode);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Finds the root node of this AST by finding the topmost parent.\n     */\n    public Node findRootNode() {\n        Node n = this;\n        while (n.getParentNode().isPresent()) {\n            n = n.getParentNode().get();\n        }\n        return n;\n    }\n\n    /**\n     * @return the containing CompilationUnit, or empty if this node is not inside a compilation unit.\n     */\n    public Optional<CompilationUnit> findCompilationUnit() {\n        Node rootNode = findRootNode();\n        if (rootNode instanceof CompilationUnit) {\n            return Optional.of((CompilationUnit) rootNode);\n        }\n        return Optional.empty();\n    }\n\n    public LineSeparator getLineEndingStyleOrDefault(LineSeparator defaultLineSeparator) {\n        if (getLineEndingStyle().isStandardEol()) {\n            return getLineEndingStyle();\n        }\n        return defaultLineSeparator;\n    }\n\n    public LineSeparator getLineEndingStyle() {\n        Node current = this;\n        // First check this node\n        if (current.containsData(Node.LINE_SEPARATOR_KEY)) {\n            LineSeparator lineSeparator = current.getData(Node.LINE_SEPARATOR_KEY);\n            return lineSeparator;\n        }\n        // Then check parent/ancestor nodes\n        while (current.getParentNode().isPresent()) {\n            current = current.getParentNode().get();\n            if (current.containsData(Node.LINE_SEPARATOR_KEY)) {\n                return current.getData(Node.LINE_SEPARATOR_KEY);\n            }\n        }\n        // Default to the system line separator if it's not already set within the parsed node/code.\n        return LineSeparator.SYSTEM;\n    }\n\n    protected SymbolResolver getSymbolResolver() {\n        return findCompilationUnit().map(cu -> {\n            if (cu.containsData(SYMBOL_RESOLVER_KEY)) {\n                return cu.getData(SYMBOL_RESOLVER_KEY);\n            } else {\n                throw new IllegalStateException(\"Symbol resolution not configured: to configure consider setting a SymbolResolver in the ParserConfiguration\");\n            }\n        }).orElseThrow(() -> new IllegalStateException(\"The node is not inserted in a CompilationUnit\"));\n    }\n\n    // We need to expose it because we will need to use it to inject the SymbolSolver\n    public static final DataKey<SymbolResolver> SYMBOL_RESOLVER_KEY = new DataKey<SymbolResolver>() {\n    };\n\n    public static final DataKey<LineSeparator> LINE_SEPARATOR_KEY = new DataKey<LineSeparator>() {\n    };\n\n    public enum TreeTraversal {\n\n        PREORDER, BREADTHFIRST, POSTORDER, PARENTS, DIRECT_CHILDREN\n    }\n\n    private Iterator<Node> treeIterator(TreeTraversal traversal) {\n        switch(traversal) {\n            case BREADTHFIRST:\n                return new BreadthFirstIterator(this);\n            case POSTORDER:\n                return new PostOrderIterator(this);\n            case PREORDER:\n                return new PreOrderIterator(this);\n            case DIRECT_CHILDREN:\n                return new DirectChildrenIterator(this);\n            case PARENTS:\n                return new ParentsVisitor(this);\n            default:\n                throw new IllegalArgumentException(\"Unknown traversal choice.\");\n        }\n    }\n\n    private Iterable<Node> treeIterable(TreeTraversal traversal) {\n        return () -> treeIterator(traversal);\n    }\n\n    /**\n     * Make a stream of nodes using traversal algorithm \"traversal\".\n     */\n    public Stream<Node> stream(TreeTraversal traversal) {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(treeIterator(traversal), NONNULL | DISTINCT), false);\n    }\n\n    /**\n     * Make a stream of nodes using pre-order traversal.\n     */\n    public Stream<Node> stream() {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(treeIterator(PREORDER), NONNULL | DISTINCT), false);\n    }\n\n    /**\n     * Walks the AST, calling the consumer for every node, with traversal algorithm \"traversal\".\n     * <br>This is the most general walk method. All other walk and findAll methods are based on this.\n     */\n    public void walk(TreeTraversal traversal, Consumer<Node> consumer) {\n        // Could be implemented as a call to the above walk method, but this is a little more efficient.\n        for (Node node : treeIterable(traversal)) {\n            consumer.accept(node);\n        }\n    }\n\n    /**\n     * Walks the AST, calling the consumer for every node with pre-order traversal.\n     */\n    public void walk(Consumer<Node> consumer) {\n        walk(PREORDER, consumer);\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, calling the consumer for every node of type \"nodeType\".\n     */\n    public <T extends Node> void walk(Class<T> nodeType, Consumer<T> consumer) {\n        walk(TreeTraversal.PREORDER, node -> {\n            if (nodeType.isAssignableFrom(node.getClass())) {\n                consumer.accept(nodeType.cast(node));\n            }\n        });\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning all nodes of type \"nodeType\".\n     */\n    public <T extends Node> List<T> findAll(Class<T> nodeType) {\n        final List<T> found = new ArrayList<>();\n        walk(nodeType, found::add);\n        return found;\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning all nodes of type \"nodeType\" that match the predicate.\n     */\n    public <T extends Node> List<T> findAll(Class<T> nodeType, Predicate<T> predicate) {\n        final List<T> found = new ArrayList<>();\n        walk(nodeType, n -> {\n            if (predicate.test(n))\n                found.add(n);\n        });\n        return found;\n    }\n\n    /**\n     * Walks the AST, applying the function for every node, with traversal algorithm \"traversal\". If the function\n     * returns something else than null, the traversal is stopped and the function result is returned. <br>This is the\n     * most general findFirst method. All other findFirst methods are based on this.\n     */\n    public <T> Optional<T> findFirst(TreeTraversal traversal, Function<Node, Optional<T>> consumer) {\n        for (Node node : treeIterable(traversal)) {\n            final Optional<T> result = consumer.apply(node);\n            if (result.isPresent()) {\n                return result;\n            }\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning the first node of type \"nodeType\" or empty() if none is found.\n     */\n    public <N extends Node> Optional<N> findFirst(Class<N> nodeType) {\n        return findFirst(TreeTraversal.PREORDER, node -> {\n            if (nodeType.isAssignableFrom(node.getClass())) {\n                return Optional.of(nodeType.cast(node));\n            }\n            return Optional.empty();\n        });\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning the first node of type \"nodeType\" that matches \"predicate\" or empty() if none is\n     * found.\n     */\n    public <N extends Node> Optional<N> findFirst(Class<N> nodeType, Predicate<N> predicate) {\n        return findFirst(TreeTraversal.PREORDER, node -> {\n            if (nodeType.isAssignableFrom(node.getClass())) {\n                final N castNode = nodeType.cast(node);\n                if (predicate.test(castNode)) {\n                    return Optional.of(castNode);\n                }\n            }\n            return Optional.empty();\n        });\n    }\n\n    /**\n     * Determines whether this node is an ancestor of the given node. A node is <i>not</i> an ancestor of itself.\n     *\n     * @param descendant the node for which to determine whether it has this node as an ancestor.\n     * @return {@code true} if this node is an ancestor of the given node, and {@code false} otherwise.\n     * @see HasParentNode#isDescendantOf(Node)\n     */\n    public boolean isAncestorOf(Node descendant) {\n        return this != descendant && findFirst(Node.class, n -> n == descendant).isPresent();\n    }\n\n    /**\n     * Performs a breadth-first node traversal starting with a given node.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\">Breadth-first traversal</a>\n     */\n    public static class BreadthFirstIterator implements Iterator<Node> {\n\n        private final Queue<Node> queue = new LinkedList<>();\n\n        public BreadthFirstIterator(Node node) {\n            queue.add(node);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !queue.isEmpty();\n        }\n\n        @Override\n        public Node next() {\n            Node next = queue.remove();\n            queue.addAll(next.getChildNodes());\n            return next;\n        }\n    }\n\n    /**\n     * Performs a simple traversal over all nodes that have the passed node as their parent.\n     */\n    public static class DirectChildrenIterator implements Iterator<Node> {\n\n        private final Iterator<Node> childrenIterator;\n\n        public DirectChildrenIterator(Node node) {\n            childrenIterator = new ArrayList<>(node.getChildNodes()).iterator();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return childrenIterator.hasNext();\n        }\n\n        @Override\n        public Node next() {\n            return childrenIterator.next();\n        }\n    }\n\n    /**\n     * Iterates over the parent of the node, then the parent's parent, then the parent's parent's parent, until running\n     * out of parents.\n     */\n    public static class ParentsVisitor implements Iterator<Node> {\n\n        private Node node;\n\n        public ParentsVisitor(Node node) {\n            this.node = node;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return node.getParentNode().isPresent();\n        }\n\n        @Override\n        public Node next() {\n            node = node.getParentNode().orElse(null);\n            return node;\n        }\n    }\n\n    /**\n     * Performs a pre-order (or depth-first) node traversal starting with a given node.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Pre-order\">Pre-order traversal</a>\n     */\n    public static class PreOrderIterator implements Iterator<Node> {\n\n        private final Stack<Node> stack = new Stack<>();\n\n        public PreOrderIterator(Node node) {\n            stack.add(node);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !stack.isEmpty();\n        }\n\n        @Override\n        public Node next() {\n            Node next = stack.pop();\n            List<Node> children = next.getChildNodes();\n            for (int i = children.size() - 1; i >= 0; i--) {\n                stack.add(children.get(i));\n            }\n            return next;\n        }\n    }\n\n    /**\n     * Performs a post-order (or leaves-first) node traversal starting with a given node.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Post-order\">Post-order traversal</a>\n     */\n    public static class PostOrderIterator implements Iterator<Node> {\n\n        private final Stack<List<Node>> nodesStack = new Stack<>();\n\n        private final Stack<Integer> cursorStack = new Stack<>();\n\n        private final Node root;\n\n        private boolean hasNext = true;\n\n        public PostOrderIterator(Node root) {\n            this.root = root;\n            fillStackToLeaf(root);\n        }\n\n        private void fillStackToLeaf(Node node) {\n            while (true) {\n                List<Node> childNodes = new ArrayList<>(node.getChildNodes());\n                if (childNodes.isEmpty()) {\n                    break;\n                }\n                nodesStack.push(childNodes);\n                cursorStack.push(0);\n                node = childNodes.get(0);\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            return hasNext;\n        }\n\n        @Override\n        public Node next() {\n            final List<Node> nodes = nodesStack.peek();\n            final int cursor = cursorStack.peek();\n            final boolean levelHasNext = cursor < nodes.size();\n            if (levelHasNext) {\n                Node node = nodes.get(cursor);\n                fillStackToLeaf(node);\n                return nextFromLevel();\n            } else {\n                nodesStack.pop();\n                cursorStack.pop();\n                hasNext = !nodesStack.empty();\n                if (hasNext) {\n                    return nextFromLevel();\n                }\n                return root;\n            }\n        }\n\n        private Node nextFromLevel() {\n            final List<Node> nodes = nodesStack.peek();\n            final int cursor = cursorStack.pop();\n            cursorStack.push(cursor + 1);\n            return nodes.get(cursor);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract And Move Method", "description": "Extract And Move Method\tpublic getWidth() : int extracted from private calculateIndentWithAlignTo(column int) : String in class com.github.javaparser.printer.SourcePrinter & moved to class com.github.javaparser.printer.configuration.Indentation.IndentType", "diffLocations": [{"filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java", "startLine": 87, "endLine": 129, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java", "startLine": 87, "endLine": 129, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java", "startLine": 53, "endLine": 55, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private String calculateIndentWithAlignTo(int column) {\n        if (column < lastPrintedIndent.length()){\n            throw new IllegalStateException(\"Attempt to indent less than the previous indent.\");\n        }\n\n        StringBuilder newIndent = new StringBuilder(lastPrintedIndent);\n        switch (indentation.type) {\n            case SPACES:\n            case TABS_WITH_SPACE_ALIGN:\n                while (newIndent.length() < column) {\n                    newIndent.append(IndentType.SPACES.car);\n                }\n                break;\n\n            case TABS:\n                IndentType currentIndentType = indentation.type; \n                int logicalIndentLength = newIndent.length();\n                while ((logicalIndentLength + currentIndentType.width) <= column) {\n                    newIndent.insert(0, currentIndentType.car);\n                    logicalIndentLength += currentIndentType.width;\n                }\n                while (logicalIndentLength < column) {\n                    newIndent.append(IndentType.SPACES.car);\n                    logicalIndentLength++;\n                }\n                StringBuilder fullTab = new StringBuilder();\n                for(int i=0; i<currentIndentType.width; i++){\n                    fullTab.append(IndentType.SPACES.car);\n                }\n                String fullTabString = fullTab.toString();\n                if ((newIndent.length() >= currentIndentType.width)\n                        && newIndent.substring(newIndent.length() - currentIndentType.width).equals(fullTabString)) {\n                    int i = newIndent.indexOf(fullTabString);\n                    newIndent.replace(i, i + currentIndentType.width, currentIndentType.car.toString());\n                }\n                break;\n\n            default:\n                throw new AssertionError(\"Unhandled indent type\");\n        }\n\n        return newIndent.toString();\n    }", "filePathBefore": "javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java", "isPureRefactoring": true, "commitId": "b08e66263903837d53a688b5d12a758c8cdf167e", "packageNameBefore": "com.github.javaparser.printer", "classNameBefore": "com.github.javaparser.printer.SourcePrinter", "methodNameBefore": "com.github.javaparser.printer.SourcePrinter#calculateIndentWithAlignTo", "invokedMethod": "methodSignature: com.github.javaparser.printer.SourcePrinter#toString\n methodBody: public String toString() {\nreturn buf.toString();\n}\nmethodSignature: com.github.javaparser.printer.SourcePrinter#append\n methodBody: private void append(String arg) {\nbuf.append(arg);\ncursor=cursor.withColumn(cursor.column + arg.length());\n}", "classSignatureBefore": "public class SourcePrinter ", "methodNameBeforeSet": ["com.github.javaparser.printer.SourcePrinter#calculateIndentWithAlignTo"], "classNameBeforeSet": ["com.github.javaparser.printer.SourcePrinter"], "classSignatureBeforeSet": ["public class SourcePrinter "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer;\n\nimport java.util.Deque;\nimport java.util.LinkedList;\n\nimport com.github.javaparser.Position;\nimport com.github.javaparser.printer.PrettyPrinterConfiguration.IndentType;\nimport com.github.javaparser.printer.PrettyPrinterConfiguration.Indentation;\nimport com.github.javaparser.utils.Utils;\n\n/**\n * A support class for code that outputs formatted source code.\n */\npublic class SourcePrinter {\n    private final String endOfLineCharacter;\n    private final Indentation indentation;\n\n    private final Deque<String> indents = new LinkedList<>();\n    private final Deque<String> reindentedIndents = new LinkedList<>();\n    private String lastPrintedIndent = \"\";\n    private final StringBuilder buf = new StringBuilder();\n    private Position cursor = new Position(Position.FIRST_LINE, Position.FIRST_COLUMN - 1); // Start before the first column\n    private boolean indented = false;\n\n    SourcePrinter() {\n        this(new PrettyPrinterConfiguration());\n    }\n\n    SourcePrinter(final PrettyPrinterConfiguration configuration) {\n        indentation = configuration.getIndentation();\n        endOfLineCharacter = configuration.getEndOfLineCharacter();\n        indents.push(\"\");\n    }\n\n    /**\n     * Add the default indentation to the current indentation and push it on the indentation stack.\n     * Does not actually output anything.\n     */\n    public SourcePrinter indent() {\n        String currentIndent = indents.peek();\n        switch (indentation.type) {\n            case SPACES:\n            case TABS_WITH_SPACE_ALIGN:\n                indents.push(currentIndent + indentation.getIndent());\n                break;\n\n            case TABS:\n                indents.push(indentation.getIndent() + currentIndent);\n                break;\n\n            default:\n                throw new AssertionError(\"Unhandled indent type\");\n        }\n        return this;\n    }\n\n    /**\n     * Add to the current indentation until it is reaches \"column\" and push it on the indentation stack.\n     * Does not actually output anything.\n     */\n    public SourcePrinter indentWithAlignTo(int column) {\n        indents.push(calculateIndentWithAlignTo(column));\n        return this;\n    }\n\n    private String calculateIndentWithAlignTo(int column) {\n        if (column < lastPrintedIndent.length()){\n            throw new IllegalStateException(\"Attempt to indent less than the previous indent.\");\n        }\n\n        StringBuilder newIndent = new StringBuilder(lastPrintedIndent);\n        switch (indentation.type) {\n            case SPACES:\n            case TABS_WITH_SPACE_ALIGN:\n                while (newIndent.length() < column) {\n                    newIndent.append(IndentType.SPACES.car);\n                }\n                break;\n\n            case TABS:\n                IndentType currentIndentType = indentation.type; \n                int logicalIndentLength = newIndent.length();\n                while ((logicalIndentLength + currentIndentType.width) <= column) {\n                    newIndent.insert(0, currentIndentType.car);\n                    logicalIndentLength += currentIndentType.width;\n                }\n                while (logicalIndentLength < column) {\n                    newIndent.append(IndentType.SPACES.car);\n                    logicalIndentLength++;\n                }\n                StringBuilder fullTab = new StringBuilder();\n                for(int i=0; i<currentIndentType.width; i++){\n                    fullTab.append(IndentType.SPACES.car);\n                }\n                String fullTabString = fullTab.toString();\n                if ((newIndent.length() >= currentIndentType.width)\n                        && newIndent.substring(newIndent.length() - currentIndentType.width).equals(fullTabString)) {\n                    int i = newIndent.indexOf(fullTabString);\n                    newIndent.replace(i, i + currentIndentType.width, currentIndentType.car.toString());\n                }\n                break;\n\n            default:\n                throw new AssertionError(\"Unhandled indent type\");\n        }\n\n        return newIndent.toString();\n    }\n\n    /**\n     * Pop the last indentation of the indentation stack.\n     * Does not actually output anything.\n     */\n    public SourcePrinter unindent() {\n        if (indents.isEmpty()) {\n            // Since we start out with an empty indent on the stack, this will only occur\n            // the second time we over-unindent.\n            throw new IllegalStateException(\"Indent/unindent calls are not well-balanced.\");\n        }\n        indents.pop();\n        return this;\n    }\n\n    private void append(String arg) {\n        buf.append(arg);\n        cursor = cursor.withColumn(cursor.column + arg.length());\n    }\n\n    /**\n     * Append the source string passed as argument to the buffer.\n     * If this is being appended at the beginning of a line, performs indentation first.\n     * <p>\n     * The source line to be printed should not contain newline/carriage-return characters;\n     * use {@link #println(String)} to automatically append a newline at the end of the source string.\n     * If the source line passed as argument contains newline/carriage-return characters would\n     * impredictably affect a correct computation of the current {@link #getCursor()} position.\n     *\n     * @param arg source line to be printed (should not contain newline/carriage-return characters)\n     * @return this instance, for nesting calls to method as fluent interface\n     * @see SourcePrinter#println(String)\n     */\n    public SourcePrinter print(final String arg) {\n        if (!indented) {\n            lastPrintedIndent = indents.peek();\n            append(lastPrintedIndent);\n            indented = true;\n        }\n        append(arg);\n        return this;\n    }\n\n    /**\n     * Append the source string passed as argument to the buffer, then append a newline.\n     * If this is being appended at the beginning of a line, performs indentation first.\n     * <p>\n     * The source line to be printed should not contain newline/carriage-return characters.\n     * If the source line passed as argument contains newline/carriage-return characters would\n     * impredictably affect a correct computation of the current {@link #getCursor()} position.\n     *\n     * @param arg source line to be printed (should not contain newline/carriage-return characters)\n     * @return this instance, for nesting calls to method as fluent interface\n     */\n    public SourcePrinter println(final String arg) {\n        print(arg);\n        println();\n        return this;\n    }\n\n    /**\n     * Append a newline to the buffer.\n     *\n     * @return this instance, for nesting calls to method as fluent interface\n     */\n    public SourcePrinter println() {\n        buf.append(endOfLineCharacter);\n        cursor = new Position(cursor.line + 1, Position.FIRST_COLUMN - 1); // Start before the first column\n        indented = false;\n        return this;\n    }\n\n    /**\n     * Return the current cursor position (line, column) in the source printer buffer.\n     * <p>\n     * Please notice in order to guarantee a correct computation of the cursor position,\n     * this printer expect the contracts of the methods {@link #print(String)} and {@link #println(String)}\n     * has been respected through all method calls, meaning the source string passed as argument to those method\n     * calls did not contain newline/carriage-return characters.\n     *\n     * @return the current cursor position (line, column).\n     */\n    public Position getCursor() {\n        return cursor;\n    }\n\n    /**\n     * @return the currently printed source code.\n     * @deprecated use toString()\n     */\n    @Deprecated\n    public String getSource() {\n        return toString();\n    }\n\n    /**\n     * @return the currently printed source code.\n     */\n    @Override\n    public String toString() {\n        return buf.toString();\n    }\n\n    /**\n     * Changes all EOL characters in \"content\" to the EOL character this SourcePrinter is using.\n     */\n    public String normalizeEolInTextBlock(String content) {\n        return Utils.normalizeEolInTextBlock(content, endOfLineCharacter);\n    }\n\n    /**\n     * Set the top-most indent to the column the cursor is currently in, can be undone with\n     * {@link #reindentToPreviousLevel()}. Does not actually output anything.\n     */\n    public void reindentWithAlignToCursor() {\n        String newIndent = calculateIndentWithAlignTo(cursor.column);\n        reindentedIndents.push(indents.pop());\n        indents.push(newIndent);\n    }\n\n    /**\n     * Set the top-most indent to the column the cursor was before the last {@link #reindentWithAlignToCursor()} call.\n     * Does not actually output anything.\n     */\n    public void reindentToPreviousLevel() {\n        if (reindentedIndents.isEmpty()) {\n            throw new IllegalStateException(\"Reindent calls are not well-balanced.\");\n        }\n        indents.pop();\n        indents.push(reindentedIndents.pop());\n    }\n\n    /**\n     * Adds an indent to the top of the stack that is a copy of the current top indent.\n     * With this you announce \"I'm going to indent the next line(s)\" but not how far yet.\n     * Once you do know, you can pop this indent (\"unindent\") and indent to the right column.\n     * (Does not actually output anything.)\n     */\n    public void duplicateIndent() {\n        indents.push(indents.peek());\n    }\n}\n", "filePathAfter": "javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java", "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer;\n\nimport java.util.Deque;\nimport java.util.LinkedList;\n\nimport com.github.javaparser.Position;\nimport com.github.javaparser.printer.configuration.Indentation;\nimport com.github.javaparser.printer.configuration.Indentation.IndentType;\nimport com.github.javaparser.utils.Utils;\n\n/**\n * A support class for code that outputs formatted source code.\n */\npublic class SourcePrinter {\n    private final String endOfLineCharacter;\n    private final Indentation indentation;\n\n    private final Deque<String> indents = new LinkedList<>();\n    private final Deque<String> reindentedIndents = new LinkedList<>();\n    private String lastPrintedIndent = \"\";\n    private final StringBuilder buf = new StringBuilder();\n    private Position cursor = new Position(Position.FIRST_LINE, Position.FIRST_COLUMN - 1); // Start before the first column\n    private boolean indented = false;\n\n    SourcePrinter() {\n        this(new PrettyPrinterConfiguration());\n    }\n\n    SourcePrinter(final PrettyPrinterConfiguration configuration) {\n        indentation = configuration.getIndentation();\n        endOfLineCharacter = configuration.getEndOfLineCharacter();\n        indents.push(\"\");\n    }\n\n    /**\n     * Add the default indentation to the current indentation and push it on the indentation stack.\n     * Does not actually output anything.\n     */\n    public SourcePrinter indent() {\n        String currentIndent = indents.peek();\n        switch (indentation.getType()) {\n            case SPACES:\n            case TABS_WITH_SPACE_ALIGN:\n                indents.push(currentIndent + indentation.getIndent());\n                break;\n\n            case TABS:\n                indents.push(indentation.getIndent() + currentIndent);\n                break;\n\n            default:\n                throw new AssertionError(\"Unhandled indent type\");\n        }\n        return this;\n    }\n\n    /**\n     * Add to the current indentation until it is reaches \"column\" and push it on the indentation stack.\n     * Does not actually output anything.\n     */\n    public SourcePrinter indentWithAlignTo(int column) {\n        indents.push(calculateIndentWithAlignTo(column));\n        return this;\n    }\n\n    private String calculateIndentWithAlignTo(int column) {\n        if (column < lastPrintedIndent.length()){\n            throw new IllegalStateException(\"Attempt to indent less than the previous indent.\");\n        }\n\n        StringBuilder newIndent = new StringBuilder(lastPrintedIndent);\n        switch (indentation.getType()) {\n            case SPACES:\n            case TABS_WITH_SPACE_ALIGN:\n                while (newIndent.length() < column) {\n                    newIndent.append(IndentType.SPACES.getCar());\n                }\n                break;\n\n            case TABS:\n                IndentType currentIndentType = indentation.getType(); \n                int logicalIndentLength = newIndent.length();\n                while ((logicalIndentLength + currentIndentType.getWidth()) <= column) {\n                    newIndent.insert(0, currentIndentType.getCar());\n                    logicalIndentLength += currentIndentType.getWidth();\n                }\n                while (logicalIndentLength < column) {\n                    newIndent.append(IndentType.SPACES.getCar());\n                    logicalIndentLength++;\n                }\n                StringBuilder fullTab = new StringBuilder();\n                for(int i=0; i<currentIndentType.getWidth(); i++){\n                    fullTab.append(IndentType.SPACES.getCar());\n                }\n                String fullTabString = fullTab.toString();\n                if ((newIndent.length() >= currentIndentType.getWidth())\n                        && newIndent.substring(newIndent.length() - currentIndentType.getWidth()).equals(fullTabString)) {\n                    int i = newIndent.indexOf(fullTabString);\n                    newIndent.replace(i, i + currentIndentType.getWidth(), currentIndentType.getCar().toString());\n                }\n                break;\n\n            default:\n                throw new AssertionError(\"Unhandled indent type\");\n        }\n\n        return newIndent.toString();\n    }\n\n    /**\n     * Pop the last indentation of the indentation stack.\n     * Does not actually output anything.\n     */\n    public SourcePrinter unindent() {\n        if (indents.isEmpty()) {\n            // Since we start out with an empty indent on the stack, this will only occur\n            // the second time we over-unindent.\n            throw new IllegalStateException(\"Indent/unindent calls are not well-balanced.\");\n        }\n        indents.pop();\n        return this;\n    }\n\n    private void append(String arg) {\n        buf.append(arg);\n        cursor = cursor.withColumn(cursor.column + arg.length());\n    }\n\n    /**\n     * Append the source string passed as argument to the buffer.\n     * If this is being appended at the beginning of a line, performs indentation first.\n     * <p>\n     * The source line to be printed should not contain newline/carriage-return characters;\n     * use {@link #println(String)} to automatically append a newline at the end of the source string.\n     * If the source line passed as argument contains newline/carriage-return characters would\n     * impredictably affect a correct computation of the current {@link #getCursor()} position.\n     *\n     * @param arg source line to be printed (should not contain newline/carriage-return characters)\n     * @return this instance, for nesting calls to method as fluent interface\n     * @see SourcePrinter#println(String)\n     */\n    public SourcePrinter print(final String arg) {\n        if (!indented) {\n            lastPrintedIndent = indents.peek();\n            append(lastPrintedIndent);\n            indented = true;\n        }\n        append(arg);\n        return this;\n    }\n\n    /**\n     * Append the source string passed as argument to the buffer, then append a newline.\n     * If this is being appended at the beginning of a line, performs indentation first.\n     * <p>\n     * The source line to be printed should not contain newline/carriage-return characters.\n     * If the source line passed as argument contains newline/carriage-return characters would\n     * impredictably affect a correct computation of the current {@link #getCursor()} position.\n     *\n     * @param arg source line to be printed (should not contain newline/carriage-return characters)\n     * @return this instance, for nesting calls to method as fluent interface\n     */\n    public SourcePrinter println(final String arg) {\n        print(arg);\n        println();\n        return this;\n    }\n\n    /**\n     * Append a newline to the buffer.\n     *\n     * @return this instance, for nesting calls to method as fluent interface\n     */\n    public SourcePrinter println() {\n        buf.append(endOfLineCharacter);\n        cursor = new Position(cursor.line + 1, Position.FIRST_COLUMN - 1); // Start before the first column\n        indented = false;\n        return this;\n    }\n\n    /**\n     * Return the current cursor position (line, column) in the source printer buffer.\n     * <p>\n     * Please notice in order to guarantee a correct computation of the cursor position,\n     * this printer expect the contracts of the methods {@link #print(String)} and {@link #println(String)}\n     * has been respected through all method calls, meaning the source string passed as argument to those method\n     * calls did not contain newline/carriage-return characters.\n     *\n     * @return the current cursor position (line, column).\n     */\n    public Position getCursor() {\n        return cursor;\n    }\n\n    /**\n     * @return the currently printed source code.\n     * @deprecated use toString()\n     */\n    @Deprecated\n    public String getSource() {\n        return toString();\n    }\n\n    /**\n     * @return the currently printed source code.\n     */\n    @Override\n    public String toString() {\n        return buf.toString();\n    }\n\n    /**\n     * Changes all EOL characters in \"content\" to the EOL character this SourcePrinter is using.\n     */\n    public String normalizeEolInTextBlock(String content) {\n        return Utils.normalizeEolInTextBlock(content, endOfLineCharacter);\n    }\n\n    /**\n     * Set the top-most indent to the column the cursor is currently in, can be undone with\n     * {@link #reindentToPreviousLevel()}. Does not actually output anything.\n     */\n    public void reindentWithAlignToCursor() {\n        String newIndent = calculateIndentWithAlignTo(cursor.column);\n        reindentedIndents.push(indents.pop());\n        indents.push(newIndent);\n    }\n\n    /**\n     * Set the top-most indent to the column the cursor was before the last {@link #reindentWithAlignToCursor()} call.\n     * Does not actually output anything.\n     */\n    public void reindentToPreviousLevel() {\n        if (reindentedIndents.isEmpty()) {\n            throw new IllegalStateException(\"Reindent calls are not well-balanced.\");\n        }\n        indents.pop();\n        indents.push(reindentedIndents.pop());\n    }\n\n    /**\n     * Adds an indent to the top of the stack that is a copy of the current top indent.\n     * With this you announce \"I'm going to indent the next line(s)\" but not how far yet.\n     * Once you do know, you can pop this indent (\"unindent\") and indent to the right column.\n     * (Does not actually output anything.)\n     */\n    public void duplicateIndent() {\n        indents.push(indents.peek());\n    }\n}\n", "diffSourceCodeSet": ["indents.push(\"\");\n    }"], "invokedMethodSet": ["methodSignature: com.github.javaparser.printer.SourcePrinter#toString\n methodBody: public String toString() {\nreturn buf.toString();\n}", "methodSignature: com.github.javaparser.printer.SourcePrinter#append\n methodBody: private void append(String arg) {\nbuf.append(arg);\ncursor=cursor.withColumn(cursor.column + arg.length());\n}"], "sourceCodeAfterRefactoring": "private String calculateIndentWithAlignTo(int column) {\n        if (column < lastPrintedIndent.length()){\n            throw new IllegalStateException(\"Attempt to indent less than the previous indent.\");\n        }\n\n        StringBuilder newIndent = new StringBuilder(lastPrintedIndent);\n        switch (indentation.getType()) {\n            case SPACES:\n            case TABS_WITH_SPACE_ALIGN:\n                while (newIndent.length() < column) {\n                    newIndent.append(IndentType.SPACES.getCar());\n                }\n                break;\n\n            case TABS:\n                IndentType currentIndentType = indentation.getType(); \n                int logicalIndentLength = newIndent.length();\n                while ((logicalIndentLength + currentIndentType.getWidth()) <= column) {\n                    newIndent.insert(0, currentIndentType.getCar());\n                    logicalIndentLength += currentIndentType.getWidth();\n                }\n                while (logicalIndentLength < column) {\n                    newIndent.append(IndentType.SPACES.getCar());\n                    logicalIndentLength++;\n                }\n                StringBuilder fullTab = new StringBuilder();\n                for(int i=0; i<currentIndentType.getWidth(); i++){\n                    fullTab.append(IndentType.SPACES.getCar());\n                }\n                String fullTabString = fullTab.toString();\n                if ((newIndent.length() >= currentIndentType.getWidth())\n                        && newIndent.substring(newIndent.length() - currentIndentType.getWidth()).equals(fullTabString)) {\n                    int i = newIndent.indexOf(fullTabString);\n                    newIndent.replace(i, i + currentIndentType.getWidth(), currentIndentType.getCar().toString());\n                }\n                break;\n\n            default:\n                throw new AssertionError(\"Unhandled indent type\");\n        }\n\n        return newIndent.toString();\n    }\nindents.push(\"\");\n    }", "diffSourceCode": "    53:         indents.push(\"\");\n    54:     }\n    55: \n    87:     private String calculateIndentWithAlignTo(int column) {\n    88:         if (column < lastPrintedIndent.length()){\n    89:             throw new IllegalStateException(\"Attempt to indent less than the previous indent.\");\n    90:         }\n    91: \n    92:         StringBuilder newIndent = new StringBuilder(lastPrintedIndent);\n-   93:         switch (indentation.type) {\n+   93:         switch (indentation.getType()) {\n    94:             case SPACES:\n    95:             case TABS_WITH_SPACE_ALIGN:\n    96:                 while (newIndent.length() < column) {\n-   97:                     newIndent.append(IndentType.SPACES.car);\n+   97:                     newIndent.append(IndentType.SPACES.getCar());\n    98:                 }\n    99:                 break;\n   100: \n   101:             case TABS:\n-  102:                 IndentType currentIndentType = indentation.type; \n+  102:                 IndentType currentIndentType = indentation.getType(); \n   103:                 int logicalIndentLength = newIndent.length();\n-  104:                 while ((logicalIndentLength + currentIndentType.width) <= column) {\n-  105:                     newIndent.insert(0, currentIndentType.car);\n-  106:                     logicalIndentLength += currentIndentType.width;\n+  104:                 while ((logicalIndentLength + currentIndentType.getWidth()) <= column) {\n+  105:                     newIndent.insert(0, currentIndentType.getCar());\n+  106:                     logicalIndentLength += currentIndentType.getWidth();\n   107:                 }\n   108:                 while (logicalIndentLength < column) {\n-  109:                     newIndent.append(IndentType.SPACES.car);\n+  109:                     newIndent.append(IndentType.SPACES.getCar());\n   110:                     logicalIndentLength++;\n   111:                 }\n   112:                 StringBuilder fullTab = new StringBuilder();\n-  113:                 for(int i=0; i<currentIndentType.width; i++){\n-  114:                     fullTab.append(IndentType.SPACES.car);\n+  113:                 for(int i=0; i<currentIndentType.getWidth(); i++){\n+  114:                     fullTab.append(IndentType.SPACES.getCar());\n   115:                 }\n   116:                 String fullTabString = fullTab.toString();\n-  117:                 if ((newIndent.length() >= currentIndentType.width)\n-  118:                         && newIndent.substring(newIndent.length() - currentIndentType.width).equals(fullTabString)) {\n+  117:                 if ((newIndent.length() >= currentIndentType.getWidth())\n+  118:                         && newIndent.substring(newIndent.length() - currentIndentType.getWidth()).equals(fullTabString)) {\n   119:                     int i = newIndent.indexOf(fullTabString);\n-  120:                     newIndent.replace(i, i + currentIndentType.width, currentIndentType.car.toString());\n+  120:                     newIndent.replace(i, i + currentIndentType.getWidth(), currentIndentType.getCar().toString());\n   121:                 }\n   122:                 break;\n   123: \n   124:             default:\n   125:                 throw new AssertionError(\"Unhandled indent type\");\n   126:         }\n   127: \n   128:         return newIndent.toString();\n   129:     }\n", "uniqueId": "b08e66263903837d53a688b5d12a758c8cdf167e_87_129_53_55_87_129", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 26, "covered": 101}, "BRANCH": {"missed": 4, "covered": 13}, "LINE": {"missed": 5, "covered": 20}, "COMPLEXITY": {"missed": 4, "covered": 6}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To refactor the provided code, we will extract the logic that handles the indentation calculation into a separate static method. This method will be moved to the `PrettyPrinterConfiguration` class, as it seems to be related to the configuration of indentation types.\n\n### Step 1: Analyze the Code\nThe `calculateIndentWithAlignTo` method in the `SourcePrinter` class contains logic for calculating indentation based on the type of indentation (spaces, tabs, etc.). This logic can be encapsulated in a static method that takes the necessary parameters.\n\n### Step 2: Extract the Method\nWe will extract the entire logic of `calculateIndentWithAlignTo` into a new static method in the `PrettyPrinterConfiguration` class.\n\n### Step 3: Move the Method\nThe extracted method will be placed in the `PrettyPrinterConfiguration` class, which is already part of the project structure.\n\n### Step 4: Refactor the Original Method\nAfter moving the method, we will refactor the `calculateIndentWithAlignTo` method in the `SourcePrinter` class to call the new static method from `PrettyPrinterConfiguration`.\n\n### Target File Path\nThe target file path for the extracted method will be:\n```\njavaparser-core/src/main/java/com/github/javaparser/printer/PrettyPrinterConfiguration.java\n```\n\n### Extracted Method Code\nHere is the extracted method code that will be added to `PrettyPrinterConfiguration`:\n\n```java\npublic static String calculateIndentWithAlignTo(String lastPrintedIndent, Indentation indentation, int column) {\n    if (column < lastPrintedIndent.length()) {\n        throw new IllegalStateException(\"Attempt to indent less than the previous indent.\");\n    }\n\n    StringBuilder newIndent = new StringBuilder(lastPrintedIndent);\n    switch (indentation.type) {\n        case SPACES:\n        case TABS_WITH_SPACE_ALIGN:\n            while (newIndent.length() < column) {\n                newIndent.append(IndentType.SPACES.car);\n            }\n            break;\n\n        case TABS:\n            IndentType currentIndentType = indentation.type; \n            int logicalIndentLength = newIndent.length();\n            while ((logicalIndentLength + currentIndentType.width) <= column) {\n                newIndent.insert(0, currentIndentType.car);\n                logicalIndentLength += currentIndentType.width;\n            }\n            while (logicalIndentLength < column) {\n                newIndent.append(IndentType.SPACES.car);\n                logicalIndentLength++;\n            }\n            StringBuilder fullTab = new StringBuilder();\n            for(int i = 0; i < currentIndentType.width; i++) {\n                fullTab.append(IndentType.SPACES.car);\n            }\n            String fullTabString = fullTab.toString();\n            if ((newIndent.length() >= currentIndentType.width)\n                    && newIndent.substring(newIndent.length() - currentIndentType.width).equals(fullTabString)) {\n                int i = newIndent.indexOf(fullTabString);\n                newIndent.replace(i, i + currentIndentType.width, currentIndentType.car.toString());\n            }\n            break;\n\n        default:\n            throw new AssertionError(\"Unhandled indent type\");\n    }\n\n    return newIndent.toString();\n}\n```\n\n### Refactored Method Code\nHere is the refactored method code in the `SourcePrinter` class:\n\n```java\nprivate String calculateIndentWithAlignTo(int column) {\n    return PrettyPrinterConfiguration.calculateIndentWithAlignTo(lastPrintedIndent, indentation, column);\n}\n```\n\n### Final Output\nHere is the complete output as per the requested format:\n\n##########################\njavaparser-core/src/main/java/com/github/javaparser/printer/PrettyPrinterConfiguration.java\n##########################\npublic static String calculateIndentWithAlignTo(String lastPrintedIndent, Indentation indentation, int column) {\n    if (column < lastPrintedIndent.length()) {\n        throw new IllegalStateException(\"Attempt to indent less than the previous indent.\");\n    }\n\n    StringBuilder newIndent = new StringBuilder(lastPrintedIndent);\n    switch (indentation.type) {\n        case SPACES:\n        case TABS_WITH_SPACE_ALIGN:\n            while (newIndent.length() < column) {\n                newIndent.append(IndentType.SPACES.car);\n            }\n            break;\n\n        case TABS:\n            IndentType currentIndentType = indentation.type; \n            int logicalIndentLength = newIndent.length();\n            while ((logicalIndentLength + currentIndentType.width) <= column) {\n                newIndent.insert(0, currentIndentType.car);\n                logicalIndentLength += currentIndentType.width;\n            }\n            while (logicalIndentLength < column) {\n                newIndent.append(IndentType.SPACES.car);\n                logicalIndentLength++;\n            }\n            StringBuilder fullTab = new StringBuilder();\n            for(int i = 0; i < currentIndentType.width; i++) {\n                fullTab.append(IndentType.SPACES.car);\n            }\n            String fullTabString = fullTab.toString();\n            if ((newIndent.length() >= currentIndentType.width)\n                    && newIndent.substring(newIndent.length() - currentIndentType.width).equals(fullTabString)) {\n                int i = newIndent.indexOf(fullTabString);\n                newIndent.replace(i, i + currentIndentType.width, currentIndentType.car.toString());\n            }\n            break;\n\n        default:\n            throw new AssertionError(\"Unhandled indent type\");\n    }\n\n    return newIndent.toString();\n}\n##########################\nprivate String calculateIndentWithAlignTo(int column) {\n    return PrettyPrinterConfiguration.calculateIndentWithAlignTo(lastPrintedIndent, indentation, column);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate String calculateIndentWithAlignTo(int column) {\n        if (column < lastPrintedIndent.length()){\n            throw new IllegalStateException(\"Attempt to indent less than the previous indent.\");\n        }\n\n        StringBuilder newIndent = new StringBuilder(lastPrintedIndent);\n        switch (indentation.type) {\n            case SPACES:\n            case TABS_WITH_SPACE_ALIGN:\n                while (newIndent.length() < column) {\n                    newIndent.append(IndentType.SPACES.car);\n                }\n                break;\n\n            case TABS:\n                IndentType currentIndentType = indentation.type; \n                int logicalIndentLength = newIndent.length();\n                while ((logicalIndentLength + currentIndentType.width) <= column) {\n                    newIndent.insert(0, currentIndentType.car);\n                    logicalIndentLength += currentIndentType.width;\n                }\n                while (logicalIndentLength < column) {\n                    newIndent.append(IndentType.SPACES.car);\n                    logicalIndentLength++;\n                }\n                StringBuilder fullTab = new StringBuilder();\n                for(int i=0; i<currentIndentType.width; i++){\n                    fullTab.append(IndentType.SPACES.car);\n                }\n                String fullTabString = fullTab.toString();\n                if ((newIndent.length() >= currentIndentType.width)\n                        && newIndent.substring(newIndent.length() - currentIndentType.width).equals(fullTabString)) {\n                    int i = newIndent.indexOf(fullTabString);\n                    newIndent.replace(i, i + currentIndentType.width, currentIndentType.car.toString());\n                }\n                break;\n\n            default:\n                throw new AssertionError(\"Unhandled indent type\");\n        }\n\n        return newIndent.toString();\n    }\n\nClass content:\n/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer;\n\nimport java.util.Deque;\nimport java.util.LinkedList;\n\nimport com.github.javaparser.Position;\nimport com.github.javaparser.printer.PrettyPrinterConfiguration.IndentType;\nimport com.github.javaparser.printer.PrettyPrinterConfiguration.Indentation;\nimport com.github.javaparser.utils.Utils;\n\n/**\n * A support class for code that outputs formatted source code.\n */\npublic class SourcePrinter {\n    private final String endOfLineCharacter;\n    private final Indentation indentation;\n\n    private final Deque<String> indents = new LinkedList<>();\n    private final Deque<String> reindentedIndents = new LinkedList<>();\n    private String lastPrintedIndent = \"\";\n    private final StringBuilder buf = new StringBuilder();\n    private Position cursor = new Position(Position.FIRST_LINE, Position.FIRST_COLUMN - 1); // Start before the first column\n    private boolean indented = false;\n\n    SourcePrinter() {\n        this(new PrettyPrinterConfiguration());\n    }\n\n    SourcePrinter(final PrettyPrinterConfiguration configuration) {\n        indentation = configuration.getIndentation();\n        endOfLineCharacter = configuration.getEndOfLineCharacter();\n        indents.push(\"\");\n    }\n\n    /**\n     * Add the default indentation to the current indentation and push it on the indentation stack.\n     * Does not actually output anything.\n     */\n    public SourcePrinter indent() {\n        String currentIndent = indents.peek();\n        switch (indentation.type) {\n            case SPACES:\n            case TABS_WITH_SPACE_ALIGN:\n                indents.push(currentIndent + indentation.getIndent());\n                break;\n\n            case TABS:\n                indents.push(indentation.getIndent() + currentIndent);\n                break;\n\n            default:\n                throw new AssertionError(\"Unhandled indent type\");\n        }\n        return this;\n    }\n\n    /**\n     * Add to the current indentation until it is reaches \"column\" and push it on the indentation stack.\n     * Does not actually output anything.\n     */\n    public SourcePrinter indentWithAlignTo(int column) {\n        indents.push(calculateIndentWithAlignTo(column));\n        return this;\n    }\n\n    private String calculateIndentWithAlignTo(int column) {\n        if (column < lastPrintedIndent.length()){\n            throw new IllegalStateException(\"Attempt to indent less than the previous indent.\");\n        }\n\n        StringBuilder newIndent = new StringBuilder(lastPrintedIndent);\n        switch (indentation.type) {\n            case SPACES:\n            case TABS_WITH_SPACE_ALIGN:\n                while (newIndent.length() < column) {\n                    newIndent.append(IndentType.SPACES.car);\n                }\n                break;\n\n            case TABS:\n                IndentType currentIndentType = indentation.type; \n                int logicalIndentLength = newIndent.length();\n                while ((logicalIndentLength + currentIndentType.width) <= column) {\n                    newIndent.insert(0, currentIndentType.car);\n                    logicalIndentLength += currentIndentType.width;\n                }\n                while (logicalIndentLength < column) {\n                    newIndent.append(IndentType.SPACES.car);\n                    logicalIndentLength++;\n                }\n                StringBuilder fullTab = new StringBuilder();\n                for(int i=0; i<currentIndentType.width; i++){\n                    fullTab.append(IndentType.SPACES.car);\n                }\n                String fullTabString = fullTab.toString();\n                if ((newIndent.length() >= currentIndentType.width)\n                        && newIndent.substring(newIndent.length() - currentIndentType.width).equals(fullTabString)) {\n                    int i = newIndent.indexOf(fullTabString);\n                    newIndent.replace(i, i + currentIndentType.width, currentIndentType.car.toString());\n                }\n                break;\n\n            default:\n                throw new AssertionError(\"Unhandled indent type\");\n        }\n\n        return newIndent.toString();\n    }\n\n    /**\n     * Pop the last indentation of the indentation stack.\n     * Does not actually output anything.\n     */\n    public SourcePrinter unindent() {\n        if (indents.isEmpty()) {\n            // Since we start out with an empty indent on the stack, this will only occur\n            // the second time we over-unindent.\n            throw new IllegalStateException(\"Indent/unindent calls are not well-balanced.\");\n        }\n        indents.pop();\n        return this;\n    }\n\n    private void append(String arg) {\n        buf.append(arg);\n        cursor = cursor.withColumn(cursor.column + arg.length());\n    }\n\n    /**\n     * Append the source string passed as argument to the buffer.\n     * If this is being appended at the beginning of a line, performs indentation first.\n     * <p>\n     * The source line to be printed should not contain newline/carriage-return characters;\n     * use {@link #println(String)} to automatically append a newline at the end of the source string.\n     * If the source line passed as argument contains newline/carriage-return characters would\n     * impredictably affect a correct computation of the current {@link #getCursor()} position.\n     *\n     * @param arg source line to be printed (should not contain newline/carriage-return characters)\n     * @return this instance, for nesting calls to method as fluent interface\n     * @see SourcePrinter#println(String)\n     */\n    public SourcePrinter print(final String arg) {\n        if (!indented) {\n            lastPrintedIndent = indents.peek();\n            append(lastPrintedIndent);\n            indented = true;\n        }\n        append(arg);\n        return this;\n    }\n\n    /**\n     * Append the source string passed as argument to the buffer, then append a newline.\n     * If this is being appended at the beginning of a line, performs indentation first.\n     * <p>\n     * The source line to be printed should not contain newline/carriage-return characters.\n     * If the source line passed as argument contains newline/carriage-return characters would\n     * impredictably affect a correct computation of the current {@link #getCursor()} position.\n     *\n     * @param arg source line to be printed (should not contain newline/carriage-return characters)\n     * @return this instance, for nesting calls to method as fluent interface\n     */\n    public SourcePrinter println(final String arg) {\n        print(arg);\n        println();\n        return this;\n    }\n\n    /**\n     * Append a newline to the buffer.\n     *\n     * @return this instance, for nesting calls to method as fluent interface\n     */\n    public SourcePrinter println() {\n        buf.append(endOfLineCharacter);\n        cursor = new Position(cursor.line + 1, Position.FIRST_COLUMN - 1); // Start before the first column\n        indented = false;\n        return this;\n    }\n\n    /**\n     * Return the current cursor position (line, column) in the source printer buffer.\n     * <p>\n     * Please notice in order to guarantee a correct computation of the cursor position,\n     * this printer expect the contracts of the methods {@link #print(String)} and {@link #println(String)}\n     * has been respected through all method calls, meaning the source string passed as argument to those method\n     * calls did not contain newline/carriage-return characters.\n     *\n     * @return the current cursor position (line, column).\n     */\n    public Position getCursor() {\n        return cursor;\n    }\n\n    /**\n     * @return the currently printed source code.\n     * @deprecated use toString()\n     */\n    @Deprecated\n    public String getSource() {\n        return toString();\n    }\n\n    /**\n     * @return the currently printed source code.\n     */\n    @Override\n    public String toString() {\n        return buf.toString();\n    }\n\n    /**\n     * Changes all EOL characters in \"content\" to the EOL character this SourcePrinter is using.\n     */\n    public String normalizeEolInTextBlock(String content) {\n        return Utils.normalizeEolInTextBlock(content, endOfLineCharacter);\n    }\n\n    /**\n     * Set the top-most indent to the column the cursor is currently in, can be undone with\n     * {@link #reindentToPreviousLevel()}. Does not actually output anything.\n     */\n    public void reindentWithAlignToCursor() {\n        String newIndent = calculateIndentWithAlignTo(cursor.column);\n        reindentedIndents.push(indents.pop());\n        indents.push(newIndent);\n    }\n\n    /**\n     * Set the top-most indent to the column the cursor was before the last {@link #reindentWithAlignToCursor()} call.\n     * Does not actually output anything.\n     */\n    public void reindentToPreviousLevel() {\n        if (reindentedIndents.isEmpty()) {\n            throw new IllegalStateException(\"Reindent calls are not well-balanced.\");\n        }\n        indents.pop();\n        indents.push(reindentedIndents.pop());\n    }\n\n    /**\n     * Adds an indent to the top of the stack that is a copy of the current top indent.\n     * With this you announce \"I'm going to indent the next line(s)\" but not how far yet.\n     * Once you do know, you can pop this indent (\"unindent\") and indent to the right column.\n     * (Does not actually output anything.)\n     */\n    public void duplicateIndent() {\n        indents.push(indents.peek());\n    }\n}\n\nRefactoring Operation:\nExtract And Move Method\n\nProject Structure:\n['javaparser-core/src/main/java/com/github/javaparser/CommentsInserter.java', 'javaparser-core/src/main/java/com/github/javaparser/HasParentNode.java', 'javaparser-core/src/main/java/com/github/javaparser/JavaParser.java', 'javaparser-core/src/main/java/com/github/javaparser/JavaToken.java', 'javaparser-core/src/main/java/com/github/javaparser/JavadocParser.java', 'javaparser-core/src/main/java/com/github/javaparser/LineEndingProcessingProvider.java', 'javaparser-core/src/main/java/com/github/javaparser/ParseProblemException.java', 'javaparser-core/src/main/java/com/github/javaparser/ParseResult.java', 'javaparser-core/src/main/java/com/github/javaparser/ParseStart.java', 'javaparser-core/src/main/java/com/github/javaparser/ParserConfiguration.java', 'javaparser-core/src/main/java/com/github/javaparser/Position.java', 'javaparser-core/src/main/java/com/github/javaparser/Problem.java', 'javaparser-core/src/main/java/com/github/javaparser/Providers.java', 'javaparser-core/src/main/java/com/github/javaparser/Range.java', 'javaparser-core/src/main/java/com/github/javaparser/StaticJavaParser.java', 'javaparser-core/src/main/java/com/github/javaparser/TokenRange.java', 'javaparser-core/src/main/java/com/github/javaparser/TokenTypes.java', 'javaparser-core/src/main/java/com/github/javaparser/UnicodeEscapeProcessingProvider.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/AccessSpecifier.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/AllFieldsConstructor.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/ArrayCreationLevel.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/CompilationUnit.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/DataKey.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/Generated.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/ImportDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/Modifier.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/Node.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/PackageDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/body/AnnotationDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/body/AnnotationMemberDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/body/BodyDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/body/ClassOrInterfaceDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/body/ConstructorDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumConstantDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/body/FieldDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/body/InitializerDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/body/MethodDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/body/Parameter.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/body/ReceiverParameter.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/body/TypeDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/body/VariableDeclarator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/comments/BlockComment.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/comments/Comment.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/comments/CommentsCollection.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/comments/JavadocComment.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/comments/LineComment.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/AnnotationExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayAccessExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayCreationExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayInitializerExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/AssignExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/BinaryExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/BooleanLiteralExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/CastExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/CharLiteralExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/ClassExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/ConditionalExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/DoubleLiteralExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/EnclosedExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/Expression.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/FieldAccessExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/InstanceOfExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/IntegerLiteralExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/LambdaExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/LiteralExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/LiteralStringValueExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/LongLiteralExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/MarkerAnnotationExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/MemberValuePair.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodCallExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodReferenceExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/Name.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/NameExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/NormalAnnotationExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/NullLiteralExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/ObjectCreationExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/PatternExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/SimpleName.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/SingleMemberAnnotationExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/StringLiteralExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/SuperExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/SwitchExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/TextBlockLiteralExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/ThisExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/TypeExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/UnaryExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/expr/VariableDeclarationExpr.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleDirective.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleExportsDirective.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleOpensDirective.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleProvidesDirective.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleRequiresDirective.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleUsesDirective.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithAnnotations.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithArguments.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithBlockStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithBody.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithCondition.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithExpression.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithExtends.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithIdentifier.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithImplements.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithJavadoc.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithMembers.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithModifiers.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithName.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithOptionalBlockStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithOptionalLabel.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithOptionalScope.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithParameters.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithRange.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithScope.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithSimpleName.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithStatements.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithThrownExceptions.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithTokenRange.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithTraversableScope.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithType.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithTypeArguments.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithTypeParameters.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithVariables.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/SwitchNode.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/modifiers/NodeWithAbstractModifier.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/modifiers/NodeWithAccessModifiers.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/modifiers/NodeWithFinalModifier.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/modifiers/NodeWithPrivateModifier.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/modifiers/NodeWithProtectedModifier.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/modifiers/NodeWithPublicModifier.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/modifiers/NodeWithStaticModifier.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/modifiers/NodeWithStrictfpModifier.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/observer/AstObserver.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/observer/AstObserverAdapter.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/observer/Observable.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/observer/ObservableProperty.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/observer/PropagatingAstObserver.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/AssertStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/BlockStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/BreakStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/CatchClause.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ContinueStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/DoStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/EmptyStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ExplicitConstructorInvocationStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ExpressionStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ForEachStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ForStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/IfStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LabeledStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LocalClassDeclarationStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ReturnStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/Statement.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SwitchEntry.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SwitchStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SynchronizedStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ThrowStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/TryStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/UnparsableStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/WhileStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/stmt/YieldStmt.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/type/ArrayType.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/type/ClassOrInterfaceType.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/type/IntersectionType.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/type/PrimitiveType.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/type/ReferenceType.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/type/Type.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/type/TypeParameter.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/type/UnionType.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/type/UnknownType.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/type/VarType.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/type/VoidType.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/type/WildcardType.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java10Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java11Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java12Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java13Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java14Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java15Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java16Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java1_0Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java1_1Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java1_2Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java1_3Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java1_4Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java5Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java6Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java7Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java8Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Java9Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/ProblemReporter.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/ReservedKeywordValidator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/SimpleValidator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/SingleNodeTypeValidator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/TreeVisitorValidator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/TypedValidator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Validator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/Validators.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/VisitorValidator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/chunks/CommonValidators.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/chunks/ModifierValidator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/chunks/NoBinaryIntegerLiteralsValidator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/chunks/NoUnderscoresInIntegerLiteralsValidator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/chunks/UnderscoreKeywordValidator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/validator/chunks/VarValidator.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/CloneVisitor.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/EqualsVisitor.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/GenericListVisitorAdapter.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/GenericVisitor.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/GenericVisitorAdapter.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/GenericVisitorWithDefaults.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/HashCodeVisitor.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/ModifierVisitor.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/NoCommentEqualsVisitor.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/NoCommentHashCodeVisitor.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/ObjectIdentityEqualsVisitor.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/ObjectIdentityHashCodeVisitor.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/TreeVisitor.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/Visitable.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/VoidVisitor.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/VoidVisitorAdapter.java', 'javaparser-core/src/main/java/com/github/javaparser/ast/visitor/VoidVisitorWithDefaults.java', 'javaparser-core/src/main/java/com/github/javaparser/javadoc/Javadoc.java', 'javaparser-core/src/main/java/com/github/javaparser/javadoc/JavadocBlockTag.java', 'javaparser-core/src/main/java/com/github/javaparser/javadoc/description/JavadocDescription.java', 'javaparser-core/src/main/java/com/github/javaparser/javadoc/description/JavadocDescriptionElement.java', 'javaparser-core/src/main/java/com/github/javaparser/javadoc/description/JavadocInlineTag.java', 'javaparser-core/src/main/java/com/github/javaparser/javadoc/description/JavadocSnippet.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/AnnotationDeclarationMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/AnnotationExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/AnnotationMemberDeclarationMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ArrayAccessExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ArrayCreationExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ArrayCreationLevelMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ArrayInitializerExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ArrayTypeMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/AssertStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/AssignExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/BaseNodeMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/BinaryExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/BlockCommentMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/BlockStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/BodyDeclarationMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/BooleanLiteralExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/BreakStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/CallableDeclarationMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/CastExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/CatchClauseMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/CharLiteralExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ClassExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ClassOrInterfaceDeclarationMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ClassOrInterfaceTypeMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/CommentMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/CompilationUnitMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ConditionalExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ConstructorDeclarationMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ContinueStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/DerivedProperty.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/DoStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/DoubleLiteralExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/EmptyStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/EnclosedExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/EnumConstantDeclarationMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/EnumDeclarationMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ExplicitConstructorInvocationStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ExpressionMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ExpressionStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/FieldAccessExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/FieldDeclarationMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ForEachStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ForStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/IfStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ImportDeclarationMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/InitializerDeclarationMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/InstanceOfExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/IntegerLiteralExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/InternalProperty.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/IntersectionTypeMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/JavaParserMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/JavadocCommentMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/LabeledStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/LambdaExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/LineCommentMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/LiteralExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/LiteralStringValueExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/LocalClassDeclarationStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/LongLiteralExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/MarkerAnnotationExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/MemberValuePairMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/MethodCallExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/MethodDeclarationMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/MethodReferenceExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ModifierMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ModuleDeclarationMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ModuleDirectiveMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ModuleExportsDirectiveMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ModuleOpensDirectiveMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ModuleProvidesDirectiveMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ModuleRequiresDirectiveMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ModuleUsesDirectiveMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/NameExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/NameMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/NodeMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/NonEmptyProperty.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/NormalAnnotationExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/NullLiteralExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ObjectCreationExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/OptionalProperty.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/PackageDeclarationMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ParameterMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/PatternExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/PrimitiveTypeMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/PropertyMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ReceiverParameterMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ReferenceTypeMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ReturnStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/SimpleNameMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/SingleMemberAnnotationExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/StatementMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/StringLiteralExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/SuperExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/SwitchEntryMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/SwitchExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/SwitchStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/SynchronizedStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/TextBlockLiteralExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ThisExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/ThrowStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/TryStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/TypeDeclarationMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/TypeExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/TypeMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/TypeParameterMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/UnaryExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/UnionTypeMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/UnknownTypeMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/UnparsableStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/VarTypeMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/VariableDeclarationExprMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/VariableDeclaratorMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/VoidTypeMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/WhileStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/WildcardTypeMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/metamodel/YieldStmtMetaModel.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/ConcreteSyntaxModel.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/DotPrinter.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/PrettyPrintVisitor.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/PrettyPrinter.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/PrettyPrinterConfiguration.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/Printable.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/Stringable.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/XmlPrinter.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/YamlPrinter.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmAttribute.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmChar.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmComment.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmConditional.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmElement.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmIndent.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmList.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmMix.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmNone.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmOrphanCommentsEnding.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmSequence.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmSingleReference.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmString.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmTextBlock.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmToken.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmUnindent.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/PrintingHelper.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/configuration/Indentation.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Added.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/ChildTextElement.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/DifferenceElement.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/DifferenceElementCalculator.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Kept.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/NodeText.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/PhantomNodeLogic.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Removed.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/RemovedGroup.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Reshuffled.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/TextElement.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/TextElementIteratorsFactory.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/TextElementMatcher.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/TextElementMatchers.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/TokenTextElement.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/WrappingRangeIterator.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/changes/Change.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/changes/ListAdditionChange.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/changes/ListRemovalChange.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/changes/ListReplacementChange.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/changes/NoChange.java', 'javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/changes/PropertyChange.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/MethodAmbiguityException.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/MethodUsage.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/Resolvable.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/SymbolResolver.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/UnsolvedSymbolException.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/AssociableToAST.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/HasAccessSpecifier.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedAnnotationDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedAnnotationMemberDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedClassDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedConstructorDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedEnumConstantDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedEnumDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedFieldDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedInterfaceDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedMethodDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedMethodLikeDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedParameterDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedPatternDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedReferenceTypeDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedTypeDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedTypeParameterDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedTypeParametrizable.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedValueDeclaration.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedArrayType.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedIntersectionType.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedLambdaConstraintType.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedPrimitiveType.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedType.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedTypeTransformer.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedTypeVariable.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedUnionType.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedVoidType.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedWildcard.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/types/parametrization/ResolvedTypeParameterValueProvider.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/types/parametrization/ResolvedTypeParametersMap.java', 'javaparser-core/src/main/java/com/github/javaparser/resolution/types/parametrization/ResolvedTypeParametrized.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/ClassUtils.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/CodeGenerationUtils.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/CollectionStrategy.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/LineSeparator.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/Log.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/Pair.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/ParserCollectionStrategy.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/PositionUtils.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/ProjectRoot.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/SeparatedItemStringBuilder.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/SourceRoot.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/SourceZip.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/StringEscapeUtils.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/Utils.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/VisitorList.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/VisitorMap.java', 'javaparser-core/src/main/java/com/github/javaparser/utils/VisitorSet.java', 'javaparser-core/src/main/java/com/github/javaparser/version/Java10PostProcessor.java', 'javaparser-core/src/main/java/com/github/javaparser/version/Java11PostProcessor.java', 'javaparser-core/src/main/java/com/github/javaparser/version/Java12PostProcessor.java', 'javaparser-core/src/main/java/com/github/javaparser/version/Java13PostProcessor.java', 'javaparser-core/src/main/java/com/github/javaparser/version/Java14PostProcessor.java', 'javaparser-core/src/main/java/com/github/javaparser/version/Java15PostProcessor.java', 'javaparser-core/src/main/java/com/github/javaparser/version/Java16PostProcessor.java', 'javaparser-core/src/main/java/com/github/javaparser/version/PostProcessors.java', 'javaparser-core/src/main/java-templates/com/github/javaparser/JavaParserBuild.java', 'javaparser-core/src/main/javacc-support/com/github/javaparser/GeneratedJavaParserBase.java', 'javaparser-core/src/main/javacc-support/com/github/javaparser/GeneratedJavaParserTokenManagerBase.java', 'javaparser-core/src/main/javacc-support/com/github/javaparser/ModifierHolder.java', 'javaparser-core/src/main/javacc-support/com/github/javaparser/RangedList.java', 'javaparser-core/src/main/javacc-support/com/github/javaparser/TokenBase.java']\n\nFile Path Before Refactoring:\njavaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, and you need move the extracted method to another existing java file, output the target file path, extracted method code, refactored method code after refactoring.\nThe extracted method code should be the public static method.\nThe refactored method code should use the moved class to call the extracted method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\ntarget_file_path\n##########################\nextracted_method_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package record_mustAllowStaticFields() : void in class com.github.javaparser.ast.body.RecordDeclarationTest", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 226, "endLine": 232, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 231, "endLine": 236, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 313, "endLine": 316, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_mustAllowStaticFields", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#record_mustAllowStaticFields"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": ["private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }", "diffSourceCode": "-  226:     @Test\n-  227:     void record_mustAllowStaticFields() {\n-  228:         String s = \"record Point(int x, int y) { static int z; }\";\n-  229:         CompilationUnit cu = parseCompilationUnit(s);\n-  230:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-  231:         assertEquals(1, recordDeclarations.size());\n-  232:     }\n-  233: \n-  234: \n-  235:     @Test\n-  236:     void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n+  226:     void record_mustNotAllowNonStaticFields() {\n+  227:         String s = \"record Point(int x, int y) { int z; }\";\n+  228:         assertCompilationFails(s);\n+  229:     }\n+  230: \n+  231:     @Test\n+  232:     void record_mustAllowStaticFields() {\n+  233:         String s = \"record Point(int x, int y) { static int z; }\";\n+  234:         CompilationUnit cu = parseCompilationUnit(s);\n+  235:         assertOneRecordDeclaration(cu);\n+  236:     }\n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n", "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_226_232_313_316_231_236", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the test method `record_mustAllowStaticFields`, we can extract the logic that parses the compilation unit and checks for record declarations into a separate method. This will help reduce duplication and make the test easier to understand.\n\nHere\u2019s the refactored method code:\n\n##########################\n```java\nprivate void assertRecordDeclaration(String recordString) {\n    CompilationUnit cu = parseCompilationUnit(recordString);\n    List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n    assertEquals(1, recordDeclarations.size());\n}\n\n@Test\nvoid record_mustAllowStaticFields() {\n    String s = \"record Point(int x, int y) { static int z; }\";\n    assertRecordDeclaration(s);\n}\n```\n##########################\n\nIn this refactoring:\n- The logic to parse the compilation unit and assert the number of record declarations has been moved to a new method called `assertRecordDeclaration`.\n- The original test method `record_mustAllowStaticFields` now simply calls this new method, improving clarity and reducing code duplication.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate assertCompilationFails(s String) : void extracted from package record_mustNotAllowNonStaticFields() : void in class com.github.javaparser.ast.body.RecordDeclarationTest", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 218, "endLine": 224, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 225, "endLine": 229, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 307, "endLine": 311, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_mustNotAllowNonStaticFields", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#record_mustNotAllowNonStaticFields"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": ["private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\nprivate void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }", "diffSourceCode": "-  218:     @Test\n-  219:     void record_mustNotAllowNonStaticFields() {\n-  220:         String s = \"record Point(int x, int y) { int z; }\";\n-  221:         assertThrows(AssertionFailedError.class, () -> {\n-  222:             CompilationUnit cu = parseCompilationUnit(s);\n-  223:         });\n-  224:     }\n-  225: \n-  226:     @Test\n-  227:     void record_mustAllowStaticFields() {\n-  228:         String s = \"record Point(int x, int y) { static int z; }\";\n-  229:         CompilationUnit cu = parseCompilationUnit(s);\n-  307:         // test parameters (none)\n-  308:     }\n-  309: }\n+  218:                 \"\\n\" +\n+  219:                 \"}\\n\" +\n+  220:                 \"\";\n+  221:         CompilationUnit cu = parseCompilationUnit(s);\n+  222:         assertOneRecordDeclaration(cu);\n+  223:     }\n+  224: \n+  225:     @Test\n+  226:     void record_mustNotAllowNonStaticFields() {\n+  227:         String s = \"record Point(int x, int y) { int z; }\";\n+  228:         assertCompilationFails(s);\n+  229:     }\n+  307:     private void assertCompilationFails(String s) {\n+  308:         assertThrows(AssertionFailedError.class, () -> {\n+  309:             CompilationUnit cu = parseCompilationUnit(s);\n+  310:         });\n+  311:     }\n", "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_218_224_307_311_225_229", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": true, "refactoredCode": "To refactor the provided code, we will extract the common logic used in the test methods that parse a compilation unit and assert the presence of record declarations. This will improve readability and maintainability by reducing code duplication.\n\nThe method `parseAndAssertRecordDeclaration` will be created to encapsulate the logic of parsing a string representation of a record and asserting that a record declaration exists in the resulting compilation unit.\n\nHere\u2019s the refactored method code:\n\n##########################\nprivate void parseAndAssertRecordDeclaration(String recordString) {\n    CompilationUnit cu = parseCompilationUnit(recordString);\n    List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n    assertEquals(1, recordDeclarations.size());\n}\n##########################\n\nNow, we will replace the existing code in the relevant test methods with calls to this new method. Here\u2019s how the refactored test method `record_mustNotAllowNonStaticFields` would look:\n\n```java\n@Test\nvoid record_mustNotAllowNonStaticFields() {\n    String s = \"record Point(int x, int y) { int z; }\";\n    assertThrows(AssertionFailedError.class, () -> {\n        parseAndAssertRecordDeclaration(s);\n    });\n}\n```\n\nSimilarly, we would replace the relevant parts in other test methods that follow the same pattern. This will make the tests cleaner and more focused on their specific assertions. \n\nThe complete refactored code for the `RecordDeclarationTest` class would include the new method and the updated test methods.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package record_permitMethods() : void in class com.github.javaparser.ast.body.RecordDeclarationTest", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 198, "endLine": 216, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 206, "endLine": 223, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 313, "endLine": 316, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_permitMethods", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#record_permitMethods"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": ["private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }", "diffSourceCode": "-  198:     @Test\n-  199:     void record_permitMethods() {\n-  200:         String s = \"\" +\n-  201:                 \"record ABC(int x, int y) {\\n\" +\n-  202:                 \"\\n\" +\n-  203:                 \"    public int x() {\\n\" +\n-  204:                 \"        return x;\\n\" +\n-  205:                 \"    }\\n\" +\n-  206:                 \"\\n\" +\n-  207:                 \"    public String xyz() {\\n\" +\n-  208:                 \"        return \\\"10\\\";\\n\" +\n-  209:                 \"    }\\n\" +\n+  198:                 \"    }\\n\" +\n+  199:                 \"\\n\" +\n+  200:                 \"}\\n\" +\n+  201:                 \"\";\n+  202:         CompilationUnit cu = parseCompilationUnit(s);\n+  203:         assertOneRecordDeclaration(cu);\n+  204:     }\n+  205: \n+  206:     @Test\n+  207:     void record_permitMethods() {\n+  208:         String s = \"\" +\n+  209:                 \"record ABC(int x, int y) {\\n\" +\n   210:                 \"\\n\" +\n-  211:                 \"}\\n\" +\n-  212:                 \"\";\n-  213:         CompilationUnit cu = parseCompilationUnit(s);\n-  214:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-  215:         assertEquals(1, recordDeclarations.size());\n-  216:     }\n-  217: \n-  218:     @Test\n-  219:     void record_mustNotAllowNonStaticFields() {\n-  220:         String s = \"record Point(int x, int y) { int z; }\";\n-  221:         assertThrows(AssertionFailedError.class, () -> {\n-  222:             CompilationUnit cu = parseCompilationUnit(s);\n-  223:         });\n+  211:                 \"    public int x() {\\n\" +\n+  212:                 \"        return x;\\n\" +\n+  213:                 \"    }\\n\" +\n+  214:                 \"\\n\" +\n+  215:                 \"    public String xyz() {\\n\" +\n+  216:                 \"        return \\\"10\\\";\\n\" +\n+  217:                 \"    }\\n\" +\n+  218:                 \"\\n\" +\n+  219:                 \"}\\n\" +\n+  220:                 \"\";\n+  221:         CompilationUnit cu = parseCompilationUnit(s);\n+  222:         assertOneRecordDeclaration(cu);\n+  223:     }\n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n", "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_198_216_313_316_206_223", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `record_permitMethods` test method, we can extract the logic that creates the record string and parses it into a separate method. This will make the test method cleaner and more focused on its purpose.\n\nHere\u2019s the refactored code:\n\n```java\n@Test\nvoid record_permitMethods() {\n    CompilationUnit cu = parseRecord(\"record ABC(int x, int y) {\\n\" +\n            \"    public int x() {\\n\" +\n            \"        return x;\\n\" +\n            \"    }\\n\" +\n            \"    public String xyz() {\\n\" +\n            \"        return \\\"10\\\";\\n\" +\n            \"    }\\n\" +\n            \"}\\n\");\n    List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n    assertEquals(1, recordDeclarations.size());\n}\n\nprivate CompilationUnit parseRecord(String recordString) {\n    return parseCompilationUnit(recordString);\n}\n```\n\nIn this refactoring:\n- The string that defines the record is passed to a new method `parseRecord`, which handles the parsing. This keeps the test method focused on its assertions and makes it easier to read.\n- The `parseRecord` method encapsulates the logic for parsing a record, which can be reused in other tests if needed.\n\nHere\u2019s the output in the requested format:\n\n##########################\n```java\n@Test\nvoid record_permitMethods() {\n    CompilationUnit cu = parseRecord(\"record ABC(int x, int y) {\\n\" +\n            \"    public int x() {\\n\" +\n            \"        return x;\\n\" +\n            \"    }\\n\" +\n            \"    public String xyz() {\\n\" +\n            \"        return \\\"10\\\";\\n\" +\n            \"    }\\n\" +\n            \"}\\n\");\n    List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n    assertEquals(1, recordDeclarations.size());\n}\n\nprivate CompilationUnit parseRecord(String recordString) {\n    return parseCompilationUnit(recordString);\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package record_permitStaticFields() : void in class com.github.javaparser.ast.body.RecordDeclarationTest", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 176, "endLine": 196, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 185, "endLine": 204, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 313, "endLine": 316, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_permitStaticFields", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#record_permitStaticFields"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": ["private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }", "diffSourceCode": "-  176:     @Test\n-  177:     void record_permitStaticFields() {\n-  178:         String s = \"\" +\n-  179:                 \"record ABC(int x, int y) {\\n\" +\n-  180:                 \"\\n\" +\n-  181:                 \"    static int z;\\n\" +\n-  182:                 \"\\n\" +\n-  183:                 \"    static {\\n\" +\n-  184:                 \"        int z = 10;\\n\" +\n-  185:                 \"    }\\n\" +\n-  186:                 \"\\n\" +\n-  187:                 \"    public int x() {\\n\" +\n-  188:                 \"        return x;\\n\" +\n-  189:                 \"    }\\n\" +\n-  190:                 \"\\n\" +\n-  191:                 \"}\\n\" +\n-  192:                 \"\";\n-  193:         CompilationUnit cu = parseCompilationUnit(s);\n-  194:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-  195:         assertEquals(1, recordDeclarations.size());\n-  196:     }\n-  197: \n-  198:     @Test\n-  199:     void record_permitMethods() {\n-  200:         String s = \"\" +\n-  201:                 \"record ABC(int x, int y) {\\n\" +\n-  202:                 \"\\n\" +\n-  203:                 \"    public int x() {\\n\" +\n-  204:                 \"        return x;\\n\" +\n+  176:         CompilationUnit cu = parseCompilationUnit(s);\n+  177:         assertOneRecordDeclaration(cu);\n+  178: \n+  179:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  180:         RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n+  181: \n+  182:         assertEquals(0, recordDeclaration.getMembers().size());\n+  183:     }\n+  184: \n+  185:     @Test\n+  186:     void record_permitStaticFields() {\n+  187:         String s = \"\" +\n+  188:                 \"record ABC(int x, int y) {\\n\" +\n+  189:                 \"\\n\" +\n+  190:                 \"    static int z;\\n\" +\n+  191:                 \"\\n\" +\n+  192:                 \"    static {\\n\" +\n+  193:                 \"        int z = 10;\\n\" +\n+  194:                 \"    }\\n\" +\n+  195:                 \"\\n\" +\n+  196:                 \"    public int x() {\\n\" +\n+  197:                 \"        return x;\\n\" +\n+  198:                 \"    }\\n\" +\n+  199:                 \"\\n\" +\n+  200:                 \"}\\n\" +\n+  201:                 \"\";\n+  202:         CompilationUnit cu = parseCompilationUnit(s);\n+  203:         assertOneRecordDeclaration(cu);\n+  204:     }\n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n", "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_176_196_313_316_185_204", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `record_permitStaticFields` test method, we can extract the logic that creates the `CompilationUnit` and checks for the `RecordDeclaration` into a separate method. This will help reduce the complexity of the test method and make it easier to understand.\n\nHere\u2019s the refactored code:\n\n```java\n@Test\nvoid record_permitStaticFields() {\n    String recordCode = createRecordWithStaticFields();\n    assertRecordDeclarationExists(recordCode);\n}\n\nprivate String createRecordWithStaticFields() {\n    return \"\" +\n            \"record ABC(int x, int y) {\\n\" +\n            \"\\n\" +\n            \"    static int z;\\n\" +\n            \"\\n\" +\n            \"    static {\\n\" +\n            \"        int z = 10;\\n\" +\n            \"    }\\n\" +\n            \"\\n\" +\n            \"    public int x() {\\n\" +\n            \"        return x;\\n\" +\n            \"    }\\n\" +\n            \"\\n\" +\n            \"}\\n\" +\n            \"\";\n}\n\nprivate void assertRecordDeclarationExists(String recordCode) {\n    CompilationUnit cu = parseCompilationUnit(recordCode);\n    List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n    assertEquals(1, recordDeclarations.size());\n}\n```\n\nIn this refactoring:\n- The string that represents the record with static fields is moved to a method called `createRecordWithStaticFields()`.\n- The logic that parses the compilation unit and asserts the existence of the record declaration is moved to a method called `assertRecordDeclarationExists(String recordCode)`.\n- The main test method `record_permitStaticFields()` now reads more clearly, focusing on the high-level intent of the test.\n\nHere\u2019s the output in the required format:\n\n##########################\n```java\n@Test\nvoid record_permitStaticFields() {\n    String recordCode = createRecordWithStaticFields();\n    assertRecordDeclarationExists(recordCode);\n}\n\nprivate String createRecordWithStaticFields() {\n    return \"\" +\n            \"record ABC(int x, int y) {\\n\" +\n            \"\\n\" +\n            \"    static int z;\\n\" +\n            \"\\n\" +\n            \"    static {\\n\" +\n            \"        int z = 10;\\n\" +\n            \"    }\\n\" +\n            \"\\n\" +\n            \"    public int x() {\\n\" +\n            \"        return x;\\n\" +\n            \"    }\\n\" +\n            \"\\n\" +\n            \"}\\n\" +\n            \"\";\n}\n\nprivate void assertRecordDeclarationExists(String recordCode) {\n    CompilationUnit cu = parseCompilationUnit(recordCode);\n    List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n    assertEquals(1, recordDeclarations.size());\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate assertCompilationFails(s String) : void extracted from package record_cannotBeAbstract() : void in class com.github.javaparser.ast.body.RecordDeclarationTest", "diffLocations": [{"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 106, "endLine": 115, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 105, "endLine": 112, "startColumn": 0, "endColumn": 0}, {"filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "startLine": 307, "endLine": 311, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }", "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "isPureRefactoring": true, "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2", "packageNameBefore": "com.github.javaparser.ast.body", "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest", "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_cannotBeAbstract", "classSignatureBefore": "public class RecordDeclarationTest ", "methodNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest#record_cannotBeAbstract"], "classNameBeforeSet": ["com.github.javaparser.ast.body.RecordDeclarationTest"], "classSignatureBeforeSet": ["public class RecordDeclarationTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n", "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java", "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n", "diffSourceCodeSet": ["private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\nprivate void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }", "diffSourceCode": "-  105: \n-  106:     /**\n-  107:      * https://openjdk.java.net/jeps/395#Restrictions-on-records\n-  108:      */\n-  109:     @Test\n-  110:     void record_cannotBeAbstract() {\n-  111:         String s = \"abstract record Point(int x, int y) { }\";\n-  112:         assertThrows(AssertionFailedError.class, () -> {\n-  113:             CompilationUnit cu = parseCompilationUnit(s);\n-  114:         });\n-  115:     }\n-  307:         // test parameters (none)\n-  308:     }\n-  309: }\n+  105:     /**\n+  106:      * https://openjdk.java.net/jeps/395#Restrictions-on-records\n+  107:      */\n+  108:     @Test\n+  109:     void record_cannotBeAbstract() {\n+  110:         String s = \"abstract record Point(int x, int y) { }\";\n+  111:         assertCompilationFails(s);\n+  112:     }\n+  113: \n+  114:     /**\n+  115:      * https://openjdk.java.net/jeps/395#Restrictions-on-records\n+  307:     private void assertCompilationFails(String s) {\n+  308:         assertThrows(AssertionFailedError.class, () -> {\n+  309:             CompilationUnit cu = parseCompilationUnit(s);\n+  310:         });\n+  311:     }\n", "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_106_115_307_311_105_112", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `record_cannotBeAbstract` test method, we can extract the common logic of parsing a compilation unit and asserting that an exception is thrown into a separate method. This will reduce duplication and make the test methods cleaner.\n\nHere's the refactored code for the `record_cannotBeAbstract` method:\n\n```java\n##########################\n@Test\nvoid record_cannotBeAbstract() {\n    assertCompilationUnitThrows(\"abstract record Point(int x, int y) { }\");\n}\n\nprivate void assertCompilationUnitThrows(String code) {\n    assertThrows(AssertionFailedError.class, () -> {\n        CompilationUnit cu = parseCompilationUnit(code);\n    });\n}\n##########################\n```\n\nIn this refactoring:\n- The logic for parsing the compilation unit and asserting that an `AssertionFailedError` is thrown has been moved to a new private method called `assertCompilationUnitThrows`.\n- The `record_cannotBeAbstract` method now simply calls this new method with the appropriate string, making it clearer and more concise. \n\nThis pattern can be applied to other similar test methods in the class to further enhance modularity and readability.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\nClass content:\npackage com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}]